# Βάσεις Δεδομένων {#sec-import-databases}

```{r}
#| echo: false

source("_common.R")
```

## Εισαγωγή

Ένας τεράστιος όγκος δεδομένων βρίσκετε σε βάσεις δεδομένων, επομένως είναι σημαντικό να γνωρίζετε με ποιο τρόπο μπορείτε να έχετε πρόσβαση σε αυτά.
Μερικές φορές μπορείτε να ζητήσετε από κάποιον να κατεβάσει για εσάς ένα `.csv` αρχείο, αλλά αυτό μπορεί να γίνει επώδυνο γρήγορα: κάθε φορά που χρειάζεται να κάνετε μια αλλαγή θα πρέπει να επικοινωνείτε με κάποιον άλλο.
Αυτό που Θέλετε είναι να μπορείτε να μεταβείτε απευθείας στη βάση δεδομένων για να λάβετε τα δεδομένα που χρειάζεστε, όταν τα χρειάζεστε.

Σε αυτό το κεφάλαιο, θα μάθετε πρώτα τα βασικά του πακέτου DBI: πώς να το χρησιμοποιήσετε για να συνδεθείτε σε μια βάση δεδομένων και στη συνέχεια να ανακτήσετε δεδομένα με ένα ερώτημα SQL[^databases-1].
Η **SQL**, συντομογραφία του **s**tructured **q**uery **l**anguage, είναι η κοινή γλώσσα των βάσεων δεδομένων και είναι μια σημαντική για να την μάθουν όλοι οι επιστήμονες δεδομένων.
Δεν πρόκειται να ξεκινήσουμε με SQL, αλλά αντ' αυτού θα σας διδάξουμε την dbplyr, η οποία μπορεί να μεταφράσει τον κώδικά σας γραμμένο με dplyr σε SQL.
Θα την χρησιμοποιήσουμε ως τρόπο για να σας διδάξουμε μερικές από τις πιο σημαντικές δυνατότητες της SQL.
Δεν θα γίνετε άριστοι στην SQL μέχρι το τέλος του κεφαλαίου, αλλά θα μπορείτε να είστε σε θέση να προσδιορίσετε τα πιο σημαντικά στοιχεία της και να κατανοήσετε τι κάνουν.

[^databases-1]: Η SQL προφέρεται είτε "s"-"q"-"l" είτε "sequel".

### Προαπαιτούμενα

Σε αυτό το κεφάλαιο, θα παρουσιάσουμε την DBI και την dbplyr.
Η DBI είναι μια διεπαφή χαμηλού επιπέδου που συνδέεται με βάσεις δεδομένων και εκτελεί SQL.
Η dbplyr είναι μια διεπαφή υψηλού επιπέδου που μεταφράζει τον κώδικα dplyr σε ερωτήματα SQL και στη συνέχεια τα εκτελεί με την DBI.

```{r}
#| label: setup
#| message: false

library(DBI)
library(dbplyr)
library(tidyverse)
```

## Τα βασικά των βάσεων δεδομένων

Στο πιο απλό επίπεδο, μπορείτε να σκεφτείτε μια βάση δεδομένων ως μια συλλογή πλαισίων δεδομένων, που ονομάζονται, στην ορολογία των βάσεων δεδομένων, **πίνακες**.
Όπως ένα πλαίσιο δεδομένων έτσι και ένας πίνακας βάσης δεδομένων είναι μια συλλογή από ονομασμένες στήλες, όπου κάθε τιμή στη στήλη είναι του ίδιου τύπου.
Υπάρχουν τρεις διαφορές υψηλού επιπέδου μεταξύ των πλαισίων δεδομένων και των πινάκων βάσεων δεδομένων:

-   Οι πίνακες βάσεων δεδομένων αποθηκεύονται στο δίσκο και μπορεί να είναι αυθαίρετα μεγάλοι.
    Τα πλαίσια δεδομένων αποθηκεύονται στη μνήμη και είναι θεμελιωδώς περιορισμένα (αν και αυτό το όριο εξακολουθεί να είναι αρκετά μεγάλο για πολλά προβλήματα).

-   Οι πίνακες βάσεων δεδομένων έχουν σχεδόν πάντα ευρετήρια (indexes).
    Όπως το ευρετήριο ενός βιβλίου έτσι και ένα ευρετήριο βάσης δεδομένων καθιστά δυνατή τη γρήγορη εύρεση γραμμών ενδιαφέροντος χωρίς να χρειάζεται να κοιτάξετε κάθε μεμονωμένη γραμμή.
    Τα πλαίσια δεδομένων και τα tibbles δεν έχουν ευρετήρια, τα data.tables όμως έχουν και είναι ένας από τους λόγους που είναι τόσο γρήγορα.

-   Οι περισσότερες κλασικές βάσεις δεδομένων είναι βελτιστοποιημένες για γρήγορη συλλογή δεδομένων και όχι για ανάλυση δεδομένων.
    Αυτές οι βάσεις δεδομένων ονομάζονται **row-oriented** επειδή τα δεδομένα αποθηκεύονται σειρά προς σειρά, αντί στήλη προς στήλη όπως στην R.
    Στις μέρες μας, υπάρχει μεγάλη ανάπτυξη **column-oriented** βάσεων δεδομένων που κάνουν την ανάλυση δεδομένων πολύ πιο γρήγορη.

Οι βάσεις δεδομένων εκτελούνται από συστήματα διαχείρισης βάσεων δεδομένων (**ΣΔΒΔ** εν συντομία), τα οποία διατίθενται σε τρεις βασικές μορφές:

-   Τα ΣΔΒΔ **πελάτη-διακομιστή** εκτελούνται σε έναν ισχυρό κεντρικό διακομιστή, τον οποίο συνδέετε από τον υπολογιστή σας (τον πελάτη). Είναι εξαιρετικά για την κοινή χρήση δεδομένων με πολλά άτομα μέσα σε μια ομάδα. Κάποια δημοφιλή ΣΔΒΔ πελάτη-διακομιστή είναι τα PostgreSQL, MariaDB, SQL Server και Oracle.
-   Τα **Cloud** ΣΔΒΔ, όπως το Snowflake, το RedShift της Amazon και το BigQuery της Google, είναι παρόμοια με τα ΣΔΒΔ διακομιστή πελατών, αλλά εκτελούνται στο cloud. Αυτό σημαίνει ότι μπορούν εύκολα να χειριστούν εξαιρετικά μεγάλα σύνολα δεδομένων και μπορούν να παρέχουν αυτόματα περισσότερους υπολογιστικούς πόρους, όποτε αυτοί απαιτούνται.
-   Τα **In-process** ΣΔΒΔ, όπως το SQLite ή το duckdb, εκτελούνται εξ ολοκλήρου στον υπολογιστή σας. Είναι ιδανικά για εργασία με μεγάλα σύνολα δεδομένων όπου είστε ο κύριος χρήστης.

## Σύνδεση σε μια βάση δεδομένων

Για να συνδεθείτε στη βάση δεδομένων απο την R, θα χρησιμοποιήσετε δύο πακέτα:

-   Θα χρησιμοποιείτε πάντα το DBI (**d**ata**b**ase **i**nterface) επειδή παρέχει ένα σύνολο γενικών συναρτήσεων που συνδέονται με τη βάση δεδομένων, ανεβάζουν δεδομένα, εκτελούν ερωτήματα SQL κ.λπ.

-   Θα χρησιμοποιήσετε επίσης ένα πακέτο προσαρμοσμένο για το ΣΔΒΔ στο οποίο συνδέεστε.
    Αυτό το πακέτο μεταφράζει τις γενικές DBI εντολές στις λεπτομέρειες που απαιτούνται για ένα σθγκεκριμένο ΣΔΒΔ.
    Συνήθως υπάρχει ένα πακέτο για κάθε ΣΔΒΔ, π.χ.
    RPostgres για PostgreSQL και RMariaDB για MySQL.

Εάν δεν μπορείτε να βρείτε ένα συγκεκριμένο πακέτο για το ΣΔΒΔ σας, μπορείτε συνήθως να χρησιμοποιήσετε το πακέτο odbc.
Χρησιμοποιεί το πρωτόκολλο ODBC που υποστηρίζεται από αρκετά ΣΔΒΔ.
Το odbc απαιτεί λίγο περισσότερο χρόμο στην εγκατάστασή του γιατί θα χρειαστεί επίσης να εγκαταστήσετε ένα πρόγραμμα οδήγησης ODBC και να πείτε στο πακέτο odbc πού να το βρει.

Συγκεκριμένα, δημιουργείτε μια σύνδεση βάσης δεδομένων χρησιμοποιώντας την `DBI::dbConnect()`.
Το πρώτο όρισμα επιλέγει το ΣΔΒΔ[^databases-2] και, στη συνέχεια, το δεύτερο και τα επόμενα ορίσματα περιγράφουν τον τρόπο σύνδεσης σε αυτό (δηλαδή την τοποθεσία και τα διαπιστευτήρια που χρειάζεστε για την πρόσβαση σε αυτό).
Ο παρακάτω κώδικας δείχνει μερικά παραδείγματα:

[^databases-2]: Συνήθως, αυτή είναι η μόνη συνάρτηση που θα χρησιμοποιήσετε από το πακέτο πελάτη, επομένως συνιστούμε να χρησιμοποιήσετε τον τελεστή `::` για να καλέστε αυτήν τη μία συνάρτηση, αντί να φορτώσετε ολόκληρο το πακέτο με το `library()` .

```{r}
#| eval: false
con <- DBI::dbConnect(
  RMariaDB::MariaDB(), 
  username = "foo"
)
con <- DBI::dbConnect(
  RPostgres::Postgres(), 
  hostname = "databases.mycompany.com", 
  port = 1234
)
```

Οι ακριβείς λεπτομέρειες της σύνδεσης διαφέρουν πολύ από ΣΔΒΔ σε ΣΔΒΔ, οπότε δυστυχώς δεν μπορούμε να καλύψουμε όλες τις λεπτομέρειες εδώ.
Αυτό σημαίνει ότι θα χρειαστεί να κάνετε λίγη έρευνα μόνοι σας.
Συνήθως μπορείτε να ρωτήσετε άλλους επιστήμονες δεδομένων στην ομάδα σας ή να μιλήσετε με τον DBA σας (**d**ata**b**ase **a**dministrator).
Η αρχική ρύθμιση θα χρειαστεί συχνά λίγο ψάξιμο (και ίσως λίγο γκουγκλάρισμα) για να γίνει σωστά, αλλά γενικά θα χρειαστεί να το κάνετε μόνο μία φορά.

### Σε αυτό τι βιβλίο

Η εγκατάσταση ενός ΣΔΒΔ πελάτη-διακομιστή ή cloud θα ήταν οδυνηρή για αυτό το βιβλίο, επομένως θα χρησιμοποιήσουμε αντ 'αυτού ένα in-process ΣΔΒΔ που υπάρχει εξ ολοκλήρου σε ένα πακέτο της R: το duckdb.
Χάρη στη μαγεία του DBI, η μόνη διαφορά μεταξύ της χρήσης του duckdb και οποιουδήποτε άλλου ΣΔΒΔ είναι ο τρόπος με τον οποίο θα συνδεθείτε στη βάση δεδομένων.
Αυτό το καθιστά υπέροχο να διδαχτεί, καθώς και ο κώδικας είναι εύκολος ως προς την εκτέλεσή του αλλά και μπορείτε να πάρετε εύκολα ό,τι μαθαίνετε και να το εφαρμόσετε αλλού.

Η σύνδεση στο duckdb είναι ιδιαίτερα απλή, επειδή οι προεπιλογές δημιουργούν μια προσωρινή βάση δεδομένων που διαγράφεται όταν τερματίσετε την R.
Αυτό είναι εξαιρετικό για εκμάθηση, επειδή εγγυάται ότι θα ξεκινάτε από κάτι καθαρό κάθε φορά που κάνετε επανεκκίνηση της R:

```{r}
con <- DBI::dbConnect(duckdb::duckdb())
```

Το duckdb είναι μια βάση δεδομένων υψηλής απόδοσης που έχει σχεδιαστεί για τις ανάγκες ενός επιστήμονα δεδομένων.
Το χρησιμοποιούμε εδώ καθώς είναι πολύ εύκολο για να ξεκινήσετε, αλλά είναι επίσης ικανό να χειρίζεται gigabyte δεδομένων με μεγάλη ταχύτητα.
Εάν θέλετε να χρησιμοποιήσετε το duckdb για ένα πραγματικό project ανάλυσης δεδομένων, θα χρειαστεί επίσης να δώσετε μια τίμή στο όρισμα `dbdir` για να δημιουργήσετε μια μόνιμη βάση δεδομένων και να πείτε στο duckdb πού να την αποθηκεύσει.
Υποθέτοντας ότι χρησιμοποιείτε ένα project (@sec-workflow-scripts-projects), είναι λογικό να το αποθηκεύσετε στον κατάλογο `duckdb` του αντίτοιχου project:

```{r}
#| eval: false
con <- DBI::dbConnect(duckdb::duckdb(), dbdir = "duckdb")
```

### Φορτώστε μερικά δεδομένα {#sec-load-data}

Δεδομένου ότι πρόκειται για μια νέα βάση δεδομένων, πρέπει να ξεκινήσουμε προσθέτοντας κάποια δεδομένα.
Εδώ θα προσθέσουμε τα σύνολα δεδομένων `mpg` και `diamonds` από την ggplot2 χρησιμοποιώντας την `DBI::dbWriteTable()`.
Η απλούστερη χρήση της `dbWriteTable()` χρειάζεται τρία ορίσματα: μια σύνδεση βάσης δεδομένων, το όνομα του πίνακα που θα δημιουργηθεί στη βάση δεδομένων και ένα πλαίσιο δεδομένων που περιέχει κάποια δεδομενα.

```{r}
dbWriteTable(con, "mpg", ggplot2::mpg)
dbWriteTable(con, "diamonds", ggplot2::diamonds)
```

Εάν χρησιμοποιείτε το duckdb σε πραγματικό project, συνιστούμε ανεπιφύλακτα να μάθετε για τις συναρτήσεις `duckdb_read_csv()` και `duckdb_register_arrow()`.
Σας δίνουν ισχυρούς και αποδοτικούς τρόπους για να φορτώνετε γρήγορα δεδομένα απευθείας στο duckdb, χωρίς να χρειάζεται να τα φορτώσετε πρώτα στην R.
Θα δείξουμε επίσης μια χρήσιμη τεχνική για τη φόρτωση πολλών αρχείων σε μια βάση δεδομένων στο @sec-save-database.

### Βασικά στοιχεία DBI

Μπορείτε να ελέγξετε ότι τα δεδομένα έχουν φορτωθεί σωστά χρησιμοποιώντας μερικές άλλες συναρτήσεις DBI: Η `dbListTables()` παραθέτει όλους τους πίνακες στη βάση δεδομένων[^databases-3] και η `dbReadTable()` ανακτά τα περιεχόμενα ενός πίνακα.

[^databases-3]: Τουλάχιστον, όλοι οι πίνακες που έχετε άδεια να δείτε.

```{r}
dbListTables(con)

con |> 
  dbReadTable("diamonds") |> 
  as_tibble()
```

Η `dbReadTable()` επιστρέφει ένα `data.frame` επομένως χρησιμοποιούμε την `as_tibble()` για να το μετατρέψουμε σε tibble έτσι ώστε να εκτυπώνεται όμορφα.

Εάν γνωρίζετε ήδη SQL, μπορείτε να χρησιμοποιήσετε την `dbGetQuery()` για να λάβετε τα αποτελέσματα της εκτέλεσης ενός ερωτήματος στη βάση δεδομένων:

```{r}
sql <- "
  SELECT carat, cut, clarity, color, price 
  FROM diamonds 
  WHERE price > 15000
"
as_tibble(dbGetQuery(con, sql))
```

Εάν δεν έχετε ξαναδεί SQL, μην ανησυχείτε!
Θα μάθετε περισσότερα σύντομα.
Αλλά αν διαβάσετε προσεκτικά, μπορεί να μαντέψετε ότι επιλέγει πέντε στήλες του συνόλου δεδομένων diamonds και όλες τις γραμμές όπου η `price` είναι μεγαλύτερη από 15.000.

## Βασικά στοιχεία της dbplyr

Τώρα που συνδεθήκαμε σε μια βάση δεδομένων και φορτώσαμε μερικά δεδομένα, μπορούμε να αρχίσουμε να μαθαίνουμε για την dbplyr.
Η dbplyr είναι ένα **σύστημα υποστήριξης** της dplyr, που σημαίνει ότι συνεχίζετε να γράφετε κώδικα dplyr αλλά το σύστημα υποστήριξης τον εκτελεί διαφορετικά.
Σε αυτό, η dbplyr μεταφράζεται σε SQL.
Άλλα συστήματα υποστήριξης περιλαμβάνουν την [dtplyr](https://dtplyr.tidyverse.org) που μεταφράζεται σε [data.table](https://r-datatable.com) και την [multidplyr](https://multidplyr.tidyverse.%20org) που εκτελεί τον κώδικά σας σε πολλαπλούς πυρήνες.

Για να χρησιμοποιήσετε την dbplyr, πρέπει πρώτα να χρησιμοποιήσετε την `tbl()` για να δημιουργήσετε ένα αντικείμενο που αντιπροσωπεύει έναν πίνακα βάσης δεδομένων:

```{r}
diamonds_db <- tbl(con, "diamonds")
diamonds_db
```

::: callout-note
Υπάρχουν δύο άλλοι συχνοί τρόποι αλληλεπίδρασης με μια βάση δεδομένων.
Πρώτον, πολλές εταιρικές βάσεις δεδομένων είναι αρκετά μεγάλες, επομένως χρειάζεστε κάποια ιεραρχία για να κρατήσετε όλους τους πίνακες οργανωμένους.
Σε αυτήν την περίπτωση, ίσως χρειαστεί να παρέχετε μια δομή ή έναν κατάλογο και μια δομή, για να επιλέξετε τον πίνακα που σας ενδιαφέρει:

```{r}
#| eval: false
diamonds_db <- tbl(con, in_schema("sales", "diamonds"))
diamonds_db <- tbl(con, in_catalog("north_america", "sales", "diamonds"))
```

Άλλες φορές μπορεί να θέλετε να χρησιμοποιήσετε το δικό σας ερώτημα SQL ως σημείο εκκίνησης:

```{r}
#| eval: false
diamonds_db <- tbl(con, sql("SELECT * FROM diamonds"))
```
:::

Αυτό το αντικείμενο είναι **οκνηρό**; Όταν χρησιμοποιείτε συναρτήσεις dplyr σε αυτό, η dplyr δεν κάνει καμία εργασία: απλώς καταγράφει την ακολουθία πράξεων που θέλετε να εκτελέσετε και τις εκτελεί μόνο όταν χρειάζεται.
Για παράδειγμα, πάρτε την ακόλουθη ροή:

```{r}
big_diamonds_db <- diamonds_db |> 
  filter(price > 15000) |> 
  select(carat:clarity, price)

big_diamonds_db
```

Μπορείτε να πείτε ότι αυτό το αντικείμενο αντιπροσωπεύει ένα ερώτημα βάσης δεδομένων επειδή εκτυπώνει το όνομα του ΣΔΒΔ στο επάνω μέρος και ενώ σας λέει τον αριθμό των στηλών, συνήθως δεν γνωρίζει τον αριθμό των γραμμών.
Αυτό συμβαίνει επειδή η εύρεση του συνολικού αριθμού γραμμών απαιτεί συνήθως την εκτέλεση του πλήρους ερωτήματος, κάτι που προσπαθούμε να αποφύγουμε.

Μπορείτε να δείτε τον κώδικα SQL που δημιουργείται από τη συνάρτηση της dplyr `show_query()`.
Το να γνωρίζετε πως να εφαρμόζετε συναρτήσεις της dplyr, είναι ένας πολύ καλός τρόπος για να μάθετε και SQL!
Γράψτε λίγο κώδικα dplyr, πείτε στην dbplyr να τον μεταφράσει σε SQL και, στη συνέχεια, προσπαθήστε να καταλάβετε πώς ταιριάζουν οι δύο γλώσσες.

```{r}
big_diamonds_db |>
  show_query()
```

Για να επαναφέρετε όλα τα δεδομένα στην R, καλείτε την `collect()`.
Στο παρασκήνιο, αυτό δημιουργεί την SQL, καλεί την `dbGetQuery()` για να πάρει τα δεδομένα και μετά μετατρέπει το αποτέλεσμα σε tibble:

```{r}
big_diamonds <- big_diamonds_db |> 
  collect()
big_diamonds
```

Συνήθως, θα χρησιμοποιήσετε την dbplyr για να επιλέξετε τα δεδομένα που θέλετε από τη βάση δεδομένων, εκτελώντας κάποιο απλό φιλτράρισμα και κάποια σύνοψη χρησιμοποιώντας τις μεταφράσεις που περιγράφονται παρακάτω.
Στη συνέχεια, μόλις είστε έτοιμοι να αναλύσετε τα δεδομένα με συναρτήσεις που βρίσκονται μόνο στην R, θα `συλλέξετε collect()` τα δεδομένα για να πάρετε ένα tibble στη μνήμη και θα συνεχίσετε την εργασία σας μόνο με κώδικα R.

## SQL

Το υπόλοιπο κεφάλαιο θα σας διδάξει λιγή SQL μέσα από το φακό της dbplyr.
Είναι μια μάλλον μη παραδοσιακή εισαγωγή στην SQL, αλλά ελπίζουμε ότι θα σας μεταφέρει τα βασικά γρήγορα.
Ευτυχώς, αν καταλαβαίνετε την dplyr, βρίσκεστε σε ένα εξαιρετικό μέρος για να καταλάβετε γρήγορα και την SQL, καθώς πολλές από τις έννοιες είναι ίδιες.

Θα εξερευνήσουμε τη σχέση μεταξύ dplyr και SQL χρησιμοποιώντας μερικούς παλιούς φίλους από το πακέτο nycflights13: τα σύνολα δεδομένων `flights` and `planes`.
Αυτά τα σύνολα δεδομένων είναι εύκολο να εισαχθούν στην δοκιμαστική βάση δεδομένων μας, καθώς η dbplyr συνοδεύεται από μια συνάρτηση που αντιγράφει τους πίνακες από το nycflights13 στη βάση:

```{r}
dbplyr::copy_nycflights13(con)
flights <- tbl(con, "flights")
planes <- tbl(con, "planes")
```

```{r}
#| echo: false
options(dplyr.strict_sql = TRUE)
```

### Βασικά στοιχεία SQL

Τα στοιχεία ανώτατου επιπέδου της SQL ονομάζονται **δηλώσεις**.
Οι κοινές δηλώσεις περιλαμβάνουν την `CREATE` για τον ορισμό νέων πινάκων, την `INSERT` για προσθήκη δεδομένων και την `SELECT` για ανάκτηση δεδομένων.
Θα επικεντρωθούμε στις δηλώσεις `SELECT` που ονομάζονται επίσης **ερωτήματα**, καθώς είναι σχεδόν αποκλειστικά αυτό που θα χρησιμοποιήσετε ως επιστήμονας δεδομένων.

Ένα ερώτημα αποτελείται από **συνθήκες**.
Υπάρχουν πέντε σημαντικές συνθήκες: `SELECT`, `FROM`, `WHERE`, `ORDER BY`, και `GROUP BY`.
Κάθε ερώτημα πρέπει να έχει τις `SELECT`[^databases-4] και `FROM`[^databases-5] και το απλούστερο ερώτημα είναι το `SELECT * FROM table`, το οποίο επιλέγει όλες τις στήλες από τον καθορισμένο πίνακα
. Το αποτέλεσμα της dbplyr για έναν καθαρό πίνακα είναι
:

[^databases-4]: Ανάλογα με τη χρήση, η `SELECT` μπορεί να είναι είτε δήλωση είτε συνθήκη.
    Για να αποφευχθεί αυτή η σύγχυση, θα χρησιμοποιούμε το ερώτημα `SELECT` αντί για τη δήλωση `SELECT`.

[^databases-5]: Τεχνικά, απαιτείται μόνο η `SELECT`, καθώς μπορείτε να γράψετε ερωτήματα όπως `SELECT 1+1` για να εκτελέσετε βασικούς υπολογισμούς.
    Εαν θέλετε όμως να εργαστείτε με δεδομένα (όπως κάνετε πάντα!), θα χρειαστείτε επίσης μια συνθήκη `FROM`.

```{r}
flights |> show_query()
planes |> show_query()
```

Οι `WHERE` και `ORDER BY` ελέγχουν ποιές γραμμές θα περιέχονται στην έξοδο και πως αυτές θα είναι ταξινομημένες.

```{r}
flights |> 
  filter(dest == "IAH") |> 
  arrange(dep_delay) |>
  show_query()
```

Η `GROUP BY` μετατρέπει το ερώτημα σε μια σύνοψη, προκαλώντας μια συνάθροιση των δεδομένων:

```{r}
flights |> 
  group_by(dest) |> 
  summarize(dep_delay = mean(dep_delay, na.rm = TRUE)) |> 
  show_query()
```

Υπάρχουν δύο σημαντικές διαφορές μεταξύ των συναρτήσεων της dplyr και των συνθηκών SELECT:

-   Στην SQL, τα πεζά και κεφαλαία δεν έχουν σημασία: μπορείτε να γράψετε `select`, `SELECT`, ή ακόμα και `SeLeCt`. Σε αυτό το βιβλίο θα επιμείνουμε στη συχνή σύνταξη λέξεων-κλειδιών SQL με κεφαλαία για να τις ξεχωρίζουμε από τα ονόματα πινάκων ή μεταβλητών.
-   Στην SQL, η σειρά έχει σημασία: πρέπει πάντα να γράφετε τις συνθήκες με την εξής σειρά `SELECT`, `FROM`, `WHERE`, `GROUP BY`, `ORDER BY`. Η σειρά αυτή όμως δεν είναι ίδια με τον τρόπο όπου πραγματικά, οι συνθήκες, αξιολογούνται. Ξεκινά η `FROM`, μετά η `WHERE`, `GROUP BY`, `SELECT` και η `ORDER BY`.

Οι ακόλουθες ενότητες εξερευνούν κάθε συνθήκη με περισσότερες λεπτομέρειες.

::: callout-note
Σημειώστε ότι ενώ η SQL είναι καθιερωμένη, είναι εξαιρετικά περίπλοκη και καμία βάση δεδομένων δεν την ακολουθεί ακριβώς.
Ενώ τα κύρια στοιχεία στα οποία θα επικεντρωθούμε σε αυτό το βιβλίο είναι παρόμοια μεταξύ των ΣΔΒΔ, υπάρχουν πολλές μικρές παραλλαγές.
Ευτυχώς, η dbplyr έχει σχεδιαστεί για να χειρίζεται αυτό το πρόβλημα και δημιουργεί διαφορετικές μεταφράσεις για διαφορετικές βάσεις δεδομένων.
Δεν είναι τέλεια, αλλά βελτιώνεται συνεχώς και στην περίπτωση που αντιμετωπίσετε κάποιο πρόβλημα, μπορείτε να υποβάλετε ένα πρόβλημα [στο GitHub](https://github.com/tidyverse/dbplyr/issues/) για να μας βοηθήσετε να τα πάμε καλύτερα.
:::

### SELECT

Η συνθήκη `SELECT` είναι "η μηχανή" των ερωτημάτων και εκτελεί την ίδια δουλειά με τις `select()`, `mutate()`, `rename()`, `relocate()` και, όπως θα μάθετε στο επόμενο ενότητα, την `summarize()`.

Οι `select()`, `rename()`, και `relocate()` έχουν αρκετά άμεσες μεταφράσεις στην `SELECT` καθώς απλώς επηρεάζουν το πού εμφανίζεται μια στήλη (αν εμφανίζεται καθόλου) μαζί με το όνομά της:

```{r}
planes |> 
  select(tailnum, type, manufacturer, model, year) |> 
  show_query()

planes |> 
  select(tailnum, type, manufacturer, model, year) |> 
  rename(year_built = year) |> 
  show_query()

planes |> 
  select(tailnum, type, manufacturer, model, year) |> 
  relocate(manufacturer, model, .before = type) |> 
  show_query()
```

Αυτό το παράδειγμα δείχνει επίσης πώς η SQL αλλάζει ονόματα σε στήλες.
Στην ορολογία της SQL η μετονομασία ονομάζεται **aliasing** και γίνεται με την `AS`.
Σημειώστε ότι σε αντίθεση με την `mutate()`, το παλιό όνομα βρίσκεται στα αριστερά και το νέο όνομα βρίσκεται στα δεξιά.

::: callout-note
Στα παραπάνω παραδείγματα σημειώστε ότι τα `"year"` and `"type"` είναι μέσα σε διπλά εισαγωγικά.
Αυτό συμβαίνει επειδή πρόκειται για **δεσμευμένες λέξεις** στο duckdb, επομένως η dbplyr τις παραθέτει για να αποφύγει οποιαδήποτε πιθανή σύγχυση μεταξύ των ονομάτων στηλών/πίνακων και των τελεστών SQL.

Όταν εργάζεστε με άλλες βάσεις δεδομένων, είναι πιθανό να βλέπετε εισαγωγικά ονομάτων κάθε μεταβλητής, επειδή μόνο λίγα πακέτα πελατών, όπως το duckdb, γνωρίζουν ποιες είναι το σύνολο των δεσμευμένων λέξεων, επομένως βάζουν σε εισαγωγικά τα πάντα για ασφάλεια.

``` sql
SELECT "tailnum", "type", "manufacturer", "model", "year"
FROM "planes"
```

Άλλα συστήματα βάσεων δεδομένων χρησιμοποιούν backticks αντί για εισαγωγικά:

``` sql
SELECT `tailnum`, `type`, `manufacturer`, `model`, `year`
FROM `planes`
```
:::

Οι μεταφράσεις για την `mutate()` είναι εξίσου απλές: κάθε μεταβλητή γίνεται μια νέα έκφραση στην `SELECT`:

```{r}
flights |> 
  mutate(
    speed = distance / (air_time / 60)
  ) |> 
  show_query()
```

Θα επανέλθουμε στη μετάφραση μεμονωμένων στοιχείων (όπως το `/`) στο @sec-sql-expressions.

### FROM

Η συθήκη `FROM` ορίζει την πηγή των δεδομένων.
Δεν θα έχει πολύ ενδιαφέρον για λίγο, επειδή χρησιμοποιούμε απλά μεμονωμένους πίνακες.
Θα δείτε πιο περίπλοκα παραδείγματα μόλις δούμε τις συναρτήσεις σύνδεσης (join).

### GROUP BY

H `group_by()` μεταφράζεται στην συνθήκη `GROUP BY`[^databases-6] και η `summarize()` μεταφράζεται στην συνθήκη `SELECT`:

[^databases-6]: Αυτό δεν είναι τυχαίο: το όνομα της συνάρτησης της dplyr εμπνεύστηκε από τον όρο SQL.

```{r}
diamonds_db |> 
  group_by(cut) |> 
  summarize(
    n = n(),
    avg_price = mean(price, na.rm = TRUE)
  ) |> 
  show_query()
```

Θα επανέλθουμε στο τι συμβαίνει με τη μετάφραση των `n()` και `mean()` στο @sec-sql-expressions.

### WHERE

Η `filter()`μεταφράζεται στη συνθήκη `WHERE`:

```{r}
flights |> 
  filter(dest == "IAH" | dest == "HOU") |> 
  show_query()

flights |> 
  filter(arr_delay > 0 & arr_delay < 20) |> 
  show_query()
```

Υπάρχουν μερικές σημαντικές λεπτομέρειες που πρέπει να σημειωθούν εδώ:

-   Ο τελεστής `|` γίνεται `OR` και το `&` γίνεται `AND`.
-   Η SQL χρησιμοποιεί τον `=` για σύγκριση, όχι τον `==`. Η SQL δεν έχει ανάθεση, επομένως δεν υπάρχει πιθανότητα σύγχυσης εκεί.
-   Η SQL χρησιμοποιεί μόνο `''` για συμβολοσειρές, όχι `""`. Στην SQL, το `""` χρησιμοποιείται για τον προσδιορισμό μεταβλητών, όπως το ``` `` ``` της R.

Ένας άλλος χρήσιμος τελεστής της SQL είναι ο `IN`, ο οποίος είναι πολύ κοντά στον `%in%` της R:

```{r}
flights |> 
  filter(dest %in% c("IAH", "HOU")) |> 
  show_query()
```

Η SQL χρησιμοποιεί `NULL` αντί για `NA`.
Τα `NULL` συμπεριφέρονται παρόμοια με τα `NA`.
Η κύρια διαφορά είναι ότι ενώ μπορούν να επιρρεάσουν αποτελέσματα στις συγκρίσεις και στην αριθμητική, απορρίπτονται σιωπηλά κατά τη σύνοψη.
Η dbplyr θα σας υπενθυμίσει αυτήν τη συμπεριφορά την πρώτη φορά που θα το συναντήσετε:

```{r}
flights |> 
  group_by(dest) |> 
  summarize(delay = mean(arr_delay))
```

Εάν θέλετε να μάθετε περισσότερα για το πώς λειτουργεί η `NULL`, μπορεί να σας φανεί καλό το "[*Three valued logic*](https://modern-sql.com/concept/three-valued-logic)" του Markus Winand.

Σε γενικές γραμμές, μπορείτε να εργαστείτε με `NULL` τιμές χρησιμοποιώντας τις συναρτήσεις που θα χρησιμοποιούσατε για `NA` στην R:

```{r}
flights |> 
  filter(!is.na(dep_delay)) |> 
  show_query()
```

Αυτό το ερώτημα SQL απεικονίζει ένα από τα μειονεκτήματα της dbplyr: ενώ η SQL είναι σωστή, δεν είναι τόσο απλό όσο θα μπορούσατε να γράψετε χειροκίνητα.
Σε αυτήν την περίπτωση, μπορείτε να αποφύγετε τις παρενθέσεις και να χρησιμοποιήσετε έναν ειδικό τελεστή που είναι πιο ευανάγνωστος:

``` sql
WHERE "dep_delay" IS NOT NULL
```

Σημειώστε ότι εάν εφαρμόσετε την `filter()` σε μια μεταβλητή που δημιουργήσατε χρησιμοποιώντας μια σύνοψη, η dbplyr θα δημιουργήσει μια συνθήκη `HAVING` αντί για μια συνθήκη `WHERE`.
Αυτή είναι μια από τις ιδιοσυγκρασίες της SQL: Η `WHERE` αξιολογείται πριν από τη `SELECT` και τη `GROUP BY`, επομένως η SQL χρειάζεται μια άλλη συνθήκη που θα αξιολογηθεί στη συνέχεια.

```{r}
diamonds_db |> 
  group_by(cut) |> 
  summarize(n = n()) |> 
  filter(n > 100) |> 
  show_query()
```

### ORDER BY

Η ταξινόμηση γραμμών περιλαμβάνει μια απλή μετάφραση από την `arrange()` στην συνθήκη `ORDER BY`:

```{r}
flights |> 
  arrange(year, month, day, desc(dep_delay)) |> 
  show_query()
```

Παρατηρήστε πώς η `desc()` μεταφράζεται στην `DESC`: αυτή είναι μια από τις πολλές συναρτήσεις της dplyr των οποίων το όνομα εμπνεύστηκαν από την SQL.

### Υποερωτήματα

Μερικές φορές δεν είναι δυνατό να μεταφραστεί μια ροή με συναρτήσεις dplyr σε μια μεμονωμένη δήλωση `SELECT` και έτσι πρέπει να χρησιμοποιήσετε ένα υποερώτημα (ή εμφολευμένο ερώτημα).
Ένα **υποερώτημα** είναι απλώς ένα ερώτημα που χρησιμοποιείται ως πηγή δεδομένων στην συνθήκη `FROM`, αντί για τον συνηθισμένο πίνακα.

Η dbplyr συνήθως χρησιμοποιεί υποερωτήματα για να αντιμετωπίσει τους περιορισμούς της SQL.
Για παράδειγμα, οι εκφράσεις στην συνθήκη `SELECT` δεν μπορούν να αναφέρονται σε στήλες που μόλις δημιουργήθηκαν.
Αυτό σημαίνει ότι η ακόλουθη (απλή) ροή συναρτήσρων dplyr πρέπει να συμβεί σε δύο βήματα: το πρώτο (εσωτερικό) ερώτημα υπολογίζει την `year1` και στη συνέχεια το δεύτερο (εξωτερικό) ερώτημα μπορεί να υπολογίσει το `year2`.

```{r}
flights |> 
  mutate(
    year1 = year + 1,
    year2 = year1 + 1
  ) |> 
  show_query()
```

Αυτό θα το δείτε επίσης αν επιχειρήσετε να εφαρμόσετε την `filter()` σε μια μεταβλητή που μόλις δημιουργήσατε.
Θυμηθείτε, παρόλο που η `WHERE` είναι γραμμένη μετά τη `SELECT`, αξιολογείται πριν από αυτή, επομένως χρειαζόμαστε ένα υποερώτημα σε αυτό το (απλό) παράδειγμα:

```{r}
flights |> 
  mutate(year1 = year + 1) |> 
  filter(year1 == 2014) |> 
  show_query()
```

Μερικές φορές η dbplyr θα δημιουργήσει ένα υποερώτημα που δεν χρειάζεται, επειδή δεν γνωρίζει ακόμη πώς να βελτιστοποιήσει αυτήν τη μετάφραση.
Καθώς η dbplyr βελτιώνεται με την πάροδο του χρόνου, αυτές οι περιπτώσεις θα γίνονται πιο σπάνιες αλλά πιθανότατα δεν θα εξαφανιστούν ποτέ.

### Ενώσεις (Joins)

Εάν είστε εξοικειωμένοι με τις ενώσεις της dplyr, οι ενώσεις της SQL είναι αρκετά παρόμοιες.
Ορίστε ένα απλό παράδειγμα:

```{r}
flights |> 
  left_join(planes |> rename(year_built = year), by = "tailnum") |> 
  show_query()
```

Το κύριο στοιχείο που πρέπει να προσέξετε εδώ είναι η σύνταξη: Οι ενώσεις της SQL χρησιμοποιούν υποσυνθήκες της `FROM` για να επιστρέψουν πρόσθετους πίνακες, χρησιμοποιώντας την `ON` για να καθορίσουν το πώς σχετίζονται οι πίνακες.

Τα ονόματα της dplyr για αυτές τις συναρτήσεις είναι τόσο στενά συνδεδεμένα με την SQL που μπορείτε εύκολα να μαντέψετε την αντιστοίχιση σε SQL για τις `inner_join()`, `right_join()` και `full_join()`:

``` sql
SELECT flights.*, "type", manufacturer, model, engines, seats, speed
FROM flights
INNER JOIN planes ON (flights.tailnum = planes.tailnum)

SELECT flights.*, "type", manufacturer, model, engines, seats, speed
FROM flights
RIGHT JOIN planes ON (flights.tailnum = planes.tailnum)

SELECT flights.*, "type", manufacturer, model, engines, seats, speed
FROM flights
FULL JOIN planes ON (flights.tailnum = planes.tailnum)
```

Είναι πιθανό να χρειαστείτε πολλές ενώσεις όταν εργάζεστε με δεδομένα από μια βάση δεδομένων.
Αυτό συμβαίνει επειδή οι πίνακες βάσεων δεδομένων αποθηκεύονται συχνά σε μια εξαιρετικά κανονικοποιημένη μορφή, όπου κάθε "γεγονός" αποθηκεύεται σε ένα μόνο μέρος και για να διατηρήσετε ένα πλήρες σύνολο δεδομένων για ανάλυση, πρέπει να πλοηγηθείτε σε ένα σύνθετο δίκτυο πινάκων που συνδέονται με πρωτεύοντα και ξένα κλειδιά.
Αν συναντήσετε αυτό το σενάριο, το [πακέτο dm](https://cynkra.github.io/dm/), των Tobias Schieferdecker, Kirill Müller και Darko Bergant, θα κάνει τη ζωή σας λίγο πιο εύκολη.
Μπορεί να καθορίσει αυτόματα τις συνδέσεις μεταξύ πινάκων χρησιμοποιώντας τους περιορισμούς που τα DBA συχνά παρέχουν, να οπτικοποιήσει τις συνδέσεις και να δημιουργήσει τις συνδέσεις που χρειάζεστε για να συνδέσετε έναν πίνακα με έναν άλλο.

### Λοιπές συναρτήσεις

Η dbplyr μεταφράζει επίσης και άλλες συναρτήσεις όπως οι `distinct()`, `slice_*()`, και `intersect()`, και μια ολοένα αυξανόμενη γκάμα από συναρτήσεις της tidyr όπως οι `pivot_longer()` και `pivot_wider()`.
Ο πιο εύκολος τρόπος για να δείτε το πλήρες σύνολο των διαθέσιμων, προς το παρόν, μεταφράσεων είναι να επισκεφτείτε τον ιστότοπο της dbplyr: <https://dbplyr.tidyverse.org/reference/>.

### Ασκήσεις

1.  Σε τι μεταφράζεται η `distinct()`; Σε τι η `head()`;

2.  Εξηγήστε τι κάνει καθένα από τα ακόλουθα ερωτήματα SQL και δοκιμάστε να τα δημιουργήσετε ξανά χρησιμοποιώντας την dbplyr.

    ``` sql
    SELECT * 
    FROM flights
    WHERE dep_delay < arr_delay

    SELECT *, distance / (air_time / 60) AS speed
    FROM flights
    ```

## Μεταφράσεις συναρτήσεων {#sec-sql-expressions}

Μέχρι στιγμής έχουμε επικεντρωθεί στη μεγάλη εικόνα του πώς οι συναρτήσεις της dplyr μεταφράζονται στις συνθήκες ενός ερωτήματος.
Τώρα θα εμβανθύνουμε λίγο και θα μιλήσουμε για τη μετάφραση των συναρτήσεων της R που λειτουργούν με μεμονωμένες στήλες, π.χ., τι συμβαίνει όταν χρησιμοποιείτε την `mean(x)` σε ένα `summarize()`;

Για να δούμε τι συμβαίνει, θα χρησιμοποιήσουμε μερικές μικρές βοηθητικές συναρτήσεις που εκτελούν μια `summarize()` ή μια `mutate()` και εμφανίζουν την SQL που δημιουργήθηκε.
Αυτό θα κάνει λίγο πιο εύκολο να εξερευνήσετε μερικές παραλλαγές και να δείτε πως μπορεί να διαφέρουν οι συνόψεις και οι μετασχηματισμοί.

```{r}
summarize_query <- function(df, ...) {
  df |> 
    summarize(...) |> 
    show_query()
}
mutate_query <- function(df, ...) {
  df |> 
    mutate(..., .keep = "none") |> 
    show_query()
}
```

Ας επικρεντρωθούμε σε μερικές συνόψεις!
Κοιτάζοντας τον παρακάτω κώδικα θα παρατηρήσετε ότι ορισμένες συναρτήσεις σύνοψης, όπως η `mean()`, έχουν σχετικά απλή μετάφραση ενώ άλλες, όπως η `median()`, είναι πολύ πιο περίπλοκες.
Η πολυπλοκότητα είναι συνήθως μεγαλύτερη για συναρτήσεις που είναι συχνές στη στατιστική αλλά λιγότερο συχνές σε βάσεις δεδομένων.

```{r}
flights |> 
  group_by(year, month, day) |>  
  summarize_query(
    mean = mean(arr_delay, na.rm = TRUE),
    median = median(arr_delay, na.rm = TRUE)
  )
```

Η μετάφραση των συναρτήσεων σύνοψης γίνεται πιο περίπλοκη όταν χρησιμοποιούντε μέσα σε μια `mutate()` επειδή πρέπει να μετατραπούν στις λεγόμενες συναρτήσεις **window**.
Στην SQL, μετατρέπετε μια συνηθισμένη συνάρτηση συνάθροισης σε συνάρτηση window προσθέτοντας το `OVER` μετά από αυτήν:

```{r}
flights |> 
  group_by(year, month, day) |>  
  mutate_query(
    mean = mean(arr_delay, na.rm = TRUE),
  )
```

Στην SQL, η έκφραση `GROUP BY` χρησιμοποιείται αποκλειστικά για συνόψεις, επομένως εδώ μπορείτε να δείτε ότι η ομαδοποίηση έχει μετακινηθεί από το όρισμα `PARTITION BY` στο `OVER`.

Οι συναρτήσεις window περιλαμβάνουν όλες τις συναρτήσεις που κοιτάζουν προς τα εμπρός ή προς τα πίσω, όπως η `lead()` και η `lag()` που κοιτάζουν την τιμή "πριν" ή "μετά" αντίστοιχα:

```{r}
flights |> 
  group_by(dest) |>  
  arrange(time_hour) |> 
  mutate_query(
    lead = lead(arr_delay),
    lag = lag(arr_delay)
  )
```

Εδώ είναι σημαντικό να εφαρμόσετε την `arrange()` στα δεδομένα, επειδή οι πίνακες SQL δεν έχουν εγγενή σειρά.
Στην πραγματικότητα, αν δεν χρησιμοποιήσετε την `arrange()`, μπορεί να πάρετε τις γραμμές με διαφορετική σειρά κάθε φορά!
Σημειώστε για τις συναρτήσεις window, οι πληροφορίες ταξινόμισης επαναλαμβάνονται: η συνθήκη `ORDER BY` του κύριου ερωτήματος δεν εφαρμόζεται αυτόματα στις συναρτήσεις window.

Μια άλλη σημαντική συνάρτηση της SQL είναι η `CASE WHEN`.
Χρησιμοποιείται ως μετάφραση των `if_else()` και `case_when()`, των συνάρτησεων της dplyr που ενέπνευσε.
Ακολουθούν μερικά απλά παραδείγματα:

```{r}
flights |> 
  mutate_query(
    description = if_else(arr_delay > 0, "delayed", "on-time")
  )
flights |> 
  mutate_query(
    description = 
      case_when(
        arr_delay < -5 ~ "early", 
        arr_delay < 5 ~ "on-time",
        arr_delay >= 5 ~ "late"
      )
  )
```

Η `CASE WHEN` χρησιμοποιείται επίσης για ορισμένες άλλες συναρτήσεις που δεν έχουν άμεση μετάφραση από την R στην SQL.
Ένα καλό παράδειγμα αυτού είναι η `cut()`:

```{r}
flights |> 
  mutate_query(
    description =  cut(
      arr_delay, 
      breaks = c(-Inf, -5, 5, Inf), 
      labels = c("early", "on-time", "late")
    )
  )
```

Η dbplyr μεταφράζει επίσης κοινές συναρτήσεις χειρισμού συμβολοσειράς και ημερομηνίας, για τις οποίες μπορείτε να μάθετε στο `vignette("translation-function", package = "dbplyr")`.
Οι μεταφράσεις της dbplyr σίγουρα δεν είναι τέλειες και υπάρχουν πολλές συναρτήσεις της R που δεν έχουν μεταφραστεί ακόμα, η dbplyr όμως κάνει εκπληκτικά καλή δουλειά καλύπτοντας τις λειτουργίες που θα χρησιμοποιείτε τις περισσότερες φορές.

## Σύνοψη

Σε αυτό το κεφάλαιο μάθατε πώς να έχετε πρόσβαση σε δεδομένα από βάσεις δεδομένων.
Εστιάσαμε στη dbplyr, ένα "σύστημα υποστήριξης" της dplyr που σας επιτρέπει να γράψετε κώδικα dplyr με τον οποίο είστε εξοικειωμένοι και να μεταφραστεί αυτόματα σε SQL.
Χρησιμοποιήσαμε, ακόμα, αυτή τη μετάφραση για να σας μάθουμε λίγο SQL.
Είναι σημαντικό να μάθετε κάποια κομμάτια της SQL καθώς είναι *η* πιο συχνά χρησιμοποιούμενη γλώσσα για εργασία με δεδομένα και η μερική γνώση θα σας διευκολύνει να επικοινωνείτε με άλλους ανθρώπους σχετικούς με δεδομένα που δεν χρησιμοποιούν R.
Εάν έχετε ολοκληρώσει αυτό το κεφάλαιο και θέλετε να μάθετε περισσότερα για την SQL, έχουμε δύο συστάσεις:

-   Το [*SQL for Data Scientists*](https://sqlfordatascientists.com) από την Renée M. P. Teate είναι μια εισαγωγή στην SQL που έχει σχεδιαστεί ειδικά για τις ανάγκες των επιστημόνων δεδομένων και περιλαμβάνει παραδείγματα του είδους των δεδομένων που είναι πολύ πιθανό να συναντηθούν σε πραγματικές επιχειρήσεις.
-   Το [*Practical SQL*](https://www.practicalsql.com) από τον Anthony DeBarros είναι γραμμένο από την οπτική γωνία ενός δημοσιογράφου δεδομένων (ένας επιστήμονας δεδομένων που ειδικεύεται στην αφήγηση συναρπαστικών ιστοριών) και αναφέρεται σε περισσότερες λεπτομέρειες σχετικά με την εισαγωγή των δεδομένων σας μια βάση δεδομένων και την εγκατάσταση του δικού σας ΣΔΒΔ.

Στο επόμενο κεφάλαιο, θα μάθουμε για ένα άλλο σύστημα υποστήριξης της dplyr για εργασία με μεγάλα δεδομένα: το arrow.
Το arrow έχει σχεδιαστεί για εργασία με μεγάλα αρχεία στον δίσκο και αποτελεί φυσικό συμπλήρωμα των βάσεων δεδομένων.
