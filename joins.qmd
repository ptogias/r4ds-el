# Ενώσεις {#sec-joins}

```{r}
#| echo: false

source("_common.R")
```

## Εισαγωγή

Είναι σπάνιο μια ανάλυση δεδομένων να περιλαμβάνει μόνο ένα πλαίσιο δεδομένων.
Συνήθως έχετε πολλά πλαίσια δεδομένων και πρέπει να τα **ενώσετε** για να απαντήσετε στις ερωτήσεις που σας ενδιαφέρουν.
Αυτό το κεφάλαιο θα σας παρουσιάσει δύο σημαντικούς τύπους ενώσεων:

-   Ενώσεις αλλαγής, οι οποίες προσθέτουν νέες μεταβλητές σε ένα πλαίσιο δεδομένων, οι οποίες προέρχονται από αντιστοιχισμένες παρατηρήσεις σε ένα άλλο πλαίσιο δεδομένων.
-   Ενώσεις φιλτραρίσματος (filtering joins), οι οποίες φιλτράρουν τις παρατηρήσεις από ένα πλαίσιο δεδομένων με βάση το αν ταιριάζουν ή όχι με μια παρατήρηση σε ένα άλλο.

Θα ξεκινήσουμε συζητώντας τα κλειδιά, τις μεταβλητές που χρησιμοποιούνται για να συνδέσουν ένα ζεύγος πλαισίων δεδομένων σε μια ένωση.
Θα εδραιώσουμε τη θεωρία εξετάζοντας τα κλειδιά στα σύνολα δεδομένων του πακέτου nycflights13 και, στη συνέχεια, χρησιμοποιούμε αυτή τη γνώση για να αρχίσουμε να ενώνουμε πλαίσια δεδομένων μεταξύ τους.
Στη συνέχεια θα συζητήσουμε το πώς λειτουργούν οι ενώσεις, εστιάζοντας στη δράση τους στις γραμμές.
Τέλος, Θα ολοκληρώσουμε με μια συζήτηση για ενώσεις που δεν είναι ισοδύναμες, μια οικογένεια ενώσεων που παρέχουν έναν πιο ευέλικτο τρόπο αντιστοίχισης κλειδιών από την προεπιλεγμένη σχέση ισότητας.

### Προαπαιτούμενα

Σε αυτό το κεφάλαιο, θα εξερευνήσουμε τα πέντε σχετικά σύνολα δεδομένων από το nycflights13 χρησιμοποιώντας τις συναρτήσεις ένωσης (join) της dplyr.

```{r}
#| label: setup
#| message: false

library(tidyverse)
library(nycflights13)
```

## Κλειδιά

Για να κατανοήσετε τις ενώσεις, πρέπει πρώτα να κατανοήσετε πώς δύο πίνακες μπορούν να συνδεθούν μέσω ενός ζεύγους κλειδιών, που υπάρχουν σε κάθε πίνακα.
Σε αυτήν την ενότητα, θα μάθετε για τους δύο τύπους κλειδιών και θα δείτε παραδείγματα και των δύο στα σύνολα δεδομένων του πακέτου nycflights13.
Θα μάθετε επίσης πώς να ελέγχετε ότι τα κλειδιά σας είναι έγκυρα και τι να κάνετε εάν ο πίνακας σας δεν διαθέτει κλειδί.

### Πρωτεύοντα και δευτερεύοντα (ξένα) κλειδιά

Κάθε ένωση περιλαμβάνει ένα ζεύγος κλειδιών: ένα πρωτεύον (ή κύριο) κλειδί και ένα ξένο (ή δευτερεύον) κλειδί.
Ένα **πρωτεύον κλειδί** είναι μια μεταβλητή ή ένα σύνολο μεταβλητών που προσδιορίζει μοναδικά κάθε παρατήρηση.
Όταν χρειάζονται περισσότερες από μία μεταβλητές, το κλειδί ονομάζεται **σύνθετο κλειδί.** Για παράδειγμα, στο nycflights13:

-   Το πλαίσιο δεδομένων `airlines` καταγράφει για κάθε αεροπορική εταιρεία δύο στοιχεία: τον κωδικό της εταιρείας και το πλήρες όνομά της.
    Μπορείτε να προσδιορίσετε μια αεροπορική εταιρεία με τον κωδικό δύο γραμμάτων που της αντιστοιχεί, καθιστώντας τη μεταβλητή `carrier` το πρωτεύον κλειδί.

    ```{r}
    airlines
    ```

-   Το `airports` καταγράφει δεδομένα για κάθε αεροδρόμιο.
    Μπορείτε να προσδιορίσετε κάθε αεροδρόμιο με τον κωδικό τριών γραμμάτων που του αντιστοιχεί, καθιστώντας τη μεταβλητή `faa` το πρωτεύον κλειδί.

    ```{r}
    #| R.options:
    #|   width: 67
    airports
    ```

-   Το `planes` καταγράφει δεδομένα για κάθε αεροπλάνο.
    Μπορείτε να προσδιορίσετε ένα αεροπλάνο με τον αναγνωριστικό κωδικό του, καθιστώντας τη μεταβλητή `tailnum` το πρωτεύον κλειδί.

    ```{r}
    #| R.options:
    #|   width: 67
    planes
    ```

-   Το `weather` καταγράφει δεδομένα για τον καιρό στο αεροδρόμιο αναχώρησης.
    Μπορείτε να προσδιορίσετε κάθε παρατήρηση από το συνδυασμό τοποθεσίας και ώρας, καθιστώντας τις μεταβλητές `origin` και `time_hour` το σύνθετο πρωτεύον κλειδί.

    ```{r}
    #| R.options:
    #|   width: 67
    weather
    ```

Ένα **ξένο κλειδί** είναι μια μεταβλητή (ή σύνολο μεταβλητών) που αντιστοιχεί στο πρωτεύον κλειδί από έναν άλλο πίνακα.
Για παράδειγμα:

-   Η μεταβλητή `flights$tailnum` είναι ένα ξένο κλειδί που αντιστοιχεί στο πρωτεύον κλειδί `planes$tailnum`.
-   Η μεταβλητή `flights$carrier` είναι ένα ξένο κλειδί που αντιστοιχεί στο πρωτεύον κλειδί `airlines$carrier`.
-   Η μεταβλητή `flights$origin` είναι ένα ξένο κλειδί που αντιστοιχεί στο πρωτεύον κλειδί `airports$faa`.
-   Η μεταβλητή `flights$dest` είναι ένα ξένο κλειδί που αντιστοιχεί στο πρωτεύον κλειδί `airports$faa`.
-   Η μεταβλητή `flights$origin`-`flights$time_hour` είναι ένα σύνθετο ξένο κλειδί που αντιστοιχεί στο σύνθετο πρωτεύον κλειδί `weather$origin`-`weather$time_hour`.

Αυτές οι σχέσεις συνοψίζονται και οπτικά στο @fig-flights-relationships.

```{r}
#| label: fig-flights-relationships
#| echo: false
#| out-width: ~
#| fig-cap: |
#|   Connections between all five data frames in the nycflights13 package.
#|   Variables making up a primary key are colored grey, and are connected
#|   to their corresponding foreign keys with arrows.
#| fig-alt: |
#|   The relationships between airports, planes, flights, weather, and
#|   airlines datasets from the nycflights13 package. airports$faa
#|   connected to the flights$origin and flights$dest. planes$tailnum
#|   is connected to the flights$tailnum. weather$time_hour and
#|   weather$origin are jointly connected to flights$time_hour and 
#|   flights$origin. airlines$carrier is connected to flights$carrier.
#|   There are no direct connections between airports, planes, airlines, 
#|   and weather data frames.
knitr::include_graphics("diagrams/relational.png", dpi = 270)
```

Θα παρατηρήσετε ένα ωραίο χαρακτηριστικό στο σχεδιασμό αυτών των κλειδιών: το πρωτεύον και το ξένο κλειδί έχουν σχεδόν πάντα τα ίδια ονόματα, κάτι που, όπως θα δείτε σύντομα, θα κάνει πολύ πιο εύκολη τη ζωή σας όταν κάνετε ενώσεις.
Αξίζει επίσης να σημειωθεί και η αντίθετη σχέση: σχεδόν κάθε όνομα μεταβλητής που χρησιμοποιείται σε πολλούς πίνακες έχει την ίδια σημασία σε κάθε μέρος.
Υπάρχει μόνο μία εξαίρεση: η μεταβλητή `year` υποδηλώνει το έτος αναχώρησης στο πλαίσιο δεδομένων `flights` το έτος του κατασκευαστή στο πλαίσιο δεδομένων `planes`.
Αυτό θα γίνει σημαντικό όταν αρχίσουμε να ενώνουμε πίνακες μαζί.

### Έλεγχος πρωτευόντων κλειδιών

Τώρα που προσδιορίσαμε τα κύρια κλειδιά σε κάθε πίνακα, είναι καλή πρακτική να επαληθεύσουμε ότι όντως προσδιορίζουν μοναδικά κάθε παρατήρηση.
Ένας τρόπος για να γίνει αυτό είναι να μετρώντας τις τιμές που αντιστοιχούν στα κύρια κλειδιά με την `count()` και να εστιάσουμε σε παρατηρήσεις όπου το πλήθος τιμών (`n`) είναι μεγαλύτερο από ένα.
Αυτός ο έλεγχος αποκαλύπτει ότι οι μεταβλητές `planes` και `weather` δείχουν και οι δύο καλά:

```{r}
planes |> 
  count(tailnum) |> 
  filter(n > 1)

weather |> 
  count(time_hour, origin) |> 
  filter(n > 1)
```

Θα πρέπει επίσης να ελέγξετε για την ύπαρξη κενών τιμών στα κύρια κλειδιά σας --- εάν λείπει μια τιμή, αυτό σημαίνει ότι μια παρατήρηση δεν μπορεί να αναγνωριστεί!

```{r}
planes |> 
  filter(is.na(tailnum))

weather |> 
  filter(is.na(time_hour) | is.na(origin))
```

### Υποκατάστατα κλειδιά

Μέχρι στιγμής δεν έχουμε μιλήσει για το πρωτεύον κλειδί στο πλαίσιο δεδομένων `flights`.
Δεν είναι πολύ σημαντικό εδώ, επειδή δεν υπάρχουν πλαίσια δεδομένων που να το χρησιμοποιούν ως ξένο κλειδί, αλλά παραμένει χρήσιμο να το ανφέρουμε γιατί είναι πιο εύκολο να εργαστούμε με παρατηρήσεις, αν έχουμε κάποιο τρόπο να τις περιγράψουμε σε άλλους.

Μετά από λίγη σκέψη και πειραματισμό, αποφασίσαμε ότι υπάρχουν τρεις μεταβλητές που μαζί προσδιορίζουν μοναδικά κάθε πτήση:

```{r}
flights |> 
  count(time_hour, carrier, flight) |> 
  filter(n > 1)
```

Κάνει αυτόματα η απουσία διπλότυπων τιμών τον συνδυασμό `time_hour`-`carrier`-`flight` ένα πρωτεύον κλειδί; Είναι σίγουρα μια καλή αρχή, ωστόσο δεν αποτελεί εγγύηση.
Για παράδειγμα, είναι το υψόμετρο και το γεωγραφικό πλάτος ένα καλό πρωτεύον κλειδί για το πλαίσιο `airports`;

```{r}
airports |>
  count(alt, lat) |> 
  filter(n > 1)
```

Η αναγνώριση ενός αεροδρομίου με βάση το υψόμετρο και το γεωγραφικό του πλάτος είναι σαφώς κακή ιδέα και γενικά δεν είναι δυνατό να γνωρίζουμε μόνο από τα δεδομένα εάν ένας συνδυασμός μεταβλητών αποτελεί ένα καλό πρωτεύον κλειδί ή όχι.
Ωστόσο, για τις πτήσεις, ο συνδυασμός των μεταβλητών `time_hour`, `carrier`, και `flight` φαίνεται λογικός γιατί θα προκαλούσε σύγχυση για μια αεροπορική εταιρεία και τους πελάτες της εάν υπήρχαν πολλές πτήσεις με τον ίδιο αριθμό πτήσης στον αέρα ταυτόχρονα .

Έχοντας ξεκαθαρίσει αυτό το σημείο, ίσως είναι καλύτερα να εισάγουμε ένα απλό αριθμητικό υποκατάστατο κλειδί χρησιμοποιώντας τον αριθμό κάθε γραμμής:

```{r}
flights2 <- flights |> 
  mutate(id = row_number(), .before = 1)
flights2
```

Τα υποκατάστατα κλειδιά μπορούν να είναι ιδιαίτερα χρήσιμα όταν επικοινωνείτε με άλλους ανθρώπους: είναι πολύ πιο εύκολο να πείτε σε κάποιον να ρίξει μια ματιά στην πτήση 2001 παρά να του πείτε να δει την UA430 που αναχώρησε στις 9 π.μ., στις 03-01-2013.

### Ασκήσεις

1.  Ξεχάσαμε να σχεδιάσουμε τη σχέση μεταξύ `weather` και `airports` στο @fig-flights-relationships.
    Ποια είναι η σχέση και πώς πρέπει να εμφανίζεται στο διάγραμμα;

2.  Η μεταβλητή `weather` περιέχει μόνο πληροφορίες για τα τρία αεροδρόμια αναχώρησης στη Νέα Υόρκη.
    Εάν περιείχε αρχεία καιρού για όλα τα αεροδρόμια των ΗΠΑ, ποια πρόσθετη σύνδεση θα έκανε με το πλαίσιο δεδομένων `flights`;

3.  Οι μεταβλητές `year`, `month`, `day`, `hour`, και `origin` σχεδόν σχηματίζουν ένα σύνθετο κλειδί για το πλαίσιο δεδομένων `weather`, ωστόσο υπάρχει μια τιμή ώρας που έχει διπλότυπες παρατηρήσεις.
    Μπορείτε να καταλάβετε τι το ιδιαίτερο έχει αυτή η ώρα;

4.  Γνωρίζουμε ότι κάποιες μέρες του χρόνου είναι ιδιαίτερες και λιγότεροι άνθρωποι από το συνηθισμένο επιλέγουν να πετάξουν αυτές τις μέρες (για παράδειγμα, παραμονή και ανήμερα Χριστουγέννων).
    Πώς μπορείτε να αναπαραστήσετε αυτά τα δεδομένα ως πλαίσιο δεδομένων; Ποιο θα ήταν το πρωτεύον κλειδί; Πώς θα συνδεόταν με τα υπάρχοντα πλαίσια δεδομένων;

5.  Σχεδιάστε ένα διάγραμμα που απεικονίζει τις συνδέσεις μεταξύ των πλαισίων δεδομένων `Batting`, `People`, και `Salaries`στο πακέτο Lahman.
    Σχεδιάστε ένα άλλο διάγραμμα που δείχνει τη σχέση μεταξύ των `People`, `Managers`, `AwardsManagers`.
    Πώς θα χαρακτηρίζατε τη σχέση μεταξύ των πλαισίων δεδομένων `Batting`, `Pitching`, και `Fielding`;

## Βασικές ενώσεις {#sec-mutating-joins}

Τώρα που καταλαβαίνετε πως συνδέονται τα πλαίσια δεδομένων με τη βοήθεια κλειδιών, μπορούμε να αρχίσουμε να χρησιμοποιούμε ενώσεις για να καανοήσουμε καλύτερα το σύνολο δεδομένων `flights`.
Η dplyr προσφέρει έξι συναρτήσεις ένωσης: `left_join()`, `inner_join()`, `right_join()`, `full_join()`, `semi_join()`, και `anti_join().` Όλες έχουν την ίδια διεπαφή: παίρνουν ένα ζευγάρι πλαισίων δεδομένων (`x` και `y`) και επιστρέφουν ένα πλαίσιο δεδομένων.
Η σειρά των γραμμών και στηλών στην έξοδο καθορίζεται κυρίως από το `x`.

Σε αυτήν την ενότητα, θα μάθετε πώς να χρησιμοποιείτε μια ένωση αλλαγής, την `left_join()`, και δύο filtering ενώσεις, τις `semi_join()` και `anti_join()`.
Στην επόμενη ενότητα, θα μάθετε πώς ακριβώς λειτουργούν αυτές οι συναρτήσεις, καθώς και για τις υπόλοιπες: `inner_join()`, `right_join()` και `full_join()`.

### Ενώσεις αλλαγής

Μια **ένωση αλλαγής** σάς επιτρέπει να συνδυάσετε μεταβλητές από δύο πλαίσια δεδομένων: πρώτα αντιστοιχίζει παρατηρήσεις με βάση τα κλειδιά τους και μετά αντιγράφει παρατηρήσεις μεταξύ των μεταβλητών από το ένα πλαίσιο δεδομένων στο άλλο.
Όπως και η `mutate()`, οι συναρτήσεις ένωσης προσθέτουν μεταβλητές στα δεξιά, οπότε αν το σύνολο δεδομένων σας έχει πολλές μεταβλητές, δεν θα δείτε τις νέες.
Για αυτά τα παραδείγματα, θα διευκολύνουμε την παρατήρηση του τι συμβαίνει δημιουργώντας ένα πιο στενό σύνολο δεδομένων με έξι μόνο μεταβλητές[^joins-1]:

[^joins-1]: Να θυμάστε ότι στο RStudio μπορείτε επίσης να χρησιμοποιήσετε το `View()` για να αποφύγετε αυτό το πρόβλημα.

```{r}
flights2 <- flights |> 
  select(year, time_hour, origin, dest, tailnum, carrier)
flights2
```

Υπάρχουν τέσσερις τύποι ενώσεων αλλαγής, ωστόσο ένας είναι που θα χρησιμοποιείτε σχεδόν συνέχεια: `left_join()`.
Αυτό είναι ιδιαίτερο γιατί η έξοδος θα έχει πάντα τις ίδιες γραμμές με το `x`, το πλαίσιο δεδομένων προς τπ οποίο συνδέετε[^joins-2].
Η κύρια χρήση του `left_join()` είναι η προσθήκη επιπλέον μεταδεδομένων.
Για παράδειγμα, μπορούμε να χρησιμοποιήσουμε το `left_join()` για να προσθέσουμε το πλήρες όνομα της αεροπορικής εταιρείας στα δεδομένα του `flights2`:

[^joins-2]: Αυτό δεν είναι 100% αλήθεια, αλλά θα λαμβάνετε μια προειδοποίηση όποτε δεν είναι.

```{r}
flights2 |>
  left_join(airlines)
```

Ή θα μπορούσαμε να μάθουμε τη θερμοκρασία και την ταχύτητα του ανέμου όταν κάθε αεροπλάνο αναχωρούσε:

```{r}
flights2 |> 
  left_join(weather |> select(origin, time_hour, temp, wind_speed))
```

Ή τι μέγεθος αεροπλάνου πετούσε:

```{r}
flights2 |> 
  left_join(planes |> select(tailnum, type, engines, seats))
```

Όταν η `left_join()` δεν βρει ταίριασμα για μια γραμμή στο `x`, συμπληρώνει τις νέες μεταβλητές με κενές τιμές.
Για παράδειγμα, δεν υπάρχουν πληροφορίες σχετικά με το αεροπλάνο με αναγνωριστικό κωδικό `N3ALAA`, οπότε οι τιμές στις στήλες `type`, `engines`, και `seats` θα λείπουν:

```{r}
flights2 |> 
  filter(tailnum == "N3ALAA") |> 
  left_join(planes |> select(tailnum, type, engines, seats))
```

Θα επανέλθουμε σε αυτό το πρόβλημα μερικές φορές στο υπόλοιπο αυτού του κεφαλαίου.

### Καθορισμός κλειδιών ένωσης

Από προεπιλογή, η `left_join()` θα χρησιμοποιεί όλες τις μεταβλητές που εμφανίζονται και στα δύο πλαίσια δεδομένων ως κλειδί ένωση, τη λεγόμενη **φυσική** (**natural**) ένωση.
Αυτός είναι ένα χρήσιμος κανόνας, αλλά δεν λειτουργεί πάντα.
Για παράδειγμα, τι θα συμβεί αν προσπαθήσουμε να ενώσουμε το `flights2` με το πλήρες σύνολο δεδομένων `planes`;

```{r}
flights2 |> 
  left_join(planes)
```

Θα λάβουμε πολλές περιπτώσεις χωρίς αντιστοίχιση επειδή η ένωση μας προσπαθεί να χρησιμοποιήσει τις μεταβλητές `tailnum` και `year` ως σύνθετο κλειδί.
Και τα δύο σύνολα, `flights` και `planes`, περιέχουν μια στήλη `year`, ωστόσο αυτή η στήλη έχει σημαίνει διαφορετικά πράγματα σε κάθε περίπτωση: η `flights$year` είναι το έτος που πραγματοποιήθηκε η πτήση και η `planes$year` είναι το έτος κατασκευής του αεροπλάνου.
Θέλουμε να πραγματοποιήσουμε ένωση μόνο με βάση την `tailnum`, επομένως πρέπει να παρέχουμε μια ρητή προδιαγραφή με το `join_by()`:

```{r}
flights2 |> 
  left_join(planes, join_by(tailnum))
```

Σημείωστε ότι η προέλευση των μεταβλητων `year` αποσαφηνίζεται στην έξοδο με ένα επίθημα (`year.x` and `year.y`), το οποίο μας λέει εάν η μεταβλητή προήλθε από το όρισμα `x` ή `y`.
Μπορείτε να παρακάμψετε τα προεπιλεγμένα επιθήματα με το όρισμα `suffix`.

Το `join_by(tailnum)` είναι η σύντομη εκδοχή του `join_by(tailnum == tailnum)`.
Είναι σημαντικό να γνωρίζετε αυτήν την πληρέστερη εκδοχή για δύο λόγους.
Πρώτον, γιατί περιγράφει τη σχέση μεταξύ των δύο πινάκων: τα κλειδιά πρέπει να είναι ίσα (equal).
Αυτός είναι ο λόγος για τον οποίο αυτός ο τύπος σύνδεσης ονομάζεται συχνά **equi join**.
Θα μάθετε για τις non-equi ενώσεις στο @sec-non-equi-joins.

Δεύτερον, γιατί δείχνει τον τρόπο με τον οποίο καθορίζετε διαφορετικά κλειδιά σύνδεσης σε κάθε πίνακα.
Για παράδειγμα, υπάρχουν δύο τρόποι για να ενώσετε τους πίνακες `flight2` και `airports`: είτε με βάση το `dest` (τον προορισμό) είτε το `origin` (την προέλευση):

```{r}
flights2 |> 
  left_join(airports, join_by(dest == faa))

flights2 |> 
  left_join(airports, join_by(origin == faa))
```

Σε παλαιότερο κώδικα, ενδέχεται να δείτε έναν διαφορετικό τρόπο καθορισμού των κλειδιών ένωσης, χρησιμοποιώντας ένα διάνυσμα χαρακτήρων:

-   Το `by = "x"` αντιστοιχεί στο `join_by(x)`.
-   Το `by = c("a" = "x")` αντιστοιχεί στο `join_by(a == x)`.

Ωστόσο, προτιμούμε το `join_by()` που υπάρχει πλέον, αφού παρέχει ένα πιο ξεκάθαρο και πιο ευέλικτο τρόπο προσδιορισμού.

Οι `inner_join()`, `right_join()`, και `full_join()` έχουν την ίδια διεπαφή με τη `left_join()`.
Η διαφορά εντοπίζετε στο ποιες γραμμές διατηρούν: η αριστερή ένωση (`left_join()`) διατηρεί όλες τις γραμμές από το `x`, η δεξιά ένωση (`right_join()`) διατηρεί όλες τις γραμμές από το `y`, η πλήρης ένωση (`full_join()`) διατηρεί όλες τις γραμμές, είτε προέρχονται από το `x` είτε από το `y` και η εσωτερική ένωση (`inner_join()`) διατηρεί μόνο τις γραμμές που εμφανίζονται και στο `x` και στο `y`.
Θα επανέλθουμε σε αυτά με περισσότερες λεπτομέρειες αργότερα.

### Ενώσεις φιλτραρίσματος

Όπως μπορείτε να μαντέψετε, η κύρια ενέργεια μιας **filtering ένωσης** είναι το φιλτράρισμα των γραμμών Υπάρχουν δύο τύποι: ημι-ενώσεις και αντι-ενώσεις.
Οι **ημι-ενώσεις** (**semi-joins**) διατηρούν όλες τις σειρές στο `x` που έχουν αντιστοιχία στο `y`.
Για παράδειγμα, θα μπορούσαμε να χρησιμοποιήσουμε μια ημι-ένωση για να φιλτράρουμε το σύνολο δεδομένων `airports` για να διατηρήσουμε μόνο τα αεροδρόμια προέλευσης:

```{r}
airports |> 
  semi_join(flights2, join_by(faa == origin))
```

Ή μόνο τους προορισμούς:

```{r}
airports |> 
  semi_join(flights2, join_by(faa == dest))
```

Οι **αντι-ενώσεις** (**anti-joins**) είναι το αντίθετο: επιστρέφουν όλες τις γραμμές από το `x` που δεν έχουν αντιστοιχία στο `y`.
Είναι χρήσιμα για την εύρεση κενών τιμών που είναι **implicit** στα δεδομένα, το θέμα του @sec-missing-implicit.
Οι τιμές που λείπουν σιωπηρά δεν εμφανίζονται ως `NA` αλλά υπάρχουν μόνο ως απουσία.
Για παράδειγμα, μπορούμε να βρούμε γραμμές που λείπουν από το `airports` αναζητώντας πτήσεις που δεν έχουν αντίστοιχο αεροδρόμιο προορισμού:

```{r}
flights2 |> 
  anti_join(airports, join_by(dest == faa)) |> 
  distinct(dest)
```

Ή μπορούμε να βρούμε ποιες τιμές της μεταβλητής `tailnum` λείπουν από το `planes`:

```{r}
flights2 |>
  anti_join(planes, join_by(tailnum)) |> 
  distinct(tailnum)
```

### Ασκήσεις

1.  Εντοπίστε τις 48 ώρες (κατά τη διάρκεια ολόκληρου του έτους) που έχουν τις χειρότερες καθυστερήσεις.
    Διασταυρώστε το με τα δεδομένα του `weather`.
    Μπορείτε να δείτε κάποιο μοτίβο;

2.  Φανταστείτε ότι έχετε βρει τους 10 πιο δημοφιλείς προορισμούς χρησιμοποιώντας αυτόν τον κώδικα:

    ```{r}
    top_dest <- flights2 |>
      count(dest, sort = TRUE) |>
      head(10)
    ```

    Πώς μπορείτε να βρείτε όλες τις πτήσεις προς αυτούς τους προορισμούς;

3.  Έχει κάθε πτήση που αναχωρεί αντίστοιχα δεδομένα καιρού για εκείνη την ώρα;

4.  Τι κοινό έχουν οι αναγνωριστικοί κωδικοί των αεροσκαφών που δεν έχουν αντίστοιχη εγγραφή στο `planes`; (Υπόδειξη: μία μεταβλητή εξηγεί \~90% των προβλημάτων.)

5.  Προσθέστε μια στήλη στο `planes` που αναφέρει κάθε `carrier` που έχει χρησιμοποιήσει αυτό το αεροπλάνο.
    Μπορεί να περιμένετε ότι υπάρχει μια έμμεση σχέση μεταξύ αεροπλάνου και αεροπορικής εταιρείας, επειδή κάθε αεροπλάνο πετά με μία μόνο αεροπορική εταιρεία.
    Επιβεβαιώστε ή απορρίψτε αυτήν την υπόθεση χρησιμοποιώντας τα εργαλεία που έχετε μάθει σε προηγούμενα κεφάλαια.

6.  Προσθέστε το γεωγραφικό πλάτος και μήκος του αεροδρομίου προέλευσης *και* προορισμού στο πλαίσιο δεδομένων `flights`.
    Είναι πιο εύκολο να μετονομάσετε τις στήλες πριν ή αφού κάνετε την ένωση;

7.  Υπολογίστε τη μέση καθυστέρηση ανά προορισμό και, στη συνέχεια, ενώστε την πληροφορία στο `airports`, ώστε να μπορέσετε να παρουσιάσετε την κατανομή των καθυστερήσεων γεωγραφικά.
    Ακολουθεί ένας εύκολος τρόπος για να σχεδιάσετε έναν χάρτη των Ηνωμένων Πολιτειών:

    ```{r}
    #| eval: false

    airports |>
      semi_join(flights, join_by(faa == dest)) |>
      ggplot(aes(x = lon, y = lat)) +
        borders("state") +
        geom_point() +
        coord_quickmap()
    ```

    Μπορεί να θέλετε να χρησιμοποιήσετε το `size` ή το `color` των σημείων για να εμφανίσετε τη μέση καθυστέρηση για κάθε αεροδρόμιο.

8.  Τι συνέβη στις 13 Ιουνίου 2013; Σχεδιάστε έναν χάρτη με τις καθυστερήσεις και, στη συνέχεια, χρησιμοποιήστε το Google για να διασταυρώσετε τα δεδομένα για τον καιρό.

    ```{r}
    #| eval: false
    #| include: false

    worst <- filter(flights, !is.na(dep_time), month == 6, day == 13)
    worst |>
      group_by(dest) |>
      summarize(delay = mean(arr_delay), n = n()) |>
      filter(n > 5) |>
      inner_join(airports, join_by(dest == faa)) |>
      ggplot(aes(x = lon, y = lat)) +
        borders("state") +
        geom_point(aes(size = n, color = delay)) +
        coord_quickmap()
    ```

## Πώς λειτουργούν οι ενώσεις;

Τώρα που έχετε χρησιμοποιήσει ενώσεις κάποιες φορές, ήρθε η ώρα να μάθετε περισσότερα σχετικά με τον τρόπο λειτουργίας τους, εστιάζοντας στο πώς κάθε γραμμή στο `x` αντιστοιχίζεται με τις γραμμές στο `y`.
Θα ξεκινήσουμε εισάγοντας μια οπτική αναπαράσταση των ενώσεων, χρησιμοποιώντας τα απλά tibbles που ορίζονται παρακάτω και εμφανίζονται στο @fig-join-setup.
Σε αυτά τα παραδείγματα θα χρησιμοποιήσουμε ένα μόνο κλειδί που ονομάζεται `key` και μια στήλη με μία τιμή (`val_x` και `val_y`), αλλά όλες οι ιδέες που χρησιμοποιούνται εδώ γενικεύονται σε πολλά κλειδιά και πολλαπλές τιμές.

```{r}
x <- tribble(
  ~key, ~val_x,
     1, "x1",
     2, "x2",
     3, "x3"
)
y <- tribble(
  ~key, ~val_y,
     1, "y1",
     2, "y2",
     4, "y3"
)
```

```{r}
#| label: fig-join-setup
#| echo: false
#| out-width: ~
#| fig-cap: |
#|   Graphical representation of two simple tables. The colored `key`
#|   columns map background color to key value. The grey columns represent
#|   the "value" columns that are carried along for the ride. 
#| fig-alt: |
#|   x and y are two data frames with 2 columns and 3 rows, with contents
#|   as described in the text. The values of the keys are colored:
#|   1 is green, 2 is purple, 3 is orange, and 4 is yellow.

knitr::include_graphics("diagrams/join/setup.png", dpi = 270)
```

Το @fig-join-setup2 εισάγει τη βάση για την οπτική μας αναπαράσταση.
Εμφανίζει όλες τις πιθανές αντιστοιχίσεις μεταξύ των `x` και `y` ως τομή μεταξύ των γραμμών που σχεδιάζονται από κάθε γραμμή του `x` και κάθε γραμμής του `y`.
Οι γραμμές και οι στήλες στην έξοδο καθορίζονται κυρίως από το `x`, επομένως ο πίνακας `x` είναι οριζόντιος και ευθυγραμμίζεται με την έξοδο.

```{r}
#| label: fig-join-setup2
#| echo: false
#| out-width: ~
#| fig-cap: | 
#|   To understand how joins work, it's useful to think of every possible
#|   match. Here we show that with a grid of connecting lines.
#| fig-alt: |
#|   x and y are placed at right-angles, with horizonal lines extending 
#|   from x and vertical lines extending from y. There are 3 rows in x and 
#|   3 rows in y, which leads to nine intersections representing nine
#|   potential matches.

knitr::include_graphics("diagrams/join/setup2.png", dpi = 270)
```

Για να περιγράψουμε έναν συγκεκριμένο τύπο ένωσης, υποδεικνύουμε τις αντιστοιχίσεις με τελείες.
Οι αντιστοιχίσεις καθορίζουν τις γραμμές στην έξοδο, ένα νέο πλαίσιο δεδομένων που περιέχει το κλειδί, τις τιμές x και τις τιμές y.
Για παράδειγμα, το @fig-join-inner δείχνει μια εσωτερική ένωση, όπου οι γραμμές διατηρούνται εάν και μόνο εάν τα κλειδιά είναι ίσα.

```{r}
#| label: fig-join-inner
#| echo: false
#| out-width: ~
#| fig-cap: |
#|   An inner join matches each row in `x` to the row in `y` that has the
#|   same value of `key`. Each match becomes a row in the output.
#| fig-alt: |
#|   x and y are placed at right-angles with lines forming a grid of
#|   potential matches. Keys 1 and 2 appear in both x and y, so we
#|   get a match, indicated by a dot. Each dot corresponds to a row
#|   in the output, so the resulting joined data frame has two rows.

knitr::include_graphics("diagrams/join/inner.png", dpi = 270)
```

Μπορούμε να εφαρμόσουμε τις ίδιες αρχές για να εξηγήσουμε τις **εξωτερικές ενώσεις** (**outer joins**), οι οποίες διατηρούν τις παρατηρήσεις που εμφανίζονται σε τουλάχιστον ένα από τα πλαίσια δεδομένων.
Αυτές οι ενώσεις λειτουργούν προσθέτοντας μια πρόσθετη "εικονική" παρατήρηση σε κάθε πλαίσιο δεδομένων.
Αυτή η παρατήρηση έχει ένα κλειδί που ταιριάζει αν δεν ταιριάζει άλλο κλειδί, και τιμές γεμάτες με `NA`.
Υπάρχουν τρεις τύποι εξωτερικών ενώσεων:

-   Μια **αριστερή ένωση** (**left join**) διατηρεί όλες τις παρατηρήσεις του `x`, @fig-join-left.
    Κάθε γραμμή του `x` διατηρείται στην έξοδο, μιας και μπορεί να αντιστοιχιστεί σε μια γραμμή με `NA` του `y`.

    ```{r}
    #| label: fig-join-left
    #| echo: false
    #| out-width: ~
    #| fig-cap: | 
    #|   A visual representation of the left join where every row in `x`
    #|   appears in the output.
    #| fig-alt: |
    #|   Compared to the previous diagram showing an inner join, the y table
    #|   gets a new virtual row containin NA that will match any row in x
    #|   that didn't otherwise match. This means that the output now has
    #|   three rows. For key = 3, which matches this virtual row, val_y takes
    #|   value NA.

    knitr::include_graphics("diagrams/join/left.png", dpi = 270)
    ```

-   Μια **δεξιά ένωση** (**right join**) διατηρεί όλες τις παρατηρήσεις του `y`, @fig-join-right.
    Κάθε γραμμή του `y` διατηρείται στην έξοδο, επειδή μπορεί να αντιστοιχιστεί σε μια γραμμή με `NA` του `x`.
    Η έξοδος εξακολουθεί να ταιριάζει με το `x` όσο το δυνατόν περισσότερο, ενώ τυχόν επιπλέον σειρές από το `y` προστίθενται στο τέλος.

    ```{r}
    #| label: fig-join-right
    #| echo: false
    #| out-width: ~
    #| fig-cap: | 
    #|   A visual representation of the right join where every row of `y` 
    #|   appears in the output. 
    #| fig-alt: |
    #|   Compared to the previous diagram showing an left join, the x table
    #|   now gains a virtual row so that every row in y gets a match in x.
    #|   val_x contains NA for the row in y that didn't match x.

    knitr::include_graphics("diagrams/join/right.png", dpi = 270)
    ```

-   Μια **πλήρης ένωση** (**full join**) διατηρεί όλες τις παρατηρήσεις που εμφανίζονται είτε στο `x` είτε στο `y`, @fig-join-full.
    Κάθε γραμμή των `x` και `y` περιλαμβάνεται στην έξοδο επειδή και τα `x` και `y` περιλαμβάνουν μια εναλλακτική γραμμή με `NA`.
    Και πάλι, η έξοδος ξεκινά με όλες τις γραμμές από το `x`, ακολουθούμενες από τις υπόλοιπες γραμμές του `y` που δεν αντιστοιχίσθηκαν σε συγκεκιρμένη γραμμή του `x`.

    ```{r}
    #| label: fig-join-full
    #| echo: false
    #| out-width: ~
    #| fig-cap: | 
    #|   A visual representation of the full join where every row in `x`
    #|   and `y` appears in the output.
    #| fig-alt: |
    #|   Now both x and y have a virtual row that always matches.
    #|   The result has 4 rows: keys 1, 2, 3, and 4 with all values 
    #|   from val_x and val_y, however key 2, val_y and key 4, val_x are NAs
    #|   since those keys don't have a match in the other data frames.

    knitr::include_graphics("diagrams/join/full.png", dpi = 270)
    ```

Ένας άλλος τρόπος για να δείξετε τις διαφορές ανάμεσα στους διάφορους τύπους της εξωτερικής ένωσης είναι με ένα διάγραμμα Venn, όπως στο @fig-join-venn.
Ωστόσο, αυτή δεν είναι μια καλή αναπαράσταση, επειδή, ενώ μπορεί να φρεσκάρει τη μνήμη σας σχετικά με το ποιες γραμμές διατηρούνται, αποτυγχάνει όμως να επεξηγήσει τι συμβαίνει με τις στήλες.

```{r}
#| label: fig-join-venn
#| echo: false
#| out-width: ~
#| fig-cap: |
#|   Venn diagrams showing the difference between inner, left, right, and
#|   full joins.
#| fig-alt: |
#|   Venn diagrams for inner, full, left, and right joins. Each join
#|   represented with two intersecting circles representing data frames x
#|   and y, with x on the right and y on the left. Shading indicates the
#|   result of the join. 
#|
#|   Inner join: the intersection is shaded. 
#|   Full join: Everything is shaded. 
#|   Left join: All of x is shaded.
#|   Right join: All of y is shaded.

knitr::include_graphics("diagrams/join/venn.png", dpi = 270)
```

Οι ενώσεις που φαίνονται εδώ είναι οι λεγόμενες **equi** **joins**, όπου οι γραμμές αντιστοιχίζονται εάν τα κλειδιά είναι ίσα.
Οι ενώσεις ισοτιμίας είναι ο πιο συνηθισμένος τύπος ένωσης, επομένως συνήθως παραλείπουμε το πρόθεμα equi και απλώς λέμε "inner join" αντί για "equi inner join".
Θα επανέλθουμε στις non-equi ενώσεις στο @sec-non-equi-joins.

### Αντιστοίχιση γραμμών

Μέχρι στιγμής έχουμε εξερευνήσει τι συμβαίνει εάν μια γραμμή από το `x` ταιριάζει με μια ή καμμία γραμμή στο `y`.
Τι συμβαίνει όμως αν ταιριάζει με περισσότερες από μία γραμμές; Για να κατανοήσουμε τι συμβαίνει, ας εστιάσουμε την προσοχή μας στο `inner_join()` και ας σχεδιάσουμε μια εικόνα, @fig-join-match-types.

```{r}
#| label: fig-join-match-types
#| echo: false
#| out-width: ~
#| fig-cap: | 
#|   The three ways a row in `x` can match. `x1` matches
#|   one row in `y`, `x2` matches two rows in `y`, `x3` matches
#|   zero rows in y. Note that while there are three rows in
#|   `x` and three rows in the output, there isn't a direct
#|   correspondence between the rows.
#| fig-alt: |
#|   A join diagram where x has key values 1, 2, and 3, and y has
#|   key values 1, 2, 2. The output has three rows because key 1 matches
#|   one row, key 2 matches two rows, and key 3 matches zero rows.

knitr::include_graphics("diagrams/join/match-types.png", dpi = 270)
```

Υπάρχουν τρία πιθανά αποτελέσματα για μια γραμμή στο `x`:

-   Αν δεν ταιριάζει με τίποτα, απορρίπτεται.
-   Εάν ταιριάζει με 1 γραμμή στο `y`, διατηρείται.
-   Εάν αντιστοιχεί σε περισσότερες από 1 γραμμές στο `y`, γίνεται διπλότυπη μία φορά για κάθε αντιστοίχιση

Κατ 'αρχήν, αυτό σημαίνει ότι δεν υπάρχει εγγυημένη αντιστοιχία μεταξύ των γραμμών στην έξοδο και των γραμμών στο `x`, αλλά πρακτικά, αυτό σπάνια προκαλεί προβλήματα.
Υπάρχει, ωστόσο, μια ιδιαίτερα επικίνδυνη περίπτωση που μπορεί να προκαλέσει μια συνδυαστική έκρηξη γραμμών.
Φανταστείτε ότι ενώνετε τους παρακάτω δύο πίνακες:

```{r}
df1 <- tibble(key = c(1, 2, 2), val_x = c("x1", "x2", "x3"))
df2 <- tibble(key = c(1, 2, 2), val_y = c("y1", "y2", "y3"))
```

Ενώ η πρώτη γραμμή του `df1` αντιστοιχίζεται με μία μόνο γραμμή του `df2`, η δεύτερη και η τρίτη γραμμή αντιστοιχίζονται με από δύο γραμμές η καθεμία.
Αυτό μπορεί να το συναντήσετε ως ένωση `πολλά-με-πολλά`, και θα έχει ως αποτελέσμα η dplyr να επιστρέψει μια προειδοποίηση:

```{r}
df1 |> 
  inner_join(df2, join_by(key))
```

Εάν το κάνετε αυτό σκόπιμα, μπορείτε να ορίσετε `relationship = "many-to-many"`,, όπως προτείνει η προειδοποίηση.

### Ενώσεις φιλτραρίσματος

Ο αριθμός των αντιστοιχιών καθορίζει επίσης τη συμπεριφορά των ενώσεων φιλτραρίσματος.
Η ημι-ένωηση (semi-join) διατηρεί γραμμές στο `x` που έχουν μία ή περισσότερες αντιστοιχίσεις στο `y`, όπως στο @fig-join-semi.
Η αντι-ένωση (anti-join) διατηρεί γραμμές στο `x` που δεν ταιριάζουν με καμία γραμμή στο `y`, όπως στο @fig-join-anti.
Και στις δύο περιπτώσεις, μόνο η ύπαρξη μιας αντιστοίχισης είναι σημαντική, και όχι το πλήθος των αντιστοιχίσεων.
Αυτό σημαίνει ότι οι ενώσεις φιλτραρίσματος δεν δημιουργούν ποτέ διπλότυπες γραμμές όπως κάνουν οι ενώσεις αλλαγής.

```{r}
#| label: fig-join-semi
#| echo: false
#| out-width: null
#| fig-cap: |
#|   In a semi-join it only matters that there is a match; otherwise
#|   values in `y` don't affect the output.
#| fig-alt: |
#|   A join diagram with old friends x and y. In a semi join, only the 
#|   presence of a match matters so the output contains the same columns
#|   as x.

knitr::include_graphics("diagrams/join/semi.png", dpi = 270)
```

```{r}
#| label: fig-join-anti
#| echo: false
#| out-width: null
#| fig-cap: |
#|   An anti-join is the inverse of a semi-join, dropping rows from `x`
#|   that have a match in `y`.
#| fig-alt: |
#|   An anti-join is the inverse of a semi-join so matches are drawn with
#|   red lines indicating that they will be dropped from the output.

knitr::include_graphics("diagrams/join/anti.png", dpi = 270)
```

## Non-equi ενώσεις {#sec-non-equi-joins}

Μέχρι στιγμής έχετε δει μόνο ενώσεις ισοτιμίας, ενώσεις όπου οι γραμμές ταιριάζουν εάν το κλειδί του `x` ισούται με το κλειδί στο `y`.
Τώρα θα χαλαρώσουμε αυτόν τον περιορισμό και θα συζητήσουμε άλλους τρόπους για να προσδιορίσουμε εάν ένα ζευγάρι γραμμών ταιριάζει.

Αλλά προτού μπορέσουμε να το κάνουμε αυτό, πρέπει να επανεξετάσουμε μια απλοποίηση που κάναμε παραπάνω.
Σε ισότιμες ενώσεις (equi joins) τα κλειδιά των `x` και `y` είναι πάντα ίσα, οπότε αρκεί να εμφανίσουμε μόνο ένα στην έξοδο.
Μπορούμε να ζητήσουμε από την dplyr να διατηρήσει και τα δύο κλειδιά με το όρισμα `keep = TRUE`, οδηγώντας στον παρακάτω κώδικα και στο επανασχεδιασμένο `inner_join()` στο @fig-inner-both.

```{r}
x |> inner_join(y, join_by(key == key), keep = TRUE)
```

```{r}
#| label: fig-inner-both
#| fig-cap: |
#|   An inner join showing both `x` and `y` keys in the output.
#| fig-alt: |
#|   A join diagram showing an inner join betwen x and y. The result
#|   now includes four columns: key.x, val_x, key.y, and val_y. The
#|   values of key.x and key.y are identical, which is why we usually
#|   only show one.
#| echo: false
#| out-width: ~

knitr::include_graphics("diagrams/join/inner-both.png", dpi = 270)
```

Όταν απομακρυνόμαστε από τις equi ενώσεις, θα εμφανίζουμε πάντα τα κλειδιά, επειδή οι τιμές των κλειδιών συχνά θα είναι διαφορετικές.
Για παράδειγμα, αντί να κάνουμε την αντιστοίχιση μόνο όταν το `x$key` και το `y$key` είναι ίσα, θα μπορούσαμε να κάνουμε την αντιστοίχιση κάθε φορά που το `x$key` είναι μεγαλύτερο ή ίσο με το `y$key`, που οδηγεί στο @fig -join-gte.
Οι συναρτήσεις ένωσης της dplyr κατανοούν αυτή τη διάκριση ανάμεσα σε ισοδύναμες και μη ισοδύναμες ενώσεις, επομένως θα εμφανίζουν πάντα και τα δύο κλειδιά όταν εκτελείτε μια ένωση χωρίς ισοδυναμία.

```{r}
#| label: fig-join-gte
#| echo: false
#| fig-cap: |
#|   A non-equi join where the `x` key must be greater than or equal to 
#|   the `y` key. Many rows generate multiple matches.
#| fig-alt: |
#|   A join diagram illustrating join_by(key >= key). The first row
#|   of x matches one row of y and the second and thirds rows each match
#|   two rows. This means the output has five rows containing each of the 
#|   following (key.x, key.y) pairs: (1, 1), (2, 1), (2, 2), (3, 1),
#|   (3, 2).
knitr::include_graphics("diagrams/join/gte.png", dpi = 270)
```

Ο όρος "non-equi" ενώσεις δεν είναι ιδιαίτερα χρήσιμος, επειδή μας λέει μόνο τι δεν είναι η ένωση, όχι τι είναι.
Η dplyr βοηθά προσδιορίζοντας τέσσερις ιδιαίτερα χρήσιμους τύπους non-equi join:

-   Οι **διασταυρούμενες ενώσεις** (**Cross joins**) αντιστοιχίζουν κάθε ζεύγος γραμμών
-   Οι **ενώσεις ανισότητας** (**Inequality joins**) χρησιμοποιούν τα `<`, `<=`, `>`, και `>=` αντί του `==`.
-   Οι **κυλιόμενες ενώσεις** (**Rolling joins**) είναι παρόμοιες με τις ενώσεις ανισότητας αλλά βρίσκουν μόνο την πλησιέστερη αντιστοιχία.
-   Οι **ενώσεις επικάλυψης** (**Overlap joins**) είναι ένας ειδικός τύπος ένωσης ανισότητας που έχει σχεδιαστεί για να λειτουργεί με εύρη.

Κάθε μία από αυτές περιγράφεται λεπτομερέστερα στις επόμενες ενότητες.

### Διασταυρούμενες ενώσεις

Μια διασταυρούμενη ένωση ταιριάζει με τα πάντα, όπως στο @fig-join-cross, δημιουργώντας το καρτεσιανό γινόμενο των γραμμών.
Αυτό σημαίνει ότι η έξοδος θα έχει `nrow(x) * nrow(y)` γραμμές.

```{r}
#| label: fig-join-cross
#| echo: false
#| out-width: ~
#| fig-cap: |
#|   A cross join matches each row in `x` with every row in `y`.
#| fig-alt: |
#|   A join diagram showing a dot for every combination of x and y.
knitr::include_graphics("diagrams/join/cross.png", dpi = 270)
```

Οι διασταυρούμενες ενώσεις είναι χρήσιμες κατά τη δημιουργία συνδυασμών.
Για παράδειγμα, ο παρακάτω κώδικας δημιουργεί κάθε πιθανό ζεύγος ονομάτων.
Εφόσον ενώνουμε το `df` με τον εαυτό του, αυτό μερικές φορές ονομάζεται **αυτο-σύνδεση** (**self-join**).
Οι διασταυρούμενες ενώσεις χρησιμοποιούν διαφορετική συνάρτηση ένωσης επειδή δεν υπάρχει διάκριση μεταξύ εσωτερικές/αριστερές/δεξιές/πλήρεις ενώσεις όταν η αντιστοίχιση αφορά κάθε γραμμή.

```{r}
df <- tibble(name = c("John", "Simon", "Tracy", "Max"))
df |> cross_join(df)
```

### Ενώσεις ανισότητας

Οι ενώσεις ανισότητας χρησιμοποιούν τους τελεστές `<`, `<=`, `>=`, ή `>` για να περιορίσουν το σύνολο των πιθανών αντιστοιχίσεων, όπως στο @fig-join-gte και το @fig-join-lt.

```{r}
#| label: fig-join-lt
#| echo: false
#| out-width: ~
#| fig-cap: |
#|   An inequality join where `x` is joined to `y` on rows where the key 
#|   of `x` is less than the key of `y`. This makes a triangular
#|   shape in the top-left corner.
#| fig-alt: |
#|   A diagram depicting an inequality join where a data frame x is joined by 
#|   a data frame y where the key of x is less than the key of y, resulting 
#|   in a triangular shape in the top-left corner.

knitr::include_graphics("diagrams/join/lt.png", dpi = 270)
```

Οι ενώσεις ανισότητας είναι εξαιρετικά γενικές, τόσο γενικές που είναι δύσκολο να βρούμε ουσιαστικές συγκεκριμένες περιπτώσεις χρήσης.
Μια μικρή χρήσιμη τεχνική είναι να τις χρησιμοποιούμε για να περιορίσουμε τη διασταυρούμενη ένωση έτσι ώστε αντί να δημιουργούμε όλες τις μεταθέσεις, να δημιουργούμε όλους τους συνδυασμούς:

```{r}
df <- tibble(id = 1:4, name = c("John", "Simon", "Tracy", "Max"))

df |> inner_join(df, join_by(id < id))
```

### Κυλιόμενες ενώσεις

Οι κυλιόμενες ενώσεις είναι ένας ειδικός τύπος ένωσης ανισότητας όπου αντί να λαμβάνουμε *κάθε* γραμμή που ικανοποιεί την ανισότητα, παίρνουμε μόνο την πλησιέστερη γραμμή, όπως στο @fig-join-closest.
Μπορείτε να μετατρέψετε οποιαδήποτε ένωση ανισότητας σε κυλιόμενη ένωση προσθέτοντας το όρισμα `closest()`.
Για παράδειγμα, το `join_by(closest(x <= y))` αντιστοιχεί στο μικρότερο `y` που είναι μεγαλύτερο ή ίσο με το `x` και το `join_by(closest(x > y))` αντιστοιχεί στο μεγαλύτερο `y` που είναι μικρότερο από το `x`.

```{r}
#| label: fig-join-closest
#| echo: false
#| out-width: ~
#| fig-cap: |
#|   A rolling join is similar to a greater-than-or-equal inequality join
#|   but only matches the first value.
#| fig-alt: |
#|   A rolling join is a subset of an inequality join so some matches are
#|   grayed out indicating that they're not used because they're not the 
#|   "closest".
knitr::include_graphics("diagrams/join/closest.png", dpi = 270)
```

Οι κυλιόμενες ενώσεις είναι ιδιαίτερα χρήσιμες όταν έχετε δύο πίνακες ημερομηνιών που δεν ευθυγραμμίζονται τέλεια και θέλετε να βρείτε (για παράδειγμα) την πλησιέστερη ημερομηνία στον πίνακα 1 που είναι πριν (ή μετά) κάποια ημερομηνία στον πίνακα 2.

Για παράδειγμα, φανταστείτε ότι είστε υπεύθυνος της επιτροπής σχεδιασμού εορτασμών για το γραφείο σας.
Η εταιρεία σας θέλει να μην ξοδέψει πολλά χρήματα, επομένως αντί να κάνετε μεμονωμένα πάρτι, θα κάνετε ένα πάρτι μόνο, μία φορά το τρίμηνο.
Οι κανόνες για τον καθορισμό του πότε θα γίνει ένα πάρτι είναι λίγο περίπλοκοι: τα πάρτι γίνονται πάντα Δευτέρα, παραλείπετε την πρώτη εβδομάδα του Ιανουαρίου, καθώς πολλοί είναι σε διακοπές, ενώ και η πρώτη Δευτέρα του τρίτου τριμήνου 2022 είναι στις 4 Ιουλίου, οπότε και σε αυτή την περίπτωση η ημερομηνία του πάρτι θα πρέπει να μεταφερθεί κατά μια εβδομάδα αργότερα.
Αυτό οδηγεί στις ακόλουθες διαθέσιμες ημέρες για τα πάρτι:

```{r}
parties <- tibble(
  q = 1:4,
  party = ymd(c("2022-01-10", "2022-04-04", "2022-07-11", "2022-10-03"))
)
```

Τώρα φανταστείτε ότι έχετε έναν πίνακα με τα γενέθλια των εργαζομένων:

```{r}
set.seed(123)
employees <- tibble(
  name = sample(babynames::babynames$name, 100),
  birthday = ymd("2022-01-01") + (sample(365, 100, replace = TRUE) - 1)
)
employees
```

Και για κάθε εργαζόμενο θέλουμε να βρούμε τη πρώτη διαθέσιμη ημερομηνία για πάρτι που έρχεται μετά (ή πάνω στα) γενέθλιά του.
Μπορούμε να το εκφράσουμε με μια κυλιόμενη ένωση:

```{r}
employees |> 
  left_join(parties, join_by(closest(birthday >= party)))
```

Υπάρχει, ωστόσο, ένα πρόβλημα με αυτήν την προσέγγιση: οι άνθρωποι με γενέθλια πριν από τις 10 Ιανουαρίου δεν κάνουν πάρτι:

```{r}
employees |> 
  anti_join(parties, join_by(closest(birthday >= party)))
```

Για να το λύσουμε αυτό, θα χρειαστεί να αντιμετωπίσουμε το πρόβλημα με διαφορετικό τρόπο, χρησιμοποιώντας ενώσεις επικάλυψης.

### Ενώσεις επικάλυψης

Οι ενώσεις επικάλυψης παρέχουν τρεις βοηθητικές συναρτήσεις που χρησιμοποιούν ενώσεις ανισότητας για να διευκολύνουν την εργασία με διαστήματα:

-   Η `between(x, y_lower, y_upper)` είναι η συντομογραφία του `x >= y_lower, x <= y_upper`.
-   Η `within(x_lower, x_upper, y_lower, y_upper)` είναι η συντομογραφία του `x_lower >= y_lower, x_upper <= y_upper`.
-   Η `overlaps(x_lower, x_upper, y_lower, y_upper)` είναι η συντομογραφία του `x_lower <= y_upper, x_upper >= y_lower`.

Ας συνεχίσουμε με το παράδειγμα γενεθλίων για να δούμε πώς μπορείτε να τα χρησιμοποιήσετε.
Υπάρχει ένα πρόβλημα με τη στρατηγική που χρησιμοποιήσαμε παραπάνω: δεν υπάρχει πάρτι που να προηγείται των γενεθλίων που είναι μεταξύ 1-9 Ιανουαρίου.
Επομένως, ίσως είναι καλύτερο να είμαστε σαφείς σχετικά με το εύρος ημερομηνιών που καλύπτει κάθε πάρτι και να κάνουμε μια ειδική περίπτωση για αυτά τα πρώιμα γενέθλια:

```{r}
parties <- tibble(
  q = 1:4,
  party = ymd(c("2022-01-10", "2022-04-04", "2022-07-11", "2022-10-03")),
  start = ymd(c("2022-01-01", "2022-04-04", "2022-07-11", "2022-10-03")),
  end = ymd(c("2022-04-03", "2022-07-11", "2022-10-02", "2022-12-31"))
)
parties
```

Ο Hadley είναι απελπιστικά κακός στην εισαγωγή δεδομένων, έτσι ήθελε επίσης να ελέγξει ότι οι περίοδοι που οργανώνονται τα πάρτι δεν αλληλεπικαλύπτονται.
Ένας τρόπος για να το κάνετε αυτό είναι χρησιμοποιώντας μια αυτο-ένωση για να ελέγξετε εάν κάποιο διάστημα έναρξης-λήξης επικαλύπτεται με κάποιο άλλο:

```{r}
parties |> 
  inner_join(parties, join_by(overlaps(start, end, start, end), q < q)) |> 
  select(start.x, end.x, start.y, end.y)
```

Υπάρχει μια επικάλυψη, οπότε ας διορθώσουμε αυτό το πρόβλημα και ας συνεχίσουμε:

```{r}
parties <- tibble(
  q = 1:4,
  party = ymd(c("2022-01-10", "2022-04-04", "2022-07-11", "2022-10-03")),
  start = ymd(c("2022-01-01", "2022-04-04", "2022-07-11", "2022-10-03")),
  end = ymd(c("2022-04-03", "2022-07-10", "2022-10-02", "2022-12-31"))
)
```

Τώρα μπορούμε να ταιριάξουμε κάθε εργαζόμενο με το πάρτι του.
Αυτό είναι ένα καλό παράδειγμα για να χρησιμοποιήσετε το όρισμα `unmatched = "error"`, επειδή θέλουμε να μάθουμε γρήγορα εάν σε κάποιους υπαλλήλους δεν ανατέθηκε πάρτι.

```{r}
employees |> 
  inner_join(parties, join_by(between(birthday, start, end)), unmatched = "error")
```

### Ασκήσεις

1.  Μπορείτε να εξηγήσετε τι συμβαίνει με τα κλειδιά σε αυτή την ένωση ισοδυναμίας; Γιατί είναι διαφορετικά;

    ```{r}
    x |> full_join(y, join_by(key == key))

    x |> full_join(y, join_by(key == key), keep = TRUE)
    ```

2.  Για να βρούμε εάν οι περίοδοι των πάρτι επικαλύπτονται με άλλα πάρτι χρησιμοποιήσαμε το `q < q` στην `join_by()`.
    Γιατί; Τι συμβαίνει εάν αφαιρέσουμε αυτή την ανισότητα;

## Σύνοψη

Σε αυτό το κεφάλαιο, μάθατε πώς να χρησιμοποιείτε ενώσεις αλλαγής και ενώσεις φιλτραρίσματος για να συνδυάσετε δεδομένα από ένα ζεύγος πλαισίων δεδομένων.
Στην πορεία μάθατε πώς να αναγνωρίζετε κλειδιά και τη διαφορά μεταξύ πρωτεύοντος και ξένου κλειδιού.
Καταλαβαίνετε επίσης πώς λειτουργούν οι ενώσεις και πώς να υπολογίσετε πόσες γραμμές θα έχει η έξοδος.
Τέλος, ρίξατε μια ματιά στη δύναμη των non-equi ενώσεων και έχετε δει μερικές ενδιαφέρουσες περιπτώσεις χρήσης.

Αυτό το κεφάλαιο ολοκληρώνει το μέρος "Μετασχηματισμός" αυτού του βιβλίου, όπου η το ενδιαφέρον μας ήταν στα εργαλεία που θα μπορούσατε να χρησιμοποιήσετε με μεμονωμένες στήλες και tibbles.
Μάθατε για συναρτήσεις από την dplyr και από το βασικό σύνολο συναρτήσεων της R για εργασία με λογικά διανύσματα, αριθμούς και πλήρεις πίνακες, τις συναρτήσεις της stringr για εργασία με συμβολοσειρές, τις συναρτήσεις της lubridate για εργασία με ημερομηνίες-ώρες και τις συναρτήσεις της forcats για εργασία με παράγοντες.

Στο επόμενο μέρος του βιβλίου, θα μάθετε περισσότερα σχετικά με τη μετατροπή διαφόρων τύπων δεδομένων στην R σε μια τακτοποιημένη (tidy) μορφή.
