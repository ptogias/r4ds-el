# Ενώσεις {#sec-joins}

```{r}
#| echo: false

source("_common.R")
```

## Εισαγωγή

Είναι σπάνιο μία ανάλυση δεδομένων να περιλαμβάνει μόνο ένα πλαίσιο δεδομένων.
Συνήθως έχετε πολλά πλαίσια δεδομένων και πρέπει να τα **ενώσετε** για να απαντήσετε στις ερωτήσεις που σας ενδιαφέρουν.
Αυτό το κεφάλαιο θα σας παρουσιάσει δύο σημαντικούς τύπους ενώσεων:

-   Ενώσεις αλλαγής, οι οποίες προσθέτουν νέες μεταβλητές σε ένα πλαίσιο δεδομένων, οι οποίες προέρχονται από αντιστοιχισμένες παρατηρήσεις σε ένα άλλο πλαίσιο δεδομένων.
-   Ενώσεις φιλτραρίσματος (filtering joins), οι οποίες φιλτράρουν τις παρατηρήσεις από ένα πλαίσιο δεδομένων με βάση το αν ταιριάζουν ή όχι με μία παρατήρηση σε ένα άλλο.

Θα ξεκινήσουμε συζητώντας τα κλειδιά, τις μεταβλητές που χρησιμοποιούνται για να συνδέσουν ένα ζεύγος πλαισίων δεδομένων σε μία ένωση.
Θα εδραιώσουμε τη θεωρία εξετάζοντας τα κλειδιά στα σύνολα δεδομένων του πακέτου nycflights13 και, στη συνέχεια, χρησιμοποιούμε αυτή τη γνώση για να αρχίσουμε να ενώνουμε πλαίσια δεδομένων μεταξύ τους.
Στη συνέχεια θα συζητήσουμε το πώς λειτουργούν οι ενώσεις, εστιάζοντας στη δράση τους στις γραμμές.
Τέλος, Θα ολοκληρώσουμε με μία συζήτηση για ενώσεις που δεν είναι ισοδύναμες, μία οικογένεια ενώσεων που παρέχουν έναν πιο ευέλικτο τρόπο αντιστοίχισης κλειδιών από την προεπιλεγμένη σχέση ισότητας.

### Προαπαιτούμενα

Σε αυτό το κεφάλαιο, θα εξερευνήσουμε τα πέντε σχετικά σύνολα δεδομένων από το nycflights13 χρησιμοποιώντας τις συναρτήσεις ένωσης (join) της dplyr.

```{r}
#| label: setup
#| message: false

library(tidyverse)
library(nycflights13)
```

## Κλειδιά

Για να κατανοήσετε τις ενώσεις, πρέπει πρώτα να κατανοήσετε πώς δύο πίνακες μπορούν να συνδεθούν μέσω ενός ζεύγους κλειδιών, που υπάρχουν σε κάθε πίνακα.
Σε αυτήν την ενότητα, θα μάθετε για τους δύο τύπους κλειδιών και θα δείτε παραδείγματα και των δύο στα σύνολα δεδομένων του πακέτου nycflights13.
Θα μάθετε επίσης πώς να ελέγχετε ότι τα κλειδιά σας είναι έγκυρα και τι να κάνετε εάν ο πίνακας σας δεν διαθέτει κλειδί.

### Πρωτεύοντα και δευτερεύοντα (ξένα) κλειδιά

Κάθε ένωση περιλαμβάνει ένα ζεύγος κλειδιών: ένα πρωτεύον (ή κύριο) κλειδί και ένα ξένο (ή δευτερεύον) κλειδί.
Ένα **πρωτεύον κλειδί** είναι μία μεταβλητή ή ένα σύνολο μεταβλητών που προσδιορίζει μοναδικά κάθε παρατήρηση.
Όταν χρειάζονται περισσότερες από μία μεταβλητές, το κλειδί ονομάζεται **σύνθετο κλειδί.** Για παράδειγμα, στο nycflights13:

-   Το πλαίσιο δεδομένων `airlines` καταγράφει για κάθε αεροπορική εταιρεία δύο στοιχεία: τον κωδικό της εταιρείας και το πλήρες όνομά της.
    Μπορείτε να προσδιορίσετε μία αεροπορική εταιρεία με τον κωδικό δύο γραμμάτων που της αντιστοιχεί, καθιστώντας τη μεταβλητή `carrier` το πρωτεύον κλειδί.

    ```{r}
    airlines
    ```

-   Το `airports` καταγράφει δεδομένα για κάθε αεροδρόμιο.
    Μπορείτε να προσδιορίσετε κάθε αεροδρόμιο με τον κωδικό τριών γραμμάτων που του αντιστοιχεί, καθιστώντας τη μεταβλητή `faa` το πρωτεύον κλειδί.

    ```{r}
    #| R.options:
    #|   width: 67
    airports
    ```

-   Το `planes` καταγράφει δεδομένα για κάθε αεροπλάνο.
    Μπορείτε να προσδιορίσετε ένα αεροπλάνο με τον αναγνωριστικό κωδικό του, καθιστώντας τη μεταβλητή `tailnum` το πρωτεύον κλειδί.

    ```{r}
    #| R.options:
    #|   width: 67
    planes
    ```

-   Το `weather` καταγράφει δεδομένα για τον καιρό στο αεροδρόμιο αναχώρησης.
    Μπορείτε να προσδιορίσετε κάθε παρατήρηση από το συνδυασμό τοποθεσίας και ώρας, καθιστώντας τις μεταβλητές `origin` και `time_hour` το σύνθετο πρωτεύον κλειδί.

    ```{r}
    #| R.options:
    #|   width: 67
    weather
    ```

Ένα **ξένο κλειδί** είναι μία μεταβλητή (ή σύνολο μεταβλητών) που αντιστοιχεί στο πρωτεύον κλειδί από έναν άλλο πίνακα.
Για παράδειγμα:

-   Η μεταβλητή `flights$tailnum` είναι ένα ξένο κλειδί που αντιστοιχεί στο πρωτεύον κλειδί `planes$tailnum`.
-   Η μεταβλητή `flights$carrier` είναι ένα ξένο κλειδί που αντιστοιχεί στο πρωτεύον κλειδί `airlines$carrier`.
-   Η μεταβλητή `flights$origin` είναι ένα ξένο κλειδί που αντιστοιχεί στο πρωτεύον κλειδί `airports$faa`.
-   Η μεταβλητή `flights$dest` είναι ένα ξένο κλειδί που αντιστοιχεί στο πρωτεύον κλειδί `airports$faa`.
-   Η μεταβλητή `flights$origin`-`flights$time_hour` είναι ένα σύνθετο ξένο κλειδί που αντιστοιχεί στο σύνθετο πρωτεύον κλειδί `weather$origin`-`weather$time_hour`.

Αυτές οι σχέσεις συνοψίζονται και οπτικά στο @fig-flights-relationships.

```{r}
#| label: fig-flights-relationships
#| echo: false
#| out-width: ~
#| fig-cap: |
#|   Συνδέσεις μεταξύ και των πέντε πλαισίων δεδομένων στο πακέτο nycflights13.
#|   Οι μεταβλητές που αποτελούν ένα πρωτεύον κλειδί έχουν γκρι χρώμα, και 
#|   συνδέονται με τα αντίστοιχα ξένα κλειδιά τους με βέλη.
#| fig-alt: |
#|   Οι σχέσεις μεταξύ αεροδρομίων, αεροπλάνων, πτήσεων, καιρού και συνόλων 
#|   δεδομένων αεροπορικών εταιρειών από το πακέτο nycflights13. Η airports$faa
#|   συνδέεται με τις flights$origin και flights$dest. Η planes$tailnum 
#|   συνδέεται με τη flights$tailnum. Οι weather$time_hour weather$origin 
#|   συνδέονται από κοινού με τις flights$time_hour και τις flights$origin. Η
#|   airlines$carrier είναι συνδεδεμένη με τη flights$carrier. Δεν υπάρχουν απευθείας
#|   συνδέσεις μεταξύ αεροδρομίων, αεροπλάνων, αεροπορικών εταιρειών και πλαισίων
#|   δεδομένων για τον καιρό.
knitr::include_graphics("diagrams/relational.png", dpi = 270)
```

Θα παρατηρήσετε ένα ωραίο χαρακτηριστικό στο σχεδιασμό αυτών των κλειδιών: το πρωτεύον και το ξένο κλειδί έχουν σχεδόν πάντα τα ίδια ονόματα, κάτι που, όπως θα δείτε σύντομα, θα κάνει πολύ πιο εύκολη τη ζωή σας όταν κάνετε ενώσεις.
Αξίζει επίσης να σημειωθεί και η αντίθετη σχέση: σχεδόν κάθε όνομα μεταβλητής που χρησιμοποιείται σε πολλούς πίνακες έχει την ίδια σημασία σε κάθε μέρος.
Υπάρχει μόνο μία εξαίρεση: η μεταβλητή `year` υποδηλώνει το έτος αναχώρησης στο πλαίσιο δεδομένων `flights` το έτος του κατασκευαστή στο πλαίσιο δεδομένων `planes`.
Αυτό θα γίνει σημαντικό όταν αρχίσουμε να ενώνουμε πίνακες μαζί.

### Έλεγχος πρωτευόντων κλειδιών

Τώρα που προσδιορίσαμε τα κύρια κλειδιά σε κάθε πίνακα, είναι καλή πρακτική να επαληθεύσουμε ότι όντως προσδιορίζουν μοναδικά κάθε παρατήρηση.
Ένας τρόπος για να γίνει αυτό είναι να μετρώντας τις τιμές που αντιστοιχούν στα κύρια κλειδιά με την `count()` και να εστιάσουμε σε παρατηρήσεις όπου το πλήθος τιμών (`n`) είναι μεγαλύτερο από ένα.
Αυτός ο έλεγχος αποκαλύπτει ότι οι μεταβλητές `planes` και `weather` δείχνουν και οι δύο καλά:

```{r}
planes |> 
  count(tailnum) |> 
  filter(n > 1)

weather |> 
  count(time_hour, origin) |> 
  filter(n > 1)
```

Θα πρέπει επίσης να ελέγξετε για την ύπαρξη κενών τιμών στα κύρια κλειδιά σας --- εάν λείπει μία τιμή, αυτό σημαίνει ότι μία παρατήρηση δεν μπορεί να αναγνωριστεί!

```{r}
planes |> 
  filter(is.na(tailnum))

weather |> 
  filter(is.na(time_hour) | is.na(origin))
```

### Υποκατάστατα κλειδιά

Μέχρι στιγμής δεν έχουμε μιλήσει για το πρωτεύον κλειδί στο πλαίσιο δεδομένων `flights`.
Δεν είναι πολύ σημαντικό εδώ, επειδή δεν υπάρχουν πλαίσια δεδομένων που να το χρησιμοποιούν ως ξένο κλειδί, αλλά παραμένει χρήσιμο να το αναφέρουμε γιατί είναι πιο εύκολο να εργαστούμε με παρατηρήσεις, αν έχουμε κάποιο τρόπο να τις περιγράψουμε σε άλλους.

Μετά από λίγη σκέψη και πειραματισμό, αποφασίσαμε ότι υπάρχουν τρεις μεταβλητές που μαζί προσδιορίζουν μοναδικά κάθε πτήση:

```{r}
flights |> 
  count(time_hour, carrier, flight) |> 
  filter(n > 1)
```

Κάνει αυτόματα η απουσία διπλότυπων τιμών τον συνδυασμό `time_hour`-`carrier`-`flight` ένα πρωτεύον κλειδί; Είναι σίγουρα μία καλή αρχή, ωστόσο δεν αποτελεί εγγύηση.
Για παράδειγμα, είναι το υψόμετρο και το γεωγραφικό πλάτος ένα καλό πρωτεύον κλειδί για το πλαίσιο `airports`;

```{r}
airports |>
  count(alt, lat) |> 
  filter(n > 1)
```

Η αναγνώριση ενός αεροδρομίου με βάση το υψόμετρο και το γεωγραφικό του πλάτος είναι σαφώς κακή ιδέα και γενικά δεν είναι δυνατό να γνωρίζουμε μόνο από τα δεδομένα εάν ένας συνδυασμός μεταβλητών αποτελεί ένα καλό πρωτεύον κλειδί ή όχι.
Ωστόσο, για τις πτήσεις, ο συνδυασμός των μεταβλητών `time_hour`, `carrier`, και `flight` φαίνεται λογικός γιατί θα προκαλούσε σύγχυση για μία αεροπορική εταιρεία και τους πελάτες της εάν υπήρχαν πολλές πτήσεις με τον ίδιο αριθμό πτήσης στον αέρα ταυτόχρονα .

Έχοντας ξεκαθαρίσει αυτό το σημείο, ίσως είναι καλύτερα να εισάγουμε ένα απλό αριθμητικό υποκατάστατο κλειδί χρησιμοποιώντας τον αριθμό κάθε γραμμής:

```{r}
flights2 <- flights |> 
  mutate(id = row_number(), .before = 1)
flights2
```

Τα υποκατάστατα κλειδιά μπορούν να είναι ιδιαίτερα χρήσιμα όταν επικοινωνείτε με άλλους ανθρώπους: είναι πολύ πιο εύκολο να πείτε σε κάποιον να ρίξει μία ματιά στην πτήση 2001 παρά να του πείτε να δει την UA430 που αναχώρησε στις 9 π.μ., στις 03-01-2013.

### Ασκήσεις

1.  Ξεχάσαμε να σχεδιάσουμε τη σχέση μεταξύ `weather` και `airports` στο @fig-flights-relationships.
    Ποια είναι η σχέση και πώς πρέπει να εμφανίζεται στο διάγραμμα;

2.  Η μεταβλητή `weather` περιέχει μόνο πληροφορίες για τα τρία αεροδρόμια αναχώρησης στη Νέα Υόρκη.
    Εάν περιείχε αρχεία καιρού για όλα τα αεροδρόμια των ΗΠΑ, ποια πρόσθετη σύνδεση θα έκανε με το πλαίσιο δεδομένων `flights`;

3.  Οι μεταβλητές `year`, `month`, `day`, `hour`, και `origin` σχεδόν σχηματίζουν ένα σύνθετο κλειδί για το πλαίσιο δεδομένων `weather`, ωστόσο υπάρχει μία τιμή ώρας που έχει διπλότυπες παρατηρήσεις.
    Μπορείτε να καταλάβετε τι το ιδιαίτερο έχει αυτή η ώρα;

4.  Γνωρίζουμε ότι κάποιες μέρες του χρόνου είναι ιδιαίτερες και λιγότεροι άνθρωποι από το συνηθισμένο επιλέγουν να πετάξουν αυτές τις μέρες (για παράδειγμα, παραμονή και ανήμερα Χριστουγέννων).
    Πώς μπορείτε να αναπαραστήσετε αυτά τα δεδομένα ως πλαίσιο δεδομένων; Ποιο θα ήταν το πρωτεύον κλειδί; Πώς θα συνδεόταν με τα υπάρχοντα πλαίσια δεδομένων;

5.  Σχεδιάστε ένα διάγραμμα που απεικονίζει τις συνδέσεις μεταξύ των πλαισίων δεδομένων `Batting`, `People`, και `Salaries`στο πακέτο Lahman.
    Σχεδιάστε ένα άλλο διάγραμμα που δείχνει τη σχέση μεταξύ των `People`, `Managers`, `AwardsManagers`.
    Πώς θα χαρακτηρίζατε τη σχέση μεταξύ των πλαισίων δεδομένων `Batting`, `Pitching`, και `Fielding`;

## Βασικές ενώσεις {#sec-mutating-joins}

Τώρα που καταλαβαίνετε πως συνδέονται τα πλαίσια δεδομένων με τη βοήθεια κλειδιών, μπορούμε να αρχίσουμε να χρησιμοποιούμε ενώσεις για να κατανοήσουμε καλύτερα το σύνολο δεδομένων `flights`.
Η dplyr προσφέρει έξι συναρτήσεις ένωσης: `left_join()`, `inner_join()`, `right_join()`, `full_join()`, `semi_join()`, και `anti_join().` Όλες έχουν την ίδια διεπαφή: παίρνουν ένα ζευγάρι πλαισίων δεδομένων (`x` και `y`) και επιστρέφουν ένα πλαίσιο δεδομένων.
Η σειρά των γραμμών και στηλών στην έξοδο καθορίζεται κυρίως από το `x`.

Σε αυτήν την ενότητα, θα μάθετε πώς να χρησιμοποιείτε μία ένωση αλλαγής, την `left_join()`, και δύο filtering ενώσεις, τις `semi_join()` και `anti_join()`.
Στην επόμενη ενότητα, θα μάθετε πώς ακριβώς λειτουργούν αυτές οι συναρτήσεις, καθώς και για τις υπόλοιπες: `inner_join()`, `right_join()` και `full_join()`.

### Ενώσεις αλλαγής

Μια **ένωση αλλαγής** σάς επιτρέπει να συνδυάσετε μεταβλητές από δύο πλαίσια δεδομένων: πρώτα αντιστοιχίζει παρατηρήσεις με βάση τα κλειδιά τους και μετά αντιγράφει παρατηρήσεις μεταξύ των μεταβλητών από το ένα πλαίσιο δεδομένων στο άλλο.
Όπως και η `mutate()`, οι συναρτήσεις ένωσης προσθέτουν μεταβλητές στα δεξιά, οπότε αν το σύνολο δεδομένων σας έχει πολλές μεταβλητές, δεν θα δείτε τις νέες.
Για αυτά τα παραδείγματα, θα διευκολύνουμε την παρατήρηση του τι συμβαίνει δημιουργώντας ένα πιο στενό σύνολο δεδομένων με έξι μόνο μεταβλητές[^joins-1]:

[^joins-1]: Να θυμάστε ότι στο RStudio μπορείτε επίσης να χρησιμοποιήσετε το `View()` για να αποφύγετε αυτό το πρόβλημα.

```{r}
flights2 <- flights |> 
  select(year, time_hour, origin, dest, tailnum, carrier)
flights2
```

Υπάρχουν τέσσερις τύποι ενώσεων αλλαγής, ωστόσο ένας είναι που θα χρησιμοποιείτε σχεδόν συνέχεια: `left_join()`.
Αυτό είναι ιδιαίτερο γιατί η έξοδος θα έχει πάντα τις ίδιες γραμμές με το `x`, το πλαίσιο δεδομένων προς το οποίο συνδέετε[^joins-2].
Η κύρια χρήση του `left_join()` είναι η προσθήκη επιπλέον μεταδεδομένων.
Για παράδειγμα, μπορούμε να χρησιμοποιήσουμε το `left_join()` για να προσθέσουμε το πλήρες όνομα της αεροπορικής εταιρείας στα δεδομένα του `flights2`:

[^joins-2]: Αυτό δεν είναι 100% αλήθεια, αλλά θα λαμβάνετε μία προειδοποίηση όποτε δεν είναι.

```{r}
flights2 |>
  left_join(airlines)
```

Ή θα μπορούσαμε να μάθουμε τη θερμοκρασία και την ταχύτητα του ανέμου όταν κάθε αεροπλάνο αναχωρούσε:

```{r}
flights2 |> 
  left_join(weather |> select(origin, time_hour, temp, wind_speed))
```

Ή τι μέγεθος αεροπλάνου πετούσε:

```{r}
flights2 |> 
  left_join(planes |> select(tailnum, type, engines, seats))
```

Όταν η `left_join()` δεν βρει ταίριασμα για μία γραμμή στο `x`, συμπληρώνει τις νέες μεταβλητές με κενές τιμές.
Για παράδειγμα, δεν υπάρχουν πληροφορίες σχετικά με το αεροπλάνο με αναγνωριστικό κωδικό `N3ALAA`, οπότε οι τιμές στις στήλες `type`, `engines`, και `seats` θα λείπουν:

```{r}
flights2 |> 
  filter(tailnum == "N3ALAA") |> 
  left_join(planes |> select(tailnum, type, engines, seats))
```

Θα επανέλθουμε σε αυτό το πρόβλημα μερικές φορές στο υπόλοιπο αυτού του κεφαλαίου.

### Καθορισμός κλειδιών ένωσης

Από προεπιλογή, η `left_join()` θα χρησιμοποιεί όλες τις μεταβλητές που εμφανίζονται και στα δύο πλαίσια δεδομένων ως κλειδί ένωση, τη λεγόμενη **φυσική** (**natural**) ένωση.
Αυτός είναι ένα χρήσιμος κανόνας, αλλά δεν λειτουργεί πάντα.
Για παράδειγμα, τι θα συμβεί αν προσπαθήσουμε να ενώσουμε το `flights2` με το πλήρες σύνολο δεδομένων `planes`;

```{r}
flights2 |> 
  left_join(planes)
```

Θα λάβουμε πολλές περιπτώσεις χωρίς αντιστοίχιση επειδή η ένωση μας προσπαθεί να χρησιμοποιήσει τις μεταβλητές `tailnum` και `year` ως σύνθετο κλειδί.
Και τα δύο σύνολα, `flights` και `planes`, περιέχουν μία στήλη `year`, ωστόσο αυτή η στήλη έχει σημαίνει διαφορετικά πράγματα σε κάθε περίπτωση: η `flights$year` είναι το έτος που πραγματοποιήθηκε η πτήση και η `planes$year` είναι το έτος κατασκευής του αεροπλάνου.
Θέλουμε να πραγματοποιήσουμε ένωση μόνο με βάση την `tailnum`, επομένως πρέπει να παρέχουμε μία ρητή προδιαγραφή με το `join_by()`:

```{r}
flights2 |> 
  left_join(planes, join_by(tailnum))
```

Σημειώστε ότι η προέλευση των μεταβλητών `year` αποσαφηνίζεται στην έξοδο με ένα επίθημα (`year.x` και `year.y`), το οποίο μας λέει εάν η μεταβλητή προήλθε από το όρισμα `x` ή `y`.
Μπορείτε να παρακάμψετε τα προεπιλεγμένα επιθήματα με το όρισμα `suffix`.

Το `join_by(tailnum)` είναι η σύντομη εκδοχή του `join_by(tailnum == tailnum)`.
Είναι σημαντικό να γνωρίζετε αυτήν την πληρέστερη εκδοχή για δύο λόγους.
Πρώτον, γιατί περιγράφει τη σχέση μεταξύ των δύο πινάκων: τα κλειδιά πρέπει να είναι ίσα (equal).
Αυτός είναι ο λόγος για τον οποίο αυτός ο τύπος ένωσης ονομάζεται συχνά **equi ένωση**.
Θα μάθετε για τις non-equi ενώσεις στην @sec-non-equi-joins.

Δεύτερον, γιατί δείχνει τον τρόπο με τον οποίο καθορίζετε διαφορετικά κλειδιά ένωσης σε κάθε πίνακα.
Για παράδειγμα, υπάρχουν δύο τρόποι για να ενώσετε τους πίνακες `flight2` και `airports`: είτε με βάση το `dest` (τον προορισμό) είτε το `origin` (την προέλευση):

```{r}
flights2 |> 
  left_join(airports, join_by(dest == faa))

flights2 |> 
  left_join(airports, join_by(origin == faa))
```

Σε παλαιότερο κώδικα, ενδέχεται να δείτε έναν διαφορετικό τρόπο καθορισμού των κλειδιών ένωσης, χρησιμοποιώντας ένα διάνυσμα χαρακτήρων:

-   Το `by = "x"` αντιστοιχεί στο `join_by(x)`.
-   Το `by = c("a" = "x")` αντιστοιχεί στο `join_by(a == x)`.

Ωστόσο, προτιμούμε το `join_by()` που υπάρχει πλέον, αφού παρέχει ένα πιο ξεκάθαρο και πιο ευέλικτο τρόπο προσδιορισμού.

Οι `inner_join()`, `right_join()`, και `full_join()` έχουν την ίδια διεπαφή με τη `left_join()`.
Η διαφορά εντοπίζετε στο ποιες γραμμές διατηρούν: η αριστερή ένωση (`left_join()`) διατηρεί όλες τις γραμμές από το `x`, η δεξιά ένωση (`right_join()`) διατηρεί όλες τις γραμμές από το `y`, η πλήρης ένωση (`full_join()`) διατηρεί όλες τις γραμμές, είτε προέρχονται από το `x` είτε από το `y` και η εσωτερική ένωση (`inner_join()`) διατηρεί μόνο τις γραμμές που εμφανίζονται και στο `x` και στο `y`.
Θα επανέλθουμε σε αυτά με περισσότερες λεπτομέρειες αργότερα.

### Ενώσεις φιλτραρίσματος

Όπως μπορείτε να μαντέψετε, η κύρια ενέργεια μιας **filtering ένωσης** είναι το φιλτράρισμα των γραμμών Υπάρχουν δύο τύποι: ημι-ενώσεις και αντι-ενώσεις.
Οι **ημι-ενώσεις** (**semi-joins**) διατηρούν όλες τις σειρές στο `x` που έχουν αντιστοιχία στο `y`.
Για παράδειγμα, θα μπορούσαμε να χρησιμοποιήσουμε μία ημι-ένωση για να φιλτράρουμε το σύνολο δεδομένων `airports` για να διατηρήσουμε μόνο τα αεροδρόμια προέλευσης:

```{r}
airports |> 
  semi_join(flights2, join_by(faa == origin))
```

Ή μόνο τους προορισμούς:

```{r}
airports |> 
  semi_join(flights2, join_by(faa == dest))
```

Οι **αντι-ενώσεις** (**anti-joins**) είναι το αντίθετο: επιστρέφουν όλες τις γραμμές από το `x` που δεν έχουν αντιστοιχία στο `y`.
Είναι χρήσιμα για την εύρεση κενών τιμών που είναι **έμμεσες** στα δεδομένα, το θέμα του @sec-missing-implicit.
Οι τιμές που λείπουν σιωπηρά δεν εμφανίζονται ως `NA` αλλά υπάρχουν μόνο ως απουσία.
Για παράδειγμα, μπορούμε να βρούμε γραμμές που λείπουν από το `airports` αναζητώντας πτήσεις που δεν έχουν αντίστοιχο αεροδρόμιο προορισμού:

```{r}
flights2 |> 
  anti_join(airports, join_by(dest == faa)) |> 
  distinct(dest)
```

Ή μπορούμε να βρούμε ποιες τιμές της μεταβλητής `tailnum` λείπουν από το `planes`:

```{r}
flights2 |>
  anti_join(planes, join_by(tailnum)) |> 
  distinct(tailnum)
```

### Ασκήσεις

1.  Εντοπίστε τις 48 ώρες (κατά τη διάρκεια ολόκληρου του έτους) που έχουν τις χειρότερες καθυστερήσεις.
    Διασταυρώστε το με τα δεδομένα του `weather`.
    Μπορείτε να δείτε κάποιο μοτίβο;

2.  Φανταστείτε ότι έχετε βρει τους 10 πιο δημοφιλείς προορισμούς χρησιμοποιώντας αυτόν τον κώδικα:

    ```{r}
    top_dest <- flights2 |>
      count(dest, sort = TRUE) |>
      head(10)
    ```

    Πώς μπορείτε να βρείτε όλες τις πτήσεις προς αυτούς τους προορισμούς;

3.  Έχει κάθε πτήση που αναχωρεί αντίστοιχα δεδομένα καιρού για εκείνη την ώρα;

4.  Τι κοινό έχουν οι αναγνωριστικοί κωδικοί των αεροσκαφών που δεν έχουν αντίστοιχη εγγραφή στο `planes`; (Υπόδειξη: μία μεταβλητή εξηγεί \~90% των προβλημάτων.)

5.  Προσθέστε μία στήλη στο `planes` που αναφέρει κάθε `carrier` που έχει χρησιμοποιήσει αυτό το αεροπλάνο.
    Μπορεί να περιμένετε ότι υπάρχει μία έμμεση σχέση μεταξύ αεροπλάνου και αεροπορικής εταιρείας, επειδή κάθε αεροπλάνο πετά με μία μόνο αεροπορική εταιρεία.
    Επιβεβαιώστε ή απορρίψτε αυτήν την υπόθεση χρησιμοποιώντας τα εργαλεία που έχετε μάθει σε προηγούμενα κεφάλαια.

6.  Προσθέστε το γεωγραφικό πλάτος και μήκος του αεροδρομίου προέλευσης *και* προορισμού στο πλαίσιο δεδομένων `flights`.
    Είναι πιο εύκολο να μετονομάσετε τις στήλες πριν ή αφού κάνετε την ένωση;

7.  Υπολογίστε τη μέση καθυστέρηση ανά προορισμό και, στη συνέχεια, ενώστε την πληροφορία στο `airports`, ώστε να μπορέσετε να παρουσιάσετε την κατανομή των καθυστερήσεων γεωγραφικά.
    Ακολουθεί ένας εύκολος τρόπος για να σχεδιάσετε έναν χάρτη των Ηνωμένων Πολιτειών:

    ```{r}
    #| eval: false

    airports |>
      semi_join(flights, join_by(faa == dest)) |>
      ggplot(aes(x = lon, y = lat)) +
        borders("state") +
        geom_point() +
        coord_quickmap()
    ```

    Μπορεί να θέλετε να χρησιμοποιήσετε το `size` ή το `color` των σημείων για να εμφανίσετε τη μέση καθυστέρηση για κάθε αεροδρόμιο.

8.  Τι συνέβη στις 13 Ιουνίου 2013; Σχεδιάστε έναν χάρτη με τις καθυστερήσεις και, στη συνέχεια, χρησιμοποιήστε το Google για να διασταυρώσετε τα δεδομένα για τον καιρό.

    ```{r}
    #| eval: false
    #| include: false

    worst <- filter(flights, !is.na(dep_time), month == 6, day == 13)
    worst |>
      group_by(dest) |>
      summarize(delay = mean(arr_delay), n = n()) |>
      filter(n > 5) |>
      inner_join(airports, join_by(dest == faa)) |>
      ggplot(aes(x = lon, y = lat)) +
        borders("state") +
        geom_point(aes(size = n, color = delay)) +
        coord_quickmap()
    ```

## Πώς λειτουργούν οι ενώσεις;

Τώρα που έχετε χρησιμοποιήσει ενώσεις κάποιες φορές, ήρθε η ώρα να μάθετε περισσότερα σχετικά με τον τρόπο λειτουργίας τους, εστιάζοντας στο πώς κάθε γραμμή στο `x` αντιστοιχίζεται με τις γραμμές στο `y`.
Θα ξεκινήσουμε εισάγοντας μία οπτική αναπαράσταση των ενώσεων, χρησιμοποιώντας τα απλά tibbles που ορίζονται παρακάτω και εμφανίζονται στο @fig-join-setup.
Σε αυτά τα παραδείγματα θα χρησιμοποιήσουμε ένα μόνο κλειδί που ονομάζεται `key` και μία στήλη με μία τιμή (`val_x` και `val_y`), αλλά όλες οι ιδέες που χρησιμοποιούνται εδώ γενικεύονται σε πολλά κλειδιά και πολλαπλές τιμές.

```{r}
x <- tribble(
  ~key, ~val_x,
     1, "x1",
     2, "x2",
     3, "x3"
)
y <- tribble(
  ~key, ~val_y,
     1, "y1",
     2, "y2",
     4, "y3"
)
```

```{r}
#| label: fig-join-setup
#| echo: false
#| out-width: ~
#| fig-cap: |
#|   Γραφική αναπαράσταση των δύο απλών πινάκων. Οι χρωματισμένες στήλες
#|   `key` αντιστοιχίζουν το χρώμα υποβάθρου στην τιμή του κλειδιού. Οι 
#|   γκρι στήλες αντιπροσωπεύουν τις στήλες τιμών που μεταφέρονται στην πορεία.
#| fig-alt: |
#|   Τα x και y είναι δύο πλαίσια δεδομένων με 2 στήλες και 3 γραμμές,
#|   με περιεχόμενα όπως περιγράφοτναι στο κείμενο. Οι τιμές των κλειδιών
#|   είναι χρωματισμένες: το 1 αντιστοιχεί στο πράσινο, το 2 στο μωβ, το 3
#|   στο πορτοκαλί και το 4 στο κίτρινο.

knitr::include_graphics("diagrams/join/setup.png", dpi = 270)
```

Το @fig-join-setup2 εισάγει τη βάση για την οπτική μας αναπαράσταση.
Εμφανίζει όλες τις πιθανές αντιστοιχίσεις μεταξύ των `x` και `y` ως τομή μεταξύ των γραμμών που σχεδιάζονται από κάθε γραμμή του `x` και κάθε γραμμής του `y`.
Οι γραμμές και οι στήλες στην έξοδο καθορίζονται κυρίως από το `x`, επομένως ο πίνακας `x` είναι οριζόντιος και ευθυγραμμίζεται με την έξοδο.

```{r}
#| label: fig-join-setup2
#| echo: false
#| out-width: ~
#| fig-cap: | 
#|   Για να κατανοήσετε πως δουλεύουν οι ενώσεις, είναι χρήσιμο να σκεφτείτε
#|   κάθε πιθανό συνδυασμό. Εδώ το δείχνουμε αυτό με ένα πλέγμα συνδεόμενων
#|   γραμμών.
#| fig-alt: |
#|   Τα x και y σχηματίζουν ορθή γωνία, με οριζόντιες γραμμές να εκτείνονται 
#|   από το x και κάθετες γραμμές να εκτείνονται από το y. Υπάρχουν 3 γραμμές
#|   στο x και 3 γραμμές στο y, που έχει σαν αποτέλεσμα 9 τομές, που αντιπροσωπεύουν
#|   9 πιθανούς συνδυασμούς.

knitr::include_graphics("diagrams/join/setup2.png", dpi = 270)
```

Για να περιγράψουμε έναν συγκεκριμένο τύπο ένωσης, υποδεικνύουμε τις αντιστοιχίσεις με τελείες.
Οι αντιστοιχίσεις καθορίζουν τις γραμμές στην έξοδο, ένα νέο πλαίσιο δεδομένων που περιέχει το κλειδί, τις τιμές x και τις τιμές y.
Για παράδειγμα, το @fig-join-inner δείχνει μία εσωτερική ένωση, όπου οι γραμμές διατηρούνται εάν και μόνο εάν τα κλειδιά είναι ίσα.

```{r}
#| label: fig-join-inner
#| echo: false
#| out-width: ~
#| fig-cap: |
#|   Μια εσωτερική ένωση αντιστοιχίζει κάθε γραμμή του `x` στη γραμμή του 
#|   `y` που έχει την ίδια τιμή στο `key`. Κάθε συνδυασμός γίνεται μια 
#|   γραμμή στην έξοδο.
#| fig-alt: |
#|   Τα x και y σχηματίζουν ορθή γωνία με γραμμές που σχηματίζουν ένα
#|   πλέγμα πιθανών συνδυασμών. Τα κλειδιά 1 και 2 εμφανίζονται τόσο
#|   στο x όσο και στο y, οπότε παίρνουμε έναν συνδυασμό που υποδεικνεύται 
#|   από μία κουκίδα. Κάθε κουκίδα αντιστοιχεί σε μια γραμμή της εξόδου, 
#|   οπότε το πλαίσιο δεδομένων που προκύπτει μετά την ένωση έχει δύο γραμμές.

knitr::include_graphics("diagrams/join/inner.png", dpi = 270)
```

Μπορούμε να εφαρμόσουμε τις ίδιες αρχές για να εξηγήσουμε τις **εξωτερικές ενώσεις** (**outer joins**), οι οποίες διατηρούν τις παρατηρήσεις που εμφανίζονται σε τουλάχιστον ένα από τα πλαίσια δεδομένων.
Αυτές οι ενώσεις λειτουργούν προσθέτοντας μία πρόσθετη "εικονική" παρατήρηση σε κάθε πλαίσιο δεδομένων.
Αυτή η παρατήρηση έχει ένα κλειδί που ταιριάζει αν δεν ταιριάζει άλλο κλειδί, και τιμές γεμάτες με `NA`.
Υπάρχουν τρεις τύποι εξωτερικών ενώσεων:

-   Μία **αριστερή ένωση** (**left join**) διατηρεί όλες τις παρατηρήσεις του `x`, @fig-join-left.
    Κάθε γραμμή του `x` διατηρείται στην έξοδο, μιας και μπορεί να αντιστοιχιστεί σε μία γραμμή με `NA` του `y`.

    ```{r}
    #| label: fig-join-left
    #| echo: false
    #| out-width: ~
    #| fig-cap: | 
    #|   Μια οπτική αναπαράσταση της αριστερής ένωσης όπου κάθε γραμμή του `x`
    #|   εμφανίζεται στην έξοδο.
    #| fig-alt: |
    #|   Σε σύγκριση με το προηγούμενο διάγραμμα που δείχνει μια εσωτερική ένωση,
    #|   ο y πίνακας αποκτά μια νέα εικονική γραμμή που περιέχει NA, η οποία θα 
    #|   ταιριάξει με κάθε γραμμή του x, η οποία δεν έχει ταιριάξει με κάποιο άλλο
    #|   τρόπο. Αυτό σημαίνει ότι η έξοδος πλέον έχει 3 γραμμές. Για την περίπτωση
    #|   του key = 3, που ταιριάζει με αυτή την εικονική γραμμή, η στήλη val_y
    #|   παίρνει την τιμή NA.

    knitr::include_graphics("diagrams/join/left.png", dpi = 270)
    ```

-   Μία **δεξιά ένωση** (**right join**) διατηρεί όλες τις παρατηρήσεις του `y`, @fig-join-right.
    Κάθε γραμμή του `y` διατηρείται στην έξοδο, επειδή μπορεί να αντιστοιχιστεί σε μία γραμμή με `NA` του `x`.
    Η έξοδος εξακολουθεί να ταιριάζει με το `x` όσο το δυνατόν περισσότερο, ενώ τυχόν επιπλέον σειρές από το `y` προστίθενται στο τέλος.

    ```{r}
    #| label: fig-join-right
    #| echo: false
    #| out-width: ~
    #| fig-cap: | 
    #|   Μια οπτική αναπαράσταση της δεξιάς ένωσης όπου κάθε γραμμή του `y` 
    #|   εμφανίζεται στην έξοδο. 
    #| fig-alt: |
    #|   Σε σύγκριση με το προηγούμενο διάγραμμα που έδειχνε μια αριστερή 
    #|   ένωση, ο x πίνακας θα αποκτήσει πλέον μια εικονική γραμμή, ώστε 
    #|   κάθε γραμμή του y να έχει ένα ταίρι στον x. Η στήλη val_x περιέχει
    #|   NA για κάθε γραμμή του y που δεν έχει ταιριάξει με κάποια γραμμή του x.

    knitr::include_graphics("diagrams/join/right.png", dpi = 270)
    ```

-   Μία **πλήρης ένωση** (**full join**) διατηρεί όλες τις παρατηρήσεις που εμφανίζονται είτε στο `x` είτε στο `y`, @fig-join-full.
    Κάθε γραμμή των `x` και `y` περιλαμβάνεται στην έξοδο επειδή και τα `x` και `y` περιλαμβάνουν μία εναλλακτική γραμμή με `NA`.
    Και πάλι, η έξοδος ξεκινά με όλες τις γραμμές από το `x`, ακολουθούμενες από τις υπόλοιπες γραμμές του `y` που δεν αντιστοιχίστηκαν σε συγκεκριμένη γραμμή του `x`.

    ```{r}
    #| label: fig-join-full
    #| echo: false
    #| out-width: ~
    #| fig-cap: | 
    #|   Μια οπτική αναπαράσταση της πλήρους ένωσης όπου κάθε γραμμή του`x`
    #|   και του `y` εμφανίζεται στην έξοδο.
    #| fig-alt: |
    #|   Τώρα τόσο το x όσο και το y έχουν μια εικονική γραμμή που θα ταιριάζει 
    #|   πάντα. Το αποτέλεσμα έχει 4 γραμμές: τα κλειδιά (keys) 1, 2, 3 και 4, 
    #|   με όλες τις τιμές από τις val_x και val_y. Ωστόσο, το κλειδί 2 στην val_y
    #|   και το κλειδί 4 στην val_x είναι NA, καθώς αυτά τα κλειδιά δεν έχουν 
    #|   αντιστοιχισθεί με το άλλο πλαίσιο δεδομένων.

    knitr::include_graphics("diagrams/join/full.png", dpi = 270)
    ```

Ένας άλλος τρόπος για να δείξετε τις διαφορές ανάμεσα στους διάφορους τύπους της εξωτερικής ένωσης είναι με ένα διάγραμμα Venn, όπως στο @fig-join-venn.
Ωστόσο, αυτή δεν είναι μία καλή αναπαράσταση, επειδή, ενώ μπορεί να φρεσκάρει τη μνήμη σας σχετικά με το ποιες γραμμές διατηρούνται, αποτυγχάνει όμως να επεξηγήσει τι συμβαίνει με τις στήλες.

```{r}
#| label: fig-join-venn
#| echo: false
#| out-width: ~
#| fig-cap: |
#|   Διαγάμματα Venn που δείχνουν τη διαφορά ανάμεσα σε εσωτερικές, αριστερές, δεξιές
#|   και πλήρεις ενώσεις.
#| fig-alt: |
#|   Διαγράμματα Venn για εσωτερικές, πλήρεις, αριστερές και δεξιές
#|   ενώσεις. Κάθε ένωση αναπαριστάται με δύο κύκλους που τέμνονται και
#|   αντιστοιχούν στα πλαίσια δεδομένανω x και y, με το x στα δεξιά και το
#|   y στα αριστερά. Η σκίαση υποδεικνύει το αποτέλεσμα της ένωσης.
#|
#|   Inner join: the intersection is shaded. 
#|   Full join: Everything is shaded. 
#|   Left join: All of x is shaded.
#|   Right join: All of y is shaded.

knitr::include_graphics("diagrams/join/venn.png", dpi = 270)
```

Οι ενώσεις που φαίνονται εδώ είναι οι λεγόμενες **equi** **ενωσεις (ενώσεις ισοτιμίας)**, όπου οι γραμμές αντιστοιχίζονται εάν τα κλειδιά είναι ίσα.
Οι ενώσεις ισοτιμίας είναι ο πιο συνηθισμένος τύπος ένωσης, επομένως συνήθως παραλείπουμε το πρόθεμα equi και απλώς λέμε "inner join" αντί για "equi inner join".
Θα επανέλθουμε στις non-equi ενώσεις στην @sec-non-equi-joins.

### Αντιστοίχιση γραμμών

Μέχρι στιγμής έχουμε εξερευνήσει τι συμβαίνει εάν μία γραμμή από το `x` ταιριάζει με μία ή καμμία γραμμή στο `y`.
Τι συμβαίνει όμως αν ταιριάζει με περισσότερες από μία γραμμές; Για να κατανοήσουμε τι συμβαίνει, ας εστιάσουμε την προσοχή μας στο `inner_join()` και ας σχεδιάσουμε μία εικόνα, @fig-join-match-types.

```{r}
#| label: fig-join-match-types
#| echo: false
#| out-width: ~
#| fig-cap: | 
#|   Οι τρεις τρόποι με τους οποίους μπορεί να αντιστοιχιστεί μια γραμμή στο `x`. 
#|   Το `x1` αντιστοιχεί σε μία γραμμή στο `y`, το `x2` αντιστοιχεί σε δύο γραμμές
#|   στο `y`, το `x3` δεν αντιστοιχεί σε καμία γραμμή στο y. Σημειώστε ότι ενώ υπάρχουν
#|   τρεις γραμμές στο `x` και τρεις γραμμές στην έξοδο, δεν υπάρχει άμεση αντιστοιχία
#|   μεταξύ των γραμμών.
#| fig-alt: |
#|   Ένα διάγραμμα ένωσης όπου το x έχει τιμές κλειδιών 1, 2 και 3, ενώ το y έχει
#|   τιμές κλειδιών 1, 2 και 2. Η έξοδος έχει τρεις γραμμές, επειδή το κλειδί 1
#|   ταιριάζει με μία γραμμή, το κλειδί 2 ταιριάζει με 2 γραμμές και το κλειδί 3
#|   δεν ταιριάζει με κάποια γραμμή.

knitr::include_graphics("diagrams/join/match-types.png", dpi = 270)
```

Υπάρχουν τρία πιθανά αποτελέσματα για μία γραμμή στο `x`:

-   Αν δεν ταιριάζει με τίποτα, απορρίπτεται.
-   Εάν ταιριάζει με 1 γραμμή στο `y`, διατηρείται.
-   Εάν αντιστοιχεί σε περισσότερες από 1 γραμμές στο `y`, γίνεται διπλότυπη μία φορά για κάθε αντιστοίχιση

Κατ' αρχήν, αυτό σημαίνει ότι δεν υπάρχει εγγυημένη αντιστοιχία μεταξύ των γραμμών στην έξοδο και των γραμμών στο `x`, αλλά πρακτικά, αυτό σπάνια προκαλεί προβλήματα.
Υπάρχει, ωστόσο, μία ιδιαίτερα επικίνδυνη περίπτωση που μπορεί να προκαλέσει μία συνδυαστική έκρηξη γραμμών.
Φανταστείτε ότι ενώνετε τους παρακάτω δύο πίνακες:

```{r}
df1 <- tibble(key = c(1, 2, 2), val_x = c("x1", "x2", "x3"))
df2 <- tibble(key = c(1, 2, 2), val_y = c("y1", "y2", "y3"))
```

Ενώ η πρώτη γραμμή του `df1` αντιστοιχίζεται με μία μόνο γραμμή του `df2`, η δεύτερη και η τρίτη γραμμή αντιστοιχίζονται με από δύο γραμμές η καθεμία.
Αυτό μπορεί να το συναντήσετε ως ένωση `πολλά-με-πολλά`, και θα έχει ως αποτέλεσμα το πακέτο dplyr να επιστρέψει μία προειδοποίηση:

```{r}
df1 |> 
  inner_join(df2, join_by(key))
```

Εάν το κάνετε αυτό σκόπιμα, μπορείτε να ορίσετε `relationship = "many-to-many"`,, όπως προτείνει η προειδοποίηση.

### Ενώσεις φιλτραρίσματος

Ο αριθμός των αντιστοιχιών καθορίζει επίσης τη συμπεριφορά των ενώσεων φιλτραρίσματος.
Η ημι-ένωση (semi-join) διατηρεί γραμμές στο `x` που έχουν μία ή περισσότερες αντιστοιχίσεις στο `y`, όπως στο @fig-join-semi.
Η αντι-ένωση (anti-join) διατηρεί γραμμές στο `x` που δεν ταιριάζουν με καμία γραμμή στο `y`, όπως στο @fig-join-anti.
Και στις δύο περιπτώσεις, μόνο η ύπαρξη μιας αντιστοίχισης είναι σημαντική, και όχι το πλήθος των αντιστοιχίσεων.
Αυτό σημαίνει ότι οι ενώσεις φιλτραρίσματος δεν δημιουργούν ποτέ διπλότυπες γραμμές όπως κάνουν οι ενώσεις αλλαγής.

```{r}
#| label: fig-join-semi
#| echo: false
#| out-width: null
#| fig-cap: |
#|   Σε μια ημι-ένωση το μόνο που έχει σημασία είναι να υπάρχει μια 
#|   αντιστοίχιση, διαφορετικά οι τιμές στο πλαίσιο δεδομένων `y` δεν
#|   επηρεάζουν την έξοδο.
#| fig-alt: |
#|   Ένα διάγραμμα ένωσης με τους παλιούς γνωστούς μας x και y. Σε μια
#|   ημι-ένωση, μόνο η παρουσία μιας αντιστοίχισης έχει σημασία, οπότε 
#|   η έξοδος έχει τις ίδιες στήλες με το x.

knitr::include_graphics("diagrams/join/semi.png", dpi = 270)
```

```{r}
#| label: fig-join-anti
#| echo: false
#| out-width: null
#| fig-cap: |
#|   Μια αντι-ένωση είναι το αντίστροφο μιας ημι-ένωσης, αφαιρώντας γραμμές
#|   από το `x` που αντιστοιχίζονται με το `y`.
#| fig-alt: |
#|   Μια αντι-ένωση είναι το αντίστροφο μιας ημι-ένωσης, οπότε οι αντιστοιχίσεις
#|   σχεδιάζονται με κόκκινες γραμμές, που υποδεικνύουν ότι αυτές οι γραμμές δεν
#|   θα εμφανιστούν στην έξοδο.

knitr::include_graphics("diagrams/join/anti.png", dpi = 270)
```

## Non-equi ενώσεις {#sec-non-equi-joins}

Μέχρι στιγμής έχετε δει μόνο ενώσεις ισοτιμίας, ενώσεις όπου οι γραμμές ταιριάζουν εάν το κλειδί του `x` ισούται με το κλειδί στο `y`.
Τώρα θα χαλαρώσουμε αυτόν τον περιορισμό και θα συζητήσουμε άλλους τρόπους για να προσδιορίσουμε εάν ένα ζευγάρι γραμμών ταιριάζει.

Αλλά προτού μπορέσουμε να το κάνουμε αυτό, πρέπει να επανεξετάσουμε μία απλοποίηση που κάναμε παραπάνω.
Σε ισότιμες ενώσεις (equi joins) τα κλειδιά των `x` και `y` είναι πάντα ίσα, οπότε αρκεί να εμφανίσουμε μόνο ένα στην έξοδο.
Μπορούμε να ζητήσουμε από το πακέτο dplyr να διατηρήσει και τα δύο κλειδιά με το όρισμα `keep = TRUE`, οδηγώντας στον παρακάτω κώδικα και στο επανασχεδιασμένο `inner_join()` στο @fig-inner-both.

```{r}
x |> inner_join(y, join_by(key == key), keep = TRUE)
```

```{r}
#| label: fig-inner-both
#| fig-cap: |
#|   Μια εσωτερική ένωση που δείνει τα κλειδιά των `x` και `y` στην έξοδο.
#| fig-alt: |
#|   Ένα διάγραμμα ένωσης που δείχνει μια εσωτερική ένωση μεταξύ των x και y.
#|   Η έξοδος περιλαμβάνει πλέον τέσσερις στήλες: τις key.x, val_x, key.y και val_y. 
#|   Οι τιμές των key.x και key.y είναι πανομοιότυπες, γι' αυτό συνήθως δείχνουμε 
#|   μόνο μία από αυτές.
#| echo: false
#| out-width: ~

knitr::include_graphics("diagrams/join/inner-both.png", dpi = 270)
```

Όταν απομακρυνόμαστε από τις equi ενώσεις, θα εμφανίζουμε πάντα τα κλειδιά, επειδή οι τιμές των κλειδιών συχνά θα είναι διαφορετικές.
Για παράδειγμα, αντί να κάνουμε την αντιστοίχιση μόνο όταν το `x$key` και το `y$key` είναι ίσα, θα μπορούσαμε να κάνουμε την αντιστοίχιση κάθε φορά που το `x$key` είναι μεγαλύτερο ή ίσο με το `y$key`, που οδηγεί στο @fig-join-gte. Οι συναρτήσεις ένωσης της dplyr κατανοούν αυτή τη διάκριση ανάμεσα σε ισοδύναμες και μη ισοδύναμες ενώσεις, επομένως θα εμφανίζουν πάντα και τα δύο κλειδιά όταν εκτελείτε μία ένωση χωρίς ισοδυναμία.

```{r}
#| label: fig-join-gte
#| echo: false
#| fig-cap: |
#|   Μία non-equi ένωση, όπου το κλειδί του `x` πρέπει να είναι μεγαλύτερο ή ίσο 
#|   του κλειδιού του `y`. Πολλές γραμμές δημιουργούν πολλαπλές αντιστοιχίσεις.
#| fig-alt: |
#|   Ένα διάγραμμα ένωσης που απεικονίζει το αποτέλεσμα της join_by(key >= key). 
#|   Η πρώτη γραμμή του x ταιριάζει με μία γραμμή του y, ενώ η δεύτερη και τρίτη 
#|   γραμμή αντιστοιχίζονται με από δύο γραμμές η καθεμία. Αυτό σημαίνει ότι η 
#|   έξοδος έχει πέντε γραμμές που περιέχουν κάθε ένα από τα ακόλουθα ζεύγη
#|   (key.x, key.y): (1, 1), (2, 1), (2, 2), (3, 1), (3, 2).

knitr::include_graphics("diagrams/join/gte.png", dpi = 270)
```

Ο όρος "non-equi" ενώσεις δεν είναι ιδιαίτερα χρήσιμος, επειδή μας λέει μόνο τι δεν είναι η ένωση, όχι τι είναι.
Η dplyr βοηθά προσδιορίζοντας τέσσερις ιδιαίτερα χρήσιμους τύπους non-equi join:

-   Οι **διασταυρούμενες ενώσεις** (**Cross joins**) αντιστοιχίζουν κάθε ζεύγος γραμμών
-   Οι **ενώσεις ανισότητας** (**Inequality joins**) χρησιμοποιούν τα `<`, `<=`, `>`, και `>=` αντί του `==`.
-   Οι **κυλιόμενες ενώσεις** (**Rolling joins**) είναι παρόμοιες με τις ενώσεις ανισότητας αλλά βρίσκουν μόνο την πλησιέστερη αντιστοιχία.
-   Οι **ενώσεις επικάλυψης** (**Overlap joins**) είναι ένας ειδικός τύπος ένωσης ανισότητας που έχει σχεδιαστεί για να λειτουργεί με εύρη.

Κάθε μία από αυτές περιγράφεται λεπτομερέστερα στις επόμενες ενότητες.

### Διασταυρούμενες ενώσεις

Μια διασταυρούμενη ένωση ταιριάζει με τα πάντα, όπως στο @fig-join-cross, δημιουργώντας το καρτεσιανό γινόμενο των γραμμών.
Αυτό σημαίνει ότι η έξοδος θα έχει `nrow(x) * nrow(y)` γραμμές.

```{r}
#| label: fig-join-cross
#| echo: false
#| out-width: ~
#| fig-cap: |
#|   Μια διασταυρούμενη ένωησ αντιστοιχίζει κάθε γραμμή του `x` με κάθε γραμμή του `y`.
#| fig-alt: |
#|   Ένα διάγραμμα ένωσης που δείνει μια κουκίδα για κάθε συνδυασμό των x και y.
knitr::include_graphics("diagrams/join/cross.png", dpi = 270)
```

Οι διασταυρούμενες ενώσεις είναι χρήσιμες κατά τη δημιουργία συνδυασμών.
Για παράδειγμα, ο παρακάτω κώδικας δημιουργεί κάθε πιθανό ζεύγος ονομάτων.
Εφόσον ενώνουμε το `df` με τον εαυτό του, αυτό μερικές φορές ονομάζεται **αυτο-ένωση** (**self-join**).
Οι διασταυρούμενες ενώσεις χρησιμοποιούν διαφορετική συνάρτηση ένωσης επειδή δεν υπάρχει διάκριση μεταξύ εσωτερικές/αριστερές/δεξιές/πλήρεις ενώσεις όταν η αντιστοίχιση αφορά κάθε γραμμή.

```{r}
df <- tibble(name = c("John", "Simon", "Tracy", "Max"))
df |> cross_join(df)
```

### Ενώσεις ανισότητας

Οι ενώσεις ανισότητας χρησιμοποιούν τους τελεστές `<`, `<=`, `>=`, ή `>` για να περιορίσουν το σύνολο των πιθανών αντιστοιχίσεων, όπως στο @fig-join-gte και το @fig-join-lt.

```{r}
#| label: fig-join-lt
#| echo: false
#| out-width: ~
#| fig-cap: |
#|   
#|   Μία ένωση ανισότητας όπου το `x` ενώνεται με το `y` στις γραμμές όπου το κλειδί
#|   του `x` είναι μικρότερο από το κλειδί του `y`. Αυτό δημιουργεί ένα τριγωνικό 
#|   σχήμα στην πάρω αριστερή γωνία.
#| fig-alt: |
#|   Ένα διάγραμμα που απεικονίζει μια ένωση ανισότητας όπου το πλαίδιο δεδομένων x
#|   ενώνεται με το πλαίσιο δεδομένων y όπου το κλειδί του x είναι μικρότερο από το 
#|   κλειδί του y, δημιουργώντας έτσι ένα τριγωνικό σχήμα στην πάνω αριστερή γωνία. 

knitr::include_graphics("diagrams/join/lt.png", dpi = 270)
```

Οι ενώσεις ανισότητας είναι εξαιρετικά γενικές, τόσο γενικές που είναι δύσκολο να βρούμε ουσιαστικές συγκεκριμένες περιπτώσεις χρήσης.
Μια μικρή χρήσιμη τεχνική είναι να τις χρησιμοποιούμε για να περιορίσουμε τη διασταυρούμενη ένωση έτσι ώστε αντί να δημιουργούμε όλες τις μεταθέσεις, να δημιουργούμε όλους τους συνδυασμούς:

```{r}
df <- tibble(id = 1:4, name = c("John", "Simon", "Tracy", "Max"))

df |> inner_join(df, join_by(id < id))
```

### Κυλιόμενες ενώσεις

Οι κυλιόμενες ενώσεις είναι ένας ειδικός τύπος ένωσης ανισότητας όπου αντί να λαμβάνουμε *κάθε* γραμμή που ικανοποιεί την ανισότητα, παίρνουμε μόνο την πλησιέστερη γραμμή, όπως στο @fig-join-closest.
Μπορείτε να μετατρέψετε οποιαδήποτε ένωση ανισότητας σε κυλιόμενη ένωση προσθέτοντας το όρισμα `closest()`.
Για παράδειγμα, το `join_by(closest(x <= y))` αντιστοιχεί στο μικρότερο `y` που είναι μεγαλύτερο ή ίσο με το `x` και το `join_by(closest(x > y))` αντιστοιχεί στο μεγαλύτερο `y` που είναι μικρότερο από το `x`.

```{r}
#| label: fig-join-closest
#| echo: false
#| out-width: ~
#| fig-cap: |
#|   Μια κυλιώμενη ένωση είναι παρόμοια με μία μεγαλύτερο-από-ή-ίσο ένωση 
#|   ανισότητας, αλλά αντιστοιχίζει μόνο την πρώτη τιμή.
#| fig-alt: |
#|   Μια κυλιώμενη ένωση είναι υποσύνολο μιας ένωσης ανισότητας, οπότε μερικές
#|   αντιστοιχίσεις είναι γκριζαρισμένες, υποδεικνύοντας ότι δεν χρησιμοποιούνται,
#|   μιας και δεν είναι οι "κοντινότερες".

knitr::include_graphics("diagrams/join/closest.png", dpi = 270)
```

Οι κυλιόμενες ενώσεις είναι ιδιαίτερα χρήσιμες όταν έχετε δύο πίνακες ημερομηνιών που δεν ευθυγραμμίζονται τέλεια και θέλετε να βρείτε (για παράδειγμα) την πλησιέστερη ημερομηνία στον πίνακα 1 που είναι πριν (ή μετά) κάποια ημερομηνία στον πίνακα 2.

Για παράδειγμα, φανταστείτε ότι είστε υπεύθυνος της επιτροπής σχεδιασμού εορτασμών για το γραφείο σας.
Η εταιρεία σας θέλει να μην ξοδέψει πολλά χρήματα, επομένως αντί να κάνετε μεμονωμένα πάρτι, θα κάνετε ένα πάρτι μόνο, μία φορά το τρίμηνο.
Οι κανόνες για τον καθορισμό του πότε θα γίνει ένα πάρτι είναι λίγο περίπλοκοι: τα πάρτι γίνονται πάντα Δευτέρα, παραλείπετε την πρώτη εβδομάδα του Ιανουαρίου, καθώς πολλοί είναι σε διακοπές, ενώ και η πρώτη Δευτέρα του τρίτου τριμήνου 2022 είναι στις 4 Ιουλίου, οπότε και σε αυτή την περίπτωση η ημερομηνία του πάρτι θα πρέπει να μεταφερθεί κατά μία εβδομάδα αργότερα.
Αυτό οδηγεί στις ακόλουθες διαθέσιμες ημέρες για τα πάρτι:

```{r}
parties <- tibble(
  q = 1:4,
  party = ymd(c("2022-01-10", "2022-04-04", "2022-07-11", "2022-10-03"))
)
```

Τώρα φανταστείτε ότι έχετε έναν πίνακα με τα γενέθλια των εργαζομένων:

```{r}
set.seed(123)
employees <- tibble(
  name = sample(babynames::babynames$name, 100),
  birthday = ymd("2022-01-01") + (sample(365, 100, replace = TRUE) - 1)
)
employees
```

Και για κάθε εργαζόμενο θέλουμε να βρούμε τη πρώτη διαθέσιμη ημερομηνία για πάρτι που έρχεται μετά (ή πάνω στα) γενέθλιά του.
Μπορούμε να το εκφράσουμε με μία κυλιόμενη ένωση:

```{r}
employees |> 
  left_join(parties, join_by(closest(birthday >= party)))
```

Υπάρχει, ωστόσο, ένα πρόβλημα με αυτήν την προσέγγιση: οι άνθρωποι με γενέθλια πριν από τις 10 Ιανουαρίου δεν κάνουν πάρτι:

```{r}
employees |> 
  anti_join(parties, join_by(closest(birthday >= party)))
```

Για να το λύσουμε αυτό, θα χρειαστεί να αντιμετωπίσουμε το πρόβλημα με διαφορετικό τρόπο, χρησιμοποιώντας ενώσεις επικάλυψης.

### Ενώσεις επικάλυψης

Οι ενώσεις επικάλυψης παρέχουν τρεις βοηθητικές συναρτήσεις που χρησιμοποιούν ενώσεις ανισότητας για να διευκολύνουν την εργασία με διαστήματα:

-   Η `between(x, y_lower, y_upper)` είναι η συντομογραφία του `x >= y_lower, x <= y_upper`.
-   Η `within(x_lower, x_upper, y_lower, y_upper)` είναι η συντομογραφία του `x_lower >= y_lower, x_upper <= y_upper`.
-   Η `overlaps(x_lower, x_upper, y_lower, y_upper)` είναι η συντομογραφία του `x_lower <= y_upper, x_upper >= y_lower`.

Ας συνεχίσουμε με το παράδειγμα γενεθλίων για να δούμε πώς μπορείτε να τα χρησιμοποιήσετε.
Υπάρχει ένα πρόβλημα με τη στρατηγική που χρησιμοποιήσαμε παραπάνω: δεν υπάρχει πάρτι που να προηγείται των γενεθλίων που είναι μεταξύ 1-9 Ιανουαρίου.
Επομένως, ίσως είναι καλύτερο να είμαστε σαφείς σχετικά με το εύρος ημερομηνιών που καλύπτει κάθε πάρτι και να κάνουμε μία ειδική περίπτωση για αυτά τα πρώιμα γενέθλια:

```{r}
parties <- tibble(
  q = 1:4,
  party = ymd(c("2022-01-10", "2022-04-04", "2022-07-11", "2022-10-03")),
  start = ymd(c("2022-01-01", "2022-04-04", "2022-07-11", "2022-10-03")),
  end = ymd(c("2022-04-03", "2022-07-11", "2022-10-02", "2022-12-31"))
)
parties
```

Ο Hadley είναι απελπιστικά κακός στην εισαγωγή δεδομένων, έτσι ήθελε επίσης να ελέγξει ότι οι περίοδοι που οργανώνονται τα πάρτι δεν αλληλεπικαλύπτονται.
Ένας τρόπος για να το κάνετε αυτό είναι χρησιμοποιώντας μία αυτο-ένωση για να ελέγξετε εάν κάποιο διάστημα έναρξης-λήξης επικαλύπτεται με κάποιο άλλο:

```{r}
parties |> 
  inner_join(parties, join_by(overlaps(start, end, start, end), q < q)) |> 
  select(start.x, end.x, start.y, end.y)
```

Υπάρχει μία επικάλυψη, οπότε ας διορθώσουμε αυτό το πρόβλημα και ας συνεχίσουμε:

```{r}
parties <- tibble(
  q = 1:4,
  party = ymd(c("2022-01-10", "2022-04-04", "2022-07-11", "2022-10-03")),
  start = ymd(c("2022-01-01", "2022-04-04", "2022-07-11", "2022-10-03")),
  end = ymd(c("2022-04-03", "2022-07-10", "2022-10-02", "2022-12-31"))
)
```

Τώρα μπορούμε να ταιριάξουμε κάθε εργαζόμενο με το πάρτι του.
Αυτό είναι ένα καλό παράδειγμα για να χρησιμοποιήσετε το όρισμα `unmatched = "error"`, επειδή θέλουμε να μάθουμε γρήγορα εάν σε κάποιους υπαλλήλους δεν ανατέθηκε πάρτι.

```{r}
employees |> 
  inner_join(parties, join_by(between(birthday, start, end)), unmatched = "error")
```

### Ασκήσεις

1.  Μπορείτε να εξηγήσετε τι συμβαίνει με τα κλειδιά σε αυτή την ένωση ισοδυναμίας; Γιατί είναι διαφορετικά;

    ```{r}
    x |> full_join(y, join_by(key == key))

    x |> full_join(y, join_by(key == key), keep = TRUE)
    ```

2.  Για να βρούμε εάν οι περίοδοι των πάρτι επικαλύπτονται με άλλα πάρτι χρησιμοποιήσαμε το `q < q` στην `join_by()`.
    Γιατί; Τι συμβαίνει εάν αφαιρέσουμε αυτή την ανισότητα;

## Σύνοψη

Σε αυτό το κεφάλαιο, μάθατε πώς να χρησιμοποιείτε ενώσεις αλλαγής και ενώσεις φιλτραρίσματος για να συνδυάσετε δεδομένα από ένα ζεύγος πλαισίων δεδομένων.
Στην πορεία μάθατε πώς να αναγνωρίζετε κλειδιά και τη διαφορά μεταξύ πρωτεύοντος και ξένου κλειδιού.
Καταλαβαίνετε επίσης πώς λειτουργούν οι ενώσεις και πώς να υπολογίσετε πόσες γραμμές θα έχει η έξοδος.
Τέλος, ρίξατε μία ματιά στη δύναμη των non-equi ενώσεων και έχετε δει μερικές ενδιαφέρουσες περιπτώσεις χρήσης.

Αυτό το κεφάλαιο ολοκληρώνει το μέρος "Μετασχηματισμός" αυτού του βιβλίου, όπου η το ενδιαφέρον μας ήταν στα εργαλεία που θα μπορούσατε να χρησιμοποιήσετε με μεμονωμένες στήλες και tibbles.
Μάθατε για συναρτήσεις από το πακέτο dplyr και από το βασικό σύνολο συναρτήσεων της R για εργασία με λογικά διανύσματα, αριθμούς και πλήρεις πίνακες, τις συναρτήσεις του πακέτου stringr για εργασία με συμβολοσειρές, τις συναρτήσεις του πακέτου lubridate για εργασία με ημερομηνίες-ώρες και τις συναρτήσεις του forcats για εργασία με παράγοντες.

Στο επόμενο μέρος του βιβλίου, θα μάθετε περισσότερα σχετικά με τη μετατροπή διαφόρων τύπων δεδομένων στην R σε μία τακτοποιημένη (tidy) μορφή.
