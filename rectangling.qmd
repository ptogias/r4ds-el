# Ιεραρχικά δεδομένα {#sec-rectangling}

```{r}
#| echo: false

source("_common.R")
```

## Εισαγωγή

Σε αυτό το κεφάλαιο, θα μάθετε την τέχνη της **ορθογωνοποίησης** των δεδομένων (μετατροπή σε μορφή πίνακα): παίρνοντας δηλαδή δεδομένα που είναι κατά βάση ιεραρχικά, ή σε μορφή δέντρου, και μετατρέποντάς τα σε ένα ορθογώνιο πλαίσιο δεδομένων που αποτελείται από γραμμές και στήλες (σαν πίνακας).
Αυτό είναι σημαντικό επειδή τα ιεραρχικά δεδομένα συναντώνται αρκετά συχνά, ειδικά όταν εργάζεστε με δεδομένα που προέρχονται από το διαδίκτυο.

Για να μάθετε για την ορθογωνοποίηση, θα πρέπει πρώτα να μάθετε για τις λίστες, τη δομή δεδομένων που καθιστά δυνατή την ύπαρξη ιεραρχικών δεδομένων.
Στη συνέχεια, θα μάθετε για δύο κρίσιμες συναρτήσεις της tidyr: την `tidyr::unnest_longer()` και την `tidyr::unnest_wider()`.
Στη συνέχεια, θα σας δείξουμε μερικές περιπτώσεις μελέτης, εφαρμόζοντας αυτές τις απλές συναρτήσεις ξανά και ξανά για την επίλυση πραγματικών προβλημάτων.
Θα ολοκληρώσουμε μιλώντας για τα JSON, την πιο συχνή πηγή ιεραρχικών συνόλων δεδομένων και μια συχνή μορφή ανταλλαγής δεδομένων στο διαδίκτυο.

### Προαπαιτούμενα

Σε αυτό το κεφάλαιο, θα χρησιμοποιήσουμε πολλές συναρτήσεις από την tidyr, ένα βασικό μέλος του tidyverse.
Θα χρησιμοποιήσουμε επίσης την repurrrsive για να πάρουμε μερικά ενδιαφέροντα σύνολα δεδομένων για εξάσκηση στην ορθογωνοποίηση και θα ολοκληρώσουμε χρησιμοποιώντας την jsonlite για την ανάγνωση αρχείων JSON σε λίστες R.

```{r}
#| label: setup
#| message: false

library(tidyverse)
library(repurrrsive)
library(jsonlite)
```

## Λίστες

Μέχρι στιγμής έχετε εργαστεί με πλαίσια δεδομένων που περιέχουν απλά διανύσματα, όπως ακέραιους, γενικούς αριθμούς, χαρακτήρες, ημερομηνίες/ώρες και παράγοντες.
Αυτά τα διανύσματα είναι απλά επειδή είναι ομοιογενή: κάθε στοιχείο είναι του ίδιου τύπου.
Εάν θέλετε να αποθηκεύσετε στοιχεία διαφορετικών τύπων στο ίδιο διάνυσμα, θα χρειαστείτε μια **λίστα**, την οποία δημιουργείτε με την `list()`:

```{r}
x1 <- list(1:4, "a", TRUE)
x1
```

Είναι συχνά βολικό να ονομάσετε τα στοιχεία ή τα **παιδιά** μιας λίστας, κάτι που μπορείτε να κάνετε με τον ίδιο τρόπο όπως ονομάζετε τις στήλες ενός tibble:

```{r}
x2 <- list(a = 1:2, b = 1:3, c = 1:4)
x2
```

Ακόμη και για αυτές τις πολύ απλές λίστες, η εκτύπωση καταλαμβάνει αρκετό χώρο.
Μια χρήσιμη εναλλακτική λύση είναι η `str()`, η οποίο δημιουργεί μια συμπαγή εμφάνιση της δομής (**str**ucture), χωρίς να δίνει έμφαση στα περιεχόμενα:

```{r}
str(x1)
str(x2)
```

Όπως μπορείτε να δείτε, η `str()` εμφανίζει κάθε παιδί της λίστας σε ξεχωριστή γραμμή.
Εμφανίζει το όνομα, εάν υπάρχει, μετά μια συντομογραφία του τύπου των δεδομένων, και μετά τις λίγες τιμές απο την αρχή.

### Ιεραρχία

Οι λίστες μπορούν να περιέχουν οποιοδήποτε είδος αντικειμένου, συμπεριλαμβανομένων άλλων λιστών.
Αυτό τις καθιστά κατάλληλες για την αναπαράσταση ιεραρχικών (δενδροειδών) δομών:

```{r}
x3 <- list(list(1, 2), list(3, 4))
str(x3)
```

Το παραπάνω διαφέρει σημαντικά από την `c()`, η οποίο δημιουργεί ένα επίπεδο διάνυσμα:

```{r}
c(c(1, 2), c(3, 4))

x4 <- c(list(1, 2), list(3, 4))
str(x4)
```

Καθώς οι λίστες γίνονται πιο περίπλοκες, η `str()` γίνεται πιο χρήσιμη, καθώς σας επιτρέπει να δείτε την ιεραρχία περιληπτικά:

```{r}
x5 <- list(1, list(2, list(3, list(4, list(5)))))
str(x5)
```

Καθώς οι λίστες γίνονται ακόμη μεγαλύτερες και πιο περίπλοκες, η `str()` αρχίζει να αποτυγχάνει και θα πρέπει να μεταβείτε στην `View()`[^rectangling-1].
Το @fig-view-collapsed δείχνει το αποτέλεσμα της κλήσης της `View(x5)`. Η λειτουργία προβολής ξεκινά εμφανίζοντας μόνο το ανώτερο επίπεδο της λίστας, αλλά μπορείτε να επεκτείνετε διαδραστικά οποιοδήποτε από τα στοιχεία για να δείτε περισσότερα, όπως φαίνεται στο @fig-view-expand-1. Το RStudio θα σας δείξει επίσης τον κώδικα που χρειάζεστε για να αποκτήσετε πρόσβαση σε αυτό το στοιχείο, όπως στο @fig-view-expand-2. Θα επανέλθουμε στο πώς λειτουργεί αυτός ο κώδικας στο @sec-subset-one.

[^rectangling-1]: Αυτή είναι μια δυνατότητα του RStudio.

```{r}
#| label: fig-view-collapsed
#| fig.cap: >
#|   Η επιλογή προβολής του RStudio σας επιτρέπει να εξερευνήσετε διαδραστικά μια περίπλοκη λίστα. 
#|   Το πρόγραμμα προβολής ανοίγει εμφανίζοντας μόνο το ανώτερο επίπεδο της λίστας.
#| fig.alt: >
#|   A screenshot of RStudio showing the list-viewer. It shows the
#|   two children of x5: the first child is a double vector and the
#|   second child is a list. A rightward facing triable indicates that the
#|   second child itself has children but you can't see them.
#| echo: false
#| out-width: NULL
knitr::include_graphics("screenshots/View-1.png", dpi = 220)
```

```{r}
#| label: fig-view-expand-1
#| fig.cap: >
#|   Επιλέγοντας το δεξιόστροφο τρίγωνο, επεκτείνετε το αντίστοιχο 
#|   στοιχείο της λίστας, ώστε να μπορείτε να δείτε και τα παιδιά του.
#| fig.alt: >
#|   Another screenshot of the list-viewer having expand the second
#|   child of x5. It also has two children, a double vector and another
#|   list.
#| echo: false
#| out-width: NULL
knitr::include_graphics("screenshots/View-2.png", dpi = 220)
```

```{r}
#| label: fig-view-expand-2
#| fig.cap: >
#|   Μπορείτε να επαναλάβετε αυτήν την διαδικασία όσες φορές χρειάζεται για 
#|   να φτάσετε στα δεδομένα που σας ενδιαφέρουν. Σημειώστε την κάτω αριστερή 
#|   γωνία: εάν επιλέξετε ένα στοιχείο της λίστας, το RStudio θα σας δώσει 
#|   τον κώδικα που απαιτείται για να ρο προσπελάσετε, 
#|   σε αυτή η περίπτωση `x5[[2]][[2]][[2]]`.
#| fig.alt: >
#|   Another screenshot, having expanded the grandchild of x5 to see its
#|   two children, again a double vector and a list.
#| echo: false
#| out-width: NULL
knitr::include_graphics("screenshots/View-3.png", dpi = 220)
```

### Στήλες λίστας

Λίστες μπορούν επίσης να υπάρχουν μέσα σε ένα tibble, όπου τις ονομάζουμε στήλες λίστας.
Οι στήλες λίστας είναι χρήσιμες επειδή σας επιτρέπουν να τοποθετήσετε σε ένα tibble αντικείμενα που συνήθως δεν θα ανήκαν εκεί.
Συγκεκριμένα, οι στήλες λίστας χρησιμοποιούνται πολύ στο οικοσύστημα των [tidymodels](https://www.tidymodels.org), επειδή σας επιτρέπουν να αποθηκεύετε πράγματα, όπως αποτελέσματα μοντέλων ή επαναδειγματοληψίας, σε ένα πλαίσιο δεδομένων.

Ορίστε ένα απλό παράδειγμα στήλης λίστας:

```{r}
df <- tibble(
  x = 1:2, 
  y = c("a", "b"),
  z = list(list(1, 2), list(3, 4, 5))
)
df
```

Δεν υπάρχει τίποτα ιδιαίτερο σχετικά με τις λίστες σε ένα tibble.
Συμπεριφέρονται όπως κάθε άλλη στήλη:

```{r}
df |> 
  filter(x == 1)
```

Ο υπολογισμός με στήλες λίστας είναι πιο δύσκολος, αλλά αυτό συμβαίνει επειδή ο υπολογισμός με λίστες είναι γενικά πιο δύσκολος.
Θα επανέλθουμε σε αυτό στο @sec-iteration.
Σε αυτό το κεφάλαιο, θα επικεντρωθούμε στην αναδόμηση στηλών λίστας σε κανονικές μεταβλητές, ώστε να μπορείτε να χρησιμοποιήσετε σε αυτές τα υπάρχοντα εργαλεία σας.

Η προεπιλεγμένη μέθοδος εκτύπωσης εμφανίζει απλώς μια κατά προσέγγιση περίληψη των περιεχομένων.
Η στήλη της λίστας μπορεί να είναι αυθαίρετα πολύπλοκη, επομένως δεν υπάρχει καλός τρόπος να την εκτυπώσετε.
Εάν θέλετε να την δείτε, θα χρειαστεί να τραβήξετε μόνο τη μία στήλη λίστας και να εφαρμόσετε μία από τις τεχνικές που μάθατε παραπάνω, όπως `df |> pull(z) |> str()` ή `df |> pull(z) |> View()`.

::: callout-note
## Βασικό σύνολο λειτουργιών της R

Το να τοποθετήσετε μια λίστα σε μια στήλη ενός `data.frame` είναι εφικτό, αλλά είναι πολύ πιο περίπλοκο, καθώς το `data.frame()` αντιμετωπίζει μια λίστα ως μια λίστα με στήλες:

```{r}
data.frame(x = list(1:3, 3:5))
```

Μπορείτε να αναγκάσετε το `data.frame()` να αντιμετωπίζει μια λίστα ως μια λίστα γραμμών τυλίγοντάς τη στη λίστα `I()`, το αποτέλεσμα όμως δεν εκτυπώνεται ιδιαίτερα καλά:

```{r}
data.frame(
  x = I(list(1:2, 3:5)), 
  y = c("1, 2", "3, 4, 5")
)
```

Είναι πιο εύκολο να χρησιμοποιείτε στήλες λίστας με tibbles, επειδή το `tibble()` αντιμετωπίζει τις λίστες σαν διανύσματα αλλά και γιατί η μέθοδος εκτύπωσης έχει σχεδιαστεί με γνώμονα τις λίστες.
:::

## Αναδόμηση (Unnest)

Τώρα που μάθατε τα βασικά των λιστών και των στηλών λίστας, ας εξερευνήσουμε πώς μπορείτε να τις μετατρέψετε ξανά σε κανονικές γραμμές και στήλες.
Εδώ θα χρησιμοποιήσουμε πολύ απλά δείγματα δεδομένων, ώστε να έχετε τη βασική ιδέα.
Στην επόμενη ενότητα θα ασχοληθούμε με πραγματικά δεδομένα.

Οι στήλες λίστας τείνουν να έρχονται σε δύο βασικές μορφές: με ονόματα και χωρίς ονόματα.
Όταν τα παιδιά της λίστας **ονομάζονται**, τείνουν να έχουν τα ίδια ονόματα σε κάθε γραμμή.
Για παράδειγμα, στο `df1`, κάθε στοιχείο της στήλης λίστας `y` έχει δύο στοιχεία που ονομάζονται `a` και `b`.
Οι στήλες λίστας με ονόματα αναδομούντε σε στήλες: κάθε ονοματισμένο στοιχείο γίνεται μια νέα στήλη με όνομα.

```{r}
df1 <- tribble(
  ~x, ~y,
  1, list(a = 11, b = 12),
  2, list(a = 21, b = 22),
  3, list(a = 31, b = 32),
)
```

Όταν τα παιδιά είναι **χωρίς όνομα**, ο αριθμός των στοιχείων τείνει να διαφέρει από γραμμή σε γραμμή.
Για παράδειγμα, στο `df2`, τα στοιχεία της στήλης λίστας `y` δεν έχουν όνομα και ποικίλλουν σε μήκος από ένα έως τρία.
Οι στήλες λίστας χωρίς ονόματα αναδομούντε σε γραμμές: θα πάρετε μία γραμμή για κάθε παιδί της λίστας.

```{r}

df2 <- tribble(
  ~x, ~y,
  1, list(11, 12, 13),
  2, list(21),
  3, list(31, 32),
)
```

Η tidyr παρέχει δύο συναρτήσεις για αυτές τις δύο περιπτώσεις: την `unnest_wider()` και `unnest_longer()`.
Οι ακόλουθες ενότητες εξηγούν πώς λειτουργούν.

### `unnest_wider()`

Όταν κάθε γραμμή έχει τον ίδιο αριθμό στοιχείων με τα ίδια ονόματα, όπως στο `df1`, είναι λογικό κάθε στοιχείο να τοποθετείται στη δική του στήλη με την `unnest_wider()`:

```{r}
df1 |> 
  unnest_wider(y)
```

Από προεπιλογή, τα ονόματα των νέων στηλών προέρχονται αποκλειστικά από τα ονόματα των στοιχείων της λίστας, μπορείτε όμως να χρησιμοποιήσετε το όρισμα `names_sep` για να συνδυάσετε το όνομα της στήλης και το όνομα του στοιχείου.
Αυτό είναι χρήσιμο για την αποσαφήνιση επαναλαμβανόμενων ονομάτων.

```{r}
df1 |> 
  unnest_wider(y, names_sep = "_")
```

### `unnest_longer()`

Όταν κάθε γραμμή περιέχει μια λίστα χωρίς ονόματα, είναι πιο λογικό να τοποθετήσετε κάθε στοιχείο στη δική του γραμμή με την `unnest_longer()`:

```{r}
df2 |> 
  unnest_longer(y)
```

Σημειώστε πως η `x` αντιγράφεται για κάθε στοιχείο μέσα στην `y`: έτσι παίρνουμε μια γραμμή εξόδου για κάθε στοιχείο μέσα στη στήλη λίστα.
Τι συμβαίνει όμως εάν ένα από τα στοιχεία είναι κενό, όπως στο παρακάτω παράδειγμα;

```{r}
df6 <- tribble(
  ~x, ~y,
  "a", list(1, 2),
  "b", list(3),
  "c", list()
)
df6 |> unnest_longer(y)
```

Λαμβάνουμε μηδέν γραμμές στην έξοδο, οπότε ουσιαστικά η γραμμή εξαφανίζεται.
Σε περίπτωση που θέλετε να κρατήσετε αυτήν τη γραμμή, προσθέτοντας `NA` στη `y`, ορίστε το `keep_empty = TRUE`.

### Αντιφατικοί τύποι δεδομένων

Τι συμβαίνει εάν αφαιρέσετε μια στήλη λίστας που περιέχει διαφορετικούς τύπους διανυσμάτων;\
Για παράδειγμα, πάρτε το ακόλουθο σύνολο δεδομένων όπου η στήλη λίστας `y` περιέχει δύο αριθμούς, έναν χαρακτήρα και μια τιμή λογικού τύπου, που κανονικά δεν μπορούν να συγχωνευθούν σε μία στήλη.

```{r}
df4 <- tribble(
  ~x, ~y,
  "a", list(1),
  "b", list("a", TRUE, 5)
)
```

Η `unnest_longer()` διατηρεί πάντα το σύνολο των στηλών αμετάβλητο, ενώ αλλάζει τον αριθμό των γραμμών.
Τι συμβαίνει λοιπόν;\
Πώς η `unnest_longer()` παράγει πέντε γραμμές ενώ διατηρεί τα πάντα στην `y`;

```{r}
df4 |> 
  unnest_longer(y)
```

Όπως μπορείτε να δείτε, η έξοδος περιέχει μια στήλη λίστας, αλλά κάθε στοιχείο της στήλης λίστας περιέχει ένα μόνο στοιχείο.
Επειδή η `unnest_longer()` δεν μπορεί να βρει έναν κοινό τύπο διανύσματος, διατηρεί τους αρχικούς τύπους σε μια στήλη λίστας.
Ίσως αναρωτηθείτε αν αυτό παραβαίνει τον κανόνα ότι κάθε στοιχείο μιας στήλης πρέπει να είναι του ίδιου τύπου.
Δεν την παραβαίνει: κάθε στοιχείο είναι μια λίστα, παρόλο που τα περιεχόμενα είναι διαφορετικών τύπων.

Η αντιμετώπιση αντιφατικών τύπων είναι μια πρόκληση και οι λεπτομέρειες εξαρτώνται από την ακριβή φύση του προβλήματος και τους στόχους σας.
Πιθανότατα όμως θα χρειαστείτε εργαλεία που αναφέρονται στο @sec-iteration.

### Λοιπές συναρτήσεις

Η tidyr έχει και μερικές άλλες χρήσιμες συναρτήσεις ορθογωνοποίησης που δεν θα καλύψουμε σε αυτό το βιβλίο:

-   Η `unnest_auto()` επιλέγει αυτόματα μεταξύ των `unnest_longer()` και `unnest_wider()` με βάση τη δομή της στήλης λίστας. Είναι εξαιρετική για γρήγορη εξερεύνηση των δεδομένων, τελικά όμως είναι κακή ιδέα γιατί δεν σας αναγκάζει να κατανοήσετε πώς είναι δομημένα τα δεδομένα σας, και κάνει τον κώδικά σας πιο δυσνόητο.
-   Η `unnest()` επεκτείνει και τις γραμμές και τις στήλες. Είναι χρήσιμη όταν έχετε μια στήλη λίστας που περιέχει μια δισδιάστατη δομή, όπως ένα πλαίσιο δεδομένων, δομή την οποία δεν συναντάτε σε αυτό το βιβλίο, αλλά μπορεί να συναντήσετε εάν χρησιμοποιήσετε το οικοσύστημα των [tidymodels](https://www.tmwr.org%20/base-r.html#combining-base-r-models-and-the-tidyverse).

Είναι καλό να γνωρίζετε αυτές τις συναρτήσεις καθώς μπορεί να τις συναντήσετε όταν διαβάζετε τον κώδικα άλλων ή όταν αντιμετωπίζετε πιο σπάνιες προκλήσεις ορθωγονοποίησης.

### Ασκήσεις

1.  Τι συμβαίνει όταν χρησιμοποιείτε την `unnest_wider()` με στήλες λίστας χωρίς ονόματα, όπως στο `df2`;\
    Ποιο όρισμα είναι τώρα απαραίτητο;\
    Τι συμβαίνει με τις κενές τιμές;

2.  Τι συμβαίνει όταν χρησιμοποιείτε την `unnest_longer()` με στήλες λίστας με ονοματα, όπως στο `df1`;\
    Ποιες πρόσθετες πληροφορίες λαμβάνετε στην έξοδο;\
    Πώς μπορείτε να αποκρύψετε αυτή την επιπλέον λεπτομέρεια;

3.  Κατά καιρούς συναντάτε πλαίσια δεδομένων με πολλαπλές στήλες λίστας με ευθυγραμμισμένες τιμές.
    Για παράδειγμα, στο ακόλουθο πλαίσιο δεδομένων, οι τιμές των `y` και `z` είναι ευθυγραμμισμένες (δηλαδή, η `y` και η `z` θα έχουν πάντα το ίδιο μήκος σε μια γραμμή και η πρώτη τιμή της `y` αντιστοιχεί στη πρώτη τιμή της `z`).
    Τι συμβαίνει εάν εφαρμόσετε δύο φορές την `unnest_longer()` σε αυτό το πλαίσιο δεδομένων;\
    Πώς μπορείτε να διατηρήσετε τη σχέση μεταξύ `x` και `y`;\
    (Υπόδειξη: διαβάστε προσεκτικά τις αντίστοιχες οδηγίες).

    ```{r}
    df4 <- tribble(
      ~x, ~y, ~z,
      "a", list("y-a-1", "y-a-2"), list("z-a-1", "z-a-2"),
      "b", list("y-b-1", "y-b-2", "y-b-3"), list("z-b-1", "z-b-2", "z-b-3")
    )
    ```

## Μελέτες περίπτωσης

Η κύρια διαφορά μεταξύ των απλών παραδειγμάτων που χρησιμοποιήσαμε παραπάνω και των πραγματικών δεδομένων είναι ότι τα πραγματικά δεδομένα περιέχουν συνήθως πολλαπλά επίπεδα ένθεσης, που απαιτούν πολλαπλές εφαρμογές της `unnest_longer()` και/ή της `unnest_wider()`.
Για να το δείξουμε αυτό στην πράξη, η ενότητα αυτή λειτουργεί μέσω τριών πραγματικών προκλήσεων ορθογωνοποίησης χρησιμοποιώντας σύνολα δεδομένων από το πακέτο repurrrsive.

### Δεδομένα με μεγάλο πλάτος

Θα ξεκινήσουμε με την `gh_repos`.
Αυτή είναι μια λίστα που περιέχει δεδομένα σχετικά με μια συλλογή αποθετηρίων στο GitHub, τα οποία ανακτήθηκαν χρησιμοποιώντας το API του GitHub.
Είναι μια εις βάθος ένθετη λίστα, κι επομένως είναι δύσκολο να δείξουμε τη δομή της σε αυτό το βιβλίο.
Πριν συνεχίσουμε, συνιστούμε να την εξερευνήσετε λίγο μόνοι σας με την `View(gh_repos)`.

Η `gh_repos` είναι μια λίστα, αλλά τα εργαλεία μας λειτουργούν με στήλες λίστας, οπότε θα ξεκινήσουμε βάζοντάς την σε ένα tibble.
Ονομάζουμε αυτήν τη στήλη `json` για λόγους που θα δούμε αργότερα.

```{r}
repos <- tibble(json = gh_repos)
repos
```

Αυτό το tibble περιέχει 6 γραμμές, μία γραμμή για κάθε παιδί της `gh_repos`.
Κάθε γραμμή περιέχει μια λίστα χωρίς ονόματα, με 26 ή 30 γραμμές.
Δεδομένου ότι αυτά είναι χωρίς ονόμα, θα ξεκινήσουμε με την `unnest_longer()` για να βάλουμε κάθε παιδί στη δική του γραμμή:

```{r}
repos |> 
  unnest_longer(json)
```

Με μια πρώτη ματιά, μπορεί να φαίνεται ότι δεν έχουμε βελτιώσει την κατάσταση: ενώ έχουμε περισσότερες γραμμές (176 αντί για 6), κάθε στοιχείο της `json` εξακολουθεί να είναι μια λίστα.
Ωστόσο, υπάρχει μια σημαντική διαφορά: τώρα κάθε στοιχείο είναι μια λίστα **με ονόματα**, ώστε να μπορούμε να χρησιμοποιήσουμε την `unnest_wider()` για να βάλουμε κάθε στοιχείο στη δική του στήλη:

```{r}
repos |> 
  unnest_longer(json) |> 
  unnest_wider(json) 
```

Αυτό λειτούργησε, αλλά το αποτέλεσμα δεν είναι με το μέρος μας: υπάρχουν τόσες πολλές στήλες που η tibble δεν τις εκτυπώνει όλες!
Μπορούμε να τις δούμε με την `names()`.
Eδώ βλέπουμε τις πρώτα 10:

```{r}
repos |> 
  unnest_longer(json) |> 
  unnest_wider(json) |> 
  names() |> 
  head(10)
```

Ας κρατήσουμε μερικές στήλες που φαίνονται ενδιαφέρουσες:

```{r}
repos |> 
  unnest_longer(json) |> 
  unnest_wider(json) |> 
  select(id, full_name, owner, description)
```

Μπορείτε να χρησιμοποιήσετε το παραπάνω για να κατανοήσετε το πως δομήθηκε η `gh_repos`: κάθε παιδί ήταν και ένας χρήστης του GitHub στον οποίο αντιστοιχεί μια λίστα, η οποία περιέχει έως και 30 αποθετήρια που αυτός ο χρήστης δημιούργησε.

Η `owner` είναι μια άλλη στήλη λίστας και δεδομένου ότι περιέχει λίστες με ονόματα, μπορούμε να χρησιμοποιήσουμε την `unnest_wider()` για να φτάσουμε στις τιμές:

```{r}
#| error: true
repos |> 
  unnest_longer(json) |> 
  unnest_wider(json) |> 
  select(id, full_name, owner, description) |> 
  unnest_wider(owner)
```

Ωχ, αυτή η στήλη λίστας περιέχει επίσης μια στήλη `id` και δεν μπορούμε να έχουμε δύο στήλες με το όνομα `id` στο ίδιο πλαίσιο δεδομένων.
Όπως προτείνεται, ας χρησιμοποιήσουμε την `names_sep` για να επιλύσουμε το πρόβλημα:

```{r}
repos |> 
  unnest_longer(json) |> 
  unnest_wider(json) |> 
  select(id, full_name, owner, description) |> 
  unnest_wider(owner, names_sep = "_")
```

Αυτό επιστρέφει ένα άλλο πλατύ σύνολο δεδομένων.
Μπορείτε όμως να καταλάβετε ότι η στήλη `owner` φαίνεται να περιέχει πολλά πρόσθετα δεδομένα σχετικά με το άτομο που "κατέχει" το αποθετήριο.

### Σχεσιακά δεδομένα

Τα ένθετα δεδομένα χρησιμοποιούνται μερικές φορές για την αναπαράσταση δεδομένων που συνήθως θα διανέμαμε σε πολλαπλά πλαίσια δεδομένων.
Για παράδειγμα, πάρτε την `got_chars` που περιέχει δεδομένα σχετικά με χαρακτήρες που εμφανίζονται στα βιβλία και τις τηλεοπτικές σειρές του Game of Thrones.
Όπως και η `gh_repos`, έτσι και αυτή είναι μια λίστα, οπότε ξεκινάμε μετατρέποντάς την σε στήλη λίστας ενός tibble:

```{r}
chars <- tibble(json = got_chars)
chars
```

Η στήλη `json` περιέχει στοιχεία με ονόματα, επομένως θα ξεκινήσουμε διευρύνοντάς την:

```{r}
chars |> 
  unnest_wider(json)
```

Και επιλέγοντας μερικές στήλες για πιο εύκολη ανάγνωση:

```{r}
characters <- chars |> 
  unnest_wider(json) |> 
  select(id, name, gender, culture, born, died, alive)
characters
```

Αυτό το σύνολο δεδομένων περιέχει επίσης πολλές στήλες λίστας:

```{r}
chars |> 
  unnest_wider(json) |> 
  select(id, where(is.list))
```

Ας εξερευνήσουμε τη στήλη `titles`.
Είναι μια στήλη λίστας χωρίς ονόματα, επομένως θα την αναδομήσουμε σε γραμμές:

```{r}
chars |> 
  unnest_wider(json) |> 
  select(id, titles) |> 
  unnest_longer(titles)
```

Ίσως να περιμένατε να δείτε τα δεδομένα στον δικό τους, ξεχωριστό πίνακα, καθώς θα ήταν εύκολο να ενωθούν με τα δεδομένα χαρακτήρων όπως απαιτείται.
Ας δοκιμάσουμε αυτή την επιλογή, μιας και απαιτεί πολύ λίγα βήματα καθαρισμού των δεδομένων: αφαιρούμε τις γραμμές που περιέχουν κενές συμβολοσειρές και μετονομάζουμε την στήλη `titles` σε `title`, καθώς κάθε γραμμή περιέχει πλέον μόνο έναν τίτλο.

```{r}
titles <- chars |> 
  unnest_wider(json) |> 
  select(id, titles) |> 
  unnest_longer(titles) |> 
  filter(titles != "") |> 
  rename(title = titles)
titles
```

Θα μπορούσατε να φανταστείτε την δημιουργία ενός πίνακα σαν αυτόν για κάθε μία από τις στήλες λίστας και στη συνέχεια να χρησιμοποιήσετε συναρτήσεις ένωσης για να τις συνδυάσετε με τα δεδομένα χαρακτήρων με όποιον τρόπο τα χρειάζεστε.

### Πολυεπίπεδη ένθεση

Θα ολοκληρώσουμε αυτές τις μελέτες περίπτωσης με μια στήλη λίστας με αρκετό βάθος ένθεσης που απαιτεί επαναλαμβανόμενους γύρους εφαρμογής της `unnest_wider()` και της `unnest_longer()` για να αναδομηθεί: την `gmaps_cities`.
Βρίσκεται σε ένα tibble δύο στηλών που περιέχει πέντε ονόματα πόλεων και τα αποτελέσματα της χρήσης του [geocoding API](https://developers.google.com/maps/documentation/geocoding) της Google για τον προσδιορισμό της τοποθεσίας τους:

```{r}
gmaps_cities
```

Η `json` είναι μια στήλη λίστας με εσωτερικά ονόματα, οπότε ξεκινάμε με ένα `unnest_wider()`:

```{r}
gmaps_cities |> 
  unnest_wider(json)
```

Αυτό μας δίνει τις στήλες `status` και `results`.
Θα απορρίψουμε τη στήλη status επειδή όλες οι τιμές της είναι `ΟΚ`.
Σε μια πραγματική ανάλυση, θα θέλατε επίσης να καταγράψετε όλες τις γραμμές όπου `status != "OK` και να καταλάβετε τι πήγε στραβά. Η `results` είναι μια λίστα χωρίς ονόματα, με ένα ή δύο στοιχεία (θα δούμε το γιατί σύντομα) οπότε θα την αναδομήσουμε σε γραμμές:

```{r}
gmaps_cities |> 
  unnest_wider(json) |> 
  select(-status) |> 
  unnest_longer(results)
```

Τώρα η `results` είναι μια λίστα με ονόματα, επομένως θα χρησιμοποιήσουμε την `unnest_wider()`:

```{r}
locations <- gmaps_cities |> 
  unnest_wider(json) |> 
  select(-status) |> 
  unnest_longer(results) |> 
  unnest_wider(results)
locations
```

Τώρα μπορούμε να δούμε γιατί δύο πόλεις έλαβαν δύο αποτελέσματα (δηλαδή δύο στοιχεία στη στήλη results): H τιμή "Washington" αντιστοιχήθηκε με τo "state of Washington" και με το "Washington DC" ενώ η τιμή "Arlington" αντιστοιχήθηκε με το "Arlington, Virginia" και το "Arlington, Texas".

Υπάρχουν μερικές διαφορετικές κατευθύνσεις που θα μπορούσαμε να πάρουμε τώρα.
Ίσως θέλουμε να προσδιορίσουμε την ακριβή τοποθεσία της αντιστοίχισης, η οποία είναι αποθηκευμένη στη στήλη λίστας `geometry`:

```{r}
locations |> 
  select(city, formatted_address, geometry) |> 
  unnest_wider(geometry)
```

Το παραπάνω μας δίνει τις νέες στήλες λίστας `bounds (όρια)` (μια ορθογώνια περιοχή) και `location (θέση)` (ένα σημείο).
Μπορούμε να αναδομήσουμε την `location` για να δούμε το γεωγραφικό πλάτος (`lat`) και το γεωγραφικό μήκος (`lng`):

```{r}
locations |> 
  select(city, formatted_address, geometry) |> 
  unnest_wider(geometry) |> 
  unnest_wider(location)
```

Η αναδόμηση της bounds απαιτεί μερικά ακόμη βήματα:

```{r}
locations |> 
  select(city, formatted_address, geometry) |> 
  unnest_wider(geometry) |> 
  # focus on the variables of interest
  select(!location:viewport) |>
  unnest_wider(bounds)
```

Στη συνέχεια μετονομάζουμε τις `southwest` και `northeast` (τις γωνίες του ορθογωνίου) ώστε να μπορούμε να χρησιμοποιήσουμε το `names_sep` για να δημιουργήσουμε σύντομα αλλά εύκολα να θυμάστε ονόματα:

```{r}
locations |> 
  select(city, formatted_address, geometry) |> 
  unnest_wider(geometry) |> 
  select(!location:viewport) |>
  unnest_wider(bounds) |> 
  rename(ne = northeast, sw = southwest) |> 
  unnest_wider(c(ne, sw), names_sep = "_") 
```

Σημειώστε πώς αφαιρούμε δύο στήλες ταυτόχρονα, παρέχοντας ένα διάνυσμα ονομάτων μεταβλητών στην `unnest_wider()`.

Μόλις ανακαλύψετε τη διαδρομή για να φτάσετε στα στοιχεία που σας ενδιαφέρουν, μπορείτε να τα εξάγετε απευθείας χρησιμοποιώντας μια άλλη συνάρτηση της tidyr, την `hoist()`:

```{r}
#| results: false
locations |> 
  select(city, formatted_address, geometry) |> 
  hoist(
    geometry,
    ne_lat = c("bounds", "northeast", "lat"),
    sw_lat = c("bounds", "southwest", "lat"),
    ne_lng = c("bounds", "northeast", "lng"),
    sw_lng = c("bounds", "southwest", "lng"),
  )
```

Εάν αυτές οι μελέτες περίπτωσης σας έχουν ανοίξει την όρεξη για περισσότερες πραγματικές εφαρμογές της ορθωγονοποίησης, μπορείτε να δείτε μερικά ακόμη παραδείγματα εκτελώντας το `vignette("rectangling", package = "tidyr")`.

### Ασκήσεις

1.  Υπολογίστε κατά προσέγγιση πότε δημιουργήθηκε η `gh_repos`.
    Γιατί μπορείτε να υπολογίσετε μόνο κατά προσέγγιση την ημερομηνία;

2.  Η στήλη `owner` του `gh_repo` περιέχει πολλές διπλότυπες πληροφορίες, επειδή κάθε κάτοχος (owner) μπορεί να έχει πολλαπλά αποθετήρια.
    Μπορείτε να δημιουργήσετε ένα πλαίσιο δεδομένων `owners` που περιέχει μία γραμμή για κάθε κάτοχο;\
    (Συμβουλή: λειτουργεί η `distinct()` με `στήλες λίστας`;)

3.  Ακολουθήστε τα βήματα που χρησιμοποιήθηκαν για το `titles` για να δημιουργήσετε παρόμοιους πίνακες για τα ψευδώνυμα, τις υποθέσεις, τα βιβλία και τις τηλεοπτικές σειρές για τους χαρακτήρες του Game of Thrones.

4.  Εξηγήστε τον ακόλουθο κώδικα γραμμή προς γραμμή.
    Γιατί είναι ενδιαφέρον;\
    Γιατί λειτουργεί για την `got_chars`, αλλά μπορεί να μην λειτουργεί γενικά;

    ```{r}
    #| results: false
    tibble(json = got_chars) |> 
      unnest_wider(json) |> 
      select(id, where(is.list)) |> 
      pivot_longer(
        where(is.list), 
        names_to = "name", 
        values_to = "value"
      ) |>  
      unnest_longer(value)
    ```

5.  Στο `gmaps_cities`, τι περιέχει η `address_components`;\
    Γιατί το μήκος (length) ποικίλλει μεταξύ γραμμών;\
    Αναδομήστε το κατάλληλα για να το καταλάβετε.
    (Συμβουλή: Η `types` φαίνεται να περιέχει πάντα δύο στοιχεία. Διευκολύνει η `unnest_wider()` την εργασία σας σε σχέση με την `unnest_longer()`;).

## JSON

Όλες οι μελέτες περίπτωσης στην προηγούμενη ενότητα προέρχονται από αρχεία JSON που βρίσκονται εκεί έξω.
Το JSON είναι συντομογραφία του **j**ava**s**cript **o**bject **n**otation και είναι ο τρόπος με τον οποίο τα περισσότερα API στο διαδίκτυο επιστρέφουν δεδομένα.
Είναι σημαντικό να το κατανοήσουμε γιατί, ενώ οι τύποι δεδομένων ενός JSON και της R είναι αρκετά παρόμοιοι, δεν υπάρχει 1-προς-1 αντιστοίχιση, επομένως είναι καλό να τα κατανοήσουμε για περίπτωση όπου τα πράγματα πάνε στραβά.

### Τύποι δεδομένων

Το JSON είναι μια απλή μορφή δεδομένων που έχει σχεδιαστεί για να διαβάζεται και να γράφεται εύκολα από μηχανές και όχι από ανθρώπους.
Διαθέτει έξι βασικούς τύπους δεδομένων.
Τέσσερα από αυτά είναι βαθμωτά μεγέθη:

-   Ο απλούστερος τύπος είναι το κενό (`null`) που παίζει τον ίδιο ρόλο με το `NA` στην R. Αντιπροσωπεύει την απουσία δεδομένων.
-   Μια **συμβολοσειρά** μοιάζει πολύ με μια συμβολοσειρά στην R, αλλά πρέπει πάντα να χρησιμοποιείται με διπλά εισαγωγικά.
-   Ένας **αριθμός** είναι παρόμοιος με τους αριθμούς της R: μπορούν να χρησιμοποιούν ακέραιο (π.χ. 123), δεκαδικό (π.χ. 123,45) ή επιστημονικό (π.χ. 1.23e3) συμβολισμό. Το JSON δεν υποστηρίζει τιμές `Inf`, `-Inf` ή `NaN`.
-   Ένα **λογικό διάνυσμα** είναι παρόμοιο με τα `TRUE` και `FALSE` της R, αλλά χρησιμοποιεί πεζά `true` και `false`.

Οι συμβολοσειρές, οι αριθμοί και τα λογικά διανύσματα των JSON μοιάζουν αρκετά με τους χαρακτήρες, τα αριθμητικά και τα λογικά διανύσματα του R.
Η κύρια διαφορά είναι ότι οι βαθμίδες των JSON μπορούν να αντιπροσωπεύουν μόνο μία τιμή.
Για να αναπαραστήσετε πολλαπλές τιμές πρέπει να χρησιμοποιήσετε έναν από τους δύο εναπομείναντες τύπους: πίνακες (arrays) και αντικείμενα.

Τόσο οι πίνακες όσο και τα αντικείμενα είναι παρόμοια με τις λίστες ατην R.
Η διαφορά είναι στο εαν ονομάζονται ή όχι.
Ένας **πίνακας** είναι σαν μια λίστα χωρίς ονόματα και γράφεται με `[]`.
Για παράδειγμα, το `[1, 2, 3]` είναι ένας πίνακας που περιέχει 3 αριθμούς και το `[null, 1, "string", false]` είναι ένας πίνακας που περιέχει ένα κενό, έναν αριθμό, μια συμβολοσειρά και ένα λογικό διάνυσμα.
Ένα **αντικείμενο** είναι σαν μια λίστα με ονόματα και γράφεται με `{}`.
Τα ονόματα (κλειδιά στην ορολογία των JSON) είναι συμβολοσειρές, επομένως πρέπει να περιβάλλονται από εισαγωγικά.
Για παράδειγμα, το `{"x": 1, "y": 2}` είναι ένα αντικείμενο που αντιστοιχίζει το `x` στο 1 και το `y` στο 2.

Σημειώστε ότι το JSON δεν διαθέτει εγγενή τρόπο αναπαράστασης ημερομηνιών ή ωρών, επομένως αποθηκεύονται συχνά ως συμβολοσειρές και θα χρειαστεί να χρησιμοποιήσετε την `readr::parse_date()` ή την `readr::parse_datetime()` για να τα μετατρέψετε στη σωστή δομή δεδομένων.
Ομοίως, οι κανόνες των JSON για την αναπαράσταση αριθμών κινητής υποδιαστολής είναι λίγο ανακριβείς, επομένως μερικές φορές θα βρείτε αριθμούς αποθηκευμένους σε συμβολοσειρές.
Εφαρμόστε την `readr::parse_double()` όπως απαιτείται για να λάβετε τον σωστό τύπο μεταβλητής.

### jsonlite

Για να μετατρέψετε ένα αρχείο JSON σε δομές δεδομένων της R, προτείνουμε το πακέτο jsonlite, του Jeroen Ooms.
Θα χρησιμοποιήσουμε μόνο δύο συναρτήσεις της jsonlite: την `read_json()` και την `parse_json()`.
Σε πραγματικές συνθήκες, θα χρησιμοποιήσετε την `read_json()` για να διαβάσετε ένα αρχείο JSON από το δίσκο.
Για παράδειγμα, το πακέτο repurrsive παρέχει επίσης το `gh_user` ως αρχείο JSON και μπορείτε να το διαβάσετε με την `read_json()`:

```{r}
# A path to a json file inside the package:
gh_users_json()

# Read it with read_json()
gh_users2 <- read_json(gh_users_json())

# Check it's the same as the data we were using previously
identical(gh_users, gh_users2)
```

Σε αυτό το βιβλίο, θα χρησιμοποιήσουμε επίσης την `parse_json()`, καθώς χρειάζεται ως είσοδο μια συμβολοσειρά που περιέχει το JSON, κάτι που το καθιστά κατάλληλο για τη δημιουργία απλών παραδειγμάτων.
Για να ξεκινήσετε, ακολουθούν τρία απλά σύνολα δεδομένων JSON, ξεκινώντας με έναν αριθμό, τοποθετώντας μερικούς αριθμούς σε έναν πίνακα και στη συνέχεια τοποθετώντας αυτόν τον πίνακα σε ένα αντικείμενο:

```{r}
str(parse_json('1'))
str(parse_json('[1, 2, 3]'))
str(parse_json('{"x": [1, 2, 3]}'))
```

Η jsonlite έχει μια άλλη σημαντική συνάρτηση που ονομάζεται `fromJSON()`.
Δεν τη χρησιμοποιούμε εδώ επειδή εφαρμόζει αυτόματη απλοποίηση του αποτελέσματος (`simplifyVector = TRUE`).
Αυτό λειτουργεί καλά σε αρκετές περιπτώσεις, ιδιαίτερα σε απλές, αλλά πιστεύουμε ότι είναι καλύτερα να κάνετε την ορθογωνιοποίηση μόνοι σας, ώστε να γνωρίζετε ακριβώς τι συμβαίνει και να χειρίζεστε πιο εύκολα πιο περίπλοκες ένθετες δομές.

### Ξεκινώντας με την διαδικασία ορθογωνιοποίησης

Στις περισσότερες περιπτώσεις, τα αρχεία JSON περιέχουν έναν μεμονομένο πίνακα ανώτατου επιπέδου, επειδή έχουν σχεδιαστεί για να παρέχουν δεδομένα σχετικά με πολλά "πράγματα", π.χ.
πολλές σελίδες ή πολλές εγγραφές ή πολλά αποτελέσματα.
Σε αυτήν την περίπτωση, θα ξεκινήσετε την ορθογωνιοποίηση με την `tibble(json)`, έτσι ώστε κάθε στοιχείο να γίνει μια γραμμή:

```{r}
json <- '[
  {"name": "John", "age": 34},
  {"name": "Susan", "age": 27}
]'
df <- tibble(json = parse_json(json))
df

df |> 
  unnest_wider(json)
```

Σε πιο σπάνιες περιπτώσεις, το αρχείο JSON αποτελείται από ένα αντικείμενο JSON ανώτατου επιπέδου, που αντιπροσωπεύει ένα "πράγμα".
Σε αυτήν την περίπτωση, θα πρέπει να ξεκινήσετε τη διαδικασία της ορθογωνιοποίησης βάζοντάς το αρχείο JSON πρώτα σε μια λίστα, προτού το βάλετε σε ένα tibble.

```{r}
json <- '{
  "status": "OK", 
  "results": [
    {"name": "John", "age": 34},
    {"name": "Susan", "age": 27}
 ]
}
'
df <- tibble(json = list(parse_json(json)))
df

df |> 
  unnest_wider(json) |> 
  unnest_longer(results) |> 
  unnest_wider(results)
```

Εναλλακτικά, μπορείτε να μπείτε μέσα στο αναγνωσμένο JSON και να ξεκινήσετε με το σημείο που πραγματικά σας ενδιαφέρει:

```{r}
df <- tibble(results = parse_json(json)$results)
df |> 
  unnest_wider(results)
```

### Ασκήσεις

1.  Ορθογωνιοποιήστε τα `df_col` και `df_row` παρακάτω.
    Αντιπροσωπεύουν τους δύο τρόπους κωδικοποίησης ενός πλαισίου δεδομένων σε JSON.

    ```{r}
    json_col <- parse_json('
      {
        "x": ["a", "x", "z"],
        "y": [10, null, 3]
      }
    ')
    json_row <- parse_json('
      [
        {"x": "a", "y": 10},
        {"x": "x", "y": null},
        {"x": "z", "y": 3}
      ]
    ')

    df_col <- tibble(json = list(json_col)) 
    df_row <- tibble(json = json_row)
    ```

## Σύνοψη

Σε αυτό το κεφάλαιο, μάθατε τι είναι οι λίστες, πώς μπορείτε να τις δημιουργήσετε από αρχεία JSON, και πώς να τις μετατρέψετε σε ορθογώνια πλαίσια δεδομένων.
Παραδόξως χρειαζόμαστε μόνο δύο νέες συναρτήσεις: την `unnest_longer()` για να βάλουμε στοιχεία λίστας σε γραμμές, και την `unnest_wider()` για να τοποθετήσουμε στοιχεία λίστας σε στήλες.
Δεν έχει σημασία το πόσο βαθιά ένθεση έχει η στήλη λίστας.
Το μόνο που χρειάζεται να κάνετε είναι να καλείτε επανειλημμένα αυτές τις δύο συναρτήσεις.

Τα JSON είναι η πιο κοινή μορφή δεδομένων που επιστρέφεται από API στο διαδίκτυο.
Τι συμβαίνει εάν ο ιστότοπος δεν διαθέτει API, αλλά μπορείτε να δείτε τα δεδομένα που θέλετε στον ιστότοπο;\
Αυτό είναι το θέμα του επόμενου κεφαλαίου: η ιστοσυγκομιδή, η εξαγωγή δεδομένων, δηλαδή, από ιστοσελίδες HTML.
