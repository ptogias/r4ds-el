# Λογικές εκφράσεις {#sec-regular-expressions}

```{r}
#| echo: false

source("_common.R")
```

## Εισαγωγή

Στο @sec-strings, μάθατε αρκετές χρήσιμες συναρτήσεις για να εργάζεστε με συμβολοσειρές.
Το κεφάλαιο αυτό θα επικεντρωθεί σε συναρτήσεις που χρησιμοποιούν **κανονικές εκφράσεις**, μια περιγραφική και ισχυρή γλώσσα για την περιγραφή μοτίβων μέσα σε συμβολοσειρές.
Ο όρος "κανονική έκφραση" είναι στα αγγλικά είναι "regular expression" και θεωρείτε γλωσσοδέτης, επομένως οι περισσότεροι τον συντομεύουν σε "regex"[^regexps-1] ή "regexp".

[^regexps-1]: Μπορείτε να το προφέρετε είτε τονίζοντας το "γκ" (ρέγκεξ) είτε το "τζ" (ρέτζεξ).

Το κεφάλαιο ξεκινά με τα βασικά των κανονικών εκφράσεων και τις πιο χρήσιμες συναρτήσεις της stringr για ανάλυση δεδομένων.
Στη συνέχεια, θα επεκτείνουμε τις γνώσεις σας σχετικά με τα μοτίβα και θα καλύψουμε επτά σημαντικά νέες θεματολογίες (διαφυγή, αγκύστρωση, κατηγορίες χαρακτήρων, κατηγορίες συντομογραφίας, ποσοτικοί δείκτες, ιεραρχία και ομαδοποίηση).
Στη συνέχεια, θα μιλήσουμε για μερικούς από τους άλλους τύπους μοτίβων με τους οποίους οι συναρτήσεις της stringr μπορούν να λειτουργήσουν και για τους διάφορους "δείκτες" που σας επιτρέπουν να τροποποιήσετε τη λειτουργία των κανονικών εκφράσεων.
Θα ολοκληρώσουμε με μια επισκόπηση άλλως σημείων στο tidyverse και το βασικό πακέτο λειτουργιών της R όπου μπορείτε να χρησιμοποιήσετε regex.

### Προαπαιτούμενα

Σε αυτό το κεφάλαιο, θα χρησιμοποιήσουμε συναρτήσεις κανονικής έκφρασης από την stringr και την tidyr, δύο βασικά μέλη του tidyverse, καθώς και δεδομένα από το πακέτο babynames.

```{r}
#| label: setup
#| message: false

library(tidyverse)
library(babynames)
```

Μέσα από αυτό το κεφάλαιο, θα χρησιμοποιήσουμε έναν συνδυασμό πολύ απλών παραδειγμάτων ώστε να μπορείτε να πάρετε τη βασική ιδέα, τα δεδομένα ονομάτων μωρών και τρία διανύσματα χαρακτήρων από την stringr:

-   Το διάνυσμα `fruit` περιέχει τα ονόματα 80 φρούτων.
-   Το `words` περιέχει 980 συχνές αγγλικές λέξεις.
-   Το `senteces` περιέχει 720 σύντομες προτάσεις.

## Βασικές αρχές των μοτίβων {#sec-reg-basics}

Θα χρησιμοποιήσουμε την `str_view()` για να μάθουμε πώς λειτουργούν τα μοτίβα σε regex.
Χρησιμοποιήσαμε την `str_view()` στο προηγούμενο κεφάλαιο για να κατανοήσουμε καλύτερα μια συμβολοσειρά έναντι της εκτυπωμένης αναπαράστασής της, και τώρα θα τη χρησιμοποιήσουμε με το δεύτερο όρισμά της, μια κανονική έκφραση.
Όταν παρέχεται, η `str_view()` θα εμφανίσει μόνο τα στοιχεία του διανύσματος συμβολοσειράς που ταιριάζουν, περιβάλλοντας κάθε αντιστοιχία με `<>` και, όπου είναι δυνατόν, επισημαίνοντας την αντιστοίχιση με μπλε χρώμα.

Τα πιο απλά μοτίβα αποτελούνται από γράμματα και αριθμούς που ταιριάζουν ακριβώς με αυτούς τους χαρακτήρες:

```{r}
str_view(fruit, "berry")
```

Τα γράμματα και οι αριθμοί που ταιριάζουν ακριβώς ονομάζονται **σταθεροί χαρακτήρες**.
Οι περισσότεροι χαρακτήρες στίξης, όπως οι `.`, `+`, `*`, `[`, `]` και `?`, έχουν ειδικές έννοιες[^regexps-2] και ονομάζονται **μεταχαρακτήρες**. Για παράδειγμα, ο χαρακτήρας `.`
θα ταιριάζει με οποιονδήποτε χαρακτήρα[^regexps-3], οπότε το `a`
`.` θα ταιριάζει με κάθε συμβολοσειρά που περιέχει ένα `a` ακολουθούμενο από έναν άλλο χαρακτήρα
:

[^regexps-2]: Θα μάθετε πώς να δισφύγετε αυτές τις ειδικές έννοιες στο @sec-regexp-escaping.

[^regexps-3]: Βασικά, οποιοσδήποτε χαρακτήρας εκτός από το `\n`.

```{r}
str_view(c("a", "ab", "ae", "bd", "ea", "eab"), "a.")
```

Ή θα μπορούσαμε να βρούμε όλα τα φρούτα που περιέχουν ένα "a", ακολουθούμενο από τρία γράμματα και ένα "e":

```{r}
str_view(fruit, "a...e")
```

**Οι ποσοτικοί δείκτες** ελέγχουν πόσες φορές μπορεί να ταιριάξει ένα μοτίβο:

-   Το `?` κάνει ένα μοτίβο προαιρετικό (να ταιριάζει δηλαδή 0 ή 1 φορές)
-   Το `+` επιτρέπει σε ένα μοτίβο να επαναλαμβάνεται (να ταιριάζει δηλαδή τουλάχιστον μία φορά)
-   Το `*` επιτρέπει σε ένα μοτίβο να είναι προαιρετικό ή να επαναλαμβάνεται (να ταιριάζει δηλαδή με οποιονδήποτε αριθμό φορών, συμπεριλαμβανομένου του 0).

```{r}
# ab? matches an "a", optionally followed by a "b".
str_view(c("a", "ab", "abb"), "ab?")

# ab+ matches an "a", followed by at least one "b".
str_view(c("a", "ab", "abb"), "ab+")

# ab* matches an "a", followed by any number of "b"s.
str_view(c("a", "ab", "abb"), "ab*")
```

**Οι κατηγορίες χαρακτήρων** ορίζονται από το `[]` και σας επιτρέπουν να αντιστοιχίσετε ένα σύνολο χαρακτήρων.
Για παράδειγμα, το `[abcd]` ταιριάζει με τους χαρακτήρες "a", "b", "c" ή "d".
Μπορείτε επίσης να αντιστρέψετε την αντιστοίχιση ξεκινώντας με το `^`: Το `[^abcd]` αντιστοιχεί σε οτιδήποτε **εκτός** των "a", "b", "c" ή "d".
Μπορούμε να χρησιμοποιήσουμε αυτήν την ιδέα για να βρούμε τις λέξεις που περιέχουν ένα "x" που περιβάλλεται από φωνήεντα ή ένα "y" που περιβάλλεται από σύμφωνα:

```{r}
str_view(words, "[aeiou]x[aeiou]")
str_view(words, "[^aeiou]y[^aeiou]")
```

Μπορείτε να χρησιμοποιήσετε την **εναλλαγή**, `|`, για να επιλέξετε ανάμεσα σε ένα ή περισσότερα εναλλακτικά μοτίβα.
Για παράδειγμα, τα ακόλουθα μοτίβα αναζητούν φρούτα που περιέχουν "apple", "melon" ή "nut" ή ένα επαναλαμβανόμενο φωνήεν.

```{r}
str_view(fruit, "apple|melon|nut")
str_view(fruit, "aa|ee|ii|oo|uu")
```

Οι κανονικές εκφράσεις είναι πολύ συμπαγείς και χρησιμοποιούν πολλούς χαρακτήρες στίξης, έτσι μπορεί να φαίνονται δύσκολες και δυσανάγνωστες στην αρχή.
Μην ανησυχείτε.
θα γίνετε καλύτεροι με την εξάσκηση και τα απλά μοτίβα σύντομα θα γίνουν συνήθεια.
Ας ξεκινήσουμε αυτή τη διαδικασία εξασκώντας μερικές χρήσιμες συναρτήσεις της stringr.

## Βασικές συναρτήσεις {#sec-stringr-regex-funs}

Τώρα που έχετε εμπεδώσει τα βασικά των κανονικών εκφράσεων, ας τις χρησιμοποιήσουμε με ορισμένες συναρτήσεις απο την stringr και την tidyr.
Στην επόμενη ενότητα, θα μάθετε πώς να ανιχνεύετε την παρουσία ή την απουσία μιας αντιστοίχισης, πώς να μετράτε τον αριθμό των αντιστοιχιών, πώς να αντικαθιστάτε μια αντιστοίχιση με σταθερό κείμενο και πώς να εξάγετε κείμενο χρησιμοποιώντας ένα μοτίβο.

### Ανίχνευση αντιστοιχιών

Η `str_detect()` επιστρέφει ένα λογικό διάνυσμα που είναι `TRUE` εάν το μοτίβο ταιριάζει με ένα στοιχείο του διανύσματος χαρακτήρων και `FALSE` σε διαφορετική περίπτωση:

```{r}
str_detect(c("a", "b", "c"), "[aeiou]")
```

Εφόσον η `str_detect()` επιστρέφει ένα λογικό διάνυσμα ίδιου μήκους με το αρχικό διάνυσμα, συνδυάζεται καλά με την `filter()`.
Για παράδειγμα, αυτός ο κώδικας βρίσκει όλα τα πιο δημοφιλή ονόματα που περιέχουν ένα πεζό "x":

```{r}
babynames |> 
  filter(str_detect(name, "x")) |> 
  count(name, wt = n, sort = TRUE)
```

Μπορούμε επίσης να χρησιμοποιήσουμε την `str_detect()` με την `summarize()` συνδυάζοντάς το με την `sum()` ή την `mean()`: Το `sum(str_detect(x, pattern))` σας λέει τον αριθμό των παρατηρήσεων που ταιριάζουν και η `mean(str_detect(x, pattern))` σας λέει την αναλογία που ταιριάζει.
Για παράδειγμα, το ακόλουθο απόσπασμα υπολογίζει και απεικονίζει την αναλογία των ονομάτων μωρών[^regexps-4] που περιέχουν το γράμμα "x", ανά έτος.
Φαίνεται ότι έχουν αυξηθεί πάρα πολύ σε δημοτικότητα τον τελευταίο καιρό!

[^regexps-4]: Αυτό μας δίνει την αναλογία των **ονομάτων** που περιέχουν ένα "x".
    Εάν θέλατε την αναλογία των μωρών με ένα όνομα που περιέχει ένα x, θα έπρεπε να υπολογίσετε μια σταθμισμένη μέση τιμή.

```{r}
#| fig-alt: |
#|   A time series showing the proportion of baby names that contain the letter x. 
#|   The proportion declines gradually from 8 per 1000 in 1880 to 4 per 1000 in 
#|   1980, then increases rapidly to 16 per 1000 in 2019.

babynames |> 
  group_by(year) |> 
  summarize(prop_x = mean(str_detect(name, "x"))) |> 
  ggplot(aes(x = year, y = prop_x)) + 
  geom_line()
```

Υπάρχουν δύο συναρτήσεις που σχετίζονται στενά με την `str_detect()`: η `str_subset()` και η `str_which()`.
Η `str_subset()` επιστρέφει ένα διάνυσμα χαρακτήρων που περιέχει μόνο τις συμβολοσειρές που ταιριάζουν.
Η `str_which()` επιστρέφει ένα ακέραιο διάνυσμα δίνοντας τις θέσεις των συμβολοσειρών που ταιριάζουν.

### Μετρήσεις αντιστοιχήσεων

Το επόμενο βήμα στην πολυπλοκότητα από την `str_detect()` είναι η `str_count()`: αντί να επιστρέψει κάποιο true ή false, σας λέει πόσες αντιστοιχίσεις υπάρχουν σε κάθε συμβολοσειρά.

```{r}
x <- c("apple", "banana", "pear")
str_count(x, "p")
```

Σημειώστε ότι κάθε αντιστοιχίση ξεκινά στο τέλος της προηγούμενης αντιστοίχισης, δηλαδή οι αντιστοιχήσεις των regex δεν επικαλύπτονται ποτέ.
Για παράδειγμα, στη συμβολοσειρά `"abababa"`, πόσες φορές θα ταιριάξει το μοτίβο `"aba"`; Οι κανονικές εκφράσεις λένε δύο, όχι τρεις:

```{r}
str_count("abababa", "aba")
str_view("abababa", "aba")
```

Είναι αναμενόμενο να χρησιμοποιείτε την `str_count()` με την `mutate()`.
Το παρακάτω παράδειγμα χρησιμοποιεί την `str_count()` με κατηγορίες χαρακτήρων για να μετρήσει τον αριθμό των φωνηέντων και των συμφώνων σε κάθε όνομα.

```{r}
babynames |> 
  count(name) |> 
  mutate(
    vowels = str_count(name, "[aeiou]"),
    consonants = str_count(name, "[^aeiou]")
  )
```

Αν κοιτάξετε προσεκτικά, θα παρατηρήσετε ότι κάτι δεν πάει καλά με τους υπολογισμούς μας: Η συμβολοσειρά "Aaban" περιέχει τρία "a", αλλά η σύνοψή μας αναφέρει μόνο δύο φωνήεντα.
Αυτό συμβαίνει επειδή οι κανονικές εκφράσεις κάνουν διάκριση μεταξύ πεζών και κεφαλαίων.
Υπάρχουν τρεις τρόποι με τους οποίους μπορούμε να το διορθώσουμε:

-   Προσθέστε τα κεφαλαία φωνήεντα στην κατηγορία χαρακτήρων: `str_count(name, "[aeiouAEIOU]")`.
-   Πείτε στην κανονική έκφραση να αγνοήσει τα πεζά γράμματα: `str_count(name, regex("[aeiou]", ignore_case = TRUE))`. Θα μιλήσουμε για περισσότερα στο @sec-flags.
-   Χρησιμοποιήστε την `str_to_lower()` για να μετατρέψετε τα ονόματα σε πεζά: `str_count(str_to_lower(name), "[aeiou]")`.

Αυτή η ποικιλία προσεγγίσεων είναι αρκετά χαρακτηριστική όταν εργάζεστε με συμβολοσειρές --- υπάρχουν συχνά πολλοί τρόποι για να πετύχετε τον στόχο σας, είτε κάνοντας το μοτίβο σας πιο περίπλοκο είτε κάνοντας κάποια προεπεξεργασία στη συμβολοσειρά σας.
Εάν κολλήσετε δοκιμάζοντας μια προσέγγιση, μπορεί συχνά να είναι χρήσιμο να μειώσετε ρυθμούς και να αντιμετωπίσετε το πρόβλημα με διαφορετική οπτική.

Σε αυτήν την περίπτωση, καθώς εφαρμόζουμε δύο συναρτήσεις στο όνομα, νομίζω ότι είναι πιο εύκολο να το μετατρέψουμε πρώτα:

```{r}
babynames |> 
  count(name) |> 
  mutate(
    name = str_to_lower(name),
    vowels = str_count(name, "[aeiou]"),
    consonants = str_count(name, "[^aeiou]")
  )
```

### Αντικαταστήστε τιμές

Εκτός από τον εντοπισμό και την καταμέτρηση αντιστοιχιών, μπορούμε και να τις τροποποιήσουμε με τις `str_replace()` και `str_replace_all()`.
Η `str_replace()` αντικαθιστά την πρώτη αντιστοίχιση και, όπως υποδηλώνει το όνομα, η `str_replace_all()` αντικαθιστά όλες τις αντιστοιχίσεις.

```{r}
x <- c("apple", "pear", "banana")
str_replace_all(x, "[aeiou]", "-")
```

Η `str_remove()` και η `str_remove_all()` είναι εύχρηστες συντομεύσεις για την `str_replace(x, pattern, "")`:

```{r}
x <- c("apple", "pear", "banana")
str_remove_all(x, "[aeiou]")
```

Αυτές οι συναρτήσεις μπορούν να συνδυαστολυν με την `mutate()` κα΄θώς καθαρίζετε δεδομένα και συχνά θα τις εφαρμόζετε επανειλημμένα για να αφαιρέσετε επίπεδα κακής μορφοποίησης.

### Εξαγάγετε μεταβλητές {#sec-extract-variables}

Η τελευταία συνάρτηση που θα συζητήσουμε χρησιμοποιεί κανονικές εκφράσεις για την εξαγωγή δεδομένων από μία στήλη σε μία ή περισσότερες νέες στήλες: η `separate_wider_regex()`.
Συγγενεύει με τις συναρτήσεις `separate_wider_position()` και `separate_wider_delim()` για τις οποίες μάθατε στις @sec-string-columns.
Αυτές οι συναρτήσεις υπάρχουν στην tidyr επειδή λειτουργούν σε (στήλες απο) πλαίσια δεδομένων και όχι σε μεμονωμένα διανύσματα.

Ας δημιουργήσουμε ένα απλό σύνολο δεδομένων για να δείξουμε πώς λειτουργεί.
Εδώ έχουμε λίγα δεδομένα που προέρχονται από το `babynames` όπου έχουμε το όνομα, το φύλο και την ηλικία πολλών ανθρώπων σε μια μάλλον περίεργη μορφή[^regexps-5]:

[^regexps-5]: Ευχόμαστε να μπορούσαμε να σας διαβεβαιώσουμε ότι δεν θα δείτε ποτέ κάτι τόσο περίεργο σε πραγματικές περιπτώσεις, αλλά δυστυχώς κατά τη διάρκεια της καριέρας σας είναι πιθανό να δείτε πολύ πιο περίεργα!

```{r}
df <- tribble(
  ~str,
  "<Sheryl>-F_34",
  "<Kisha>-F_45", 
  "<Brandon>-N_33",
  "<Sharon>-F_38", 
  "<Penny>-F_58",
  "<Justin>-M_41", 
  "<Patricia>-F_84", 
)
```

Για να εξαγάγουμε αυτά τα δεδομένα χρησιμοποιώντας την `separate_wider_regex()` πρέπει απλώς να δημιουργήσουμε μια ακολουθία κανονικών εκφράσεων που να ταιριάζουν με κάθε κομμάτι.
Αν θέλουμε τα περιεχόμενα αυτού του κομματιού να εμφανίζονται στην έξοδο, του δίνουμε ένα όνομα:

```{r}
df |> 
  separate_wider_regex(
    str,
    patterns = c(
      "<", 
      name = "[A-Za-z]+", 
      ">-", 
      gender = ".",
      "_",
      age = "[0-9]+"
    )
  )
```

Εάν η αντιστοίχιση αποτύχει, μπορείτε να χρησιμοποιήσετε το `too_short = "debug"` για να καταλάβετε τι πήγε στραβά, όπως ακριβώς στην `separate_wider_delim()` και στην `separate_wider_position()`.

### Ασκήσεις

1.  Ποιο όνομα μωρού έχει τα περισσότερα φωνήεντα; Ποιο όνομα έχει την υψηλότερη αναλογία φωνηέντων; (Υπόδειξη: ποιος είναι ο παρονομαστής;)

2.  Αντικαταστήστε όλες τις μπροστινές κάθετες στο `"a/b/c/d/e"` με ανάστροφες κάθετες.
    Τι συμβαίνει εάν επιχειρήσετε να αναιρέσετε τον μετασχηματισμό αντικαθιστώντας όλες τις ανάστροφες κάθετες με κάθετες προς τα εμπρός; (Θα συζητήσουμε το πρόβλημα πολύ σύντομα.)

3.  Υλοποιήστε μια απλή έκδοση ττηςου `str_to_lower()` χρησιμοποιώντας την `str_replace_all()`.

4.  Δημιουργήστε μια κανονική έκφραση που θα ταιριάζει με τους αριθμούς τηλεφώνου όπως συνήθως γράφονται στη χώρα σας.

## Λεπτομέρειες των μοτίβων

Τώρα που καταλαβαίνετε τα βασικά της γλώσσας μοτίβων και πώς να τη χρησιμοποιήσετε με ορισμένες λειτουργίες της stringr και της tidyr, ήρθε η ώρα να εμβαθύνετε σε περισσότερες λεπτομέρειες.
Αρχικά, θα ξεκινήσουμε με την **δισφυγή**, η οποία σας επιτρέπει να αντιστοιχίσετε μεταχαρακτήρες που διαφορετικά θα αντιμετώπιζαν ειδικά.
Στη συνέχεια, θα μάθετε για τις **αγκυστρώσεις** που σας επιτρέπουν να ταιριάξετε την αρχή ή το τέλος της συμβολοσειράς.
Στη συνέχεια, θα μάθετε περισσότερα για τις **κατηγορίες χαρακτήρων** και τις συντομεύσεις τους οι οποίες σας επιτρέπουν να ταιριάξετε οποιονδήποτε χαρακτήρα από ένα σύνολο.
Στη συνέχεια, θα μάθετε τις τελευταίες λεπτομέρειες των **ποσοδεικτών** οι οποίοι ελέγχουν πόσες φορές μπορεί να ταιριάζει ένα μοτίβο.
Στη συνέχεια, πρέπει να καλύψουμε το σημαντικό (αλλά πολύπλοκο) θέμα της **ιεραρχίας τελεστή** και τις παρενθέσεις.
Και θα ολοκληρώσουμε με λίγες λεπτομέρειες σχετικά με την **ομαδοποίηση** των στοιχείων του μοτίβου.

Οι όροι που χρησιμοποιούμε εδώ είναι οι τεχνικές ονομασίες για κάθε στοιχείο.
Δεν θυμίζουν πάντα τον σκοπό τους, αλλά είναι πολύ χρήσιμο να γνωρίζετε τους σωστούς όρους εάν αργότερα θέλετε να τους γκουγκλάρετε για περισσότερες λεπτομέρειες.

### Διαφυγή {#sec-regexp-escaping}

Για να αντιστοιχίσετε ένα σταθερό `.`, χρειάζεστε μια **διαφυγή** η οποία λέει στην τυπική έκφραση να ταιριάζει κυριολεκτικά με μεταχαρακτήρες[^regexps-6].
Όπως οι συμβολοσειρές, έτσι και οι κανονικές εκφράσεις χρησιμοποιούν την ανάστροφη κάθετο για διαφυγή.
Έτσι, για να αντιστοιχίσετε ένα `.`, χρειάζεστε το regexp `\.`. Δυστυχώς αυτό δημιουργεί πρόβλημα.
Χρησιμοποιούμε συμβολοσειρές για να αναπαραστήσουμε κανονικές εκφράσεις και το `\` χρησιμοποιείται ως σύμβολο διαφυγής σε συμβολοσειρές.
Για να δημιουργήσουμε λοιπόν την κανονική έκφραση `\.` χρειαζόμαστε τη συμβολοσειρά `"\\."`, όπως δείχνει το παρακάτω παράδειγμα.

[^regexps-6]: Το πλήρες σύνολο μεταχαρακτήρων είναι `.^$\|*+?{}[]()`

```{r}
# To create the regular expression \., we need to use \\.
dot <- "\\."

# But the expression itself only contains one \
str_view(dot)

# And this tells R to look for an explicit .
str_view(c("abc", "a.c", "bef"), "a\\.c")
```

Σε αυτό το βιβλίο, συνήθως γράφουμε κανονικές εκφράσεις χωρίς εισαγωγικά, όπως η `\.`.
Εάν πρέπει να τονίσουμε τι θα πληκτρολογήσετε στην πραγματικότητα, θα το περιβάλουμε με εισαγωγικά και θα προσθέσουμε επιπλέον διαφυγές, όπως η `"\\."`.

Εάν το `\` χρησιμοποιείται ως χαρακτήρας διαφυγής σε κανονικές εκφράσεις, πώς αντιστοιχίζετε ένα σταθερό `\`; Πρέπει να το διαφύγετε, δημιουργώντας την κανονική έκφραση `\\`.
Για να δημιουργήσετε αυτήν την κανονική έκφραση, πρέπει να χρησιμοποιήσετε μια συμβολοσειρά, η οποία πρέπει επίσης να διαφύγει από το `\`.
Αυτό σημαίνει ότι για να ταιριάξετε ένα κυριολεκτικό `\` πρέπει να γράψετε `"\\\\"` --- χρειάζεστε τέσσερις ανάστροφες κάθετες για να ταιριάξετε μία!

```{r}
x <- "a\\b"
str_view(x)
str_view(x, "\\\\")
```

Εναλλακτικά, μπορεί να είναι πιο εύκολο να χρησιμοποιήσετε τις ακατέργαστες συμβολοσειρές που μάθατε στο @sec-raw-strings).
Αυτό σας επιτρέπει να αποφύγετε ένα επίπεδο διαφυγής:

```{r}
str_view(x, r"{\\}")
```

Εάν προσπαθείτε να αντιστοιχίσετε ένα σταθερό `.`, `$`, `|`, `*`, `+`, `?`, `{`, `}`, `(`, `)`, υπάρχει μια εναλλακτική από τη χρήση μιας διαφυγής ανάστροφης κάθετου: μπορείτε να χρησιμοποιήσετε μια κατηγρία χαρακτήρων: `[.]`, `[$]`, `[|]`, ...
όλα ταιριάζουν με τις σταθερές τιμές.

```{r}
str_view(c("abc", "a.c", "a*c", "a c"), "a[.]c")
str_view(c("abc", "a.c", "a*c", "a c"), ".[*]c")
```

### Αγκυστρώσεις

Από προεπιλογή, οι κανονικές εκφράσεις θα ταιριάζουν με οποιοδήποτε μέρος μιας συμβολοσειράς.
Εάν θέλετε να ταιριάξετε στην αρχή ή στο τέλος, πρέπει να **αγκυστρώσετε** την κανονική έκφραση χρησιμοποιώντας το `^` για να ταιριάζει με την αρχή ή το `$` για να ταιριάζει με το τέλος:

```{r}
str_view(fruit, "^a")
str_view(fruit, "a$")
```

Είναι δελεαστικό να πιστεύουμε ότι το `$` πρέπει να ταιριάζει με την αρχή μιας συμβολοσειράς, γιατί έτσι συμβολίζουμε ποσά σε δολάρια, αλλά δεν είναι αυτός ο τρόπος που λειτουργούν οι κανονικές εκφράσεις.

Για να αναγκάσετε μια κανονική έκφραση να ταιριάζει μόνο με την πλήρη συμβολοσειρά, αγκυστρώστε την και με το `^` και με το `$`:

```{r}
str_view(fruit, "apple")
str_view(fruit, "^apple$")
```

Μπορείτε επίσης να αντιστοιχίσετε το όριο μεταξύ των λέξεων (δηλαδή την αρχή ή το τέλος μιας λέξης) με `\b»`.
Αυτό μπορεί να είναι ιδιαίτερα χρήσιμο όταν χρησιμοποιείτε το εργαλείο εύρεσης και αντικατάστασης του RStudio.
Για παράδειγμα, για να βρείτε όλες τις χρήσεις της `sum()`, μπορείτε να αναζητήσετε `\bsum\b` για να αποφύγετε την αντιστοίχιση με τα `summarize`, `summary`, `rowsum` και ούτω καθεξής:

```{r}
x <- c("summary(x)", "summarize(df)", "rowsum(x)", "sum(x)")
str_view(x, "sum")
str_view(x, "\\bsum\\b")
```

Όταν χρησιμοποιούνται μόνες τους, οι αγκυστρώσεις θα παράγουν μια αντιστοίχιση μηδενικού πλάτους:

```{r}
str_view("abc", c("$", "^", "\\b"))
```

Αυτό σας βοηθά να κατανοήσετε τι συμβαίνει όταν αντικαθιστάτε μια αυτόνομη αγκύστρωση:

```{r}
str_replace_all("abc", c("$", "^", "\\b"), "--")
```

### Καατηγορίες χαρκτήρων

Μια **κατηγορία χαρακτήρων** ή **σύνολο χαρακτήρων**, σας επιτρέπει να αντιστοιχίσετε οποιονδήποτε χαρακτήρα σε ένα σύνολο.
Όπως συζητήσαμε παραπάνω, μπορείτε να δημιουργήσετε τα δικά σας σύνολα με το `[]`, όπου το `[abc]` ταιριάζει με τα "a", "b" ή "c" και το `[^abc]` ταιριάζει με οποιονδήποτε χαρακτήρα εκτός από το "a" , "b" ή "c".
Εκτός από το `^`, υπάρχουν δύο άλλοι χαρακτήρες που έχουν ιδιαίτερη σημασία μέσα στο `[]:`

-   Το `-` ορίζει ένα εύρος, π.χ., το `[a-z]` αντιστοιχεί σε οποιοδήποτε πεζό γράμμα και το `[0-9]` αντιστοιχεί σε οποιονδήποτε αριθμό.
-   Το `\` διαφεύγει ειδικούς χαρακτήρες, επομένως το `[\^\-\]]` ταιριάζει με τα `^`, `-` ή `]`.

Ακολουθούν μερικά παραδείγματα:

```{r}
x <- "abcd ABCD 12345 -!@#%."
str_view(x, "[abc]+")
str_view(x, "[a-z]+")
str_view(x, "[^a-z0-9]+")

# You need an escape to match characters that are otherwise
# special inside of []
str_view("a-b-c", "[a-c]")
str_view("a-b-c", "[a\\-c]")
```

Ορισμένες κατηγορίες χαρακτήρων χρησιμοποιούνται τόσο συχνά που έχουν τη δική τους συντόμευση.
Έχετε ήδη δει το `.`, το οποίο ταιριάζει με οποιονδήποτε χαρακτήρα εκτός από μια νέα γραμμή.
Υπάρχουν άλλα τρία ιδιαίτερα χρήσιμα ζεύγη[^regexps-7]:

[^regexps-7]: Θυμηθείτε, για να δημιουργήσετε μια κανονική έκφραση που περιέχει τα `\d` ή `\s`, θα πρέπει να διαφύγετε το `\` για τη συμβολοσειρά, επομένως θα πληκτρολογήσετε `"\\d"` ή `"\\s"`.

-   Το `\d` αντιστοιχεί σε οποιοδήποτε ψηφίο\
    Το `\D` αντιστοιχεί σε οτιδήποτε δεν είναι ψηφίο.
-   Το `\s` αντιστοιχεί σε οποιοδήποτε κενό διάστημα (π.χ. κενό, tab, νέα γραμμή)\
    Το `\S` αντιστοιχεί σε οτιδήποτε δεν είναι κενό.
-   Το `\w` ταιριάζει με οποιονδήποτε χαρακτήρα "λέξης", π.χ. γράμματα και αριθμούς\
    Το `\W` αντιστοιχεί σε οποιονδήποτε χαρακτήρα "μη λέξης".

Ο παρακάτω κώδικας δείχνει τις έξι συντομεύσεις με μια επιλογή από γράμματα, αριθμούς και χαρακτήρες στίξης.

```{r}
x <- "abcd ABCD 12345 -!@#%."
str_view(x, "\\d+")
str_view(x, "\\D+")
str_view(x, "\\s+")
str_view(x, "\\S+")
str_view(x, "\\w+")
str_view(x, "\\W+")
```

### Ποσοτικοί δείκτες {#sec-quantifiers}

Οι **ποσοτικοί δείκτες** ελέγχουν πόσες φορές ταιριάζει ένα μοτίβο.
Στο @sec-reg-basics μάθατε για το `?` (0 ή 1 αντιστοιχίσεις), το `+` (1 ή περισσότερες αντιστοιχίσεις) και το `*` (0 ή περισσότερες αντιστοιχίσεις).
Για παράδειγμα, το `colou?r` θα ταιριάζει με την αμερικανική ή τη βρετανική ορθογραφία, το `\d+` θα ταιριάζει με ένα ή περισσότερα ψηφία και το `\s?` θα ταιριάζει προαιρετικά με ένα μόνο στοιχείο κενού διαστήματος.
Μπορείτε επίσης να καθορίσετε τον αριθμό των αντιστοιχιών με ακρίβεια με το `{}`":

-   Το `{n}` αντιστοιχεί ακριβώς n φορές.
-   Το `{n,}` αντιστοιχεί τουλάχιστον n φορές.
-   Το `{n,m}` αντιστοιχεί μεταξύ n και m φορών.

### Ιεραρχία τελεστή και παρενθέσεις

Τι ταιριάζει το `ab+`; Ταιριάζει με το "a" ακολουθούμενο από ένα ή περισσότερα "b" ή ταιριάζει με το "ab" που επαναλαμβάνεται πολλές φορές; Τι ταιριάζει το `^a|b$`; Ταιριάζει με την πλήρη συμβολοσειρά a ή την πλήρη συμβολοσειρά b ή ταιριάζει με μια συμβολοσειρά που αρχίζει με a ή μια συμβολοσειρά που τελειώνει με b;

Η απάντηση σε αυτές τις ερωτήσεις καθορίζεται από την ιεραρχία του τελεστή, παρόμοια με τους κανόνες PEMDAS ή BEDMAS που μπορεί να έχετε μάθει στο σχολείο (Αυτό ισχυεί για την Αμερική. Στην Ελλάδα έχουμε απλά την προτεραιότητα των πράξεων).
Γνωρίζετε ότι το «`+ b * c` είναι ισοδύναμο με το `a + (b * c)` όχι με το `(a + b) * c` επειδή το `*` έχει μεγαλύτερη προτεραιότητα και το `+` έχει χαμηλότερη προτεραιότητα: άρα υπολογίζετε το `*` (πολλαπλασιασμό) πριν από το `+` (προόσθεση).

Ομοίως, οι κανονικές εκφράσεις έχουν τους δικούς τους κανόνες προτεραιότητας: οι ποσοτικοί δείκτες έχουν υψηλή προτεραιότητα και η εναλλαγή έχει χαμηλή προτεραιότητα που σημαίνει ότι το `ab+` είναι ισοδύναμο με το `a(b+)` και το `^a|b$` είναι ισοδύναμο με το `(^a )|(b$)`.
Όπως και με την άλγεβρα, μπορείτε να χρησιμοποιήσετε παρενθέσεις για να παρακάμψετε τη συνήθη σειρά.
Αλλά σε αντίθεση με την άλγεβρα, στις κανονικές εκφράεις, είναι απίθανο να θυμάστε τους κανόνες προτεραιότητας, γι' αυτό μη διστάσετε να χρησιμοποιήσετε τις παρενθέσεις ελεύθερα.

### Ομαδοποίηση και αποτύπωση

Εκτός από την υπέρβαση της προτεραιότητας τελεστή, οι παρενθέσεις έχουν ένα άλλο σημαντικό αποτέλεσμα: δημιουργούν **ομάδες καταγραφής** που σας επιτρέπουν να χρησιμοποιείτε δευτερεύοντα στοιχεία της αντιστοίχισης.

Ο πρώτος τρόπος για να χρησιμοποιήσετε μια ομάδα καταγραφής είναι να ανατρέξετε σε αυτήν μέσα σε μια αντιστοίχιση με την **οπίσθια αναφορά**: το `\1` αναφέρεται στην αντιστοίχιση που περιέχεται στην πρώτη παρένθεση, το `\2` στη δεύτερη παρένθεση και ούτω καθεξής.
Για παράδειγμα, το ακόλουθο μοτίβο βρίσκει όλα τα φρούτα που έχουν ένα επαναλαμβανόμενο ζευγάρι γραμμάτων:

```{r}
str_view(fruit, "(..)\\1")
```

Και αυτό βρίσκει όλες τις λέξεις που ξεκινούν και τελειώνουν με το ίδιο ζεύγος γραμμάτων:

```{r}
str_view(words, "^(..).*\\1$")
```

Μπορείτε επίσης να χρησιμοποιήσετε οπίσθιες αναφορά στην `str_replace()`.
Για παράδειγμα, αυτός ο κώδικας αλλάζει τη σειρά της δεύτερης και της τρίτης λέξης στο `sentences`:

```{r}
sentences |> 
  str_replace("(\\w+) (\\w+) (\\w+)", "\\1 \\3 \\2") |> 
  str_view()
```

Εάν θέλετε να εξαγάγετε τις αντιστοιχίσεις για κάθε ομάδα, μπορείτε να χρησιμοποιήσετε την `str_match()`.
Η `str_match()` όμως επιστρέφει έναν πίνακα, επομένως δεν είναι ιδιαίτερα εύκολη στη χρήση της[^regexps-8]:

[^regexps-8]: Κυρίως επειδή δεν συζητάμε ποτέ πίνακες σε αυτό το βιβλίο!

```{r}
sentences |> 
  str_match("the (\\w+) (\\w+)") |> 
  head()
```

Θα μπορούσατε κάνετε μετατροπή σε ένα tibble και να ονομάσετε τις στήλες:

```{r}
sentences |> 
  str_match("the (\\w+) (\\w+)") |> 
  as_tibble(.name_repair = "minimal") |> 
  set_names("match", "word1", "word2")
```

Στην ουσία έχετε δημιουργήσει ξανά τη δική σας έκδοση της `separate_wider_regex()`.
Πράγματι, στο παρασκήνιο, η `separate_wider_regex()` μετατρέπει το διάνυσμα των μοτίβων σας σε μία ενιαία κανονική έκραση που χρησιμοποιεί ομαδοποίηση για την καταγραφή των ονομαζόμενων στοιχείων.

Περιστασιακά, θα θέλετε να χρησιμοποιήσετε παρενθέσεις χωρίς να δημιουργήσετε αντίστοιχες ομάδες.
Μπορείτε να δημιουργήσετε μια ομάδα χωρίς καταγραφή με το `(?:)`.

```{r}
x <- c("a gray cat", "a grey dog")
str_match(x, "gr(e|a)y")
str_match(x, "gr(?:e|a)y")
```

### Ασκήσεις

1.  Πώς θα αντιστοιχιζατε με την σταθερή συμβολοσειρά `"'\`; Πώς την `"$^$"`;

2.  Εξηγήστε γιατί καθένα από αυτά τα μοτίβα δεν ταιριάζει με ένα `\`: `"\"`, `"\\"`, `"\\\"`.

3.  Δεδομένου του κειμένου των κοινών λέξεων στο `stringr::words`, δημιουργήστε κανονικές εκφράσεις που βρίσκουν όλες τις λέξεις που:

    α.
    Ξεκινούν με "y".
    β.
    Δεν ξεκινούν με «y».
    γ.
    Τελειώνουν με "x".
    δ.
    Είναι ακριβώς τρία γράμματα.
    (Μην κλέψετε χρησιμοποιώντας την `str_length()`!)
    ε.
    Έχουν επτά γράμματα ή περισσότερα.
    στ.
    Περιέχουν ένα ζεύγος φωνήεντος-σύμφωνου.
    ζ.
    Περιέχουν τουλάχιστον δύο ζεύγη φωνήεντος-συμφώνου στη σειρά.
    η.
    Αποτελούνται μόνο από επαναλαμβανόμενα ζεύγη φωνήεντος-συμφώνου.

4.  Δημιουργήστε 11 κανονικές εκφράσεις που να ταιριάζουν με τη βρετανική ή την αμερικανική ορθογραφία για καθεμία από τις ακόλουθες λέξεις: airplane/aeroplane, aluminum/aluminium, analog/analogue, ass/arse, center/centre, defense/defence, donut/doughnut, gray/grey, modeling/modelling, skeptic/sceptic, summarize/summarise.
    Δοκιμάστε και κατασκευάστε το συντομότερο δυνατό regex!

5.  Αλλάξτε το πρώτο και το τελευταίο γράμμα στις λέξεις.
    Ποιες από αυτές τις συμβολοσειρές είναι ακόμα στο `words`;

6.  Περιγράψτε με λέξεις τι ταιριάζουν αυτές οι κανονικές εκφράσεις: (διαβάστε προσεκτικά για να δείτε αν κάθε καταχώρηση είναι μια κανονική έκφραση ή μια συμβολοσειρά που ορίζει μια κανονική έκφραση.)

    a.  `^.*$`
    b.  `"\\{.+\\}"`
    c.  `\d{4}-\d{2}-\d{2}`
    d.  `"\\\\{4}"`
    e.  `\..\..\..`
    f.  `(.)\1\1`
    g.  `"(..)\\1"`

7.  Λύστε τα σταυρόλεξα για αρχάριους regexp στη διεύθυνση <https://regexcrossword.com/challenges/beginner>.

## Έλεγχος μοτίβων

Είναι εφικτό να ασκήσετε επιπλέον έλεγχο στις λεπτομέρειες της αντιστοίχισης χρησιμοποιώντας ένα αντικείμενο μοτίβου αντί απλώς μια συμβολοσειρά.
Αυτό σας επιτρέπει να ελέγχετε τους λεγόμενους δείκτες regex και να ταιριάζετε διάφορους τύπους σταθερών συμβολοσειρών, όπως περιγράφεται παρακάτω.

### Δείκτες regex {#sec-flags}

Υπάρχει ένας αριθμός ρυθμίσεων που μπορούν να χρησιμοποιηθούν για τον έλεγχο των λεπτομερειών του regexp.
Αυτές οι ρυθμίσεις ονομάζονται συχνά **δείκτες** σε άλλες γλώσσες προγραμματισμού.
Στην stringr, μπορείτε να τα χρησιμοποιήσετε ενθυλακώνοντας το μοτίβο σε μια κλήση της `regex()`.
Ο πιο χρήσιμος δείκτης είναι πιθανώς το `ignore_case = TRUE` επειδή επιτρέπει στους χαρακτήρες να ταιριάζουν είτε με κεφαλαία είτε με πεζά γράμματα:

```{r}
bananas <- c("banana", "Banana", "BANANA")
str_view(bananas, "banana")
str_view(bananas, regex("banana", ignore_case = TRUE))
```

Εάν δουλεύετε αρκετά με συμβολοσειρές πολλαπλών γραμμών (δηλαδή συμβολοσειρές που περιέχουν `\n`), το `dotall` και το `multiline` μπορούν επίσης να είναι χρήσιμα:

-   Το `dotall = TRUE` επιτρέπει στο `.` να ταιριάζει με τα πάντα, συμπεριλαμβανομένου του `\n`:

    ```{r}
    x <- "Line 1\nLine 2\nLine 3"
    str_view(x, ".Line")
    str_view(x, regex(".Line", dotall = TRUE))
    ```

-   Το `multiline = TRUE` κάνει τα `^` και `$` να ταιριάζουν με την αρχή και το τέλος κάθε γραμμής αντί για την αρχή και το τέλος της πλήρους συμβολοσειράς:

    ```{r}
    x <- "Line 1\nLine 2\nLine 3"
    str_view(x, "^Line")
    str_view(x, regex("^Line", multiline = TRUE))
    ```

Τέλος, εάν γράφετε μια περίπλοκη κανονική έκφραση και ανησυχείτε ότι μπορεί να μην την καταλάβετε στο μέλλον, μπορείτε να δοκιμάσετε το `comments = TRUE`.
Προσαρμόζει τη γλώσσα του μοτίβου ώστε να αγνοεί τα κενά και τις νέες γραμμές, καθώς και τα πάντα μετά το `#`.
Αυτό σας επιτρέπει να χρησιμοποιείτε σχόλια και κενά διαστήματα για να κάνετε πιο κατανοητές σύνθετες κανονικές εκφράσεις[^regexps-9], όπως στο ακόλουθο παράδειγμα:

[^regexps-9]: Το `comments = TRUE` είναι ιδιαίτερα αποτελεσματικό σε συνδυασμό με μια ακατέργαστη συμβολοσειρά, όπως χρησιμοποιούμε εδώ.

```{r}
phone <- regex(
  r"(
    \(?     # optional opening parens
    (\d{3}) # area code
    [)\-]?  # optional closing parens or dash
    \ ?     # optional space
    (\d{3}) # another three numbers
    [\ -]?  # optional space or dash
    (\d{4}) # four more numbers
  )", 
  comments = TRUE
)

str_extract(c("514-791-8141", "(123) 456 7890", "123456"), phone)
```

Εάν χρησιμοποιείτε σχόλια και θέλετε να αντιστοιχίσετε ένα κενό διάστημα, μια νέα γραμμή ή ένα `#`, θα πρέπει να τα διαφύγετε με το `\`.

### Σταθερές αντιστοιχίσεις

Μπορείτε να επιλέξετε να μην χρησιμοποιήσετε κανονικές εκφράσεις με το `fixed()`:

```{r}
str_view(c("", "a", "."), fixed("."))
```

Το `fixed()` σάς δίνει επίσης τη δυνατότητα να αγνοήσετε πεζά και κεφαλαία:

```{r}
str_view("x X", "X")
str_view("x X", fixed("X", ignore_case = TRUE))
```

Εάν εργάζεστε με μη αγγλικό κείμενο, πιθανότατα θα θέλετε το `coll()` αντί για το `fixed()`, καθώς εφαρμόζει τους πλήρεις κανόνες για τη χρήση κεφαλαίων όπως χρησιμοποιείται από τις `τοπικές ρυθμίσεις γλώσσας` που καθορίζετε.
Δείτε το @sec-other-languages για περισσότερες λεπτομέρειες σχετικά με τις τοπικές ρυθμίσεις γλώσσας.

```{r}
str_view("i İ ı I", fixed("İ", ignore_case = TRUE))
str_view("i İ ı I", coll("İ", ignore_case = TRUE, locale = "tr"))
```

## Εξάσκηση

Για να εφαρμόσουμε αυτές τις ιδέες θα λύσουμε στη συνέχεια μερικά ημι-αυθεντικά προβλήματα.
Θα συζητήσουμε τρεις γενικές τεχνικές:

1.  Έλεγχος της εργασία σας δημιουργώντας απλούς θετικούς και αρνητικούς ελέγχους
2.  Συνδυασμός κανονικών εφράσεων με άλγεβρα Boole
3.  Δημιουργία σύνθετων μοτίβων χρησιμοποιώντας με τον χειρισμό συμβολοσειρών

### Ελέγξτε την εργασία σας

Αρχικά, ας βρούμε όλες τις προτάσεις που ξεκινούν με "The".
Η χρήση του άγκυστρου `^` από μόνο του δεν αρκεί:

```{r}
str_view(sentences, "^The")
```

Επειδή αυτό το μοτίβο ταιριάζει επίσης με προτάσεις που ξεκινούν με λέξεις όπως `They` ή `These`.
Πρέπει να βεβαιωθούμε ότι το "e" είναι το τελευταίο γράμμα της λέξης, το οποίο μπορούμε να κάνουμε προσθέτοντας ένα όριο λέξης:

```{r}
str_view(sentences, "^The\\b")
```

Τι γίνεται με την εύρεση όλων των προτάσεων που ξεκινούν με μια αντωνυμία;

```{r}
str_view(sentences, "^She|He|It|They\\b")
```

Μια γρήγορη επιθεώρηση των αποτελεσμάτων δείχνει ότι παίρνουμε κάποιες λάθος αντιστοιχίσεις.
Αυτό συμβαίνει επειδή έχουμε ξεχάσει να χρησιμοποιήσουμε παρενθέσεις:

```{r}
str_view(sentences, "^(She|He|It|They)\\b")
```

Ίσως αναρωτιέστε πώς θα μπορούσατε να εντοπίσετε ένα τέτοιο λάθος αν δεν συνέβαινε στις πρώτες αντιστοιχίσεις.
Μια καλή τεχνική είναι να δημιουργήσετε μερικές θετικές και αρνητικές αντιστοιχίσεις και να τις χρησιμοποιήσετε για να ελέγξετε ότι το μοτίβο σας λειτουργεί όπως αναμένεται:

```{r}
pos <- c("He is a boy", "She had a good time")
neg <- c("Shells come from the sea", "Hadley said 'It's a great day'")

pattern <- "^(She|He|It|They)\\b"
str_detect(pos, pattern)
str_detect(neg, pattern)
```

Συνήθως είναι πολύ πιο εύκολο να βρείτε καλά θετικά παραδείγματα παρά αρνητικά, γιατί χρειάζεται χρόνος για να είστε αρκετά καλοί με τις κανονικές εκφράσεις έτσι ώστε να προβλέψετε πού βρίσκονται οι αδυναμίες σας.
Ωστόσο, εξακολουθούν να είναι χρήσιμα: καθώς εργάζεστε πάνω στο πρόβλημα, μπορείτε σιγά-σιγά να συγκεντρώσετε μια συλλογή από τα λάθη σας, διασφαλίζοντας ότι δεν θα κάνετε ποτέ το ίδιο λάθος δύο φορές.

### Λειτουργίες Boolean {#sec-boolean-operations}

Φανταστείτε ότι θέλουμε να βρούμε λέξεις που περιέχουν μόνο σύμφωνα.
Μια τεχνική είναι να δημιουργήσετε μια κατηγορία χαρακτήρων που περιέχει όλα τα γράμματα εκτός από τα φωνήεντα (`[^aeiou]`), στη συνέχεια να επιτρέψετε να ταιριάζει με οποιονδήποτε αριθμό γραμμάτων (`[^aeiou]+`) και στη συνέχεια να την αναγκάσετε να ταιριάζει με ολόκληρη τη συμβολοσειρά αγκυστρώνοντας στην αρχή και στο τέλος (`^[^aeiou]+$`):

```{r}
str_view(words, "^[^aeiou]+$")
```

Μπορείτε όμως να κάνετε αυτό το πρόβλημα λίγο πιο εύκολο αναστρέφοντάς το.
Αντί να αναζητούμε λέξεις που περιέχουν μόνο σύμφωνα, θα μπορούσαμε να αναζητήσουμε λέξεις που δεν περιέχουν φωνήεντα:

```{r}
str_view(words[!str_detect(words, "[aeiou]")])
```

Αυτή είναι μια χρήσιμη τεχνική για κάθε φορά που έχετε να κάνετε με λογικούς συνδυασμούς, ιδιαίτερα αυτούς που περιλαμβάνουν "και" ή "όχι".
Για παράδειγμα, φανταστείτε αν θέλετε να βρείτε όλες τις λέξεις που περιέχουν "a" και "b".
Δεν υπάρχει ενσωματωμένος τελεστής "και" στις κανονικές εκφράσεις, επομένως πρέπει να το αντιμετωπίσουμε αναζητώντας όλες τις λέξεις που περιέχουν ένα "a" ακολουθούμενο από ένα "b" ή ένα "b" ακολουθούμενο από ένα "a":

```{r}
str_view(words, "a.*b|b.*a")
```

Είναι πιο απλό να συνδυάσετε τα αποτελέσματα δύο κλήσεων στην `str_detect()`:

```{r}
words[str_detect(words, "a") & str_detect(words, "b")]
```

Τι θα γινόταν αν θέλαμε να δούμε αν υπάρχει μια λέξη που περιέχει όλα τα φωνήεντα; Αν το κάναμε με μοτίβα θα έπρεπε να δημιουργήσουμε 5!
(120) διαφορετικά μοτίβα:

```{r}
#| results: false
words[str_detect(words, "a.*e.*i.*o.*u")]
# ...
words[str_detect(words, "u.*o.*i.*e.*a")]
```

Είναι πολύ πιο απλό να συνδυάσετε πέντε κλήσεις στην `str_detect()`:

```{r}
words[
  str_detect(words, "a") &
  str_detect(words, "e") &
  str_detect(words, "i") &
  str_detect(words, "o") &
  str_detect(words, "u")
]
```

Γενικά, αν κολλήσετε προσπαθώντας να δημιουργήσετε ένα ενιαίο regexp που λύνει το πρόβλημά σας, κάντε ένα βήμα πίσω και σκεφτείτε αν θα μπορούσατε να σπάσετε το πρόβλημα σε μικρότερα κομμάτια, λύνοντας κάθε πτυχή πριν προχωρήσετε στην επόμενη.

### Δημιουργία μοτίβου με κώδικα

Τι θα γινόταν αν θέλαμε να βρούμε όλες τις προτάσεις (`sentences`) που αναφέρουν ένα χρώμα; Η βασική ιδέα είναι απλή: απλώς συνδυάζουμε την εναλλαγή με τα όρια λέξεων.

```{r}
str_view(sentences, "\\b(red|green|blue)\\b")
```

Αλλά καθώς ο αριθμός των χρωμάτων αυξάνεται, το να κατασκευάσετε αυτό το σχέδιο με το χέρι θα γινόταν γρήγορα κουραστικό.
Δεν θα ήταν ωραίο αν μπορούσαμε να αποθηκεύσουμε τα χρώματα σε ένα διάνυσμα;

```{r}
rgb <- c("red", "green", "blue")
```

Λοιπόν, μπορούμε!
Απλώς θα χρειαστεί να δημιουργήσουμε το μοτίβο από το διάνυσμα χρησιμοποιώντας την `str_c()` και την `str_flatten()`:

```{r}
str_c("\\b(", str_flatten(rgb, "|"), ")\\b")
```

Θα μπορούσαμε να κάνουμε αυτό το μοτίβο πιο ολοκληρωμένο αν είχαμε μια καλή λίστα χρωμάτων.
Ένα μέρος από το οποίο θα μπορούσαμε να ξεκινήσουμε είναι η λίστα των ενσωματωμένων χρωμάτων που μπορεί να χρησιμοποιήσει η R για γραφικά:

```{r}
str_view(colors())
```

Ας εξαλείψουμε όμως πρώτα τις αριθμημένες παραλλαγές:

```{r}
cols <- colors()
cols <- cols[!str_detect(cols, "\\d")]
str_view(cols)
```

Τότε μπορούμε να το μετατρέψουμε σε ένα μεγάλο μοτίβο.
Δεν θα δείξουμε το μοτίβο εδώ επειδή είναι μεγάλο, αλλά μπορείτε να το δείτε να λειτουργεί:

```{r}
pattern <- str_c("\\b(", str_flatten(cols, "|"), ")\\b")
str_view(sentences, pattern)
```

Σε αυτό το παράδειγμα, το `cols` περιέχει μόνο αριθμούς και γράμματα, επομένως δεν χρειάζεται να ανησυχείτε για μεταχαρακτήρες.
Αλλά γενικά, κάθε φορά που δημιουργείτε μοτίβα από υπάρχουσες συμβολοσειρές, είναι καλό να τα περνάτε μέσα από την `str_escape()` για να διασφαλίσετε ότι ταιριάζουν κυριολεκτικά.

### Ασκήσεις

1.  Για καθεμία από τις παρακάτω προκλήσεις, δοκιμάστε να την λύσετε χρησιμοποιώντας τόσο μια απλή κανονική έκφραση όσο και έναν συνδυασμό πολλαπλών κλήσεων της `str_detect()`.

    α.
    Βρείτε όλες τις λέξεις (`words`) που ξεκινούν ή τελειώνουν με `x`.
    β.
    Βρείτε όλες τις λέξεις που ξεκινούν από φωνήεν και τελειώνουν σε σύμφωνο.
    γ.
    Υπάρχουν λέξεις που περιέχουν τουλάχιστον ένα από κάθε διαφορετικό φωνήεν;

2.  Κατασκευάστε μοτίβα για να βρείτε στοιχεία υπέρ και κατά του κανόνα "i πριν από e εκτός από το c"

3.  H `colors()` περιέχει έναν αριθμό τροποποιητών όπως "lightgray" και "darkblue".
    Πώς θα μπορούσατε να αναγνωρίσετε αυτόματα αυτούς τους τροποποιητές; (Σκεφτείτε πώς μπορείτε να εντοπίσετε και, στη συνέχεια, αφαιρέστε τα χρώματα που έχουν τροποποιηθεί).

4.  Δημιουργήστε μια κανονική έκφραση που βρίσκει οποιοδήποτε βασικό σύνολο δεδομένων της R.
    Μπορείτε να λάβετε μια λίστα με αυτά τα σύνολα δεδομένων μέσω μιας ειδικής χρήσης της συνάρτησης `data()`: `data(package = "datasets")$results[, "Item"]`.
    Σημειώστε ότι ορισμένα παλιά σύνολα δεδομένων είναι μεμονωμένα διανύσματα.
    Αυτά περιέχουν το όνομα του ομαδοποιημένου "πλαισίου δεδομένων" σε παρένθεση, επομένως θα πρέπει να τα αφαιρέσετε.

## Κανονικές εκφράσεις σε άλλα μέρη

Ακριβώς όπως και στις συναρτήσεις της stringr και της tidyr, υπάρχουν πολλά άλλα μέρη στην R όπου μπορείτε να χρησιμοποιήσετε κανονικές εκφράσεις.
Οι ακόλουθες ενότητες περιγράφουν μερικές άλλες χρήσιμες λειτουργίες στο ευρύτερο tidyverse και στο βασικό πακέτο λειτουργιών της R.

### tidyverse

Υπάρχουν τρία άλλα ιδιαίτερα χρήσιμα μέρη όπου μπορεί να θέλετε να χρησιμοποιήσετε κανονικές εκφράσεις

-   Η `match(pattern)` θα επιλέξει όλες τις μεταβλητές των οποίων το όνομα ταιριάζει με το παρεχόμενο μοτίβο.
    Είναι μια συνάρτηση που χρησιμοποιεί κανονόνες "tidyselect" και μπορείτε να χρησιμοποιήσετε οπουδήποτε σε οποιαδήποτε συνάρτηση της tidyverse που επιλέγει μεταβλητές (π.χ. `select()`, `rename_with()` και `across()`).

-   Το όρισμα `names_pattern` της `pivot_longer()` παίρνει ένα διάνυσμα κανονικών εκφράσεων, ακριβώς όπως η `separate_wider_regex()`.
    Είναι χρήσιμο κατά την εξαγωγή δεδομένων από ονόματα μεταβλητών με σύνθετη δομή.

-   Το όρισμα `delim` της `separate_longer_delim()` και της `separate_wider_delim()` συνήθως ταιριάζει με μια σταθερή συμβολοσειρά, αλλά μπορείτε να χρησιμοποιήσετε την `regex()` για να την κάνετε να ταιριάζει με ένα μοτίβο.
    Αυτό είναι χρήσιμο, για παράδειγμα, εάν θέλετε να ταιριάξετε ένα κόμμα που προαιρετικά ακολουθείται από ένα κενό, π.χ.
    `regex(", ?")`.

### Βασικό πακέτο λειτουργιών της R

Η `apropos(pattern)` αναζητά όλα τα διαθέσιμα αντικείμενα από το περιβάλλον της R που ταιριάζουν με το συγκεκριμένο μοτίβο.
Αυτό είναι χρήσιμο εάν δεν μπορείτε να θυμηθείτε το όνομα μιας συνάρτησης:

```{r}
apropos("replace")
```

H `list.files(path, pattern)` παραθέτει όλα τα αρχεία στο μονοπάτι `path` που ταιριάζουν με μια κανονική έκφραση `pattern`.
Για παράδειγμα, μπορείτε να βρείτε όλα τα αρχεία R Markdown στον τρέχοντα κατάλογο με:

```{r}
head(list.files(pattern = "\\.Rmd$"))
```

Αξίζει να σημειωθεί ότι η γλώσσα μοτίβων που χρησιμοποιείται από τη βασική R είναι ελαφρώς διαφορετική από αυτή που χρησιμοποιείται από την stringr.
Αυτό συμβαίνει επειδή η stringr είναι χτισμένο πάνω από το [πακέτο stringi](https://stringi.gagolewski.com), το οποίο με τη σειρά του είναι χτισμένο πάνω από το [ICU engine](https://unicode-org.github.io%20/icu/userguide/strings/regexp.html), ενώ οι βασικές συναρτήσεις της R χρησιμοποιούν είτε το [TRE engine](https://github.com/laurikari/tre) είτε το [PCRE engine](https://www.pcre%20.org), ανάλογα με το αν έχετε ορίσει ή όχι `perl = TRUE`.
Ευτυχώς, τα βασικά στοιχεία των κανονικών εκφράσεων είναι τόσο καλά εδραιωμένα που θα συναντήσετε λίγες παραλλαγές όταν εργάζεστε με τα μοτίβα που θα μάθετε σε αυτό το βιβλίο.
Χρειάζεται μόνο να γνωρίζετε τη διαφορά όταν αρχίσετε να βασίζεστε σε προηγμένες δυνατότητες όπως σύνθετες περιοχές χαρακτήρων Unicode ή ειδικές δυνατότητες που χρησιμοποιούν τη σύνταξη τύπου `(?…)`.

## Σύνοψη

Με κάθε χαρακτήρα στίξης να είναι υπερφορτωμένος με νόημα, οι κανονικές εκφράσεις είναι μια από τις πιο συμπαγείς γλώσσες.
Σίγουρα προκαλούν σύγχυση στην αρχή, αλλά καθώς εκπαιδεύετε τα μάτια σας να τα διαβάζουν και τον εγκέφαλό σας να τα κατανοεί, ξεκλειδώνετε μια ισχυρή δεξιότητα που μπορείτε να χρησιμοποιήσετε σστηντο R και σε πολλά άλλα μέρη.

Σε αυτό το κεφάλαιο, ξεκινήσατε το ταξίδι σας για να κατακτήσετε τις κανονικές εκφράσεις μαθαίνοντας τις πιο χρήσιμες συναρτήσεις της stringr και τα πιο σημαντικά στοιχεία της γλώσσας της κανονικής έκφρασης.
Υπάρχουν πολλές πηγές για να μάθετε περισσότερα.

Ένα καλό μέρος για να ξεκινήσετε είναι το `vignette("regular-expressions, package = "stringr")`: τεκμηριώνει το πλήρες σύνολο της σύνταξης που υποστηρίζεται από την stringr.
Μια άλλη χρήσιμη αναφορά είναι το [https://www.regular-expressions.info/](https://www.regular-expressions.info/tutorial.html).
Δεν είναι συγκεκριμένο για την R, αλλά μπορείτε να το χρησιμοποιήσετε για να μάθετε για τις πιο προηγμένες δυνατότητες των regexes και πώς λειτουργούν στο παρασκήνιο.

Είναι επίσης καλό να γνωρίζετε ότι η stringr υλοποιείται πάνω από το πακέτο stringi από τον Marek Gagolewski.
Αν δυσκολεύεστε να βρείτε μια συνάρτηση που κάνει ό,τι χρειάζεστε στην stringr, μην φοβάστε να ψάξετε στην stringi.
Θα βρείτε την stringi πολύ εύκολη να μάθετε επειδή ακολουθεί πολλές από τις ίδιες συμβάσεις με την stringr.

Στο επόμενο κεφάλαιο, θα μιλήσουμε για μια δομή δεδομένων που σχετίζεται στενά με συμβολοσειρές: τους παράγοντες.
Οι παράγοντες χρησιμοποιούνται για την αναπαράσταση κατηγορικών δεδομένων στην R, δηλαδή δεδομένα με ένα σταθερό και γνωστό σύνολο πιθανών τιμών που προσδιορίζονται από ένα διάνυσμα συμβολοσειρών.
