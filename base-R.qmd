# Ένας οδηγός για τo βασικό σύνολο λειτουργειών της R

```{r}
#| echo: false

source("_common.R")
```

## Εισαγωγή

Ως επίλογο της ενότητας του προγραμματισμού, θα σας δώσουμε μια ιδέα για τις πιο σημαντικές βασικές συναρτήσεις της R που διαφορετικά δεν θα συζητούσαμε σε αυτό το βιβλίο.
Τα εργαλεία αυτά είναι αρκετά χρήσιμα όσο προγραματίζετε περισσότερο και θα σας βοηθήσουν στο να διαβάζετε κώδικα που κυκλοφορεί εκεί έξω.

Σε αυτό το σημείο είναι καλό να σας επινθυμήσουμε οτι το tidyverse δεν ευπάρχει μόνο για να αντιμετωπίζει προβλήματα επιστήμης δεδομένων.
Δείχνουμε το tidyverse σε αυτό το βιβλίο επειδή τα αντίστοιχα πακέτα του μοιράζονται μια κοινλη φιλοσοφία, αυξάνοντας τη συνοχή μεταξύ των λειτουργιών και καθιστώντας κάθε νέα λειτουργία ή πακέτο λίγο πιο εύκολα στην εκμάθηση και χρήση.
Δεν είναι δυνατό να χρησιμοποιήσετε το tidyverse χωρίς τη χρήση των βασικών λειτουργιών της R.
Σας έχουμε ήδη μάθει **πολλές** βασικές συναρτήσεις R: από την `library()` για την φόρτωση πακέτων, τη `sum()` και τη `mean()` για αριθμητικές περιλήψεις, για τους τύπους δεδομένων με παράγοντες (factors), ημερομηνίες και POSIXct και φυσικά όλους τους βασικούς τελεστές όπως `+`, `-`, `/`, `*`, `|`, `&`, και `!`.
Αυτό στο οποίο δεν έχουμε επικεντρωθεί μέχρι στιγμής είναι οι βασικές ροές εργασίας της R, επομένως θα επισημάνουμε μερικές από αυτές σε αυτό το κεφάλαιο.

Αφού διαβάσετε αυτό το βιβλίο, θα μάθετε και άλλες προσεγγίσεις πάνω στα ίδια προβλήματα χρησιμοποιώντας το βασικό σύνολο λειτουργειών της R, τη data.table και άλλα πακέτα.
Θα συναντήσετε αυτές τις άλλες προσεγγίσεις χωρίς αμφιβολία όταν αρχίσετε να διαβάζετε κώδικα R που γράφτηκε από άλλους, ιδιαίτερα εάν χρησιμοποιείτε το StackOverflow.
Είναι 100% εντάξει να γράφετε κώδικα που χρησιμοποιεί έναν συνδυασμό προσεγγίσεων και μην αφήνετε κανέναν να σας πει το αντίθετο!

Σε αυτό το κεφάλαιο, θα εστιάσουμε σε τέσσερις μεγάλες θεματολογίες: δημιουργία υποσυνόλων με `[`, δημιουργία υποσυνόλων με τα `[[` και `$`, την οικογένεια συναρτήσεων apply και βρόχους `for`.
Τέλος, θα συζητήσουμε εν συντομία δύο βασικές συναρτήσεις διαγραμμάττων.

### Προαπαιτούμενα

Το πακέτο αυτό εστιάζει στις βασικές λειτουργίες της R, επομένως δεν έχει πραγματικά προαπαιτούμενα, αλλά θα φορτώσουμε το tidyverse για να εξηγήσουμε μερικές διαφορές.

```{r}
#| label: setup
#| message: false

library(tidyverse)
```

## Επιλογή πολλαπλών στοιχείων με `[` {#sec-subset-many}

Το `[` χρησιμοποιείται για την εξαγωγή υποσυνόλων από διανύσματα και πλαίσια δεδομένων και καλείται ως `x[i]` ή `x[i, j]`.
Σε αυτήν την ενότητα, θα σας παρουσιάσουμε τις ικανότητες του `[`, δείχνοντάς σας πρώτα πώς μπορείτε να το χρησιμοποιήσετε με διανύσματα και στη συνέχεια πώς οι ίδιες αρχές επεκτείνονται με απλό τρόπο στις δύο δισδιάστατες όπως στα πλαίσια δεδομένων.
Στη συνέχεια, θα σας βοηθήσουμε να το εμπεδώσετε δείχνοντας πώς διάφορες συναρτήσεις της dplyr είναι ειδικές περιπτώσεις του `[`.

### Υποσύνολα απο διανύσματα

Υπάρχουν πέντε κύριοι τύποι κατηγοριών με τις οποίες μπορείτε να εξάγετε ένα υποσύνολο απο ένα διάνυσμα, δηλαδή που μπορεί να είναι το `i` στο `x[i]`:

1.  **Διάνυσμα με θετικούς ακέραιους αριθμούς**.
    Η δημιουργία υποσυνόλων με θετικούς ακέραιους αριθμούς επιστρέφει τα στοιχεία των αντίστοιχων θέσεων:

    ```{r}
    x <- c("one", "two", "three", "four", "five")
    x[c(3, 2, 5)]
    ```

    Επαναλλαμβάνοντας μια θέση μπορείτε να δημιουργήσετε μια μεγαλύτερη έξοδο, κάνοντας τον όρο "υποσύνολο" ελαφρώς λανθασμένο.

    ```{r}
    x[c(1, 1, 5, 5, 5, 2)]
    ```

2.  **Διάνυσμα με αρνητικούς ακέραιους αριθμούς**.
    Αρνητικές τιμές αφαιρούν τα στοιχεία στις αντίστοιχες θέσεις:

    ```{r}
    x[c(-1, -3, -5)]
    ```

3.  **Λογικό διάνυσμα**.
    Δημιουργώντας ένα υποσύνολο χρησιμοποιώντας λογικές τιμές επιστρέφει όλες τις τιμές όπου είναι `TRUE`.
    Συχνά, αυτό είναι πιο χρήσιμο σε συνδυασμό με συναρτήσεις σύγκρισης.

    ```{r}
    x <- c(10, 3, NA, 5, 8, 1, NA)

    # All non-missing values of x
    x[!is.na(x)]

    # All even (or missing!) values of x
    x[x %% 2 == 0]
    ```

    Σε αντίθεση με την `filter()`, οι θέσεις που περιέχουν `NA` θα συμπεριληφθούν στην έξοδο ως `NA`.

4.  **Διάνυσμα χαρακτήρα**.
    Εάν έχετε ένα διάνυσμα με ονόματα για κάθε στοιχείο του, μπορείτε να δημιουργήσετε ένα υποσύνολο με ένα διάνυσμα χαρακτήρα:

    ```{r}
    x <- c(abc = 1, def = 2, xyz = 5)
    x[c("xyz", "def")]
    ```

    Όπως και με τα υποσύνολα απο θετικούς ακέραιους αριθμούς, μπορείτε να χρησιμοποιήσετε ένα διάνυσμα χαρακτήρων για να επαναλλάβετε μεμονωμένες εγγραφές.

5.  **Κενό** Ο τελευταίος τύπος δημιουργίας υποσύνολου είναι το κενό, `x[]`, το οποίο επιστρέφει ολόκληρο το `x`.
    Δεν είναι χρήσιμο όμως για υποσύνολα διανυσμάτων, αλλά όπως θα δούμε σύντομα, είναι χρήσιμο για υποσύνολα δισδιάστατων δομών όπως τα tibbles.

### Υποσύνολα πλαισίων δεδομένων

Υπάρχουν αρκετοί διαφορετικοί τρόποι[^base-r-1] με τους οποίους μπορείτε να χρησιμοποιήσετε το `[` με ένα πλαίσιο δεδομένων, αλλά ο πιο σημαντικός είναι να επιλέξετε γραμμές και στήλες ξεχωριστά χρησιμοποιόντας το `df[γραμμές, στήλες]`. Εδώ οι `γραμμές` και οι `στήλες` είναι διανύσματα όπως περιγράφονται παραπάνω.
Για παράδειγμα, τα `df[γραμμές, ]` και `df[, στήλες]` επιλέγουν μόνο γραμμές ή μόνο στήλες, χρησιμοποιώντας το κενό υποσύνολο για να διατηρήσουν την άλλη διάσταση.

[^base-r-1]: Διαβάστε το <https://adv-r.hadley.nz/subsetting.html#subset-multiple> για να δείτε πώς μπορείτε επίσης να ορίσετε ένα υποσύνολο σε ένα πλαίσιο δεδομένων σαν να είναι αντικείμενο μίας διάστασης και πώς μπορείτε να δημιουργήσετε ένα υποσύνολο με ένα μητρώο.

Μερικά παραδείγματα:

```{r}
df <- tibble(
  x = 1:3, 
  y = c("a", "e", "f"), 
  z = runif(3)
)

# Select first row and second column
df[1, 2]

# Select all rows and columns x and y
df[, c("x" , "y")]

# Select rows where `x` is greater than 1 and all columns
df[df$x > 1, ]
```

Θα επανέλθουμε σύντομα στο `$`, θα πρέπει όμως να μπορείτε να μαντέψετε ήδη τι κάνει το `df$x` από τα συμφραζόμενα: εξάγει τη μεταβλητή `x` από το `df`.
Εδώ, πρέπει να το χρησιμοποιήσουμε επειδή το `[` δεν χρησιμοποιεί αξιολόγηση tidy, επομένως πρέπει να είστε ξεκάθαροι σχετικά με την πηγή της μεταβλητής `x`.

Υπάρχει μια σημαντική διαφορά μεταξύ των tibbles και των πλαισίων δεδομένων όσον αφορά το `[`.
Σε αυτό το βιβλίο, χρησιμοποιήσαμε κυρίως τα tibbles, τα οποία *είναι* πλαίσια δεδομένων, αλλά τροποποιούν ορισμένες συμπεριφορές για να κάνουν τη ζωή σας λίγο πιο εύκολη.
Στα περισσότερα σημεία, μπορείτε να χρησιμοποιήσετε το "tibble" και το "data frame" (πλάισιο δεδομένων) εναλλάξιμα, οπότε όταν θέλουμε να δώσουμε έμφαση στο ενσωματωμένο πλαίσιο δεδομένων της R, θα γράψουμε `data.frame`.
Εάν το `df` είναι ένα `data.frame`, τότε το `df[, cols]` θα επιστρέψει ένα διάνυσμα εάν το `col` επιλέγει μία στήλη, και ένα πλαίσιο δεδομένων εάν επιλέγει περισσότερες από μία στήλες.
Εάν το `df` είναι tibble, τότε η χρήση του `[` θα επιστρέφει πάντα ένα tibble.

```{r}
df1 <- data.frame(x = 1:3)
df1[, "x"]

df2 <- tibble(x = 1:3)
df2[, "x"]
```

Ένας τρόπος για να αποφύγετε αυτή την ασάφεια με τα `data.frame` είναι να θέτετε το όρισμα `drop = FALSE`:

```{r}
df1[, "x" , drop = FALSE]
```

### Ισοδύναμα της dplyr

Αρκετές συναρτήσεις της dplyr είναι ειδικές περιπτώσεις του `[`:

-   Η `filter()` ισοδυναμεί με το να δημιουργείτε υποσύνολα γραμμών χρησιμοποιώντας ένα λογικό διάνυσμα ενώ ταυχρόχρονα εξαιρείτε τις κενές τιμές:

    ```{r}
    #| results: false

    df <- tibble(
      x = c(2, 3, 1, 1, NA), 
      y = letters[1:5], 
      z = runif(5)
    )
    df |> filter(x > 1)

    # same as
    df[!is.na(df$x) & df$x > 1, ]
    ```

    Μία άλλη γνωστή τεχνική είναι η χρήση της `which()` εξαιτίας της ιδιότητάς της να εξαιρεί κενές τιμές: `df[which(df$x > 1), ]`.

-   Η `arrange()` ισοδυναμεί με την αναδιωργάνωση των γραμμών χρησιμοποιώντας ένα διάνυσμα ακέραιου αριθμού.
    Συνήθως γίνεται με την `order()`:

    ```{r}
    #| results: false

    df |> arrange(x, y)

    # same as
    df[order(df$x, df$y), ]
    ```

    Μπορείτε να χρησιμοποιήσετε το `order(decreasing = TRUE)` για να ταξινομήσετε όλες τις στήλες με φθίνουσα σειρά ή το "-rank(col)" για να ταξινομήσετε τις στήλες με φθίνουσα σειρά μία μία.

-   Τόσο η `select()` όσο και η `relocate()` είναι παρόμοιες με το να δημιουργείτε υποσύνολα στηλών χρησιμοποιώντας ένα διάνυσμα χαρακτήρων:

    ```{r}
    #| results: false

    df |> select(x, z)

    # same as
    df[, c("x", "z")]
    ```

Το βασικό σύνολο της R προσφέρει μια συνάρτηση η οποία συνδυάζει τα χαρακτηριστικά της `filter()` και της `select()`[^base-r-2] και ονομάζεται `subset()`:

[^base-r-2]: Δεν χειρίζεται γκρουπαρισμένα πλαίσια δεδομένων με διαφορετικό τρόπο και δεν υποστηρίζει βοηθητικές συναρτήσεις επιλογής όπως η `starts_with()`.

```{r}
df |> 
  filter(x > 1) |> 
  select(y, z)
```

```{r}
#| results: false

# same as
df |> subset(x > 1, c(y, z))
```

Η συνάρτηση αυτή ήταν η έμπνευση για ένα αρκετά μεγάλο μέρος του συντακτικού της dplyr.

### Ασκήσεις

1.  Δημιουργήστε συναρτήσεις οι οποίες παίρνουν ως είσοδο ένα διάνυσμα και επιστρέφουν:

    ```         
    α.  Τα στοιχεία που βρίσκονται σε ζυγές θέσεις.
    β.  Όλα τα στοιχεία εκτός του τελευταίου.
    γ.  Μόνο ζυγές τιμές (και όχι κενές τιμές).
    ```

2.  Γιατί το `x[-which(x > 0)]` δεν είναι το ίδιο με το `x[x <= 0]`; Διαβάστε τις οδηγίες για την `which()` και εφαρμόστε μερικά πειράματα για να το βρείτε.

## Επιλέγοντας μόνο ένα στοιχείο με το `$` και το `[[` {#sec-subset-one}

Το `[`, το οποίο επιλέγει πολλαπλά στοιχεία, συνδυάζεται με τα `[[` και `$`, τα οποία εξάγουν ένα μεμονωμένο στοιχείο.
Σε αυτήν την ενότητα, θα σας δείξουμε πώς να χρησιμοποιείτε τα `[[` και `$` για να εξάγετε στήλες από τα πλαίσια δεδομένων, θα συζητήσουμε μερικές ακόμη διαφορές μεταξύ των `data.frame` και των tibbles και θα τονίσουμε μερικές σημαντικές διαφορές μεταξύ του `[` και του `[[` όταν χρησιμοποιούνται με λίστες.

### Πλαίσια δεδομένων

Τα `[[` και `$` μπορούν να χρησιμοποιηθούν για την εξαγωγή στηλών από ένα πλαίσιο δεδομένων.
Το `[[` μπορεί να έχει πρόσβαση σε δομές δεδομένων με βάση τη θέση ή το όνομα, και το `$` είναι ειδικά για πρόσβαση με βάση το όνομα:

```{r}
tb <- tibble(
  x = 1:4,
  y = c(10, 4, 1, 21)
)

# by position
tb[[1]]

# by name
tb[["x"]]
tb$x
```

Μπορούν να χρησιμοποιηθούν και για τη δημιουργία νέων στηλών.
Το αντίστοιχο της `mutate()` στο βασικό σύνολο της R είναι:

```{r}
tb$z <- tb$x + tb$y
tb
```

Υπάρχουν πολλές άλλες προσεγγίσεις του βασικού συνόλου της R για τη δημιουργία νέων στηλών, συμπεριλαμβανομένων των `transform()`, `with()` και `within()`.
Ο Hadley συγκέντρωσε μερικά παραδείγματα στη διεύθυνση <https://gist.github.com/hadley/1986a273e384fb2d4d752c18ed71bedf>.

Η απευθείας χρήση του `$` είναι βολική για την κατασκευή γρήγορων περιλήψεων.
Για παράδειγμα, εάν θέλετε απλώς να βρείτε το μέγεθος του μεγαλύτερου διαμαντιού ή τις πιθανές τιμές της `cut`, δεν χρειάζεται να χρησιμοποιήσετε την `summarize()`:

```{r}
max(diamonds$carat)

levels(diamonds$cut)
```

Η dplyr παρέχει επίσης ένα ισοδύναμο με το `[[`/`$` που δεν αναφέραμε στο @sec-data-transform: την `pull()`.
Η `pull()` παίρνει είτε ένα όνομα μεταβλητής είτε μία θέση μεταβλητής και επιστρέφει ακριβώς αυτήν τη στήλη.
Αυτό σημαίνει ότι θα μπορούσαμε να ξαναγράψουμε τον παραπάνω κώδικα για να χρησιμοποιήσουμε το pipe:

```{r}
diamonds |> pull(carat) |> max()

diamonds |> pull(cut) |> levels()
```

### Tibbles

Υπάρχουν μερικές σημαντικές διαφορές μεταξύ των tibbles και των βασικών `data.frame` όσον αφορά το `$`.
Στα πλαίσια δεδομένων αρκεί να ταιριάξει το πρόθεμα οποιουδήποτε ονόματος μεταβλητής (η λεγόμενη **μερική αντιστοίχιση**) και δεν παραπονιέται εάν η στήλη δεν υπάπρχει:

```{r}
df <- data.frame(x1 = 1)
df$x
df$z
```

Τα Tibble είναι πιο αυστηρά: ταιριάζουν μόνο ακριβώς με τα ονόματα των μεταβλητών και θα δώσουν μια προειδοποίηση εάν η στήλη στην οποία προσπαθείτε να αποκτήσετε πρόσβαση δεν υπάρχει:

```{r}
tb <- tibble(x1 = 1)

tb$x
tb$z
```

Για αυτόν τον λόγο, μερικές φορές αστειευόμαστε ότι τα tibbles είναι τεμπέλικα και κακόκεφα: κάνουν λίγα και παραπονιούνται περισσότερο.

### Λίστες

Τα `[[` και `$` είναι επίσης πολύ σημαντικά για εργασίες με λίστες και είναι σημαντικό να κατανοήσουμε πώς διαφέρουν από το `[`.
Ας δείξουμε τις διαφορές με μια λίστα με όνομα `l`:

```{r}
l <- list(
  a = 1:3, 
  b = "a string", 
  c = pi, 
  d = list(-1, -5)
)
```

-   Το `[` εξάγει μια υπο-λίστα.
    Δεν έχει σημασία πόσα στοιχεία θα εξάγετε, το αποτέλεσμα θα είναι πάντα λίστα.

    ```{r}
    str(l[1:2])

    str(l[1])

    str(l[4])
    ```

    Όπως και με τα διανύσματα, μπορείτε να δημιουρήσετε υποσύνολα χρησιμοποιώντας διανύσματα λογικών τιμών, ακέραιων αριθμών ή χαρακτήρων.

-   Τα `[[` και `$` εξάγουν ένα μόνο στοιχείο από μια λίστα.
    Αφαιρούν ένα επίπεδο από τη λίστα.

    ```{r}
    str(l[[1]])

    str(l[[4]])

    str(l$a)
    ```

Η διαφορά μεταξύ `[` και `[[` είναι ιδιαίτερα σημαντική για τις λίστες, επειδή το `[[` εμβαθύνει στη λίστα ενώ το `[` επιστρέφει μια νέα, μικρότερη λίστα.
Για να σας βοηθήσουμε να θυμάστε τη διαφορά, ρίξτε μια ματιά στην ασυνήθιστη πιπεριέρα στο @fig-pepper.
Εάν η πιπεριέρα είναι η λίστα σας με όνομα `pepper`, τότε, το `pepper[1]` είναι μια πιπεριέρα που περιέχει ένα μόνο φακελάκι πιπεριού.
Το `pepper[2]` θα ήταν το ίδιο, αλλά θα περιέχει το δεύτερο φακελάκι.
Το `pepper[1:2]` θα ήταν μια πιπεριέρα με δύο φακελάκια πιπεριού.
Το `pepper[[1]]` θα εξάγει το ίδιο το φακελάκι πιπεριού.

```{r}
#| label: fig-pepper
#| echo: false
#| out-width: "100%"
#| fig-cap: |
#|   (Αριστερά) Μια πιπεριά που βρήκε κάποτε ο Χάντλεϊ στο δωμάτιο του ξενοδοχείου του.
#|   (Μέση) `pepper[1]`.
#|   (Δεξιά) `pepper[[1]]`
#| fig-alt: |
#|   Three photos. On the left is a photo of a glass pepper shaker. Instead of 
#|   the pepper shaker containing pepper, it contains a single packet of pepper.
#|   In the middle is a photo of a single packet of pepper. On the right is a 
#|   photo of the contents of a packet of pepper.

knitr::include_graphics("diagrams/pepper.png")
```

Η ίδια αρχή ισχύει όταν χρησιμοποιείτε το μονοσδιάστατο `[` σε ένα πλαίσιο δεδομένων: το `df["x"]` επιστρέφει ένα πλαίσιο δεδομένων μίας στήλης και το `df[["x"]]` επιστρέφει ένα διάνυσμα.

### Ασκήσεις

1.  Τι συμβαίνει όταν χρησιμοποιείτε το `[[` με έναν θετικό ακέραιο που είναι μεγαλύτερος από το μήκος του διανύσματος; Τι συμβαίνει κατα τη δημιουργείτε ενός υποσυνόλου χρησιμοποιώντας ένα όνομα που δεν υπάρχει;

2.  Τι θα μπορούσε να είναι το `pepper[[1]][1]`; Το `pepper[[1]][[1]]`;

## Οικογένεια συναρτήσεων apply

Στο @sec-iteration, μάθατε τεχνικές σχετικές με το tidyverse για επανάληψη όπως την `dplyr::across()` και την οικογένεια συναρτήσεων map.
Σε αυτήν την ενότητα, θα μάθετε για τα βασικά τους ισοδύναμα, την **οικογένεια συναρτήσεων apply**.
Σε αυτό το πλαίσιο, η apply κκαι η map είναι συνώνυμες επειδή ένας άλλος τρόπος να πούμε "αντιστοίχιση (map) μιας συνάρτησης σε κάθε στοιχείο ενός διανύσματος" είναι "εφαρμογή (apply) μιας συνάρτησης σε κάθε στοιχείο ενός διανύσματος".
Εδώ θα σας δώσουμε μια γρήγορη επισκόπηση αυτής της οικογένειας συναρτήσεων, ώστε να μπορείτε να την αναγνωρίσετε εκεί έξω.

Το πιο σημαντικό μέλος αυτής της οικογένειας είναι η `lapply()`, η οποία μοιάζει πολύ με τη `purrr::map()`[^base-r-3].
Στην πραγματικότητα, επειδή δεν έχουμε χρησιμοποιήσει καμία από τις πιο προχωρημένες δυνατότητες της `map()`, μπορείτε να αντικαταστήσετε κάθε κλήση της `map()` στο @sec-iteration με την `lapply()`.

[^base-r-3]: Απλώς δεν διαθέτει βολικές λειτουργίες, όπως καταστάσεις προόδου και αναφορές για το ποιο στοιχείο προκάλεσε το πρόβλημα εάν υπάρχει σφάλμα.

Δεν υπάρχει ακριβής αντιστοίχιση του βασικού συνόλου λειτουργειών της R με την `across()`, αλλά μπορείτε να έρθετε αρκετά κοντά χρησιμοποιώντας το `[` με την `lapply()`.
Αυτό λειτουργεί επειδή στο παρασκήνιο, τα πλαίσια δεδομένων είναι λίστες στηλών, επομένως η κλήση της `lapply()` σε ένα πλαίσιο δεδομένων εφαρμόζει τη συνάρτηση σε κάθε στήλη.

```{r}
df <- tibble(a = 1, b = 2, c = "a", d = "b", e = 4)

# First find numeric columns
num_cols <- sapply(df, is.numeric)
num_cols

# Then transform each column with lapply() then replace the original values
df[, num_cols] <- lapply(df[, num_cols, drop = FALSE], \(x) x * 2)
df
```

Ο παραπάνω κώδικας χρησιμοποιεί μια νέα συνάρτηση, την `sapply()`.
Είναι παρόμοια με την `lapply()`, αλλά προσπαθεί πάντα να απλοποιήσει το αποτέλεσμα, εξ ου και το `s` στο όνομά της.
Εδώ παράγει ένα λογικό διάνυσμα αντί για μια λίστα.
Δεν συνιστούμε να τη χρησιμοποιήσετε για τη δημιουργεία προγραμμάτων, επειδή η απλοποίηση μπορεί να αποτύχει και να σας δώσει έναν απροσδόκητο τύπο δεδομένων.
Συνήθως όμως είναι καλή για διαδραστική χρήση.
Η purrr έχει μια παρόμοια συνάρτηση που ονομάζεται `map_vec()` που δεν αναφέραμε στο @sec-iteration.

Το βασικό σύνολο της R παρέχει μια πιο αυστηρή έκδοση της `sapply()` που ονομάζεται `vapply()`, συντομογραφία για το **v**ector apply.
Παίρνει ένα πρόσθετο όρισμα που καθορίζει τον αναμενόμενο τύπο, διασφαλίζοντας ότι η απλοποίηση γίνεται με τον ίδιο τρόπο ανεξάρτητα από την είσοδο.
Για παράδειγμα, θα μπορούσαμε να αντικαταστήσουμε την κλήση της `sapply()` παραπάνω με αυτήν της `vapply()` όπου προσδιορίζουμε ότι αναμένουμε από την `is.numeric()` να επιστρέψει ένα λογικό διάνυσμα μήκους 1:

```{r}
vapply(df, is.numeric, logical(1))
```

Η διαφορά μεταξύ `sapply()` και `vapply()` είναι πολύ σημαντική όταν βρίσκονται μέσα σε μια συνάρτηση (καθώς επηρεάζεται η ανθεκτηκότητα της συνάρτησης σε ασυνήθιστες εισόδους), αλλά συνήθως δεν έχει σημασία στην ανάλυση δεδομένων.

Ένα άλλο σημαντικό μέλος της οικογένειας συναρτήσεων apply είναι η `tapply()` η οποία υπολογίζει μια ενιαία ομαδοποιημένη σύνοψη:

```{r}
diamonds |> 
  group_by(cut) |> 
  summarize(price = mean(price))

tapply(diamonds$price, diamonds$cut, mean)
```

Δυστυχώς η `tapply()` επιστρέφει τα αποτελέσματά της σε ένα διάνυσμα με όνομα και απαιτεί λίγη προσπάθεια εάν θέλετε να συλλέξετε πολλές περιλήψεις και μεταβλητές ομαδοποίησης σε ένα πλαίσιο δεδομένων (είναι σίγουρα εφικτό το να μην το κάνετε αυτό και απλώς να εργαστείτε με ξεχωριστά διανύσματα, αλλά κατά την εμπειρία μας αυτό απλώς καθυστερεί την δουλειά που πρέπει να γίνει).
Αν θέλετε να δείτε πώς μπορείτε να χρησιμοποιήσετε την `tapply()` ή άλλες βασικές τεχνικές για να εκτελέσετε άλλες ομαδοποιημένες περιλήψεις, ο Hadley έχει συγκεντρώσει μερικές τεχνικές [σε ένα gist](https://gist.github.com/hadley/c430501804349d382ce90754936ab8ec).

Το τελευταίο μέλος της οικογένειας apply είναι η `apply()`, η οποία λειτουργεί με μητρώα και arrays.
Πιο αναλυτικά, προσέξτε την `apply(df, 2, something)`, που είναι ένας αργός και δυνητικά επικίνδυνος τρόπος για να εφαρμόσετε την `lapply(df, something)`.
Αυτό σπάνια εμφανίζεται στην επιστήμη δεδομένων επειδή συνήθως εργαζόμαστε με πλαίσια δεδομένων και όχι με μητρώα.

## Βρόχοι `for`

Οι βρόχοι `for` είναι το θεμελιώδες δομικό στοιχείο της επανάληψης που χρησιμοποιούν και οι οικογένειες apply και map στο πρασκήνιο.
Οι βρόχοι `for` είναι ισχυρά και γενικά εργαλεία που είναι σημαντικό να μάθετε καθώς γίνεστε πιο έμπειρος προγραμματιστής R.
Η βασική δομή ενός βρόχου `for` μοιάζει με το εξής:

```{r}
#| eval: false

for (element in vector) {
  # do something with element
}
```

Η πιο απλή χρήση των βρόχων `for` είναι η επίτευξη του ίδιου αποτελέσματος με την `walk()`: η κλήση κάποιας συνάρτησης με κάποιο αποτέλεσμα σε κάθε στοιχείο μιας λίστας.
Για παράδειγμα, στο @sec-save-database αντί να χρησιμοποιήσετε τη `walk()`:

```{r}
#| eval: false

paths |> walk(append_file)
```

Θα μπορούσαμε να χρησιμοποιήσουμε έναν βρόχο `for`:

```{r}
#| eval: false

for (path in paths) {
  append_file(path)
}
```

Τα πράγματα γίνονται λίγο πιο δύσκολα αν θέλετε να αποθηκεύσετε την έξοδο του βρόχου `for`, για παράδειγμα η ανάγνωση όλων των αρχείων excel σε έναν κατάλογο όπως κάναμε στο @sec-iteration:

```{r}
paths <- dir("data/gapminder", pattern = "\\.xlsx$", full.names = TRUE)
files <- map(paths, readxl::read_excel)
```

Υπάρχουν μερικές διαφορετικές τεχνικές που μπορείτε να χρησιμοποιήσετε, αλλά σας συνιστούμε να είστε ξεκάθαροι σχετικά με το πώς θα είναι το αποτέλεσμα εκ των προτέρων.
Σε αυτήν την περίπτωση, θα θέλουμε μια λίστα με το ίδιο μήκος του `paths`, την οποία μπορούμε να δημιουργήσουμε με την `vector()`:

```{r}
files <- vector("list", length(paths))
```

Στη συνέχεια, αντί να επαναλαμβάνουμε τις διαδικασίες μας στα στοιχεία του `paths`, θα τις επαναλαμβάνουμε στους δείκτες τους, χρησιμοποιώντας τη `seq_along()` για να δημιουργήσουμε ένα ευρετήριο για κάθε στοιχείο του paths:

```{r}
seq_along(paths)
```

Η χρήση των δεικτών είναι σημαντική γιατί μας επιτρέπει να συνδέσουμε κάθε θέση στην είσοδο με την αντίστοιχη θέση στην έξοδο:

```{r}
for (i in seq_along(paths)) {
  files[[i]] <- readxl::read_excel(paths[[i]])
}
```

Για να συνδυάσετε τη λίστα των tibbles σε ένα μόνο tibble, μπορείτε να χρησιμοποιήσετε τις `do.call()` + `rbind()`:

```{r}
do.call(rbind, files)
```

Αντί να δημιουργήσουμε μια λίστα και να αποθηκεύουμε εκεί τα αποτελέσματα καθώς προχωράμε, μια απλούστερη προσέγγιση είναι να δημιουργήσουμε το πλαίσιο δεδομένων κομμάτι-κομμάτι:

```{r}
out <- NULL
for (path in paths) {
  out <- rbind(out, readxl::read_excel(path))
}
```

Συνιστούμε να αποφύγετε αυτό το μοτίβο γιατί μπορεί να γίνει αρκετά αργό όταν το διάνυσμα είναι πολύ μεγάλο.
Αυτή είναι και η πηγή του μύθου ότι οι βρόχοι `for` είναι αργοί: δεν είναι, αλλά το να αυξάνεται επαναλαμβανόμενα ένα διάνυσμα, είναι.

## Διαγράμματα

Πολλοί χρήστες της R που δεν χρησιμοποιούν υπο άλλες συνθήκες το tidyverse προτιμούν την ggplot2 για σχεδίαση λόγω των χρήσιμων χαρακτηριστικών της όπως οι λογικές προεπιλογές, τα αυτοματοποιημένα υπομνήματα και η μοντέρνα εμφάνιση.
Ωστόσο, οι βασικές συναρτήσεις σχεδίασης της R μπορούν να είναι ακόμα χρήσιμες μόνο επειδή είναι τόσο συνοπτικές --- χρειάζεται πολύ λίγη πληκτρολόγηση για να κάνετε ένα απλό εξερευνητικό διάγραμμα.

Υπάρχουν δύο κύριοι τύποι απλού διαγράμματος που θα δείτε εκεί έξω: διαγράμματα διασποράς και ιστογράμματα, που παράγονται με τις `plot()` και `hist()` αντίστοιχα.
Ακολουθεί ένα γρήγορο παράδειγμα από το σύνολο δεδομένων diamonds:

```{r}
#| dev: png
#| fig-width: 4
#| fig-asp: 1
#| layout-ncol: 2
#| fig-alt: |
#|   On the left, histogram of carats of diamonds, ranging from 0 to 5 carats.
#|   The distribution is unimodal and right-skewed. On the right, scatter 
#|   plot of price vs. carat of diamonds, showing a positive relationship 
#|   that fans out as both price and carat increases. The scatter plot 
#|   shows very few diamonds bigger than 3 carats compared to diamonds between 
#|   0 to 3 carats.

# Left
hist(diamonds$carat)

# Right
plot(diamonds$carat, diamonds$price)
```

Σημειώστε ότι οι βασικές συναρτήσεις διαγραμμάτων λειτουργούν με διανύσματα, επομένως πρέπει να επιλέξετε στήλες από το πλαίσιο δεδομένων χρησιμοποιώντας το `$` ή κάποια άλλη τεχνική.

## Σύνοψη

Σε αυτό το κεφάλαιο, σας δείξαμε μια επιλογή απο βασικές συναρτήσεις της R που είναι χρήσιμες για την δημιουργία υποσυνόλων και την επανάληψη.
Σε σύγκριση με προσεγγίσεις που συζητούνται αλλού στο βιβλίο, αυτές οι συναρτήσεις τείνουν να έχουν περισσότερο άρωμα "διανύσματος" παρά "πλαισίου δεδομένων" επειδή οι βασικές συναρτήσεις της R τείνουν να λαμβάνουν μεμονωμένα διανύσματα ως είσοδο, παρά ένα πλαίσιο δεδομένων μαζί με προδιαγραφές στηλών.
Αυτό συχνά, στον προγραμματισμό, κάνει τη ζωή πιο εύκολη και γι' αυτό γίνεται πιο σημαντικό καθώς γράφετε περισσότερες συναρτήσεις και αρχίζετε να γράφετε τα δικά σας πακέτα.

Αυτό το κεφάλαιο ολοκληρώνει την ενότητα προγραμματισμού του βιβλίου.
Έχετε κάνει μια καλή αρχή στο ταξίδι σας για να γίνετε όχι απλώς επιστήμονας δεδομένων που χρησιμοποιεί την R, αλλά επιστήμονας δεδομένων που μπορεί να *προγραμματίσει* σε R.
Ελπίζουμε ότι αυτά τα κεφάλαια έχουν κεντρίσει το ενδιαφέρον σας για τον προγραμματισμό και ότι ανυπομονείτε να μάθετε περισσότερα εκτός αυτού του βιβλίου.
