# Υπολογιστικά φύλλα {#sec-import-spreadsheets}

```{r}
#| echo: false

source("_common.R")
```

## Εισαγωγή

Στο @sec-data-import μάθατε για την εισαγωγή δεδομένων από αρχεία απλού κειμένου, όπως `.csv` και `.tsv`.
Τώρα ήρθε η ώρα να μάθετε πώς να εξάγετε δεδομένα από ένα υπολογιστικό φύλλο, είτε από Excel, είτε από Google Sheet.
Θα βασιστούμε σε πολλά από αυτά που έχετε μάθει στο @sec-data-import, θα συζητήσουμε όμως πρόσθετες οπτικές και δυσκολίες κατά την εργασία σας με δεδομένα από υπολογιστικά φύλλα.

Εάν εσείς ή οι συνεργάτες σας χρησιμοποιείτε υπολογιστικά φύλλα για την οργάνωση δεδομένων, συνιστούμε ανεπιφύλακτα να διαβάσετε τη δημοσίευση "Data Organization in Spreadsheets" των Karl Broman και Kara Woo: <https://doi.org/10.1080/00031305.2017.1375989>.
Οι βέλτιστες πρακτικές που παρουσιάζονται θα σας γλυτώσουν από αρκετούς πονεκεφάλους καθώς εισάγετε δεδομένα από ένα υπολογιστικό φύλλο στην R για αναλύσετε και να οπτικοποιήσετε.

## Excel

Το Microsoft Excel είναι ένα ευρέως χρησιμοποιούμενο πρόγραμμα λογισμικού υπολογιστικών φύλλων, όπου τα δεδομένα οργανώνονται σε φύλλα εργασίας μέσα σε αρχεία υπολογιστικών φύλλων.

### Προαπαιτούμενα

Σε αυτήν την ενότητα, θα μάθετε πώς να φορτώνετε δεδομένα από υπολογιστικά φύλλα Excel στην R με το πακέτο **readxl**.
Αυτό το πακέτο δεν είναι βασικό στο tidyverse, επομένως πρέπει να το φορτώσετε ξεχωριστά.
Εγκαθίσταται όμως αυτόματα όταν εγκαθιστάτε το tidyverse.
Αργότερα, θα χρησιμοποιήσουμε επίσης το πακέτο writexl, το οποίο μας επιτρέπει να δημιουργήσουμε υπολογιστικά φύλλα Excel.

```{r}
#| message: false

library(readxl)
library(tidyverse)
library(writexl)
```

### Ξεκινώντας

Οι περισσότερες από τις λειτουργίες του πακέτου readxl σας επιτρέπουν να φορτώνετε υπολογιστικά φύλλα Excel στην R:

-   Η `read_xls()` διαβάζει αρχεία Excel με μορφή `xls`.
-   Η `read_xlsx()` διαβάζει αρχεία Excel με μορφή `xlsx`.
-   Η `read_excel()` μπορεί να διαβάζει αρχεία τόσο με τη μορφή `xls` αλλά και `xlsx`. Αυτό γίνεται μαντεύοντας τον τύπο του αρχείου με βάση την είσοδο.

Αυτές οι συναρτήσεις έχουν παρόμοια σύνταξη όπως και άλλες συναρτήσεις για τις οποίες έχουμε μιλήσει προηγουμένως για την ανάγνωση άλλων τύπων αρχείων, π.χ., `read_csv()`, `read_table()` κ.λπ.
Για το υπόλοιπο του κεφαλαίου θα επικεντρωθούμε στη χρήση της `read_excel()`.

### Διαβάζοντας υπολογιστικά φύλλα Excel {#sec-reading-spreadsheets-excel}

Το @fig-students-excel δείχνει πώς φαίνεται στο Excel το υπολογιστικό φύλλο που θα διαβάσουμε στην R.
Μπορείτε να το κατεβάσετε ως αρχείο Excel απο το <https://docs.google.com/spreadsheets/d/1V1nPp1tzOuutXFLb3G9Eyxi3qxeEhnOXUzL5_BcCQ0w/>.

```{r}
#| label: fig-students-excel
#| echo: false
#| fig-width: 5
#| fig-cap: |
#|   Υπολογιστικό φύλλο με όνομα students.xlsx στο Excel.
#| fig-alt: |
#|   A look at the students spreadsheet in Excel. The spreadsheet contains 
#|   information on 6 students, their ID, full name, favourite food, meal plan, 
#|   and age.

knitr::include_graphics("screenshots/import-spreadsheets-students.png")
```

Το πρώτο όρισμα της `read_excel()` είναι το μονοπάτι του αρχείου προς ανάγνωση.

```{r}
students <- read_excel("data/students.xlsx")
```

Η `read_excel()` θα διαβάσει το αρχείο ως tibble.

```{r}
students
```

Έχουμε έξι μαθητές στα δεδομένα και πέντε μεταβλητές για κάθε μαθητή.
Ωστόσο, υπάρχουν μερικά πράγματα που ίσως θέλουμε να αντιμετωπίσουμε σε αυτό το σύνολο δεδομένων:

1.  Τα ονόματα των στηλών δεν είναι ορισμένα με συνέπεια.
    Μπορείτε να παρέχετε ονόματα στηλών που ακολουθούν μία συνεπή μορφή.
    Συνιστούμε τη μορφή `snake_case` χρησιμοποιώντας το όρισμα `col_names`.

    ```{r}
    #| include: false

    options(
      dplyr.print_min = 7,
      dplyr.print_max = 7
    )
    ```

    ```{r}
    read_excel(
      "data/students.xlsx",
      col_names = c("student_id", "full_name", "favourite_food", "meal_plan", "age")
    )
    ```

    ```{r}
    #| include: false

    options(
      dplyr.print_min = 6,
      dplyr.print_max = 6
    )
    ```

    Δυστυχώς, αυτό δεν δούλεψε πολύ καλά.
    Τώρα, έχουμε τα ονόματα των μεταβλητών που θέλουμε, αλλά αυτό που προηγουμένως ήταν η γραμμή με τα ονόματα των στηλών, τώρα εμφανίζεται ως η πρώτη παρατήρηση στα δεδομένα.
    Μπορείτε να παραλείψετε αυτή τη γραμμή χρησιμοποιώντας το όρισμα `skip`.

    ```{r}
    read_excel(
      "data/students.xlsx",
      col_names = c("student_id", "full_name", "favourite_food", "meal_plan", "age"),
      skip = 1
    )
    ```

2.  Στη στήλη `favourite_food`, μία από τις παρατηρήσεις είναι `N/A`, το οποίο σημαίνει "μη διαθέσιμο (not available)", αλλά επί του παρόντος δεν αναγνωρίζεται ως τιμή `ΝΑ` (σημειώστε την αντίθεση μεταξύ του `N/A` και της ηλικίας του τέταρτου μαθητή στη λίστα).
    Μπορείτε να καθορίσετε ποιες τιμές χαρακτήρων θα αναγνωρίζονται ως `NA` με το όρισμα `na`.
    Από προεπιλογή, μόνο το `""` (κενή συμβολοσειρά ή, στην περίπτωση ανάγνωσης από υπολογιστικό φύλλο, ένα κενό κελί, ή ένα κελί με τον τύπο `=NA()`) αναγνωρίζεται ως `NA`.

    ```{r}
    read_excel(
      "data/students.xlsx",
      col_names = c("student_id", "full_name", "favourite_food", "meal_plan", "age"),
      skip = 1,
      na = c("", "N/A")
    )
    ```

3.  Ένα άλλο ζήτημα που απομένει είναι ότι η στήλη `age` διαβάζεται ως μεταβλητή χαρακτήρων, αλλά στην πραγματικότητα θα έπρεπε να είναι αριθμητική.
    Ακριβώς όπως με τη `read_csv()` και τις παρόμοιες συναρτήσεις για ανάγνωση δεδομένων από flat αρχεία, μπορείτε να παρέχετε το όρισμα `col_types` στη `read_excel()` και να καθορίσετε τους τύπους των στηλών για τις μεταβλητές που διαβάζετε.
    Ωστόσο, η σύνταξη είναι λίγο διαφορετική.
    Οι επιλογές σας είναι `skip"`, `"guess"`, `"logical"`, `"numeric"`, `"date"`, `"text"` or `"list"`.

    ```{r}
    read_excel(
      "data/students.xlsx",
      col_names = c("student_id", "full_name", "favourite_food", "meal_plan", "age"),
      skip = 1,
      na = c("", "N/A"),
      col_types = c("numeric", "text", "text", "text", "numeric")
    )
    ```

    Ωστόσο, ούτε και αυτό έφερε το επιθυμητό αποτέλεσμα.
    Καθορίζοντας ότι η στήλη `age` πρέπει να είναι αριθμητική, έχουμε μετατρέψει το ένα κελί με τη μη αριθμητική καταχώρηση (που είχε την τιμή `five`) σε `NA`.
    Σε αυτήν την περίπτωση, θα πρέπει να διαβάσουμε την ηλικία ως κείμενο (`"text"`) και στη συνέχεια να κάνουμε την αλλαγή μόλις τα δεδομένα φορτωθούν στην R.

    ```{r}
    students <- read_excel(
      "data/students.xlsx",
      col_names = c("student_id", "full_name", "favourite_food", "meal_plan", "age"),
      skip = 1,
      na = c("", "N/A"),
      col_types = c("numeric", "text", "text", "text", "text")
    )

    students <- students |>
      mutate(
        age = if_else(age == "five", "5", age),
        age = parse_number(age)
      )

    students
    ```

Μας χρειάστηκαν πολλά βήματα και δοκιμές για να φορτώσουμε τα δεδομένα ακριβώς στη μορφή που θέλουμε, και αυτό δεν είναι απροσδόκητο.
Η επιστήμη των δεδομένων είναι μία επαναληπτική διαδικασία, και η διαδικασία της επανάληψης μπορεί να είναι ακόμη πιο κουραστική κατά την ανάγνωση δεδομένων από υπολογιστικά φύλλα σε σύγκριση με άλλα αρχεία απλού κειμένου, ή αρχεία δεδομένων σε μορφή πίνακα, επειδή οι άνθρωποι τείνουν να εισάγουν δεδομένα σε υπολογιστικά φύλλα, και να τα χρησιμοποιούν όχι μόνο για αποθήκευση, αλλά και για κοινή χρήση και επικοινωνία.

Δεν υπάρχει τρόπος να γνωρίζετε ακριβώς πώς θα είναι τα δεδομένα μέχρι να τα φορτώσετε και να τα δείτε.
Βασικά, στην πραγματικότητα, υπάρχει.
Μπορείτε να ρίξετε μία ματιά ανοίγοντας το αρχείο στο Excel.
Εάν πρόκειται να το κάνετε, συνιστούμε να δημιουργήσετε ένα αντίγραφο του αρχείου Excel για να το ανοίξετε και να περιηγηθείτε διαδραστικά και να αφήσετε ως έχει το αρχικό αρχείο που θα διαβάσετε στην R.
Αυτό θα διασφαλίσει ότι δεν θα αντικαταστήσετε κατά λάθος κάτι μέσα στο υπολογιστικό φύλλο όσο το εξερευνείτε.
Επίσης, δεν πρέπει να φοβάστε να κάνετε αυτό που κάναμε εδώ: φορτώστε τα δεδομένα, ρίξτε μία ματιά, κάντε προσαρμογές στον κώδικά σας, φορτώστε το αρχείο ξανά και επαναλάβετε μέχρι να είστε ευχαριστημένοι με το αποτέλεσμα.

### Διαβάζοντας φύλλα εργασίας

Ένα σημαντικό χαρακτηριστικό που ξεχωρίζει τα υπολογιστικά φύλλα από τα flat αρχεία είναι η έννοια των πολλαπλών φύλλων, που ονομάζονται φύλλα εργασίας.
Το @fig-penguins-islands εμφανίζει ένα υπολογιστικό φύλλο Excel με πολλά φύλλα εργασίας.
Τα δεδομένα προέρχονται από το πακέτο **palmerpenguins** ενώ μπορείτε να κατεβάσετε το υπολογιστικό φύλλο ως αρχείο Excel από το <https://docs.google.com/spreadsheets/d/1aFu8lnD_g0yjF5O-K6SFgSEWiHPpgvFCF0NY9D6LXnY/>.
Κάθε φύλλο εργασίας περιέχει πληροφορίες για πιγκουίνους από διαφορετικά νησιά.

```{r}
#| label: fig-penguins-islands
#| echo: false
#| fig-cap: |
#|   Υπολογιστικό φύλλο με όνομα penguins.xlsx στο Excel που περιέχει τρία φύλλα εργασίας.
#| fig-alt: |
#|   A look at the penguins spreadsheet in Excel. The spreadsheet contains has 
#|   three worksheets: Torgersen Island, Biscoe Island, and Dream Island.

knitr::include_graphics("screenshots/import-spreadsheets-penguins-islands.png")
```

Μπορείτε να διαβάσετε ένα μεμονωμένο φύλλο εργασίας από ένα υπολογιστικό φύλλο με το όρισμα `sheet` στη `read_excel()`.
Η προεπιλογή, στην οποία βασιζόμασταν μέχρι τώρα, είναι το πρώτο φύλλο.

```{r}
read_excel("data/penguins.xlsx", sheet = "Torgersen Island")
```

Ορισμένες μεταβλητές που φαίνεται να περιέχουν αριθμητικά δεδομένα διαβάζονται ως χαρακτήρες λόγω του ότι η συμβολοσειρά χαρακτήρων `"NA"` δεν αναγνωρίζεται ως πραγματικό `NA`.

```{r}
penguins_torgersen <- read_excel("data/penguins.xlsx", sheet = "Torgersen Island", na = "NA")

penguins_torgersen
```

Εναλλακτικά, μπορείτε να χρησιμοποιήσετε την `excel_sheets()` για να πάρετε πληροφορίες για όλα τα φύλλα εργασίας σε ένα υπολογιστικό φύλλο Excel και, στη συνέχεια, να διαβάσετε μόνο αυτά που σας ενδιαφέρουν.

```{r}
excel_sheets("data/penguins.xlsx")
```

Εάν γνωρίζετε τα ονόματα των φύλλων εργασίας, μπορείτε να τα διαβάσετε μεμονωμένα με τη `read_excel()`.

```{r}
penguins_biscoe <- read_excel("data/penguins.xlsx", sheet = "Biscoe Island", na = "NA")
penguins_dream  <- read_excel("data/penguins.xlsx", sheet = "Dream Island", na = "NA")
```

Σε αυτήν την περίπτωση, το πλήρες σύνολο δεδομένων penguins κατανέμεται σε τρία φύλλα εργασίας μέσα στο υπολογιστικό φύλλο.
Κάθε φύλλο εργασίας έχει τον ίδιο αριθμό στηλών αλλά διαφορετικό αριθμό σειρών.

```{r}
dim(penguins_torgersen)
dim(penguins_biscoe)
dim(penguins_dream)
```

Μπορούμε να τα ενώσουμε με την `bind_rows()`.

```{r}
penguins <- bind_rows(penguins_torgersen, penguins_biscoe, penguins_dream)
penguins
```

Στο @sec-iteration θα μιλήσουμε για τρόπους εκτέλεσης αυτού του είδους εργασίας χωρίς επαναλαμβανόμενο κώδικα.

### Διαβάζοντας μέρος ενός φύλλου

Δεδομένου ότι πολλοί χρησιμοποιούν υπολογιστικά φύλλα Excel για παρουσίαση καθώς και για αποθήκευση δεδομένων, είναι πολύ συνηθισμένο να βρίσκουμε καταχωρήσεις κελιών σε ένα υπολογιστικό φύλλο που δεν αποτελούν μέρος των δεδομένων που θέλετε να διαβάσετε στην R.
Το @fig-deaths-excel δείχνει ένα τέτοιο υπολογιστικό φύλλο: στη μέση του φύλλου υπάρχει κάτι που μοιάζει με πλαίσιο δεδομένων.
Υπάρχει όμως εξωτερικό κείμενο στα κελιά πάνω και κάτω από τα δεδομένα.

```{r}
#| label: fig-deaths-excel
#| echo: false
#| fig-cap: |
#|   Υπολογσιτικό φύλλο με όνομα deaths.xlsx στο Excel.
#| fig-alt: |
#|   A look at the deaths spreadsheet in Excel. The spreadsheet has four rows 
#|   on top that contain non-data information; the text 'For the same of 
#|   consistency in the data layout, which is really a beautiful thing, I will 
#|   keep making notes up here.' is spread across cells in these top four rows. 
#|   Then, there is a data frame that includes information on deaths of 10 
#|   famous people, including their names, professions, ages, whether they have 
#|   kids or not, date of birth and death. At the bottom, there are four more 
#|   rows of non-data information; the text 'This has been really fun, but 
#|   we're signing off now!' is spread across cells in these bottom four rows.

knitr::include_graphics("screenshots/import-spreadsheets-deaths.png")
```

Αυτό το υπολογιστικό φύλλο είναι ένα από τα παραδείγματα που παρέχονται στο πακέτο readxl.
Μπορείτε να χρησιμοποιήσετε τη συνάρτηση `readxl_example()` για να εντοπίσετε το υπολογιστικό φύλλο στο σύστημά σας στον κατάλογο όπου είναι εγκατεστημένο το πακέτο.
Αυτή η συνάρτηση επιστρέφει το μονοπάτι προς το υπολογιστικό φύλλο, το οποίο μπορείτε να χρησιμοποιήσετε στην `read_excel()` ως συνήθως.

```{r}
deaths_path <- readxl_example("deaths.xlsx")
deaths <- read_excel(deaths_path)
deaths
```

Οι τρεις επάνω γραμμές και οι τέσσερις κάτω γραμμές δεν αποτελούν μέρος του πλαισίου δεδομένων.
Οι εξωτερικές γραμμές μπορούν να αποφευχθούν χρησιμοποιώντας τα ορίσματα `skip` και `n_max`, συνιστούμε όμως τη χρήση εύρους κελιών.
Στο Excel, το επάνω αριστερό κελί είναι το `A1`.
Καθώς μετακινείστε στις στήλες προς τα δεξιά, η ετικέτα του κελιού μετακινείται προς τα κάτω στο αλφάβητο, δηλαδή `B1`, `C1`, κ.λπ.
Και καθώς μετακινείστε προς τα κάτω σε μία στήλη, ο αριθμός στην ετικέτα του κελιού αυξάνεται, για παράδειγμα `A2`, `A3` κ.λπ.

Εδώ τα δεδομένα που θέλουμε να διαβάσουμε ξεκινούν στο κελί `A5` και τελειώνουν στο κελί `F15`.
Σε όρους υπολογιστικών φύλλων, αυτό μεταφράζεται σε `A5:F1`, το οποίο και παρέχουμε στο όρισμα `range`:

```{r}
read_excel(deaths_path, range = "A5:F15")
```

### Τύποι δεδομένων

Σε αρχεία CSV, όλες οι τιμές είναι συμβολοσειρές.
Αυτό δεν ισχύει ιδιαίτερα για τα δεδομένα κάθε φορά, αλλά είναι απλό: όλα είναι μία συμβολοσειρά.

Τα υποκείμενα δεδομένα στα υπολογιστικά φύλλα του Excel είναι πιο περίπλοκα.
Ένα κελί μπορεί να είναι ένα από τέσσερα πράγματα:

-   Βoolean, όπως `TRUE`, `FALSE` ή `NA`.

-   Αριθμός, όπως `10` ή `10,5`.

-   Ημερομηνία, η οποία μπορεί επίσης να περιλαμβάνει και πληροφορία ώρας όπως `11/1/21` ή `11/1/21 3:00 PM`.

-   Μία συμβολοσειρά, όπως "δέκα".

Όταν εργάζεστε με δεδομένα απο υπολογιστικά φύλλα, είναι σημαντικό να θυμάστε ότι τα υποκείμενα δεδομένα μπορεί να είναι πολύ διαφορετικά από αυτά που βλέπετε στο κελί.
Για παράδειγμα, το Excel δεν ορίζει την έννοια του ακέραιου αριθμού.
Όλοι οι αριθμοί αποθηκεύονται ως στοιχεία με κινητή υποδιαστολή.
Μπορείτε όμως να επιλέξετε τα δεδομένα να εμφανίζονται με έναν προσαρμόσιμο αριθμό δεκαδικών ψηφίων.
Ομοίως, οι ημερομηνίες αποθηκεύονται ως αριθμοί, συγκεκριμένα ο αριθμός των δευτερολέπτων από την 1η Ιανουαρίου 1970.
Μπορείτε να προσαρμόσετε τον τρόπο εμφάνισης της ημερομηνίας εφαρμόζοντας κάποιοα μορφοποίηση στο Excel.
Συνεχίζοντας με τη σύγχυση, είναι επίσης πιθανό να έχετε κάτι που μοιάζει με αριθμό, αλλά στην πραγματικότητα να είναι μία συμβολοσειρά (π.χ. πληκτρολογήστε `10` σε ένα κελί στο Excel).

Οι διαφορές μεταξύ του τρόπου αποθήκευσης των υποκείμενων δεδομένων και του τρόπου εμφάνισής τους μπορεί να προκαλέσουν εκπλήξεις όταν τα δεδομένα φορτώνονται στην R.
Από προεπιλογή, το πακέτο readxl θα μαντέψει τον τύπο δεδομένων για κάθε στήλη.
Ένας συνιστώμενος τρόπος εργασίας είναι να επιτρέψετε στην readxl να μαντέψει τους τύπους των στηλών, να επιβεβαιώσει ότι είστε ικανοποιημένοι με αυτούς που μάντεψε και, αν όχι, να επιστρέψετε και να εισαγάγετε ξανά προσδιορίζοντας το `col_types` όπως φαίνεται στην @sec-reading-spreadsheets-excel.

Μια άλλη πρόκληση είναι όταν έχετε μία στήλη στο υπολογιστικό φύλλο του Excel που περιέχει έναν συνδυασμό αυτών των τύπων, π.χ.
ορισμένα κελιά είναι αριθμητικά, άλλα κείμενο, άλλα ημερομηνίες.
Κατά την εισαγωγή των δεδομένων στην R, το πακέτο readxl πρέπει να λάβει κάποιες αποφάσεις.
Σε αυτές τις περιπτώσεις, μπορείτε να ορίσετε τον τύπο αυτής της στήλης σε `λίστα ("list")`, η οποία θα φορτώσει τη στήλη ως λίστα διανυσμάτων μήκους 1, όπου μαντεύεται ο τύπος κάθε στοιχείου του διανύσματος.

::: callout-note
Μερικές φορές τα δεδομένα αποθηκεύονται με πιο ιδιαίτερους τρόπους, όπως το χρώμα του φόντου του κελιού ή αν το κείμενο είναι έντονο ή όχι.
Σε τέτοιες περιπτώσεις, μπορεί να βρείτε χρήσιμο το [πακέτο tidyxl](https://nacnudus.github.io/tidyxl/).
Ανατρέξτε στο <https://nacnudus.github.io/spreadsheet-munging-strategies/> για περισσότερα σχετικά με τις στρατηγικές εργασίας με δεδομένα που δεν ειναι σε μορφή πίνακα από το Excel.
:::

### Γράφοντας σε Excel {#sec-writing-to-excel}

Ας δημιουργήσουμε ένα μικρό πλαίσιο δεδομένων που μπορούμε στη συνέχεια να το γράψουμε σε ένα αρχείο.
Σημειώστε ότι το `item` είναι μία παραγοντική μεταβλητή και το `quantity` είναι ακέραιος.

```{r}
bake_sale <- tibble(
  item     = factor(c("brownie", "cupcake", "cookie")),
  quantity = c(10, 5, 8)
)

bake_sale
```

Μπορείτε να γράψετε δεδομένα στον δίσκο ως αρχείο Excel χρησιμοποιώντας την `write_xlsx()` από το [πακέτο writexl](https://docs.ropensci.org/writexl/):

```{r}
#| eval: false

write_xlsx(bake_sale, path = "data/bake-sale.xlsx")
```

Το @fig-bake-sale-excel δείχνει πως φαίνονται τα δεδομένα στο Excel.
Σημειώστε ότι τα ονόματα των στηλών περιλαμβάνονται και είναι με έντονη γραφή.
Αυτά μπορούν να απενεργοποιηθούν θέτοντας τα ορίσματα `col_names` και `format_headers` σε `FALSE`.

```{r}
#| label: fig-bake-sale-excel
#| echo: false
#| fig-width: 5
#| fig-cap: |
#|   Υπολογιστικό φύλλο με όνομα bake_sale.xlsx στο Excel.
#| fig-alt: |
#|   Bake sale data frame created earlier in Excel.

knitr::include_graphics("screenshots/import-spreadsheets-bake-sale.png")
```

Ακριβώς όπως και κατα την ανάγνωση από ένα CSV, οι πληροφορίες σχετικά με τον τύπο δεδομένων χάνονται όταν διαβάζουμε ξανά τα δεδομένα.
Αυτό καθιστά τα αρχεία Excel αναξιόπιστα για την προσωρινή αποθήκευση ενδιάμεσων αποτελεσμάτων.
Για εναλλακτικές, ανατρέξτε στην @sec-writing-to-a-file.

```{r}
read_excel("data/bake-sale.xlsx")
```

### Μορφοποιημένη έξοδος

Το πακέτο writexl είναι μία απλή λύση για τη σύνταξη ενός απλού υπολογιστικού φύλλου Excel, αλλά αν σας ενδιαφέρουν πρόσθετες δυνατότητες όπως η εγγραφή σε φύλλα μέσα σε ένα υπολογιστικό φύλλο και το στυλ, θα θέλετε να χρησιμοποιήσετε το [πακέτο openxlsx](https://ycphs.github.io/openxlsx).
Δεν θα μπούμε σε λεπτομέρειες σχετικά με τη χρήση αυτού του πακέτου, αλλά συνιστούμε να διαβάσετε το <https://ycphs.github.io/openxlsx/articles/Formatting.html> για μία εκτενή συζήτηση σχετικά με την περαιτέρω λειτουργικότητα μορφοποίησης για δεδομένα που έχουν γραφτεί από την R σε Excel με την openxlsx.

Σημειώστε ότι αυτό το πακέτο δεν αποτελεί μέρος του tidyverse, επομένως οι λειτουργίες και οι ροές εργασίας μπορεί να σας φαίνονται άγνωστες.
Για παράδειγμα, τα ονόματα συναρτήσεων είναι γραμμένα σε camelCase, πολλαπλές συναρτήσεις δεν μπορούν να συντεθούν με pipes και τα ορίσματα έχουν διαφορετική σειρά από αυτή που είναι στο tidyverse.
Ωστόσο, αυτό είναι εντάξει.
Καθώς η εκμάθηση και η χρήση της R επεκτείνονται εκτός αυτού του βιβλίου, θα συναντήσετε πολλούς διαφορετικούς τρόπους γραφής που χρησιμοποιούνται σε διάφορα πακέτα της R, τα οποία μπορεί να χρησιμοποιήσετε για να επιτύχετε συγκεκριμένους στόχους.
Ένας καλός τρόπος για να εξοικειωθείτε με το στυλ προγραμματισμού που χρησιμοποιείται σε ένα νέο πακέτο είναι να εκτελέσετε τα παραδείγματα που παρέχονται στις οδηγίες των συναρτήσεων για να πάρετε μία ιδέα της σύνταξης και των μορφών εξόδου, καθώς και να διαβάσετε τυχόν εγχειρίδια που μπορεί να συνοδεύουν το πακέτο.

### Ασκήσεις

1.  Σε ένα αρχείο Excel, δημιουργήστε το ακόλουθο σύνολο δεδομένων και αποθηκεύστε το ως `survey.xlsx`.
    Εναλλακτικά, μπορείτε να το κατεβάσετε ως αρχείο Excel από [εδώ](https://docs.google.com/spreadsheets/d/1yc5gL-a2OOBr8M7B3IsDNX5uR17vBHOyWZq6xSTG2G8).

    ```{r}
    #| echo: false
    #| fig-width: 4
    #| fig-alt: |
    #|   A spreadsheet with 3 columns (group, subgroup, and id) and 12 rows. 
    #|   The group column has two values: 1 (spanning 7 merged rows) and 2 
    #|   (spanning 5 merged rows). The subgroup column has four values: A 
    #|   (spanning 3 merged rows), B (spanning 4 merged rows), A (spanning 2 
    #|   merged rows), and B (spanning 3 merged rows). The id column has twelve 
    #|   values, numbers 1 through 12.

    knitr::include_graphics("screenshots/import-spreadsheets-survey.png")
    ```

    Στη συνέχεια, διαβάστε το στην R, με την `survey_id` ως μεταβλητή χαρακτήρα και την `n_pets` ως αριθμητική μεταβλητή.

    ```{r}
    #| echo: false

    read_excel("data/survey.xlsx", na = c("", "N/A"), col_types = c("text", "text")) |>
      mutate(
        n_pets = case_when(
          n_pets == "none" ~ "0",
          n_pets == "two"  ~ "2",
          TRUE             ~ n_pets
        ),
        n_pets = as.numeric(n_pets)
      )
    ```

2.  Σε ένα άλλο αρχείο Excel, δημιουργήστε το ακόλουθο σύνολο δεδομένων και αποθηκεύστε το ως `roster.xlsx`.
    Εναλλακτικά, μπορείτε να το κατεβάσετε ως αρχείο Excel από [εδώ](https://docs.google.com/spreadsheets/d/1LgZ0Bkg9d_NK8uTdP2uHXm07kAlwx8-Ictf8NocebIE).

    ```{r}
    #| echo: false
    #| fig-width: 4
    #| fig-alt: |
    #|   A spreadsheet with 3 columns (group, subgroup, and id) and 12 rows. The 
    #|   group column has two values: 1 (spanning 7 merged rows) and 2 (spanning 
    #|   5 merged rows). The subgroup column has four values: A (spanning 3 merged 
    #|   rows), B (spanning 4 merged rows), A (spanning 2 merged rows), and B 
    #|   (spanning 3 merged rows). The id column has twelve values, numbers 1 
    #|   through 12.

    knitr::include_graphics("screenshots/import-spreadsheets-roster.png")
    ```

    Στη συνέχεια, διαβάστε το στην R.
    Το πλαίσιο δεδομένων που προκύπτει θα πρέπει να ονομάζεται `roster` και θα πρέπει να μοιάζει με το ακόλουθο.

    ```{r}
    #| echo: false
    #| message: false

    read_excel("data/roster.xlsx") |>
      fill(group, subgroup) |>
      print(n = 12)
    ```

3.  Σε ένα νέο αρχείο Excel, δημιουργήστε το ακόλουθο σύνολο δεδομένων και αποθηκεύστε το ως `sales.xlsx`.
    Εναλλακτικά, μπορείτε να το κατεβάσετε ως αρχείο Excel από [εδώ](https://docs.google.com/spreadsheets/d/1oCqdXUNO8JR3Pca8fHfiz_WXWxMuZAp3YiYFaKze5V0).

    ```{r}
    #| echo: false
    #| fig-alt: |
    #|   A spreadsheet with 2 columns and 13 rows. The first two rows have text 
    #|   containing information about the sheet. Row 1 says "This file contains
    #|   information on sales". Row 2 says "Data are organized by brand name, and 
    #|   for each brand, we have the ID number for the item sold, and how many are 
    #|   sold.". Then there are two empty rows, and then 9 rows of data.

    knitr::include_graphics("screenshots/import-spreadsheets-sales.png")
    ```

    a.  Διαβάστε το `sales.xlsx` και αποθηκεύστε ως `sales`. Το πλαίσιο δεδομένων θα πρέπει να μοιάζει με το ακόλουθο, με τα `id` και `n` ως ονόματα στηλών και με 9 γραμμές.

    ```{r}
    #| echo: false
    #| message: false

    read_excel("data/sales.xlsx", skip = 3, col_names = c("id", "n")) |>
      print(n = 9)
    ```

    b.  Τροποποιήστε περαιτέρω το `sales` για να το μεταφέρετε στην ακόλουθη tidy μορφή με τρεις στήλες (`brand`, `id` και `n`) και 7 γραμμές. Σημειώστε ότι οι `id` και `n` είναι αριθμητικές, η `brand` είναι μεταβλητή χαρακτήρα.

    ```{r}
    #| echo: false
    #| message: false

    read_excel("data/sales.xlsx", skip = 3, col_names = c("id", "n")) |>
      mutate(brand = if_else(str_detect(id, "Brand"), id, NA)) |>
      fill(brand) |>
      filter(n != "n") |>
      relocate(brand) |>
      mutate(
        id = as.numeric(id),
        n = as.numeric(n)
      ) |>
      print(n = 7)
    ```

4.  Δημιουργήστε ξανά το πλαίσιο δεδομένων `bake_sale`, και γράψτε το σε ένα αρχείο Excel χρησιμοποιώντας τη συνάρτηση `write.xlsx()` από το πακέτο openxlsx.

5.  Στο @sec-data-import μάθατε για τη συνάρτηση `janitor::clean_names()` για τη μετατροπή των ονομάτων των στηλών σε snake case.
    Διαβάστε το αρχείο `students.xlsx` που παρουσιάσαμε νωρίτερα σε αυτήν την ενότητα και χρησιμοποιήστε αυτήν τη συνάρτηση για να "καθαρίσετε" τα ονόματα των στηλών.

6.  Τι συμβαίνει αν προσπαθήσετε να διαβάσετε σε ένα αρχείο με επέκταση `.xlsx` με την `read_xls()`;

## Google Sheets

Το Google Sheets είναι ένα άλλο ευρέως χρησιμοποιούμενο πρόγραμμα υπολογιστικών φύλλων.
Είναι δωρεάν και online.
Ακριβώς όπως και με το Excel, στο Google Sheets τα δεδομένα οργανώνονται σε φύλλα εργασίας μέσα σε αρχεία υπολογιστικών φύλλων.

### Προαπαιτούμενα

Αυτή η ενότητα θα επικεντρωθεί επίσης σε υπολογιστικά φύλλα, αλλά αυτή τη φορά θα φορτώνετε δεδομένα από ένα Google Sheet με το πακέτο **googlesheets4**.
Αυτό το πακέτο επίσης δεν είναι στο tidyverse, πρέπει να το φορτώσετε ξεχωριστά.

```{r}
library(googlesheets4)
library(tidyverse)
```

Μια γρήγορη σημείωση σχετικά με το όνομα του πακέτου: το googlesheets4 χρησιμοποιεί την έκδοση v4 του [Sheets API v4](https://developers.google.com/sheets/api/) για να παρέχει στην R μια δεπαφή στο Google Sheets, εξ ου και το όνομα.

### Ξεκινώντας

Η κύρια συνάρτηση του πακέτου googlesheets4 είναι η `read_sheet()`, η οποία διαβάζει ένα φύλλο Google από μία διεύθυνση URL ή ένα αναγνωριστικό αρχείου.
Αυτή η συνάρτηση έχει επίσης το όνομα `range_read()`.

Μπορείτε ακόμα να δημιουργήσετε ένα ολοκαίνουργιο φύλλο με την `gs4_create()` ή να γράψετε σε ένα υπάρχον φύλλο με την `sheet_write()` και τις σχετικές συναρτήσεις.

Σε αυτήν την ενότητα θα εργαστούμε με τα ίδια σύνολα δεδομένων με αυτά που είδαμε στην ενότητα του Excel, ώστε να επισημάνουμε ομοιότητες και διαφορές μεταξύ των ροών εργασίας για την ανάγνωση δεδομένων από το Excel και το Google Sheets.
Τα πακέτα readxl και googlesheets4 είναι σχεδιασμένα για να μιμούνται τη λειτουργικότητα του πακέτου readr, το οποίο παρέχει τη συνάρτηση `read_csv()` που έχετε δει στο @sec-data-import.
Επομένως, πολλές εργασίες μπορούν να επιτευχθούν με μία απλή αντικατάσταση της `read_excel()` με την `read_sheet()`.
Ωστόσο, θα δείτε ότι το Excel και το Google Sheets δεν συμπεριφέρονται με τον ίδιο ακριβώς τρόπο, επομένως κάποιες εργασίες ενδέχεται να απαιτούν επιπλέον αναβαθμίσεις στις κλήσεις των συναρτήσεων.

### Διαβάζοντας Google Sheets

Το @fig-students-googlesheets δείχνει πώς φαίνεται το υπολογιστικό φύλλο που πρόκειται να διαβάσουμε στην R στο Google Sheets.
Αυτό είναι το ίδιο σύνολο δεδομένων όπως και στο @fig-students-excel, με τη διαφορά ότι είναι αποθηκευμένο σε ένα Google Sheet αντί για Excel.

```{r}
#| label: fig-students-googlesheets
#| echo: false
#| fig-cap: |
#|   Google Sheet called students in a browser window.
#| fig-alt: |
#|   A look at the students spreadsheet in Google Sheets. The spreadsheet contains 
#|   information on 6 students, their ID, full name, favourite food, meal plan, 
#|   and age.

knitr::include_graphics("screenshots/import-googlesheets-students.png")
```

Το πρώτο όρισμα της `read_sheet()` είναι η διεύθυνση URL του αρχείου προς ανάγνωση και επιστρέφει ένα tibble: <https://docs.google.com/spreadsheets/d/1V1nPp1tzOuutXFLb3G9Eyxi3qxeEhnOXUzL5_BcCQ0w>.
Το να δουλεύεις με διευθύνσεις URL δεν είναι ό,τι πιο ευχάριστο, επομένως συχνά θα θέλετε να προσδιορίσετε ένα φύλλο με το αναγνωριστικό του.

```{r}
gs4_deauth()
```

```{r}
students_sheet_id <- "1V1nPp1tzOuutXFLb3G9Eyxi3qxeEhnOXUzL5_BcCQ0w"
students <- read_sheet(students_sheet_id)
students
```

Ακριβώς όπως κάναμε με την `read_excel()`, μπορούμε να παρέχουμε ονόματα στηλών, συμβολοσειρές NA και τύπους στηλών στην `read_sheet()`.

```{r}
students <- read_sheet(
  students_sheet_id,
  col_names = c("student_id", "full_name", "favourite_food", "meal_plan", "age"),
  skip = 1,
  na = c("", "N/A"),
  col_types = "dcccc"
)

students
```

Σημειώστε ότι ορίσαμε τους τύπους των στηλών λίγο διαφορετικά εδώ, χρησιμοποιώντας σύντομους κωδικούς.
Για παράδειγμα, το "dcccc" σημαίνει "double, character, character, character, character".

H ανάγνωση μεμονωμένων φύλλων από το Google Sheets είναι επίσης δυνατή.
Ας διαβάσουμε το φύλλο "Torgersen Island" από το [penguins Google Sheet](https://pos.it/r4ds-penguins):

```{r}
penguins_sheet_id <- "1aFu8lnD_g0yjF5O-K6SFgSEWiHPpgvFCF0NY9D6LXnY"
read_sheet(penguins_sheet_id, sheet = "Torgersen Island")
```

Μπορείτε να πάρετε μία λίστα με όλα τα φύλλα σε ένα Google Sheet με την `sheet_names()`:

```{r}
sheet_names(penguins_sheet_id)
```

Τέλος, όπως και με την `read_excel()`, μπορούμε να διαβάσουμε σε ένα τμήμα ενός Google Sheet ορίζοντας ένα `εύρος (range)` στην `read_sheet()`.
Σημειώστε επίσης ότι χρησιμοποιούμε τη συνάρτηση `gs4_example()` παρακάτω για να εντοπίσουμε ένα παράδειγμα Google Sheet που συνοδεύει το πακέτο googlesheets4.

```{r}
deaths_url <- gs4_example("deaths")
deaths <- read_sheet(deaths_url, range = "A5:F15")
deaths
```

### Γράφοντας σε Google Sheets

Μπορείτε να γράψετε από την R σε Google Sheets με την `write_sheet()`.
Το πρώτο όρισμα είναι το πλαίσιο δεδομένων που πρέπει να γραφτεί και το δεύτερο όρισμα είναι το όνομα (ή κάποιο άλλο αναγνωριστικό) του Google Sheet για εγγραφή:

```{r}
#| eval: false

write_sheet(bake_sale, ss = "bake-sale")
```

Εάν θέλετε να γράψετε τα δεδομένα σας σε ένα συγκεκριμένο φύλλο μέσα σε ένα Google Sheet, μπορείτε να το καθορίσετε και με το όρισμα `sheet`.

```{r}
#| eval: false

write_sheet(bake_sale, ss = "bake-sale", sheet = "Sales")
```

### Έλεγχος ταυτότητας

Ενώ μπορείτε να διαβάσετε από ένα δημόσιο Google Sheet χωρίς έλεγχο ταυτότητας με τον Google λογαρισμό σας και με την `gs4_deauth()`, η ανάγνωση ενός ιδιωτικού φύλλου ή η εγγραφή σε ένα φύλλο απαιτεί έλεγχο ταυτότητας, έτσι ώστε η googlesheets4 να μπορεί να προβάλλει και να διαχειρίζετε τα *δικά σας* Google Sheets.

Όταν επιχειρείτε να διαβάσετε ένα φύλλο που απαιτεί έλεγχο ταυτότητας, η googlesheets4 θα σας κατευθύνει σε ένα πρόγραμμα περιήγησης ιστού με ένα αντίστοιχο μήνυμα, για να συνδεθείτε στον Google λογαριασμό σας και να δώσετε άδεια λειτουργίας με το Google Sheets.
Ωστόσο, εάν θέλετε να καθορίσετε έναν συγκεκριμένο λογαριασμό Google, εύρος ελέγχου ταυτότητας κ.λπ., μπορείτε να το κάνετε με την `gs4_auth()`, η οποία θα επιβάλει τη χρήση ενός διακριτικού που σχετίζεται με ένα συγκεκριμένο email.
Για παράδειγμα: `gs4_auth(email = "mine@example.com")`.
Για περισσότερες λεπτομέρειες ελέγχου ταυτότητας, συνιστούμε να διαβάσετε τις οδηγίες της googlesheets4 περί ελέγχου ταυτότητας: <https://googlesheets4.tidyverse.org/articles/auth.html>.

### Ασκήσεις

1.  Διαβάστε το σύνολο δεδομένων `students` που συναντήσαμε νωρίτερα στο κεφάλαιο με το Excel, όπως και από Google Sheets, χωρίς να πρόσθετα ορίσματα στις συναρτήσεις `read_excel()` και `read_sheet()`.
    Είναι ακριβώς τα ίδια τα πλαίσια δεδομένων που προκύπτουν στην R;\
    Αν όχι, σε τι διαφέρουν;

2.  Διαβάστε το Google Sheet με όνομα survey από το <https://pos.it/r4ds-survey>, με την `survey_id"` ως μεταβλητή χαρακτήρα και την `n_pets` ως αριθμητική μεταβλητή.

3.  Διαβάστε το Google Sheet με όνομα roster από το <https://pos.it/r4ds-roster>.
    Το πλαίσιο δεδομένων που προκύπτει θα πρέπει να ονομάζεται `roster` και θα πρέπει να μοιάζει με το ακόλουθο.

    ```{r}
    #| echo: false
    #| message: false

    read_sheet("https://docs.google.com/spreadsheets/d/1LgZ0Bkg9d_NK8uTdP2uHXm07kAlwx8-Ictf8NocebIE/") |>
      fill(group, subgroup) |>
      print(n = 12)
    ```

## Σύνοψη

Το Microsoft Excel και το Google Sheets είναι δύο από τα πιο δημοφιλή συστήματα υπολογιστικών φύλλων.
Η δυνατότητα αλληλεπίδρασης με δεδομένα που είναι αποθηκευμένα σε αρχεία Excel και Google Sheets απευθείας από την R είναι μία υπερδύναμη!
Σε αυτό το κεφάλαιο μάθατε πώς να διαβάζετε δεδομένα στην R από υπολογιστικά φύλλα από το Excel με την `read_excel()`, με το πακέτο readxl, και από Google Sheets, με την `read_sheet()` από το πακέτο googlesheets4.
Αυτές οι συναρτήσεις λειτουργούν παρόμοια μεταξύ τους και έχουν παρόμοια ορίσματα για τον καθορισμό ονομάτων στηλών, συμβολοσειρών NA, γραμμών προς παράλειψη από την αρχή του αρχείου που διαβάζετε κ.λπ.
Επιπλέον, και οι δύο λειτουργίες καθιστούν δυνατή την ανάγνωση ενός μόνο φύλλου από ένα υπολογιστικό φύλλο.

Από την άλλη, η εγγραφή σε ένα αρχείο Excel απαιτεί διαφορετικό πακέτο και συνάρτηση (`writexl::write_xlsx()`), ενώ μπορείτε να γράψετε σε ένα Google Sheet με το πακέτο googlesheets4, χρησιμοποιώντας την `write_sheet()`.

Στο επόμενο κεφάλαιο, θα μάθετε για μία διαφορετική πηγή δεδομένων και πως να διαβάζετε δεδομένα από αυτήν στην R: τις βάσεις δεδομένων.
