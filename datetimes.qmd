# Ημερομηνίες και ώρες {#sec-dates-and-times}

```{r}
#| echo: false

source("_common.R")

# https://github.com/tidyverse/lubridate/issues/1058
options(warnPartialMatchArgs = FALSE)
```

## Εισαγωγή

Αυτό το κεφάλαιο θα σας δείξει πώς να εργάζεστε με ημερομηνίες και ώρες στην R.
Με μια πρώτη ματιά, οι ημερομηνίες και οι ώρες φαίνονται απλές.
Τα χρησιμοποιείτε όλη την ώρα στην κανονική σας ζωή και δεν φαίνεται να προκαλούν μεγάλη σύγχυση.
Ωστόσο, όσο περισσότερα μαθαίνετε για τις ημερομηνίες και τις ώρες, τόσο πιο περίπλοκες φαίνονται να γίνονται!

Για να προετοιμαστείτε, σκεφτείτε πόσες ημέρες υπάρχουν σε ένα χρόνο και πόσες ώρες σε μια μέρα.
Πιθανότατα θυμηθήκατε ότι τα περισσότερα χρόνια έχουν 365 ημέρες, αλλά τα δίσεκτα έχουν 366.
Γνωρίζετε τον πλήρη κανόνα για να προσδιορίσετε εάν ένα έτος είναι δίσεκτο[^datetimes-1]; Ο αριθμός των ωρών σε μια ημέρα είναι λίγο λιγότερο προφανής: οι περισσότερες μέρες έχουν 24 ώρες, αλλά σε μέρη που χρησιμοποιούν θερινή ώρα (DST), μια μέρα κάθε χρόνο έχει 23 ώρες και μια άλλη έχει 25.

[^datetimes-1]: Ένα έτος είναι δίσεκτο εάν διαιρείται με το 4, εκτός αν διαιρείται επίσης με το 100, εκτός εάν διαιρείται επίσης με το 400.
    Με άλλα λόγια, σε κάθε σύνολο 400 ετών, υπάρχουν 97 δίσεκτα έτη.

Οι ημερομηνίες και οι ώρες είναι δύσκολες γιατί πρέπει να συμβιβάσουν δύο φυσικά φαινόμενα (την περιστροφή της Γης και την τροχιά της γύρω από τον ήλιο) με μια ολόκληρη σειρά γεωπολιτικών φαινομένων, συμπεριλαμβανομένων των μηνών, των ζωνών ώρας και της θερινής ώρας.
Αυτό το κεφάλαιο δεν θα σας διδάξει και την παραμικρή λεπτομέρεια σχετικά με τις ημερομηνίες και τις ώρες, αλλά θα σας δώσει μια σταθερή βάση πρακτικών δεξιοτήτων που θα σας βοηθήσουν με κοινές προκλήσεις ανάλυσης δεδομένων.

Θα ξεκινήσουμε δείχνοντάς σας πώς να δημιουργείτε ημερομηνίες-ώρες από διάφορες εισόδους και, στη συνέχεια, αφού έχετε μια ημερομηνία-ώρα, πώς μπορείτε να εξαγάγετε στοιχεία όπως το έτος, ο μήνας και η ημέρα.
Στη συνέχεια, θα βουτήξουμε στο δύσκολο θέμα της εργασίας με χρονικά διαστήματα, τα οποία είναι διαθέσιμα σε εύρος επιλογών ανάλογα με το τι προσπαθείτε να κάνετε.
Θα κλείσουμε με μια σύντομη συζήτηση των πρόσθετων προκλήσεων που δημιουργούν οι ζώνες ώρας.

### Προαπαιτούμενα

Αυτό το κεφάλαιο θα επικεντρωθεί στο πακέτο **lubridate**, το οποίο διευκολύνει την εργασία με ημερομηνίες και ώρες στην R.
Από την τελευταία κυκλοφορία του tidyverse, το lubridate αποτελεί μέρος του core tidyverse.
Θα χρειαστούμε επίσης το nycflights13 για δεδομένα εξάσκησης.

```{r}
#| message: false
library(tidyverse)
library(nycflights13)
```

## Δημιουργώντας ημερομηνίες/ώρες {#sec-creating-datetimes}

Υπάρχουν τρεις τύποι δεδομένων ημερομηνίας/ώρας που αναφέρονται σε μια συγκεκριμένη χρονική στιγμή:

-   Μια ημερομηνία **date**.
    Τα tibbles την εκτυπώνουν ως `<date>`.

-   Μια ώρα **time** μέσα σε μια μέρα.
    Τα tibbles την εκτυπώνουν ως `<time>`.

-   Μια **ημερομηνία-ώρα** είναι ο συνδυασμός μιας ημερομηνίας με μια ώρα και προσδιορίζει μοναδικά μια στιγμή στο χρόνο (συνήθως στο πλησιέστερο δευτερόλεπτο).
    Τα tibbles την εκτυπώνουν ως `<dttm>`.
    Η βασική έκδοση της R τα ονομάζει POSIXct, όχι και το πιο εύκολο να το προφέρουμε όνομα.

Σε αυτό το κεφάλαιο θα εστιάσουμε σε ημερομηνίες και ημερομηνίες-ώρες, καθώς η R δεν έχει εγγενή κλάση για την αποθήκευση της ώρας μόνο.

Εάν χρειάζεστε κάτι τέτοιο, μπορείτε να χρησιμοποιήσετε το πακέτο **hms**.

Θα πρέπει πάντα να χρησιμοποιείτε τον απλούστερο δυνατό τύπο δεδομένων που λειτουργεί για τις ανάγκες σας.
Αυτό σημαίνει ότι αν μπορείτε να χρησιμοποιήσετε μια ημερομηνία αντί για μια ημερομηνία-ώρα, θα είναι καλύτερα να το κάνετε.
Οι ημερομηνίες-ώρες είναι πολύ πιο περίπλοκες λόγω της ανάγκης χειρισμού των ζωνών ώρας, στις οποίες θα επανέλθουμε στο τέλος του κεφαλαίου.

Για να λάβετε την τρέχουσα ημερομηνία ή ημερομηνία-ώρα, μπορείτε να χρησιμοποιήσετε τις συναρτήσεις `today()` ή `now()`:

```{r}
today()
now()
```

Εναλλακτικά, οι ακόλουθες ενότητες περιγράφουν τους τέσσερις τρόπους με τους οποίους μπορείτε να δημιουργήσετε μια ημερομηνία/ώρα:

-   Κατά την ανάγνωση ενός αρχείου με τη readr.
-   Από μια συμβολοσειρά.
-   Από μεμονωμένα στοιχεία ημερομηνίας-ώρας.
-   Από ένα υπάρχον αντικείμενο ημερομηνίας/ώρας.

### Κατά την εισαγωγή

Εάν το CSV αρχείο σας περιέχει μια ημερομηνία ή ημερομηνία-ώρα που ακολουθεί το πρότυπο ISO8601, δεν χρειάζεται να κάνετε τίποτα - η readr θα το αναγνωρίσει αυτόματα:

```{r}
#| message: false
csv <- "
  date,datetime
  2022-01-02,2022-01-02 05:12
"
read_csv(csv)
```

Εάν δεν έχετε ακούσει για το **ISO8601** πριν, είναι ένα διεθνές πρότυπο[^datetimes-2] για τη σύνταξη ημερομηνιών όπου τα στοιχεία μιας ημερομηνίας είναι οργανωμένα από το μεγαλύτερο στο μικρότερο και χωρίζονται με `-`. Για παράδειγμα, στο ISO8601, η 3 Μαΐου 2022 γράφετε ως `2022-05-03`. Οι ημερομηνίες ISO8601 μπορούν επίσης να περιλαμβάνουν ώρες, όπου οι ώρες, τα λεπτά και τα δευτερόλεπτα διαχωρίζονται με `:` και τα στοιχεία ημερομηνίας και ώρας διαχωρίζονται είτε με ένα `T` ή ένα διάστημα.
Για παράδειγμα, θα μπορούσατε να γράψετε 4:26 μ.μ.
στις 3 Μαΐου 2022 είτε ως `2022-05-03 16:26` είτε ως `2022-05-03T16:26`.

[^datetimes-2]: <https://xkcd.com/1179/>

Για άλλες μορφές ημερομηνίας-ώρας, θα χρειαστεί να χρησιμοποιήσετε τα ορίσματα `col_types` και `col_date()` ή `col_datetime()` μαζί με ένα πρότυπο ημερομηνίας-ώρας.
Το πρότυπο ημερομηνίας-ώρας που χρησιμοποιείται από τη readr είναι ένα πρότυπο που χρησιμοποιείται σε πολλές γλώσσες προγραμματισμού, και περιγράφει ένα στοιχείο ημερομηνίας με ένα `%` ακολουθούμενο από έναν μόνο χαρακτήρα.
Για παράδειγμα, το `%Y-%m-%d` καθορίζει μια ημερομηνία που αφορά ένα έτος, `-`, μήνα (ως αριθμό) `-`, ημέρα.
Ο πίνακας @tbl-date-formats παραθέτει όλες τις επιλογές.

| Τύπος | Κωδικός | Εξήγηση                        | Παράδειγμα      |
|-------|---------|--------------------------------|-----------------|
| Year  | `%Y`    | 4 digit year                   | 2021            |
|       | `%y`    | 2 digit year                   | 21              |
| Month | `%m`    | Number                         | 2               |
|       | `%b`    | Abbreviated name               | Feb             |
|       | `%B`    | Full name                      | February        |
| Day   | `%d`    | One or two digits              | 2               |
|       | `%e`    | Two digits                     | 02              |
| Time  | `%H`    | 24-hour hour                   | 13              |
|       | `%I`    | 12-hour hour                   | 1               |
|       | `%p`    | AM/PM                          | pm              |
|       | `%M`    | Minutes                        | 35              |
|       | `%S`    | Seconds                        | 45              |
|       | `%OS`   | Seconds with decimal component | 45.35           |
|       | `%Z`    | Time zone name                 | America/Chicago |
|       | `%z`    | Offset from UTC                | +0800           |
| Other | `%.`    | Skip one non-digit             | :               |
|       | `%*`    | Skip any number of non-digits  |                 |

: Όλα τα πρότυπο που γίνονται κατανοητά από τη readr {#tbl-date-formats}

Και ο παρακάτω κώδικας δείχνει την εφαρμογή μερικών επιλογών σε μια πολύ ασαφή ημερομηνία:

```{r}
#| messages: false

csv <- "
  date
  01/02/15
"

read_csv(csv, col_types = cols(date = col_date("%m/%d/%y")))

read_csv(csv, col_types = cols(date = col_date("%d/%m/%y")))

read_csv(csv, col_types = cols(date = col_date("%y/%m/%d")))
```

Λάβετε υπόψη ότι ανεξάρτητα από το πώς προσδιορίζετε τη μορφή της ημερομηνίας, εμφανίζεται πάντα με τον ίδιο τρόπο μόλις τη διαβάσετε στην R.

Εάν χρησιμοποιείτε το `%b` ή το `%B` και εργάζεστε με μη αγγλικές ημερομηνίες, θα πρέπει επίσης να παρέχετε ένα `locale()`.
Δείτε τη λίστα των ενσωματωμένων γλωσσών με την συνάρτηση `date_names_langs()` ή δημιουργήστε τη δική σας με τη `date_names()`,

### Από συμβολοσειρές

Η γλώσσα προσδιορισμού της ημερομηνίας-ώρας είναι ένα ισχυρό όρισμα, αλλά απαιτεί προσεκτική ανάλυση του προτύπου γραφής της ημερομηνίας.
Μια εναλλακτική προσέγγιση είναι η χρήση βοηθητικών συναρτήσεων της lubridate που προσπαθούν να προσδιορίσουν αυτόματα τη μορφή μόλις καθορίσετε τη σειρά των διαφόρων στοιχείων.
Για να τις χρησιμοποιήσετε, προσδιορίστε τη σειρά με την οποία εμφανίζονται το έτος, ο μήνας και η ημέρα στις ημερομηνίες σας και, στη συνέχεια, τακτοποιήστε τα "y", "m" και "d" με την ίδια σειρά.
Αυτό σας δίνει το όνομα της lubridate συνάρτησης που θα αναλύσει την ημερομηνία σας.
Για παράδειγμα:

```{r}
ymd("2017-01-31")
mdy("January 31st, 2017")
dmy("31-Jan-2017")
```

Η `ymd()` και οι όμοιες της συναρτήσεις δημιουργούν ημερομηνίες.
Για να δημιουργήσετε μια ημερομηνία-ώρα, προσθέστε μια υπογράμμιση και ένα ή περισσότερα από τα "h", "m" και "s" στο όνομα της συνάρτησης που διαβάζει την ημερομηνία:

```{r}
ymd_hms("2017-01-31 20:11:59")
mdy_hm("01/31/2017 08:01")
```

Μπορείτε επίσης να επιβάλετε τη δημιουργία μιας ημερομηνίας-ώρας από μια ημερομηνία παρέχοντας μια ζώνη ώρας:

```{r}
ymd("2017-01-31", tz = "UTC")
```

Εδώ χρησιμοποιώ τη ζώνη ώρας UTC[^datetimes-3], την οποία ίσως γνωρίζετε και ως GMT, ή ώρα Γκρίνουιτς, την ώρα δηλαδή σε γεωγραφικό μήκος 0°[^datetimes-4]
. Δεν χρησιμοποιεί θερινή ώρα, καθιστώντας λίγο πιο εύκολους τους υπολογισμού
ς

[^datetimes-3]: Ίσως αναρωτιέστε τι σημαίνει το UTC.
    Είναι ένας συμβιβασμός μεταξύ του αγγλικού "Coordinated Universal Time" και του γαλλικού "Temps Universel Coordonné".

[^datetimes-4]: Δεν υπάρχει κάποιο βραβείο αν καταφέρετε να μαντέψετε ποια χώρα δημιούργησε το σύστημα γεωγραφικού μήκους.

### Από μεμονωμένα στοιχεία

Αντί για μία συμβολοσειρά, μερικές φορές θα έχετε τα μεμονωμένα στοιχεία της ημερομηνίας-ώρας κατανεμημένα σε πολλές στήλες.
Αυτό έχουμε στα δεδομένα του `flights`:

```{r}
flights |> 
  select(year, month, day, hour, minute)
```

Για να δημιουργήσετε μια ημερομηνία/ώρα από αυτό το είδος εισόδου, χρησιμοποιήστε τη `make_date()` για ημερομηνίες ή το `make_datetime()` για τις ημερομηνίες-ώρες:

```{r}
flights |> 
  select(year, month, day, hour, minute) |> 
  mutate(departure = make_datetime(year, month, day, hour, minute))
```

Ας κάνουμε το ίδιο πράγμα για καθεμία από τις τέσσερις στήλες του `flights` με δεδομένα ημερομηνίας.
Οι ώρες αναπαρίστανται σε μια ελαφρώς περίεργη μορφή, επομένως χρησιμοποιούμε αριθμητική υπολοίπων για να εξάγουμε τα στοιχεία της ώρας και των λεπτών.
Αφού δημιουργήσουμε τις μεταβλητές ημερομηνίας-ώρας, εστιάζουμε στις μεταβλητές που θα εξερευνήσουμε στο υπόλοιπο κεφάλαιο.

```{r}
make_datetime_100 <- function(year, month, day, time) {
  make_datetime(year, month, day, time %/% 100, time %% 100)
}

flights_dt <- flights |> 
  filter(!is.na(dep_time), !is.na(arr_time)) |> 
  mutate(
    dep_time = make_datetime_100(year, month, day, dep_time),
    arr_time = make_datetime_100(year, month, day, arr_time),
    sched_dep_time = make_datetime_100(year, month, day, sched_dep_time),
    sched_arr_time = make_datetime_100(year, month, day, sched_arr_time)
  ) |> 
  select(origin, dest, ends_with("delay"), ends_with("time"))

flights_dt
```

Με αυτά τα δεδομένα μπορούμε να απεικονίσουμε την κατανομή των ωρών αναχώρησης κατά τη διάρκεια του έτους:

```{r}
#| fig.alt: >
#|   A frequency polyon with departure time (Jan-Dec 2013) on the x-axis
#|   and number of flights on the y-axis (0-1000). The frequency polygon
#|   is binned by day so you see a time series of flights by day. The
#|   pattern is dominated by a weekly pattern; there are fewer flights 
#|   on weekends. The are few days that stand out as having a surprisingly
#|   few flights in early February, early July, late November, and late
#|   December.
flights_dt |> 
  ggplot(aes(x = dep_time)) + 
  geom_freqpoly(binwidth = 86400) # 86400 seconds = 1 day
```

Ή στη διάρκεια μιας μέρας:

```{r}
#| fig.alt: >
#|   A frequency polygon with departure time (6am - midnight Jan 1) on the
#|   x-axis, number of flights on the y-axis (0-17), binned into 10 minute
#|   increments. It's hard to see much pattern because of high variability,
#|   but most bins have 8-12 flights, and there are markedly fewer flights 
#|   before 6am and after 8pm.
flights_dt |> 
  filter(dep_time < ymd(20130102)) |> 
  ggplot(aes(x = dep_time)) + 
  geom_freqpoly(binwidth = 600) # 600 s = 10 minutes
```

Σημειώστε ότι όταν χρησιμοποιείτε ημερομηνίες-ώρες σε ένα αριθμητικό πλαίσιο (όπως για παράδειγμα σε ένα ιστόγραμμα), το 1 σημαίνει 1 δευτερόλεπτο, επομένως ένα πλάτος bin 86400 σημαίνει μία ημέρα.
Για ημερομηνίες, 1 σημαίνει 1 ημέρα.

### Από άλλους τύπους

Μπορεί να θέλετε να κάνετε εναλλαγή μεταξύ ημερομηνίας-ώρας και ημερομηνίας.
Αυτή είναι η δουλειά των `as_datetime()` και `as_date()`:

```{r}
as_datetime(today())
as_date(now())
```

Μερικές φορές θα λάβετε δεδομένα ημερομηνίας/ώρας ως αριθμητικές μετατοπίσεις από την "Unix εποχή", δηλαδή από την 1970-01-01.
Εάν η μετατόπιση είναι σε δευτερόλεπτα, χρησιμοποιήστε το `as_datetime()`, ενώ εάν είναι σε ημέρες, χρησιμοποιήστε το `as_date()`.

```{r}
as_datetime(60 * 60 * 10)
as_date(365 * 10 + 2)
```

### Ασκήσεις

1.  Τι συμβαίνει εαν διαβάσετε μια συμβολοσιερά που περιέχει μη έγκυρες ημερομηνίες;

    ```{r}
    #| eval: false

    ymd(c("2010-10-10", "bananas"))
    ```

2.  Ποιος είναι ο ρόλος του ορίσματος `tzone` στη συνάρτηση `today()`; Γιατί είναι σημαντικό;

3.  Για κάθε μία από τις παρακάτω ημερομηνίες-ώρες δείξτε πως θα τις διαβάζατε χρησιμοποιώντας προδιαγραφές στηλών από τη readr και μία από τις συναρτήσεις της lubridate.

    ```{r}
    d1 <- "January 1, 2010"
    d2 <- "2015-Mar-07"
    d3 <- "06-Jun-2017"
    d4 <- c("August 19 (2015)", "July 1 (2015)")
    d5 <- "12/30/14" # Dec 30, 2014
    t1 <- "1705"
    t2 <- "11:15:10.12 PM"
    ```

## Στοιχεία ημερομηνίας-ώρας

Τώρα που ξέρετε πώς να μεταφέρετε δεδομένα ημερομηνίας-ώρας στις δομές δεδομένων ημερομηνίας-ώρας της R, ας εξερευνήσουμε τι μπορείτε να κάνετε με αυτά.
Αυτή η ενότητα θα επικεντρωθεί στις λειτουργίες του accessor που σας επιτρέπουν να λαμβάνετε και να ορίζετε μεμονωμένα στοιχεία.
Η επόμενη ενότητα θα εξετάσει πώς λειτουργεί η αριθμητική σε δεδομένα ημερομηνίας-ώρας.

### Εξαγωγή στοιχείων

Μπορείτε να εξάγετε μεμονωμένα μέρη της ημερομηνίας με τις συναρτήσεις της accessor `year()`, `month()`, `mday()` (ημέρα του μήνα), `yday()` (ημέρα του έτους), `wday()` (ημέρα της εβδομάδας), `hour()`, `minute()` και `second()`.
Αυτές είναι ουσιαστικά το αντίθετο της `make_datetime()`.

```{r}
datetime <- ymd_hms("2026-07-08 12:34:56")

year(datetime)
month(datetime)
mday(datetime)

yday(datetime)
wday(datetime)
```

Για τις `month()` και `wday()` μπορείτε να ορίσετε το `label = TRUE` για να επιστρέφει τη συντομογραφία του μήνα ή της ημέρας της εβδομάδας.
Ορίστε `abbr = FALSE` για να λαμβάνετε το πλήρες όνομα.

```{r}
month(datetime, label = TRUE)
wday(datetime, label = TRUE, abbr = FALSE)
```

Μπορούμε να χρησιμοποιήσουμε τη `wday()` για να δούμε ότι περισσότερες πτήσεις αναχωρούν στη διάρκεια της εβδομάδας παρά κατά το σαββατοκύριακο:

```{r}
#| fig-alt: |
#|   A bar chart with days of the week on the x-axis and number of 
#|   flights on the y-axis. Monday-Friday have roughly the same number of
#|   flights, ~48,0000, decreasingly slightly over the course of the week.
#|   Sunday is a little lower (~45,000), and Saturday is much lower 
#|   (~38,000).
flights_dt |> 
  mutate(wday = wday(dep_time, label = TRUE)) |> 
  ggplot(aes(x = wday)) +
  geom_bar()
```

Μπορούμε επίσης να δούμε τη μέση καθυστέρηση αναχώρησης ανά λεπτό μέσα στην ώρα.
Υπάρχει ένα ενδιαφέρον μοτίβο: οι πτήσεις που αναχωρούν μεταξύ των λεπτών 20-30 και 50-60 έχουν πολύ μικρότερες καθυστερήσεις από πτήσεις που αναχωρούν την υπόλοιπη ώρα!

```{r}
#| fig-alt: | 
#|   A line chart with minute of actual departure (0-60) on the x-axis and
#|   average delay (4-20) on the y-axis. Average delay starts at (0, 12),
#|   steadily increases to (18, 20), then sharply drops, hitting at minimum
#|   at ~23 minute past the hour and 9 minutes of delay. It then increases
#|   again to (17, 35), and sharply decreases to (55, 4). It finishes off
#|   with an increase to (60, 9).
flights_dt |> 
  mutate(minute = minute(dep_time)) |> 
  group_by(minute) |> 
  summarize(
    avg_delay = mean(dep_delay, na.rm = TRUE),
    n = n()
  ) |> 
  ggplot(aes(x = minute, y = avg_delay)) +
  geom_line()
```

Είναι ενδιαφέρον ότι, αν κοιτάξουμε την *προγραμματισμένη* ώρα αναχώρησης, δεν βλέπουμε τόσο ισχυρό μοτίβο:

```{r}
#| fig-alt: | 
#|   A line chart with minute of scheduled departure (0-60) on the x-axis
#|   and average delay (4-16). There is relatively little pattern, just a
#|   small suggestion that the average delay decreases from maybe 10 minutes
#|   to 8 minutes over the course of the hour.
sched_dep <- flights_dt |> 
  mutate(minute = minute(sched_dep_time)) |> 
  group_by(minute) |> 
  summarize(
    avg_delay = mean(arr_delay, na.rm = TRUE),
    n = n()
  )

ggplot(sched_dep, aes(x = minute, y = avg_delay)) +
  geom_line()
```

Γιατί λοιπόν βλέπουμε αυτό το μοτίβο με τις πραγματικές ώρες αναχώρησης; Λοιπόν, όπως πολλά δεδομένα που συλλέγονται από ανθρώπους, υπάρχει μια ισχυρή προκατάληψη για πτήσεις που αναχωρούν σε «ωραίες» ώρες αναχώρησης, όπως δείχνει το @fig-human-rounding.
Να είστε πάντα σε εγρήγορση για αυτού του είδους τα μοτίβα κάθε φορά που εργάζεστε με δεδομένα που περιλαμβάνουν ανθρώπινη κρίση!

```{r}
#| label: fig-human-rounding
#| fig-cap: |
#|   A frequency polygon showing the number of flights scheduled to 
#|   depart each hour. You can see a strong preference for round numbers
#|   like 0 and 30 and generally for numbers that are a multiple of five.
#| fig-alt: |
#|   A line plot with departure minute (0-60) on the x-axis and number of
#|   flights (0-60000) on the y-axis. Most flights are scheduled to depart
#|   on either the hour (~60,000) or the half hour (~35,000). Otherwise,
#|   all most all flights are scheduled to depart on multiples of five, 
#|   with a few extra at 15, 45, and 55 minutes.
#| echo: false
ggplot(sched_dep, aes(x = minute, y = n)) +
  geom_line()
```

### Στρογγλοποίηση

Μια εναλλακτική προσέγγιση για τη γραφική αναπαράσταση μεμονωμένων στοιχείων είναι η στρογγυλοποίηση της ημερομηνίας σε μια κοντινή μονάδα χρόνου, χρησιμοποιώντας τις `floor_date()`, `round_date()`, και `ceiling_date()` Κάθε συνάρτηση χρειάζεται ένα διάνυσμα ημερομηνιών για προσαρμογή και, στη συνέχεια, το όνομα της μονάδας για στρογγυλοποίηση προς τα κάτω (floor), προς τα πάνω (ceiling) ή προς σε αυτή.
Αυτό, για παράδειγμα, μας επιτρέπει να αναπαραστίσουμε τον αριθμό των πτήσεων ανά εβδομάδα:

```{r}
#| fig-alt: |
#|   A line plot with week (Jan-Dec 2013) on the x-axis and number of
#|   flights (2,000-7,000) on the y-axis. The pattern is fairly flat from
#|   February to November with around 7,000 flights per week. There are
#|   far fewer flights on the first (approximately 4,500 flights) and last
#|   weeks of the year (approximately 2,500 flights).
flights_dt |> 
  count(week = floor_date(dep_time, "week")) |> 
  ggplot(aes(x = week, y = n)) +
  geom_line() + 
  geom_point()
```

Μπορείτε να χρησιμοποιήσετε τη στρογγυλοποίηση για να παρουσιάσετε την κατανομή των πτήσεων στη διάρκεια μιας ημέρας, υπολογίζοντας τη διαφορά μεταξύ του `dep_time` και της νωρίτερης στιγμής εκείνης της ημέρας:

```{r}
#| fig-alt: |
#|   A line plot with depature time on the x-axis. This is units of seconds
#|   since midnight so it's hard to interpret.
flights_dt |> 
  mutate(dep_hour = dep_time - floor_date(dep_time, "day")) |> 
  ggplot(aes(x = dep_hour)) +
  geom_freqpoly(binwidth = 60 * 30)
```

Ο υπολογισμός της διαφοράς μεταξύ ενός ζεύγους τιμών ημερομηνίας-ώρας επιστρέφει ένα difftime (θα δούμε περισσότερα για αυτό στα @sec-intervals).
Μπορούμε να το μετατρέψουμε σε αντικείμενο `hms` για να πάρουμε έναν πιο χρήσιμο άξονα x:

```{r}
#| fig-alt: |
#|   A line plot with depature time (midnight to midnight) on the x-axis
#|   and number of flights on the y-axis (0 to 15,000). There are very few
#|   (<100) flights before 5am. The number of flights then rises rapidly 
#|   to 12,000 / hour, peaking at 15,000 at 9am, before falling to around
#|   8,000 / hour for 10am to 2pm. Number of flights then increases to
#|   around 12,000 per hour until 8pm, when they rapidly drop again. 
flights_dt |> 
  mutate(dep_hour = hms::as_hms(dep_time - floor_date(dep_time, "day"))) |> 
  ggplot(aes(x = dep_hour)) +
  geom_freqpoly(binwidth = 60 * 30)
```

### Τροποποίηση στοιχείων

Μπορείτε επίσης να χρησιμοποιήσετε κάθε συνάρτηση της accessor για να τροποποιήσετε τα στοιχεία μιας ημερομηνίας/ώρας.
Αυτό δεν συναντάται ιδιαίτερα στην ανάλυση δεδομένων, αλλά μπορεί να είναι χρήσιμο κατά τον καθαρισμό δεδομένων που έχουν σαφώς εσφαλμένες ημερομηνίες.

```{r}
(datetime <- ymd_hms("2026-07-08 12:34:56"))

year(datetime) <- 2030
datetime
month(datetime) <- 01
datetime
hour(datetime) <- hour(datetime) + 1
datetime
```

Εναλλακτικά, αντί να τροποποιήσετε μια υπάρχουσα μεταβλητή, μπορείτε να δημιουργήσετε μια νέα ημερομηνία-ώρα με την `update()`.
Αυτό σας επιτρέπει επίσης να ορίσετε πολλές τιμές σε ένα βήμα:

```{r}
update(datetime, year = 2030, month = 2, mday = 2, hour = 2)
```

Εάν οι τιμές είναι πολύ μεγάλες, θα τροποποιηθούν αντίστοιχα (?):

```{r}
update(ymd("2023-02-01"), mday = 30)
update(ymd("2023-02-01"), hour = 400)
```

### Ασκήσεις

1.  Πώς αλλάζει η κατανομή των χρόνων πτήσης μέσα σε μια ημέρα κατά τη διάρκεια του έτους;

2.  Συγκρίνετε τις `dep_time`, `sched_dep_time` και `dep_delay`.
    Είναι συνεπείς; Εξηγήστε τα ευρήματά σας.

3.  Συγκρίνετε τη μεταβλητή `air_time` με τη διάρκεια μεταξύ της αναχώρησης και της άφιξης.
    Εξηγήστε τα ευρήματά σας.
    (Υπόδειξη: λάβετε υπόψη την τοποθεσία του αεροδρομίου.)

4.  Πώς αλλάζει ο μέσος χρόνος καθυστέρησης κατά τη διάρκεια μιας ημέρας; Θα πρέπει να χρησιμοποιήσετε το `dep_time` ή το `sched_dep_time`; Γιατί;

5.  Ποια ημέρα της εβδομάδας πρέπει να φύγετε αν θέλετε να ελαχιστοποιήσετε την πιθανότητα καθυστέρησης;

6.  Τι κάνει την κατανομή των `diamonds$carat` και `flights$sched_dep_time` παρόμοια;

7.  Επιβεβαιώστε την υπόθεσή μας ότι οι πρόωρες αναχωρήσεις πτήσεων στα λεπτά 20-30 και 50-60 προκαλούνται από προγραμματισμένες πτήσεις που αναχωρούν νωρίς.
    Υπόδειξη: δημιουργήστε μια δυαδική μεταβλητή που σας ενημερώνει εάν μια πτήση καθυστέρησε ή όχι.

## Χρονικά διαστήματα

Στη συνέχεια θα μάθετε πώς λειτουργεί η αριθμητική με ημερομηνίες, συμπεριλαμβανομένης της αφαίρεσης, της πρόσθεσης και της διαίρεσης.
Στην πορεία, θα μάθετε για τρεις σημαντικές κλάσεις που αντιπροσωπεύουν χρονικά διαστήματα:

-   **Durations** (διάρκειες), που αντιπροσωπεύουν έναν ακριβή αριθμό δευτερολέπτων.
-   **Periods** (περίοδοι), που αντιπροσωπεύουν ανθρώπινες μονάδες μέτρησης του χρόνου, όπως εβδομάδες και μήνες.
-   **Intervals** (διαστήματα), τα οποία αντιπροσωπεύουν ένα σημείο αρχής και τέλους

Πώς επιλέγετε μεταξύ διάρκειας, περιόδων και διαστημάτων; Όπως πάντα, επιλέξτε την απλούστερη δομή δεδομένων που λύνει το πρόβλημά σας.
Εάν ενδιαφέρεστε μόνο για τον φυσικό χρόνο, χρησιμοποιήστε τη διάρκεια.
Εάν χρειάζεται να προσθέσετε ανθρώπινους χρόνους, χρησιμοποιήστε μια περίοδο εάν πρέπει να υπολογίσετε πόσο μεγάλο είναι ένα διάστημα σε ανθρώπινες μονάδες, χρησιμοποιήστε ένα διάστημα.

### Διάρκεια

Στο R, όταν αφαιρείτε δύο ημερομηνίες, λαμβάνετε ένα αντικείμενο difftime:

```{r}
# How old is Hadley?
h_age <- today() - ymd("1979-10-14")
h_age
```

Ένα αντικείμενο κλάσης `difftime` καταγράφει ένα χρονικό διάστημα δευτερολέπτων, λεπτών, ωρών, ημερών ή εβδομάδων.
Αυτή η ασάφεια μπορεί να δυσκολέψει την εργασία με τα difftimes, οπότε η lubridate παρέχει μια εναλλακτική λύση που χρησιμοποιεί πάντα δευτερόλεπτα: τη **διάρκεια** (duration).

```{r}
as.duration(h_age)
```

Οι διάρκειες συνοδεύονται από μια σειρά από βολικές συναρτήσεις για την κατασκευή τους:

```{r}
dseconds(15)
dminutes(10)
dhours(c(12, 24))
ddays(0:5)
dweeks(3)
dyears(1)
```

Οι διάρκειες καταγράφουν πάντα το χρονικό διάστημα σε δευτερόλεπτα.
Μεγαλύτερες μονάδες δημιουργούνται μετατρέποντας λεπτά, ώρες, ημέρες, εβδομάδες και χρόνια σε δευτερόλεπτα: 60 δευτερόλεπτα σε ένα λεπτό, 60 λεπτά σε μια ώρα, 24 ώρες την ημέρα και 7 ημέρες την εβδομάδα.
Οι μεγαλύτερες μονάδες χρόνου είναι πιο προβληματικές.
Ένα έτος χρησιμοποιεί τον «μέσο» αριθμό ημερών σε ένα έτος, δηλαδή 365,25.
Δεν υπάρχει τρόπος να μετατραπεί ένας μήνας σε διάρκεια, γιατί απλώς υπάρχει υπερβολική διακύμανση.

Επίσης, μπορείτε να προσθέσετε και να πολλαπλασιάσετε τις διάρκειες:

```{r}
2 * dyears(1)
dyears(1) + dweeks(12) + dhours(15)
```

Μπορείτε να προσθέσετε και να αφαιρέσετε διάρκειες σε και από ημέρες:

```{r}
tomorrow <- today() + ddays(1)
last_year <- today() - dyears(1)
```

Ωστόσο, επειδή οι διάρκειες αντιπροσωπεύουν έναν ακριβή αριθμό δευτερολέπτων, μερικές φορές μπορεί να έχετε ένα απροσδόκητο αποτέλεσμα:

```{r}
one_am <- ymd_hms("2026-03-08 01:00:00", tz = "America/New_York")

one_am
one_am + ddays(1)
```

Γιατί μια μέρα μετά τη 1 π.μ.
της 8 Μαρτίου, είναι 2 π.μ.
9 Μαρτίου; Εάν κοιτάξετε προσεκτικά την ημερομηνία, μπορεί επίσης να παρατηρήσετε ότι οι ζώνες ώρας έχουν αλλάξει.
Η 8η Μαρτίου έχει μόνο 23 ώρες, επειδή είναι η έναρξη της θερινής ώρας, οπότε αν προσθέσουμε ολόκληρες ημέρες σύμφωνα με τη διάρκεια τους σε δευτερόλεπτα, καταλήγουμε σε διαφορετική ώρα.

### Περίοδος

Για την επίλυση αυτού του προβλήματος, η lubridate παρέχει **περιόδους**.
Οι περίοδοι είναι χρονικά διαστήματα, αλλά δεν έχουν σταθερή διάρκεια σε δευτερόλεπτα.
Αντίθετα λειτουργούν με «ανθρώπινους» χρόνους, όπως ημέρες και μήνες.
Αυτό τους επιτρέπει να εργάζονται με πιο διαισθητικό τρόπο:

```{r}
one_am
one_am + days(1)
```

Όπως οι διάρκειες, οι περίοδοι μπορούν να δημιουργηθούν με μια σειρά από βοητικές συναρτήσεις για την κατασκευή τους.

```{r}
hours(c(12, 24))
days(7)
months(1:6)
```

Μπορείτε να προσθέσετε και να πολλαπλασιάσετε περιόδους:

```{r}
10 * (months(6) + days(1))
days(50) + hours(25) + minutes(2)
```

Και φυσικά, να τις προσθέσετεε σε ημερομηνίες.
Σε σύγκριση με τις διάρκειες, οι περίοδοι είναι πιο πιθανό να κάνουν αυτό που θα περιμένατε:

```{r}
# A leap year
ymd("2024-01-01") + dyears(1)
ymd("2024-01-01") + years(1)

# Daylight saving time
one_am + ddays(1)
one_am + days(1)
```

Ας χρησιμοποιήσουμε περιόδους για να διορθώσουμε ένα παράδοξο που σχετίζεται με τις ημερομηνίες πτήσης μας.
Μερικά αεροπλάνα φαίνεται να έφτασαν στον προορισμό τους *πριν* αναχωρήσουν από τη Νέα Υόρκη.

```{r}
flights_dt |> 
  filter(arr_time < dep_time) 
```

Πρόκειται για ολονύχτια πτήσεις.
Χρησιμοποιήσαμε τις ίδιες πληροφορίες ημερομηνίας τόσο για τις ώρες αναχώρησης όσο και για τις ώρες άφιξης, αλλά αυτές οι πτήσεις έφτασαν την επόμενη μέρα.
Μπορούμε να το διορθώσουμε προσθέτοντας το `days(1)` στην ώρα άφιξης κάθε ολονύκτιας πτήσης.

```{r}
flights_dt <- flights_dt |> 
  mutate(
    overnight = arr_time < dep_time,
    arr_time = arr_time + days(overnight),
    sched_arr_time = sched_arr_time + days(overnight)
  )
```

Τώρα όλες μας οι πτήσεις υπακούουν στους νόμους της φυσικής.

```{r}
flights_dt |> 
  filter(arr_time < dep_time) 
```

### Διάστημα {#sec-intervals}

Τι επιστρέφει το `dyears(1) / ddays(365)`; Δεν είναι ακριβώς μονάδα, επειδή το `dyears()` ορίζεται ως ο αριθμός των δευτερολέπτων ανά μέσο χρόνο, που είναι 365,25 ημέρες.

Τι επιστρέφει το `years(1) / days(1)`; Εαν το έτος ήταν 2015 θα έπρεπε να επιστρέψει 365, αλλά αν ήταν 2016, θα έπρεπε να επιστρέψει 366!
Δεν υπάρχουν επαρκείς πληροφορίες ώστε η lubridate να δώσει μια σαφή απάντηση.
Αυτό που κάνει είναι να δώσει μια εκτίμηση:

```{r}
years(1) / days(1)
```

Εάν θέλετε μια πιο ακριβή μέτρηση, θα πρέπει να χρησιμοποιήσετε ένα **διάστημα**.
Ένα διάστημα είναι ένα ζεύγος χρόνων ημερομηνίας αρχής και τέλους ή μπορείτε να το σκεφτείτε ως διάρκεια με ένα σημείο εκκίνησης.

Μπορείτε να δημιουργήσετε ένα διάστημα γράφοντας `start %--% end`:

```{r}
y2023 <- ymd("2023-01-01") %--% ymd("2024-01-01")
y2024 <- ymd("2024-01-01") %--% ymd("2025-01-01")

y2023
y2024
```

Στη συνέχεια, θα μπορούσατε να το διαιρέσετε με `days()` για να μάθετε πόσες ημέρες υπάρχουν μέσα στο έτος:

```{r}
y2023 / days(1)
y2024 / days(1)
```

### Ασκήσεις

1.  Εξηγήστε τα `days(!overnight)` και `days(overnight)` σε κάποιον που μόλις άρχισε να μαθαίνει R.
    Ποιο είναι το βασικό στοιχείο που πρέπει να γνωρίζετε;

2.  Δημιουργήστε ένα διάνυσμα ημερομηνιών δίνοντας την πρώτη ημέρα κάθε μήνα το 2015.
    Δημιουργήστε ένα διάνυσμα ημερομηνιών δίνοντας την πρώτη ημέρα κάθε μήνα στο *τρέχον* έτος.

3.  Γράψτε μια συνάρτηση που με βάση τα γενέθλιά σας (ως ημερομηνία), να εμφανίζει πόσο χρονών είστε σε χρόνια.

4.  Γιατί δεν μπορεί να λειτουργήσει το `(today() %--% (today() + years(1))) / months(1)`;

## Ζώνες ώρας

Οι ζώνες ώρας είναι ένα εξαιρετικά περίπλοκο θέμα λόγω της αλληλεπίδρασής τους με γεωπολιτικές οντότητες.
Ευτυχώς δεν χρειάζεται να εμβαθύνουμε σε όλες τις λεπτομέρειες, καθώς δεν είναι όλες σημαντικές για την ανάλυση δεδομένων, αλλά υπάρχουν μερικές προκλήσεις που θα πρέπει να αντιμετωπίσουμε κατά μέτωπο.

<!--# https://www.ietf.org/timezones/tzdb-2018a/theory.html -->

Η πρώτη πρόκληση είναι ότι τα καθημερινά ονόματα των ζωνών ώρας τείνουν να είναι ασαφή.
Για παράδειγμα, εάν είστε Αμερικανός, πιθανότατα είστε εξοικειωμένοι με την EST ή την ανατολική τυπική ώρα.
Ωστόσο, τόσο η Αυστραλία όσο και ο Καναδάς έχουν επίσης EST!
Για να αποφευχθεί η σύγχυση, η R χρησιμοποιεί τις διεθνείς τυποποιημένες ζώνες ώρας IANA.
Αυτά χρησιμοποιούν ένα συνεπές σχήμα ονοματοδοσίας `{area}/{location}`, συνήθως με τη μορφή `{continent}/{city}` ή `{ocean}/{city}`.
Παραδείγματα περιλαμβάνουν τα "America/New_York", "Europe/Paris" και "Pacific/Auckland".

Ίσως αναρωτιέστε γιατί η ζώνη ώρας χρησιμοποιεί μια πόλη, όταν συνήθως σκέφτεστε ότι οι ζώνες ώρας σχετίζονται με μια χώρα ή περιοχή σε μια χώρα.
Αυτό συμβαίνει επειδή η βάση δεδομένων IANA πρέπει να καταγράφει κανόνες ζώνης ώρας για δεκαετίες.
Κατά τη διάρκεια των δεκαετιών, οι χώρες αλλάζουν ονόματα (ή διασπώνται) αρκετά συχνά, αλλά τα ονόματα των πόλεων τείνουν να παραμένουν ίδια.
Ένα άλλο πρόβλημα είναι ότι το όνομα πρέπει να αντικατοπτρίζει όχι μόνο την τρέχουσα συμπεριφορά, αλλά και την πλήρη ιστορία.
Για παράδειγμα, υπάρχουν ζώνες ώρας και για το "America/New_York" όσο και για το "America/Detroit".
Και οι δύο αυτές πόλεις χρησιμοποιούν αυτήν τη στιγμή την Ανατολική Τυπική Ώρα, αλλά το 1969-1972 το Μίσιγκαν (η πολιτεία στην οποία βρίσκεται το Ντιτρόιτ), δεν ακολούθησε το DST, επομένως χρειάζεται διαφορετικό όνομα.
Αξίζει να διαβάσετε την ακατέργαστη βάση δεδομένων ζώνης ώρας (διαθέσιμη στο <https://www.iana.org/time-zones>) μόνο για να διαβάσετε μερικές από αυτές τις ιστορίες!

Μπορείτε να μάθετε τι πιστεύει η R για την τρέχουσα ζώνη ώρας σας με το `Sys.timezone()`:

```{r}
Sys.timezone()
```

(Εαν η R δεν γνωρίζει, θα σας επιστρέωψει `NA`.)

Δείτε την πλήρη λίστα όλων των ζωνών ώρας με τη βοήθεια της συνάρτησης `OlsonNames()`:

```{r}
length(OlsonNames())
head(OlsonNames())
```

Στην R, η ζώνη ώρας είναι ένα χαρακτηριστικό της ημερομηνίας-ώρας που ελέγχει μόνο το πως τυπώνετε η πληροφορία.
Για παράδειγμα, αυτά τα τρία αντικείμενα αντιπροσωπεύουν την ίδια χρονική στιγμή:

```{r}
x1 <- ymd_hms("2024-06-01 12:00:00", tz = "America/New_York")
x1

x2 <- ymd_hms("2024-06-01 18:00:00", tz = "Europe/Copenhagen")
x2

x3 <- ymd_hms("2024-06-02 04:00:00", tz = "Pacific/Auckland")
x3
```

Μπορείτε να επαληθεύσετε ότι όντως αφορούν την ίδια χρονική στιγμή χρησιμοποιώντας την αφαίρεση:

```{r}
x1 - x2
x1 - x3
```

Εκτός εάν ορίζεται κάπως διαφορετικά, η lubridate χρησιμοποιεί πάντα τη UTC.
Η UTC (Συντονισμένη Παγκόσμια Ώρα) είναι η τυπική ζώνη ώρας που χρησιμοποιείται από την επιστημονική κοινότητα και είναι περίπου ισοδύναμη με τη GMT (μέση ώρα Γκρίνουιτς).
Δεν έχει DST, το οποίο κάνει μια βολική αναπαράσταση για τους υπολογισμούς.
Λειτουργίες που συνδυάζουν ημερομηνίες-ώρα, όπως το `c()`, συχνά αγνοούν τη ζώνη ώρας.
Σε αυτήν την περίπτωση, οι ημερομηνίες-ώρες θα εμφανίζονται στη ζώνη ώρας του πρώτου στοιχείου:

```{r}
x4 <- c(x1, x2, x3)
x4
```

Μπορείτε να αλλάξετε τη ζώνη ώρας με δύο τρόπους:

-   Διατηρήστε τη χρονική στιγμή σταθερή και αλλάξτε τον τρόπο με τον οποίο αυτό παρουσιάζεται.
    Ακολουθήστε αυτή την προσέγγιση όταν η χρονική στιγμή είναι σωστή, αλλά θέλετε μια πιο φυσική παρουσίαση.

    ```{r}
    x4a <- with_tz(x4, tzone = "Australia/Lord_Howe")
    x4a
    x4a - x4
    ```

    (Αυτό δείχνει επίσης μια άλλη πρόκληση των ζωνών ώρας: δεν είναι όλες μετατοπίσεις ακέραιων ωρών!)

-   Αλλάξτε την υποκείμενη χρονική στιγμή.
    Χρησιμοποιήστε το όταν έχετε ένα στιγμιότυπο που έχει επισημανθεί με εσφαλμένη ζώνη ώρας και πρέπει να το διορθώσετε.

    ```{r}
    x4b <- force_tz(x4, tzone = "Australia/Lord_Howe")
    x4b
    x4b - x4
    ```

## Σύνοψη

Αυτό το κεφάλαιο σας παρουσίασε τα εργαλεία που παρέχει η lubridate για να σας βοηθήσουν να εργαστείτε με δεδομένα ημερομηνίας-ώρας.
Η εργασία με ημερομηνίες και ώρες μπορεί να φαίνεται πιο δύσκολη από όσο χρειάζεται, αλλά ελπίζουμε ότι αυτό το κεφάλαιο σας βοήθησε να καταλάβετε γιατί συμβαίνει αυτό --- οι ημερομηνίες-ώρα είναι πιο περίπλοκες από ό,τι φαίνονται με την πρώτη ματιά, και ο χειρισμός κάθε πιθανής κατάστασης προσθέτει πολυπλοκότητα.
Ακόμα κι αν τα δεδομένα σας δεν ξεπερνούν ποτέ τα όρια της θερινής ώρας ή δεν περιλαμβάνουν ένα δίσεκτο έτος, οι συναρτήσεις θα πρέπει να μπορούν να χειριστούν κι αυτές τις καταστάσεις.

Το επόμενο κεφάλαιο εστιάζει στις κενές τιμές.
Τις έχετε συναντήσει σε μερικά σημεία και χωρίς αμφιβολία θα τα συναντήσετε και στη δική σας ανάλυση, οπότε ήρθε η ώρα να μάθετε μια σειρά με χρήσιμες τεχνικές για την αντιμετώπισή τους.
