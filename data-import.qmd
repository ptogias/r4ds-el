# Εισαγωγή δεδομένων {#sec-data-import}

```{r}
#| echo: false

source("_common.R")
```

## Εισαγωγή

Η εργασία με δεδομένα που παρέχονται από πακέτα της R είναι ένας πολύ καλός τρόπος για να μάθετε εργαλεία επιστήμης δεδομένων, αλλά κάποια στιγμή θα θέλετε να εφαρμόσετε ό,τι έχετε μάθει στα δικά σας δεδομένα.
Σε αυτό το κεφάλαιο, θα μάθετε τα βασικά για την ανάγνωσης αρχείων δεδομένων στην R.

Συγκεκριμένα, αυτό το κεφάλαιο θα επικεντρωθεί στην ανάγνωση ορθογώνιων αρχείων απλού κειμένου.
Θα ξεκινήσουμε με πρακτικές συμβουλές για το χειρισμό διαφόρων στοιχείων, όπως ονόματα στηλών, τύποι και ελλιπή δεδομένα.
Στη συνέχεια θα μάθετε για την ανάγνωση δεδομένων από πολλά αρχεία ταυτόχρονα και την εγγραφή δεδομένων από την R σε ένα αρχείο.
Τέλος, θα μάθετε πώς να δημιουργείτε τα δικά σας πλαίσια δεδομένων στην R.

### Προαπαιτούμενα

Σε αυτό το κεφάλαιο, θα μάθετε πώς να διαβάζετε απλά αρχεία στην R με το πακέτο **readr**, το οποίο αποτελεί μέρος του βασικού tidyverse.

```{r}
#| label: setup
#| message: false

library(tidyverse)
```

## Ανάγνωση δεδομένων από ένα αρχείο

Αρχικά, θα επικεντρωθούμε στον πιο συνηθισμένο ορθογώνιο τύπο αρχείου δεδομένων: CSV, που είναι συντομογραφία για τιμές διαχωρισμένες με κόμμα.
Παρακάτω βλέπουμε πώς μοιάζει ένα απλό αρχείο CSV.
Η πρώτη σειρά, που συνήθως ονομάζεται γραμμή κεφαλίδας, δίνει τα ονόματα των στηλών και οι ακόλουθες έξι γραμμές παρέχουν τα δεδομένα.
Οι στήλες χωρίζονται (οριοθετούνται) με κόμμα.

```{r}
#| echo: false
#| message: false
#| comment: ""

read_lines("data/students.csv") |> cat(sep = "\n")
```

Το @tbl-students-table δείχνει μια αναπαράσταση των ίδιων δεδομένων ως πίνακα.

```{r}
#| label: tbl-students-table
#| echo: false
#| message: false
#| tbl-cap: Data from the students.csv file as a table.

read_csv("data/students.csv") |>
  knitr::kable()
```

Μπορούμε να διαβάσουμε αυτό το αρχείο σε R χρησιμοποιώντας το `read_csv()`.
Το πρώτο όρισμα είναι το πιο σημαντικό: το μονοπάτι προς το αρχείο.
Μπορείτε να φανταστείτε το μονοπάτι ως τη διεύθυνση του αρχείου: το αρχείο ονομάζεται `students.csv` και βρίσκεται στο φάκελο `data`.

```{r}
#| message: true

students <- read_csv("data/students.csv")
```

Ο παραπάνω κώδικας θα λειτουργήσει εάν έχετε το αρχείο `students.csv` μέσα σε έναν φάκελο που ονομάζεται `data` στο project σας.
Μπορείτε να κατεβάσετε το αρχείο`students.csv` από το <https://pos.it/r4ds-students-csv> ή μπορείτε να το διαβάσετε απευθείας από αυτήν τη διεύθυνση URL με:

```{r}
#| eval: false

students <- read_csv("https://pos.it/r4ds-students-csv")
```

Όταν εκτελείτε την `read_csv()`, εκτυπώνει ένα μήνυμα που σας λέει τον αριθμό των γραμμών και των στηλών δεδομένων, τον οριοθέτη που χρησιμοποιήθηκε και τις προδιαγραφές στηλών (ονόματα στηλών που οργανώνονται ανάλογα με τον τύπο δεδομένων που περιέχει η στήλη).
Εκτυπώνει επίσης ορισμένες πληροφορίες σχετικά με την ανάκτηση της πλήρους προδιαγραφής των στηλών, καθώς και τον τρόπο σίγασης αυτού του μηνύματος.
Αυτό το μήνυμα είναι αναπόσπαστο μέρος του readr και θα επιστρέψουμε σε αυτό στην ενότητα @sec-col-types.

### Πρακτική συμβουλή

Μόλις διαβάσετε δεδομένα, το πρώτο βήμα συνήθως περιλαμβάνει το μετασχηματισμό τους με κάποιο τρόπο για να διευκολύνετε την εργασία σας στην υπόλοιπη ανάλυσή σας.
Ας ρίξουμε μια άλλη ματιά στα δεδομένα των `students` έχοντας αυτό κατά νου.

```{r}
students
```

Στη στήλη `favourite.food`, υπάρχουν διάφορα τρόφιμα και, στη συνέχεια, η συμβολοσειρά χαρακτήρων `N/A`, η οποία θα έπρεπε να ήταν ένα πραγματικό `NA`, το οποίο η R θα αναγνωρίσει ως "μη διαθέσιμη τιμή".
Αυτό είναι κάτι που μπορούμε να αντιμετωπίσουμε χρησιμοποιώντας το όρισμα `na`.
Από προεπιλογή, η `read_csv()` αναγνωρίζει μόνο κενές συμβολοσειρές (`""`) σε αυτό το σύνολο δεδομένων ως `NA`s, ενώ εμείς θέλουμε να αναγνωρίζει επίσης τη συμβολοσειρά χαρακτήρων `"N/A"`.

```{r}
#| message: false
students <- read_csv("data/students.csv", na = c("N/A", ""))

students
```

Μπορεί επίσης να παρατηρήσετε ότι οι στήλες `Student ID` και `Full Name` περιβάλλονται από "``` ". Αυτό συμβαίνει επειδή περιέχουν κενά, παραβιάζοντας τους συνήθεις κανόνες της R για τα επιτρεπτά ονόματα μεταβλητών - είναι **μη συντακτικά** ονόματα. Για να αναφερθείτε σε αυτές τις μεταβλητές, πρέπει να τις περιβάλετε με `` ``` \`\`:

```{r}
students |> 
  rename(
    student_id = `Student ID`,
    full_name = `Full Name`
  )
```

Μια εναλλακτική προσέγγιση είναι να χρησιμοποιήσετε τη συνάρτηση `janitor::clean_names()` για να χρησιμοποιήσετε κάποιους ευρετικούς κανόνες για να αντικαταστήσετε τα κενά με κάτω παύλες (snake case)[^data-import-1].

[^data-import-1]: Το πακέτο [janitor](http://sfirke.github.io/janitor/) δεν αποτελεί μέρος του tidyverse, αλλά προσφέρει εύχρηστες λειτουργίες για τον καθαρισμό δεδομένων και λειτουργεί καλά σε ροές εργασιών σε δεδομένα που χρησιμοποιούν `|>`.

```{r}
#| message: false

students |> janitor::clean_names()
```

Μια άλλη κοινή εργασία μετά την ανάγνωση δεδομένων είναι η εξέταση του τύπου των μεταβλητών.
Για παράδειγμα, το `meal_plan` είναι μια κατηγορική μεταβλητή με ένα γνωστό σύνολο πιθανών τιμών, η οποία στην R θα πρέπει να αντιπροσωπεύεται ως παράγοντας:

```{r}
students |>
  janitor::clean_names() |>
  mutate(meal_plan = factor(meal_plan))
```

Σημειώστε ότι οι τιμές στη μεταβλητή `meal_plan` έχουν παραμείνει ίδιες, αλλά ο τύπος της μεταβλητής που υποδεικνύεται κάτω από το όνομα της μεταβλητής έχει αλλάξει από χαρακτήρα (`<chr>`) σε παράγοντα (`<fct>`).
Θα μάθετε περισσότερα σχετικά με τους παράγοντες στου @sec-factors.

Προτού αναλύσετε αυτά τα δεδομένα, θα πρέπει πιθανώς να διορθώσετε τις στήλες `age` και `id`. Επί του παρόντος, η `age` είναι μια μεταβλητή χαρακτήρων επειδή μία από τις παρατηρήσεις πληκτρολογείται ως `five` αντί για το αριθμητικό `5`.
Θα συζητήσουμε τις λεπτομέρειες της επίλυσης αυτού του ζητήματος στο @sec-import-spreadsheets.

```{r}
students <- students |>
  janitor::clean_names() |>
  mutate(
    meal_plan = factor(meal_plan),
    age = parse_number(if_else(age == "five", "5", age))
  )

students
```

Μια νέα συνάρτηση εδώ είναι η `if_else()`, η οποία διαθέτει τρία ορίσματα.
Το πρώτο όρισμα `test` πρέπει να είναι ένα λογικό διάνυσμα.
Το αποτέλεσμα θα περιέχει την τιμή του δεύτερου ορίσματος, `yes`, όταν το `test` είναι `TRUE` και την τιμή του τρίτου ορίσματος, `no`, όταν είναι `FALSE`.
Εδώ λέμε αν η μεταβλητή `age` είναι η συμβολοσειρά χαρακτήρων `"five"`, κάνε την `"5"` και, αν όχι, αφήστε την ως `age`.
Θα μάθετε περισσότερα για το `if_else()` και τα λογικά διανύσματα στο @sec-logicals.

### Άλλα ορίσματα

Υπάρχουν μερικά άλλα σημαντικά ορίσματα που πρέπει να αναφέρουμε και θα είναι πιο εύκολο να τα δείξουμε αν πρώτα σας δείξουμε ένα εύχρηστο κόλπο: η `read_csv()` μπορεί να διαβάσει συμβολοσειρές κειμένου που έχετε δημιουργήσει και μορφοποιήσει ως CSV αρχείο:

```{r}
#| message: false

read_csv(
  "a,b,c
  1,2,3
  4,5,6"
)
```

Συνήθως, η `read_csv()` χρησιμοποιεί την πρώτη γραμμή των δεδομένων ως ονόματα των στηλών, κάτι που αποτελεί μια πολύ κοινή σύμβαση.
Ωστόσο, δεν είναι ασυνήθιστο να περιλαμβάνονται μερικές γραμμές μεταδεδομένων στην κορυφή του αρχείου.
Μπορείτε να χρησιμοποιήσετε το `skip = n` για να παραλείψετε τις πρώτες `n` γραμμές ή να χρησιμοποιήσετε το `comment = "#"` για να απορρίψετε όλες τις γραμμές που ξεκινούν με (π.χ.) `#`:

```{r}
#| message: false

read_csv(
  "The first line of metadata
  The second line of metadata
  x,y,z
  1,2,3",
  skip = 2
)

read_csv(
  "# A comment I want to skip
  x,y,z
  1,2,3",
  comment = "#"
)
```

Σε άλλες περιπτώσεις, τα δεδομένα ενδέχεται να μην έχουν ονόματα στηλών.
Μπορείτε να χρησιμοποιήσετε το `col_names = FALSE` για να πείτε στη `read_csv()` να μην αντιμετωπίζει την πρώτη σειρά ως επικεφαλίδες και αντ' αυτού να τις επισημαίνει διαδοχικά ξεκινώντας από το `X1` έως το `Xn`:

```{r}
#| message: false

read_csv(
  "1,2,3
  4,5,6",
  col_names = FALSE
)
```

Εναλλακτικά, μπορείτε να εισάγετε στο `col_names` ένα διάνυσμα χαρακτήρων που θα χρησιμοποιηθούν ως ονόματα στηλών:

```{r}
#| message: false

read_csv(
  "1,2,3
  4,5,6",
  col_names = c("x", "y", "z")
)
```

Αυτά τα ορίσματα είναι όλα όσα πρέπει να γνωρίζετε για να διαβάσετε τα περισσότερα αρχεία CSV που θα συναντήσετε στην πράξη.
(Για τα υπόλοιπα, θα πρέπει να επιθεωρήσετε προσεκτικά το αρχείο `.csv` που έχετε στα χέρια σας και να διαβάσετε το εγχειρίδιο της `read_csv()` όπου θα βρείτε πολλά ακόμη ορίσματα.)

### Άλλοι τύποι αρχείων

Μόλις κατακτήσετε την `read_csv()`, η χρήση των άλλων συναρτήσεων της readr γίνεται απλή.
είναι απλώς θέμα να γνωρίζουμε ποια συνάρτηση να χρησιμοποίησοθμε:

-   Η `read_csv2()` διαβάζει αρχεία διαχωρισμένα με ερωτηματικό.
    Αυτά χρησιμοποιούν `;` αντί για `,` για να διαχωρίσουν πεδία και είναι κοινά σε χώρες που χρησιμοποιούν το `,` ως δείκτη των δεκαδικών.

-   Η `read_tsv()` διαβάζει αρχεία οριοθετημένα με στηλοθέτες.

-   Η `read_delim()` διαβάζει αρχεία με οποιονδήποτε οριοθέτη, προσπαθώντας να μαντέψει αυτόματα τον οριοθέτη εάν δεν τον καθορίσετε.

-   Η `read_fwf()` διαβάζει αρχεία σταθερού πλάτους.
    Μπορείτε να καθορίσετε τα πεδία με το πλάτος τους, χρησιμοποιώντας το `fwf_widths()` ή με τις θέσεις τους με το `fwf_positions()`.

-   Η `read_table()` διαβάζει μια κοινή παραλλαγή αρχείων σταθερού πλάτους όπου οι στήλες χωρίζονται με λευκό διάστημα.

-   Η `read_log()` διαβάζει αρχεία καταγραφής τύπου Apache.

### Ασκήσεις

1.  Ποια συνάρτηση θα χρησιμοποιούσατε για να διαβάσετε ένα αρχείο όπου τα πεδία ήταν διαχωρισμένα με "\|";

2.  Εκτός από τα `file`, `skip`, και `comment`, ποια άλλα ορίσματα είναι κοινά στην `read_csv()` και την `read_tsv()`;

3.  Ποια είναι τα πιο σημαντικά ορίσματα για την `read_fwf()`;

4.  Ορισμένες φορές οι συμβολοσειρές σε ένα αρχείο CSV περιέχουν κόμματα.
    Για να μην προκαλούν προβλήματα, πρέπει να περιβάλλονται από έναν χαρακτήρα εισαγωγικού, όπως το `"` ή το `'`. Από προεπιλογή, η `read_csv()` υποθέτει ότι ο χαρακτήρας εισαγωγικού θα είναι `"`.
    Για να διαβάσετε το ακόλουθο κείμενο σε ένα πλαίσιο δεδομένων, ποιο όρισμα της `read_csv()` πρέπει να καθορίσετε;

    ```{r}
    #| eval: false

    "x,y\n1,'a,b'"
    ```

5.  Προσδιορίστε ποιο είναι το πρόβλημα σε κάθε ένα από τα ακόλουθα ενσωματωμένα αρχεία CSV.
    Τι συμβαίνει όταν εκτελείτε τον κώδικα;

    ```{r}
    #| eval: false

    read_csv("a,b\n1,2,3\n4,5,6")
    read_csv("a,b,c\n1,2\n1,2,3,4")
    read_csv("a,b\n\"1")
    read_csv("a,b\n1,2\na,b")
    read_csv("a;b\n1;3")
    ```

6.  Practice referring to non-syntactic names in the following data frame by:

    a.  Extracting the variable called `1`.
    b.  Plotting a scatterplot of `1` vs. `2`.
    c.  Creating a new column called `3`, which is `2` divided by `1`.
    d.  Renaming the columns to `one`, `two`, and `three`.

7.  Εξασκηθείτε στην αναφορά μη συντακτικών ονόματα στο ακόλουθο πλαίσιο δεδομένων:

    a.  Εξάγωγοντας τη μεταβλητής που ονομάζεται `1`.
    b.  Σχεδιάζοντας ένα διάγραμμα διασποράς της `1` έναντι της `2`.
    c.  Δημιουργώντας μιας νέας στήλης που ονομάζεται `3`, η οποία περιέχει το αποτέλεσμα της διαίρεσης της `2` με την `1`.
    d.  Μετονομάζοντας τις στηλών σε `one`, `two`, και `three`.

    ```{r}
    annoying <- tibble(
      `1` = 1:10,
      `2` = `1` * 2 + rnorm(length(`1`))
    )
    ```

## Ελέγχοντας τον τύπο των στηλών {#sec-col-types}

Ένα αρχείο CSV δεν περιέχει πληροφορίες σχετικά με τον τύπο κάθε μεταβλητής (δηλαδή εάν είναι λογική, αριθμός, συμβολοσειρά κ.λπ.), επομένως η readr θα προσπαθήσει να μαντέψει τον τύπο.
Αυτή η ενότητα περιγράφει πώς λειτουργεί αυτή η διαδικασία εικασίας, πώς να επιλύσετε ορισμένα κοινά προβλήματα που προκαλούν την αποτυχία της και, εάν χρειάζεται, πώς να παρέχετε μόνοι σας τους τύπους στηλών.
Τέλος, θα αναφέρουμε μερικές γενικές στρατηγικές που είναι χρήσιμες όταν η readr αποτυγχάνει καταστροφικά και πρέπει να αποκτήσετε περισσότερες πληροφορίες σχετικά με τη δομή του αρχείου σας.

### Μαντεύοντας τύπους

Η readr χρησιμοποιεί ευρετικούς κανόνες για να προσδιορίσει τους τύπους στηλών.
Για κάθε στήλη, κρατάει τις τιμές 1.000 γραμμών[^data-import-2] με ομοιόμορφη απόσταση από την πρώτη γραμμή μέχρι την τελευταία, αγνοώντας τις τιμές που λείπουν.
Στη συνέχεια εξετάζει τις ακόλουθες ερωτήσεις:

[^data-import-2]: Μπορείτε να παρακάμψετε την προεπιλογή των 1000 με το όρισμα `guess_max`.

-   Το δείγμα περιέχει μόνο `F`, `T`, `FALSE`, ή `TRUE` (παραβλεποντας πεζά-κεφαλαία); Αν ναι, η στήλη είναι λογική.
-   Το δείγμα περιέχει μόνο αριθμούς (π.χ. `1`, `-4.5`, `5e6`, `Inf`); Αν ναι, η στήλη είναι αριθμητική.
-   Το δείγμα ταιριάζει με το πρότυπο ISO8601; Αν ναι, η αντίστοιχη στήλη περέχει ημερομηνίες ή ημερομηνίες-ώρες. (Θα επιστρέψουμε στις ημερομηνίες-ώρες με περισσότερες λεπτομέρειες στο @sec-creating-datetimes).
-   Διαφορετικά, η στήλη μας πρέπει να είναι συμβολοσειρά.

Μπορείτε να δείτε αυτή τη συμπεριφορά σε δράση σε αυτό το απλό παράδειγμα:

```{r}
#| message: false

read_csv("
  logical,numeric,date,string
  TRUE,1,2021-01-15,abc
  false,4.5,2021-02-15,def
  T,Inf,2021-02-16,ghi
")
```

Αυτό το ευρετικό λειτουργεί καλά εάν έχετε ένα καθαρό σύνολο δεδομένων, αλλά στην πραγματική ζωή, θα συναντήσετε έναν συνδυασμό από περίεργες και όμορφες αποτυχίες.

### Ελλιπής τιμές, τύποι στηλών και προβλήματα

Ο πιο συνηθισμένος τρόπος με τον οποίο αποτυγχάνει η ανίχνευση του τύπου μιας στήλης είναι όταν η στήλη περιέχει μη αναμενόμενες τιμές, οπότε λαμβάνετε μια στήλη χαρακτήρων αντί για έναν πιο συγκεκριμένο τύπο.
Μία από τις πιο συνηθισμένες αιτίες για αυτό είναι μια τιμή που λείπει, η οποία καταγράφεται χρησιμοποιώντας κάτι διαφορετικό από το `NA` που αναμένει η readr

Πάρτε σαν παράδειγμα αυτό το απλό αρχείο CSV που περιέχει μόνο 1 στήλη:

```{r}
simple_csv <- "
  x
  10
  .
  20
  30"
```

Αν το διαβάσουμε αυτό χωρίς πρόσθετα ορίσματα, το `x` μετατρέπεται σε στήλη χαρακτήρων:

```{r}
#| message: false

read_csv(simple_csv)
```

Σε αυτήν την πολύ μικρή περίπτωση, μπορείτε εύκολα να δείτε την τιμή που λείπει ως `.`.
Τι συμβαίνει όμως εάν έχετε χιλιάδες σειρές με λίγες μόνο τιμές που λείπουν και οι οποίες αντιπροσωπεύονται από `.`, διάσπαρτες ανάμεσα σε συμπληρωμένες τιμές; Μια προσέγγιση είναι να πείτε στην readr ότι το `x` είναι μια αριθμητική στήλη και στη συνέχεια να δείτε σε ποιο σημείο αποτυγχάνει.
Αυτό μπορείτε να το κάνετε με το όρισμα `col_types`, το οποίο δέχεται μια ονοματισμένη λίστα (κάθε αντικείμενο διαθέτει όνομα), όπου τα ονόματα ταιριάζουν με τα ονόματα στηλών στο αρχείο CSV:

```{r}
df <- read_csv(
  simple_csv, 
  col_types = list(x = col_double())
)
```

Τώρα η `read_csv()` αναφέρει ότι υπήρξε πρόβλημα και μας λέει ότι μπορούμε να μάθουμε περισσότερα χρησιμοποιώντας την `problems()`:

```{r}
problems(df)
```

Αυτό μας λέει ότι βρέθηκε ένα πρόβλημα στη γραμμή 3 και στήλη 1 όπου η readr περίμενε έναν πραγματικό αριθμό αλλά εντόπισε ένα `.`.
Αυτό υποδηλώνει ότι αυτό το σύνολο δεδομένων χρησιμοποιεί `.` για τιμές που λείπουν.
Στη συνέχεια, ορίζουμε `na = "."`, και η αυτόματη εικασία επιτυγχάνει, δίνοντάς μας την αριθμητική στήλη που θέλουμε:

```{r}
#| message: false

read_csv(simple_csv, na = ".")
```

### Τύποι στηλών

Η readr παρέχει συνολικά εννέα τύπους στηλών που μπορούμε να χρησιμοποιήσουμε:

-   Οι `col_logical()` και `col_double()` διαβάζουν στήλες με λογικές τιμές και πραγματικούς αριθμούς αντίστοιχα. Η χρήση τους απαιτείται σχετικά σπάνια (εκτός από παραπάνω), μιας και η readr συνήθως μαντεύει αντίστοιχες στήλες για εσάς.
-   Η `col_integer()` διαβάζει ακέραιους αριθμούς. Σπάνια κάνουμε διάκριση ανάμεσα σε ακέραιους και πραγματικούς αριθμούς σε αυτό το βιβλίο επειδή είναι λειτουργικά ισοδύναμοι, ωστόσο, η ρητή ανάγνωση ακεραίων μπορεί περιστασιακά να είναι χρήσιμη επειδή καταλαμβάνουν τη μισή μνήμη από τους πραγματικούς.
-   Η `col_character()` διαβάζει συμβολοσειρές. Αυτό μπορεί να είναι χρήσιμο για να προσδιορίσετε ρητά όταν έχετε μια στήλη που είναι ένα αριθμητικό αναγνωριστικό, δηλαδή μεγάλη σειρά ψηφίων που προσδιορίζει ένα αντικείμενο, αλλά δεν έχει νόημα να εφαρμόσετε μαθηματικές πράξεις σε αυτό. Παραδείγματα περιλαμβάνουν αριθμούς τηλεφώνου, αριθμούς κοινωνικής ασφάλισης, αριθμούς πιστωτικών καρτών κ.λπ.
-   Οι `col_factor()`, `col_date()` και `col_datetime()` δημιουργούν παράγοντες, ημερομηνίες και ημερομηνίες-ώρες αντίστοιχα. θα μάθετε περισσότερα για αυτούς όταν φτάσουμε σε αυτούς τους τύπους δεδομένων στα κεφάλαια @sec-factors και @sec-dates-and-times.
-   Η `col_number()` χρησιμοποιείται για το διάβασμα αριθμητικών στηλών, αγνοώντας μη αριθμητικά στοιχεία, επιτρέποντας μεγαλύτερη ευελιξία, και είναι χρήσιμος για νομισματικές ισοδυναμίες. Περισσότερα γι' αυτό θα μάθετε στο @sec-numbers.
-   Η `col_skip()` παρακάμπτει μια στήλη, ώστε να μην περιλαμβάνεται στο αποτέλεσμα, κάτι που μπορεί να είναι χρήσιμο για την επιτάχυνση της ανάγνωσης των δεδομένων, εάν έχετε ένα μεγάλο αρχείο CSV και θέλετε να χρησιμοποιήσετε μερικές μόνο από τις στήλες.

Είναι επίσης δυνατό να παρακάμψετε την προεπιλεγμένη στήλη μεταβαίνοντας από τη λίστα `list()` σε `cols()` και θέτοντας το όρισμα `.default`:

```{r}
another_csv <- "
x,y,z
1,2,3"

read_csv(
  another_csv, 
  col_types = cols(.default = col_character())
)
```

Μια άλλη χρήσιμη βοηθητική συνάρτηση είναι η `cols_only()` που θα διαβάζει μόνο στις στήλες που καθορίζετε:

```{r}
read_csv(
  another_csv,
  col_types = cols_only(x = col_character())
)
```

## Διαβάζοντας δεδομένα από πολλαπλά αρχεία {#sec-readr-directory}

Μερικές φορές τα δεδομένα σας χωρίζονται σε πολλά αρχεία αντί να περιέχονται σε ένα μόνο αρχείο.
Για παράδειγμα, μπορεί να έχετε δεδομένα πωλήσεων για πολλούς μήνες, με τα δεδομένα κάθε μήνα σε ξεχωριστό αρχείο: `01-sales.csv` για τον Ιανουάριο, `02-sales.csv` για το Φεβρουάριο και `03-sales.csv` για το Μάρτιο.
Με την `read_csv()` μπορείτε να διαβάσετε αυτά τα δεδομένα ταυτόχρονα και να τα στοιβάξετε το ένα πάνω στο άλλο, δημιουργώντας ένα συγκεντρωτικό πλαίσιο δεδομένων.

```{r}
#| message: false

sales_files <- c("data/01-sales.csv", "data/02-sales.csv", "data/03-sales.csv")
read_csv(sales_files, id = "file")
```

Για ακόμη μια φορά, ο παραπάνω κώδκας θα δουλέψει εάν έχετε τα CSV αρχεία σας σε έναν `data` φάκελο στο project σας.
Μπορείτε να κατεβάσετε αυτά τα αρχεία από τα <https://pos.it/r4ds-01-sales>, <https://pos.it/r4ds-02-sales>, και <https://pos.it/r4ds-03-sales> ή μπορείτε να διαβάσετε απευθείας, όπως φαίνεται παρακάτω:

```{r}
#| eval: false

sales_files <- c(
  "https://pos.it/r4ds-01-sales",
  "https://pos.it/r4ds-02-sales",
  "https://pos.it/r4ds-03-sales"
)
read_csv(sales_files, id = "file")
```

Το όρισμα `id` προσθέτει μια νέα στήλη που ονομάζεται `file` στο προκύπτον πλαίσιο δεδομένων και η οποία προσδιορίζει το αρχείο από το οποίο προέρχονται τα δεδομένα.
Αυτό είναι ιδιαίτερα χρήσιμο σε περιπτώσεις όπου τα αρχεία που διαβάζετε δεν έχουν μια στήλη αναγνώρισης που μπορεί να σας βοηθήσει να συνδέσετε τις παρατηρήσεις με τις αρχικές τους πηγές.

Εάν έχετε πολλά αρχεία τα οποία θέλετε να διαβάσετε, μπορεί να είναι δύσκολο να γράψετε τα ονόματά τους ως λίστα.
Αντίθετα, μπορείτε να χρησιμοποιήσετε τη βασική συνάρτηση `list.files()` για να βρείτε τα αρχεία για εσάς, χρησιμοποιώντας ένα μοτίβο στα ονόματα των αρχείων.
Θα μάθετε περισσότερα για αυτά τα μοτίβα στο @sec-regular-expressions.

```{r}
sales_files <- list.files("data", pattern = "sales\\.csv$", full.names = TRUE)
sales_files
```

## Γράφοντας δεδομένα σε ένα αρχείο {#sec-writing-to-a-file}

Η readr διαθέτει επίσης δύο χρήσιμες λειτουργίες για την εγγραφή δεδομένων πίσω στο δίσκο: την `write_csv()` και την `write_tsv()`.
Τα πιο σημαντικά ορίσματα σε αυτές τις συναρτήσεις είναι `x` (το πλαίσιο δεδομένων προς αποθήκευση) και το `file` (η τοποθεσία που θα χρησιμοποιηθεί για την αποθήκευση).
Μπορείτε επίσης να καθορίσετε πώς γράφονται οι τιμές που λείπουν με το `na` όρισμα, και εάν θέλετε να προσαρτήσετε (`append` ) το πλαίσιο δεδομένων σας σε ένα υπάρχον αρχείο.

```{r}
#| eval: false

write_csv(students, "students.csv")
```

Τώρα ας διαβάσουμε ξανά αυτό το αρχείο csv.
Σημειώστε ότι οι πληροφορίες τύπου μεταβλητής που μόλις ρυθμίσατε χάνονται όταν αποθηκεύετε στο CSV, επειδή ξεκινάτε ξανά με την ανάγνωση από ένα αρχείο απλού κειμένου:

```{r}
#| warning: false
#| message: false

students
write_csv(students, "students-2.csv")
read_csv("students-2.csv")
```

Αυτό καθιστά τα CSV αρχεία λίγο αναξιόπιστα για την προσωρινή αποθήκευση ενδιάμεσων αποτελεσμάτων --- θα πρέπει να δημιουργείτε εκ νέου τις προδιαγραφές των στηλών κάθε φορά που φορτώνετε τα δεδομένα.
Υπάρχουν δύο βασικές εναλλακτικές:

1.  Οι `write_rds()` και `read_rds()` είναι ομοιόμορφα περιτυλίγματα (wrappers) γύρω από τις βασικές συναρτήσεις `readRDS()` και `saveRDS()`.
    Αυτές αποθηκεύουν δεδομένα στην προσαρμοσμένη δυαδική μορφή της R που ονομάζεται RDS.
    Αυτό σημαίνει ότι όταν φορτώνετε ξανά το αντικείμενο, φορτώνετε το *ακριβώς το ίδιο* αντικείμενο R που αποθηκεύσατε.

    ```{r}
    write_rds(students, "students.rds")
    read_rds("students.rds")
    ```

2.  Το πακέτο arrow σάς επιτρέπει να διαβάζετε και να γράφετε αρχεία parquet, μια γρήγορη μορφή δυαδικού αρχείου που μπορεί να κοινοποιηθεί σε διάφορες γλώσσες προγραμματισμού.
    Θα επιστρέψουμε στο arrow σε μεγαλύτερο βάθος στο @sec-arrow.

    ```{r}
    #| eval: false

    library(arrow)
    write_parquet(students, "students.parquet")
    read_parquet("students.parquet")
    #> # A tibble: 6 × 5
    #>   student_id full_name        favourite_food     meal_plan             age
    #>        <dbl> <chr>            <chr>              <fct>               <dbl>
    #> 1          1 Sunil Huffmann   Strawberry yoghurt Lunch only              4
    #> 2          2 Barclay Lynn     French fries       Lunch only              5
    #> 3          3 Jayendra Lyne    NA                 Breakfast and lunch     7
    #> 4          4 Leon Rossini     Anchovies          Lunch only             NA
    #> 5          5 Chidiegwu Dunkel Pizza              Breakfast and lunch     5
    #> 6          6 Güvenç Attila    Ice cream          Lunch only              6
    ```

Parquet tends to be much faster than RDS and is usable outside of R, but does require the arrow package.
Τα αρχεία parquet τείνουν να είναι πολύ πιο γρήγορα από τα RDS και μπορεί να χρησιμοποιηθούν και εκτός της R, αλλά απαιτούν το πακέτο arrow

```{r}
#| include: false
file.remove("students-2.csv")
file.remove("students.rds")
```

## Εισαγωγή δεδομένων

Μερικές φορές θα χρειαστεί να συναρμολογήσετε ένα tibble "με το χέρι" κάνοντας μια μικρή εισαγωγή δεδομένων στο αρχείο κώδικα R σας.
Υπάρχουν δύο χρήσιμες συναρτήσεις που σας βοηθούν να το κάνετε αυτό, οι οποίες διαφέρουν ως προς το αν σχεδιάζετε το tibble κατά στήλες ή κατά γραμμές Η `tibble()` λειτουργεί ανά στήλες:

```{r}
tibble(
  x = c(1, 2, 5), 
  y = c("h", "m", "g"),
  z = c(0.08, 0.83, 0.60)
)
```

Η διάταξη των δεδομένων ανά στήλες μπορεί να δυσκολέψει τον τρόπο με τον οποίο συσχετίζονται οι γραμμές, επομένως μια εναλλακτική είναι η `tribble()`, συντομογραφία για το **tr**ansposed t**ibble**, η οποία σας επιτρέπει να τοποθετήσετε τα δεδομένα σας γραμμή προς γραμμή.
Η `tribble()` προσαρμόζεται για την εισαγωγή δεδομένων στον κώδικα: οι επικεφαλίδες στηλών ξεκινούν με `~` και οι εγγραφές διαχωρίζονται με κόμμα.
Αυτό καθιστά δυνατή τη διάταξη μικρών ποσοτήτων δεδομένων σε μια ευανάγνωστη μορφή:

```{r}
tribble(
  ~x, ~y, ~z,
  1, "h", 0.08,
  2, "m", 0.83,
  5, "g", 0.60
)
```

## Σύνοψη

Σε αυτό το κεφάλαιο, μάθατε πώς να φορτώνετε αρχεία CSV με την `read_csv()` και να κάνετε τη δική σας εισαγωγή δεδομένων με τις `tibble()` και `tribble()`.
Έχετε μάθει πώς λειτουργούν τα αρχεία csv, μερικά από τα προβλήματα που ενδέχεται να αντιμετωπίσετε και πώς να τα ξεπεράσετε.
Θα επανέλθουμε στην εισαγωγή δεδομένων μερικές ακόμη φορές σε αυτό το βιβλίο: @sec-import-spreadsheets από το Excel και τα Φύλλα Google, το @sec-import-databases θα σας δείξει πώς να φορτώνετε δεδομένα από βάσεις δεδομένων, το @sec-arrow από αρχεία parquet, @sec-rectangling από JSON και @sec-scraping από ιστότοπους.

Βρισκόμαστε ακριβώς στο τέλος αυτής της ενότητας του βιβλίου, αλλά υπάρχει ένα σημαντικό τελευταίο θέμα που πρέπει να καλυφθεί: πώς να λάβετε βοήθεια.
Έτσι, στο επόμενο κεφάλαιο, θα μάθετε μερικά καλά μέρη για να αναζητήσετε βοήθεια, πώς να δημιουργήσετε ένα reprex για να μεγιστοποιήσετε τις πιθανότητές σας να λάβετε χρήσιμη βοήθεια και μερικές γενικές συμβουλές για να συμβαδίσετε με τον κόσμο της R.
