[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Η R για την Επιστήμη των Δεδομένων (2η έκδοση)",
    "section": "",
    "text": "Καλώς ήλθατε\nΑυτός είναι ο ιστότοπος για την 2η έκδοση του βιβλίου “Η R για την Επιστήμη των Δεδομένων”. Το βιβλίο αυτό θα σας διδάξει πως να εφαρμόσετε την επιστήμη των δεδομένων χρησιμοποιώντας την R. Θα μάθετε πως να βάλετε τα δεδομένα σας στην R, να τα μετατρέψετε σε μία χρήσιμη δομή, να τα μετασχηματίσετε και να τα οπτικοποιήσετε.\nΣε αυτό το βιβλίο, θα βρείτε πρακτικές δεξιότητες για την επιστήμη των δεδομένων. Έτσι όπως ένας χημικός μαθαίνει πως να καθαρίζει δοκιμαστικούς σωλήνες και να εξοπλίζει ένα εργαστήριο, έτσι και εσείς θα μάθετε πως να καθαρίζετε δεδομένα και να σχεδιάζετε διαγράμματα—όπως και αρκετά άλλα πράγματα. Αυτές είναι οι δεξιότητες που κάνουν την επιστήμη των δεδομένων εφικτή και εδώ θα βρείτε τις βέλτιστες πρακτικές για να τις εφαρμόσετε όλες με την R. Θα μάθετε πως να χρησιμοποιήσετε την γραμματική των γραφικών, λογοτεχνικό προγραμματισμό, και αναπαράξιμη έρευνα για να εξοικονομήσετε χρόνο. Θα μάθετε επίσης πως να διαχειρίζεστε γνωστικούς πόρους για να διευκολύνετε την εξαγωγή αποτελεσμάτων όταν μετασχηματίζετε, οπτικοποιείτε, και εξερευνείτε δεδομένα.\nΟ ιστότοπος αυτός είναι και θα είναι δωρεάν για πάντα, σύμφωνα με την άδεια χρήσης CC BY-NC-ND 3.0. Εάν επιθυμείτε ένα φυσικό αντίγραφο αυτού του βιβλίου (στα αγγλικά), μπορείτε να το αγοράσετε στο Amazon. Εάν αναγνωρίζετε την δωρεάν ανάγνωση του βιβλίου και θέλετε, με κάποιο τρόπο, να ανταποδώσετε, παρακαλώ κάντε μία δωρεά στο Kākāpō Recovery: το kākāpō (το οποίο εμφανίζεται στο εξώφυλλο του βιβλίου) είναι ένα κρίσιμα απειλούμενο είδος παπαγάλου της Νέας Ζηλανδίας. Έχουν απομείνει μόνο 248.\nΣε περίπτωση που μιλάτε κάποια άλλη γλώσσα, μπορεί να σας ενδιαφέρουν οι δωρεάν διαθέσιμες μεταφράσεις της 1ης έκδοσης:\nΜπορείτε να βρείτε προτεινόμενες απαντήσεις για τις ασκήσεις του βιβλίου στο https://mine-cetinkaya-rundel.github.io/r4ds-solutions.\nΠαρακαλώ σημειώστε ότι το βιβλίο χρησιμοποιεί έναν Κώδικα Δεοντολογίας για Συντελεστές (ελληνική μετάφραση: https://www.contributor-covenant.org/el/version/1/4/code-of-conduct/). Συνεισφέροντας σε αυτό το βιβλίο, συμφωνείτε να τηρείτε τους όρους του.",
    "crumbs": [
      "Καλώς ήλθατε"
    ]
  },
  {
    "objectID": "index.html#καλωσόρισμα-από-τους-μεταφραστές",
    "href": "index.html#καλωσόρισμα-από-τους-μεταφραστές",
    "title": "Η R για την Επιστήμη των Δεδομένων (2η έκδοση)",
    "section": "Καλωσόρισμα από τους μεταφραστές",
    "text": "Καλωσόρισμα από τους μεταφραστές\nΣας καλωσορίζουμε στην ελληνική μετάφραση της 2ης έκδοσης του βιβλίου R for Data Science (Η R για την Επιστήμη των Δεδομένων). Ελπίζουμε ότι ο οδηγός αυτός θα αποτελέσει την αρχή ενός συναρπαστικού ταξιδιού στον προγραμματιστικό κόσμο της R και της επιστήμης των δεδομένων.\nΕίτε είστε νέος στην R είτε έχετε ήδη κάποια εμπειρία, αυτό είναι ένα εξαιρετικό μέρος για να πάρετε βάσεις που θα σας βοηθήσουν να επεκτείνετε τις ικανότητές σας κάτω από μια μεγάλη γκάμα σεναρίων της επιστήμης των δεδομένων.\nΑυτή η μετάφραση του βιβλίου έγινε από τους Παναγιώτη Τόγια και Μαρία-Θεοδώρα Πανδή.",
    "crumbs": [
      "Καλώς ήλθατε"
    ]
  },
  {
    "objectID": "index.html#ευχαριστίες",
    "href": "index.html#ευχαριστίες",
    "title": "Η R για την Επιστήμη των Δεδομένων (2η έκδοση)",
    "section": "Ευχαριστίες",
    "text": "Ευχαριστίες\nΤο βιβλίο φιλοξενείται από το https://www.netlify.com ως μέρος της υποστήριξής του σε λογισμικά ανοιχτού κώδικα και κοινότητες.",
    "crumbs": [
      "Καλώς ήλθατε"
    ]
  },
  {
    "objectID": "preface-2e.html",
    "href": "preface-2e.html",
    "title": "Πρόλογος δεύτερης έκδοσης",
    "section": "",
    "text": "Καλώς ήρθατε στη δεύτερη έκδοση του βιβλίου “Η R για την Επιστήμη των Δεδομένων”! Πρόκειται για μία μεγάλης κλίμακας επανεπεξεργασία της πρώτης έκδοσης, αφαιρώντας υλικό που δεν θεωρούμε πλέον χρήσιμο, προσθέτοντας υλικό που θα θέλαμε να είχαμε συμπεριλάβει στην πρώτη έκδοση και γενικά ανανεώνοντας το κείμενο και τον κώδικα για να αντικατοπτρίζουν αλλαγές στις καλές πρακτικές. Είμαστε επίσης ιδιαίτερα ενθουσιασμένοι που καλωσορίζουμε μία νέα συν-συγγραφέα: την Mine Çetinkaya-Rundel, μία διακεκριμένη εκπαιδευτικό στην επιστήμη των δεδομένων και μία από τους συναδέλφους μας στην Posit (την εταιρεία που ήταν παλαιότερα γνωστή ως RStudio).\nΑκολουθεί μία σύντομη περίληψη των μεγαλύτερων αλλαγών:\n\nΤο πρώτο μέρος του βιβλίου μετονομάστηκε σε “Η ολοκληρωμένη εικόνα”. Ο στόχος αυτής της ενότητας είναι να σας δώσει την ευρύτερη εικόνα της επιστήμης των δεδομένων προτού εμβαθύνουμε σε λεπτομέρειες.\nΤο δεύτερο μέρος του βιβλίου ονομάζεται «Οπτικοποίηση». Αυτό το μέρος παρέχει μία πιο εμπεριστατωμένη κάλυψη των εργαλείων οπτικοποίησης των δεδομένων και των αντίστοιχων καλών πρακτικών, σε σύγκριση με την πρώτη έκδοση. Το καλύτερο μέρος όπου θα βρείτε όλες τις σχετικές λεπτομέρειες εξακολουθεί να είναι το βιβλίο της ggplot2, πλέον όμως το βιβλίο καλύπτει περισσότερες από τις πιο σημαντικές τεχνικές.\nΤο τρίτο μέρος του βιβλίου ονομάζεται πλέον “Μετασχηματισμοί” και περιλαμβάνει νέα κεφάλαια σχετικά με αριθμούς, λογικά διανύσματα και κενές τιμές. Αυτά ήταν προηγουμένως μέρη του κεφαλαίου του μετασχηματισμού δεδομένων, για να καλυφθούν όλες οι λεπτομέρειες όμως χρειάζονταν πολύ περισσότερος χώρος.\nΤο τέταρτο μέρος του βιβλίου ονομάζεται «Εισαγωγή δεδομένων». Πρόκειται για ένα νέο σύνολο κεφαλαίων που εκτείνεται πέρα από την ανάγνωση απλών αρχείων κειμένων όπως στην εργασία με υπολογιστικά φύλλα, τη λήψη δεδομένων από βάσεις δεδομένων, την εργασία με δεδομένα μεγάλου όγκου (big data), την ορθογωνοποίηση ιεραρχικών δεδομένων και την ιστοσυγκομιδή, την συγκομιδή δεδομένων από ιστοσελίδες.\nΤο μέρος “Προγραμματισμός” παραμένει, αλλά έχει ξαναγραφτεί από την αρχή έτσι ώστε να εστιάσει στα πιο σημαντικά μέρη της δημιουργίας συναρτήσεων και των δομών επανάληψης. Η δημιουργία συναρτήσεων περιλαμβάνει πλέον λεπτομέρειες σχετικά με τον τρόπο περιτύλιξης (wrapping) των συναρτήσεων του tidyverse (αντιμετώπιση των προκλήσεων που προκύπτουν από τον τρόπο που οι tidy συναρτήσεις αξιολογούν τα ορίσματα), καθώς αυτό έχει γίνει πολύ πιο εύκολο και σημαντικό τα τελευταία χρόνια. Έχουμε ακόμη προσθέσει ένα νέο κεφάλαιο με σημαντικές συναρτήσεις του βασικού συνόλου λειτουργιών της R που είναι πιθανό να συναντήσετε εκεί έξω.\nΤο μέρος της μοντελοποίησης έχει αφαιρεθεί. Ποτέ δεν είχαμε αρκετό χώρο για να αποδώσουμε πλήρως τη μοντελοποίηση και πλέον υπάρχουν πολύ καλύτεροι διαθέσιμοι πόροι. Γενικά συνιστούμε να χρησιμοποιήσετε τα πακέτα tidymodels, καθώς και να διαβάσετε το Tidy Modeling with R των Max Kuhn και Julia Silge.\nΤο μέρος “Επικοινωνία” παραμένει, αλλά έχει ενημερωθεί διεξοδικά έτσι ώστε να περιλαμβάνει το Quarto στη θέση του R Markdown. Αυτή η έκδοση του βιβλίου έχει γραφτεί σε Quarto, το ξεκάθαρο εργαλείο του μέλλοντος.",
    "crumbs": [
      "Πρόλογος δεύτερης έκδοσης"
    ]
  },
  {
    "objectID": "intro.html",
    "href": "intro.html",
    "title": "Εισαγωγή",
    "section": "",
    "text": "Τι θα μάθετε\nΗ επιστήμη των δεδομένων είναι πεδίο με μεγάλο εύρος και είναι αδύνατο να κατανοηθούν τα πάντα διαβάζοντας ένα μόνο βιβλίο. Αυτό το βιβλίο στοχεύει στο να σας δώσει μία σταθερή βάση στα πιο σημαντικά εργαλεία και αρκετή γνώση έτσι ώστε να βρείτε τους πόρους για να μάθετε περισσότερα όταν αυτό χρειαστεί. Το μοντέλο μας σχετικά με τα βήματα ενός τυπικού έργου επιστήμης δεδομένων μοιάζει κάπως έτσι Σχήμα 1.\nΣχήμα 1: Στο μοντέλο μας για τη διαδικασία της επιστήμης των δεδομένων, ξεκινάτε με την εισαγωγή και την τακτοποίηση δεδομένων. Στη συνέχεια, κατανοείτε τα δεδομένα σας με έναν επαναληπτικό κύκλο μετασχηματισμού, οπτικοποίησης και μοντελοποίησης. Ολοκληρώνετε τη διαδικασία επικοινωνώντας τα αποτελέσματά σας με άλλους.\nΠρώτα, πρέπει να εισάγετε τα δεδομένα σας στην R. Αυτό συνήθως σημαίνει ότι λαμβάνετε δεδομένα που είναι αποθηκευμένα σε ένα αρχείο, βάση δεδομένων ή διεπαφή προγραμματισμού εφαρμογών (application programming interface; API) και τα φορτώνετε σε ένα πλαίσιο δεδομένων στην R. Εάν δεν μπορείτε να βάλετε τα δεδομένα σας στην R, δεν μπορείτε να κάνετε επιστήμη δεδομένων σε αυτά!\nΑφού εισάγετε τα δεδομένα σας, είναι καλή ιδέα να τα οργανώσετε. Η οργάνωση των δεδομένων σας σημαίνει την αποθήκευσή τους σε μία συνεπή μορφή που ταιριάζει με τη σημασιολογία του συνόλου δεδομένων ως προς τον αρχικό τρόπο αποθήκευσής τους. Εν συντομία, όταν τα δεδομένα σας είναι οργανωμένα, κάθε στήλη είναι μία μεταβλητή και κάθε γραμμή είναι μία παρατήρηση. Τα οργανωμένα δεδομένα είναι σημαντικά επειδή η συνέπεια στη δομή τους σας επιτρέπει να εστιάσετε στην απάντηση ερωτήσεων σχετικά με τα δεδομένα και όχι στο να αγωνίζεστε να φέρετε τα δεδομένα στη σωστή μορφή για διαφορετικές λειτουργίες.\nΑφού έχετε οργανωμένα δεδομένα, ένα σύνηθες επόμενο βήμα είναι να τα μετασχηματίσετε. Ο μετασχηματισμός περιλαμβάνει τον περιορισμό των παρατηρήσεων (όπως για παράδειγμα όλοι οι άνθρωποι σε μία συγκεκριμένη πόλη ή όλα τα δεδομένα του περασμένου έτους), τη δημιουργία νέων μεταβλητών που είναι συναρτήσεις άλλων (όπως ο εξ αποστάσεων υπολογισμός της ταχύτητας και του χρόνου) και τον υπολογισμό ενός συνόλου συνοπτικών στατιστικών (όπως αθροίσματα και μέσοι όροι). Όλα μαζί, η οργάνωση και ο μετασχηματισμός ονομάζονται διένεξη (wrangling) επειδή η μετατροπή των δεδομένων σε μία εύκολα επεξεργάσιμη μορφή συχνά μοιάζει με πάλη!\nΈχοντας οργανωμένα δεδομένα με τις μεταβλητές που χρειάζεστε, υπάρχουν δύο κύριες μηχανές παραγωγής γνώσης: οπτικοποίηση και μοντελοποίηση. Αυτά έχουν συμπληρωματικά πλεονεκτήματα και αδυναμίες, επομένως τα στοιχεία οποιασδήποτε σωστής ανάλυσης δεδομένων θα εναλλάσσονται μεταξύ των δύο πολλές φορές.\nΗ οπτικοποίηση είναι μία βασικά ανθρώπινη δραστηριότητα. Μία καλή οπτικοποίηση θα σας δείξει στοιχεία που δεν περιμένατε ή θα δημιουργήσει νέες ερωτήσεις σχετικά με τα δεδομένα. Μία καλή οπτικοποίηση μπορεί επίσης να υποδηλώσει ότι ρωτάτε μία λάθος ερώτηση ή ότι πρέπει να συλλέξετε διαφορετικά δεδομένα. Οι οπτικοποιήσεις μπορεί να σας εκπλήξουν, αλλά η χρήση τους δεν επεκτείνεται ιδιαίτερα διότι απαιτούν ανθρώπινη ερμηνεία.\nΤα μοντέλα είναι συμπληρωματικά εργαλεία οπτικοποίησης. Αφού κάνετε τις ερωτήσεις σας αρκετά ακριβείς, μπορείτε να χρησιμοποιήσετε ένα μοντέλο για να τις απαντήσετε. Τα μοντέλα είναι βασικά μαθηματικά ή υπολογιστικά εργαλεία, επομένως επεκτείνονται συνήθως καλά. Ακόμα κι όταν δεν το κάνουν, συνήθως είναι φθηνότερο να αγοράσεις περισσότερους υπολογιστές παρά περισσότερους εγκεφάλους! Όμως, κάθε μοντέλο κάνει υποθέσεις, και από τη φύση του, ένα μοντέλο δεν μπορεί να αμφισβητήσει τις δικές του υποθέσεις. Αυτό σημαίνει ότι ένα μοντέλο δεν μπορεί κατα βάση να σας εκπλήξει.\nΤο τελευταίο βήμα της επιστήμης δεδομένων είναι η επικοινωνία, ένα απολύτως κρίσιμο μέρος κάθε έργου ανάλυσης δεδομένων. Δεν έχει σημασία πόσο καλά τα μοντέλα και η οπτικοποίηση σας οδήγησαν να κατανοήσετε τα δεδομένα εάν δεν μπορείτε επίσης να κοινοποιήσετε τα αποτελέσματά σας σε άλλους.\nΓύρω από όλα αυτά τα εργαλεία είναι ο προγραμματισμός. Ο προγραμματισμός είναι ένα γενικό εργαλείο που χρησιμοποιείτε σχεδόν σε κάθε μέρος ενός έργου επιστήμης δεδομένων. Δεν χρειάζεται να είστε έμπειρος προγραμματιστής για να είστε επιτυχημένος επιστήμονας δεδομένων, αλλά το να μάθετε περισσότερα για τον προγραμματισμό αποδίδει, επειδή το να γίνετε καλύτερος προγραμματιστής σας επιτρέπει να αυτοματοποιείτε συνηθισμένες εργασίες και να επιλύετε νέα προβλήματα με μεγαλύτερη ευκολία.\nΘα χρησιμοποιήσετε αυτά τα εργαλεία σε κάθε έργο επιστήμης δεδομένων, αλλά για τα περισσότερα έργα, δεν είναι αρκετά. Υπάρχει ένας πρόχειρος “80/20” κανόνας που ισχύει εδώ: μπορείτε να αντιμετωπίσετε περίπου το 80% κάθε έργου χρησιμοποιώντας τα εργαλεία που θα μάθετε σε αυτό το βιβλίο, αλλά θα χρειαστείτε άλλα εργαλεία για να αντιμετωπίσετε το υπόλοιπο 20%. Σε όλα τα μέρη του βιβλίου αυτού, θα σας υποδεικνύουμε πηγές μέσα από τις οποίες μπορείτε να μάθετε περισσότερα.",
    "crumbs": [
      "Εισαγωγή"
    ]
  },
  {
    "objectID": "intro.html#πώς-είναι-οργανωμένο-αυτό-το-βιβλίο",
    "href": "intro.html#πώς-είναι-οργανωμένο-αυτό-το-βιβλίο",
    "title": "Εισαγωγή",
    "section": "Πώς είναι οργανωμένο αυτό το βιβλίο",
    "text": "Πώς είναι οργανωμένο αυτό το βιβλίο\nΗ προηγούμενη περιγραφή των εργαλείων της επιστήμης των δεδομένων είναι οργανωμένη κατά προσέγγιση σύμφωνα με τη σειρά με την οποία τα χρησιμοποιείτε σε μία ανάλυση (αν και, φυσικά, θα τα επαναλάβετε αρκετές φορές). Σύμφωνα με την εμπειρία μας, ωστόσο, η εκμάθηση της εισαγωγής και οργάνωσης δεδομένων ως πρώτο βήμα δεν είναι η ιδανική, επειδή, στο 80% των περιπτώσεων, γίνεται ρουτίνα και βαρετή, και το υπόλοιπο 20% των περιπτώσεων είναι περίεργη και κουραστική. Αυτό είναι ένα κακό μέρος για να ξεκινήσετε να μάθετε ένα νέο αντικείμενο! Αντίθετα, θα ξεκινήσουμε με την οπτικοποίηση και τον μετασχηματισμό δεδομένων που έχουν ήδη εισαχθεί και οργανωθεί. Έτσι, όταν εισάγετε και οργανώνετε τα δικά σας δεδομένα, το κίνητρό σας θα παραμείνει υψηλό επειδή γνωρίζετε ότι η ταλαιπωρία αξίζει τον κόπο.\nΜέσα σε κάθε κεφάλαιο, προσπαθούμε να τηρούμε ένα συνεπές μοτίβο: ξεκινάμε με μερικά ενθαρρυντικά παραδείγματα, ώστε να μπορείτε να δείτε τη μεγαλύτερη εικόνα και στη συνέχεια εξερευνούμε τις λεπτομέρειες. Κάθε ενότητα του βιβλίου συνδυάζεται με ασκήσεις που θα σας βοηθήσουν να εξασκήσετε αυτά που έχετε μάθει. Αν και μπορεί να είναι δελεαστικό να παραλείψετε τις ασκήσεις, δεν υπάρχει καλύτερος τρόπος για να μάθετε από την εξάσκηση πάνω σε πραγματικά προβλήματα.",
    "crumbs": [
      "Εισαγωγή"
    ]
  },
  {
    "objectID": "intro.html#τι-δεν-θα-μάθετε",
    "href": "intro.html#τι-δεν-θα-μάθετε",
    "title": "Εισαγωγή",
    "section": "Τι δεν θα μάθετε",
    "text": "Τι δεν θα μάθετε\nΥπάρχουν πολλά σημαντικά θέματα που δεν καλύπτει αυτό το βιβλίο. Πιστεύουμε ότι είναι σημαντικό να παραμείνετε αδίστακτα συγκεντρωμένοι στα βασικά, ώστε να μπορείτε να είστε έτοιμοι όσο το δυνατόν γρηγορότερα. Αυτό σημαίνει ότι αυτό το βιβλίο δεν μπορεί να καλύψει κάθε σημαντικό θέμα.\nΜοντελοποίηση\nΗ μοντελοποίηση είναι εξαιρετικά σημαντική για την επιστήμη των δεδομένων, αλλά είναι ένα μεγάλο θέμα και, δυστυχώς, απλώς δεν έχουμε τον χώρο να της δώσουμε την κάλυψη που της αξίζει εδώ. Για να μάθετε περισσότερα σχετικά με τη μοντελοποίηση, προτείνουμε ανεπιφύλακτα το Tidy Modeling with R από τους συναδέλφους μας Max Kuhn και Julia Silge. Αυτό το βιβλίο θα σας διδάξει την οικογένεια πακέτων tidymodels, τα οποία, όπως μπορείτε να μαντέψετε από το όνομα, μοιράζονται πολλούς κανόνες με τα πακέτα του tidyverse που χρησιμοποιούμε σε αυτό το βιβλίο.\nΔεδομένα μεγάλου όγκου\nΚυρίως και με υπερηφάνεια, αυτό το βιβλίο εστιάζει σε μικρά σύνολα δεδομένων με δυνατότητα να αποθηκευτούν στη μνήμη. Αυτό είναι το σωστό μέρος για να ξεκινήσετε, επειδή δεν μπορείτε να αντιμετωπίσετε δεδομένα μεγάλου όγκου εκτός εάν έχετε εμπειρία με μικρά σύνολα δεδομένων. Τα εργαλεία που θα μάθετε στο μεγαλύτερο μέρος αυτού του βιβλίου θα χειριστούν εύκολα εκατοντάδες megabyte δεδομένων και με λίγη προσοχή, μπορείτε να τα χρησιμοποιήσετε για να εργαστείτε με λίγα gigabyte δεδομένων. Θα σας δείξουμε επίσης πώς να λαμβάνετε δεδομένα από βάσεις δεδομένων και αρχεία parquet, τα οποία χρησιμοποιούνται συχνά για την αποθήκευση δεδομένων μεγάλoυ όγκου. Δεν θα μπορείτε απαραίτητα να εργαστείτε με ολόκληρο το σύνολο δεδομένων, αλλά αυτό δεν είναι πρόβλημα, επειδή χρειάζεστε μόνο ένα υποσύνολο για να απαντήσετε στην ερώτηση που σας ενδιαφέρει.\nΕάν εργάζεστε τακτικά με δεδομένα μεγαλύτερου όγκου (ας πούμε 10–100 GB), συνιστούμε να μάθετε περισσότερα σχετικά με το πακέτο data.table. Δεν το μαθαίνουμε εδώ επειδή χρησιμοποιεί διαφορετική διεπαφή από το tidyverse και απαιτεί από εσάς να μάθετε μερικούς διαφορετικούς κανόνες. Ωστόσο, είναι απίστευτα ταχύτερο και αξίζει να επενδύσετε λίγο χρόνο για να το μάθετε εάν εργάζεστε με δεδομένα μεγάλου όγκου.\nPython, Julia και φίλοι\nΣε αυτό το βιβλίο, δεν θα μάθετε τίποτα για Python, Julia ή οποιαδήποτε άλλη γλώσσα προγραμματισμού χρήσιμη για την επιστήμη των δεδομένων. Αυτό δεν συμβαίνει επειδή πιστεύουμε ότι αυτά τα εργαλεία είναι κακά. Δεν είναι! Και στην πράξη, οι περισσότερες ομάδες επιστήμης δεδομένων χρησιμοποιούν έναν συνδυασμό γλωσσών, σε πολλές περιπτώσεις τουλάχιστον R και Python. Πιστεύουμε όμως ακράδαντα ότι είναι καλύτερο να είστε καλοί σε ένα εργαλείο τη φορά και η R είναι ένα εξαιρετικό μέρος για να ξεκινήσετε.",
    "crumbs": [
      "Εισαγωγή"
    ]
  },
  {
    "objectID": "intro.html#προαπαιτούμενα",
    "href": "intro.html#προαπαιτούμενα",
    "title": "Εισαγωγή",
    "section": "Προαπαιτούμενα",
    "text": "Προαπαιτούμενα\nΚάναμε μερικές υποθέσεις σχετικά με αυτά που ήδη γνωρίζετε για να αξιοποιήσετε στο έπακρο αυτό το βιβλίο. Θα πρέπει να κατέχετε γενική αριθμητική παιδεία και είναι χρήσιμο εάν έχετε ήδη κάποια βασική εμπειρία προγραμματισμού. Εάν δεν έχετε προγραμματίσει ποτέ πριν, μπορεί να βρείτε το Hands on Programming with R του Garrett ως ένα πολύτιμο συμπλήρωμα αυτού του βιβλίου.\nΧρειάζεστε τέσσερα πράγματα για να εκτελέσετε τον κώδικα σε αυτό το βιβλίο: την R, το RStudio, μία συλλογή πακέτων R που ονομάζεται tidyverse και μία μερίδα άλλων πακέτων. Τα πακέτα είναι οι θεμελιώδεις μονάδες του αναπαράξιμου κώδικα R. Περιλαμβάνουν επαναχρησιμοποιήσιμες συναρτήσεις, τεκμηρίωση που περιγράφει τον τρόπο χρήσης τους και δείγματα δεδομένων.\nR\nΓια να κατεβάσετε την R, μεταβείτε στο CRAN, comprehensive R archive network, https://cloud.r-project.org. Μία νέα κύρια έκδοση της R κυκλοφορεί μία φορά κάθε χρόνο καθώς υπάρχουν και 2-3 μικρές εκδόσεις κάθε χρόνο. Είναι καλή ιδέα να αναβαθμίζετε τακτικά. Η αναβάθμιση μπορεί να περιέχει λίγη ταλαιπωρία, ειδικά για τις κύριες εκδόσεις που απαιτούν να εγκαταστήσετε ξανά όλα τα πακέτα σας, αλλά η αναβολή κάνει τα πράγματα μόνο χειρότερα. Προτείνουμε την R 4.2.0 ή κάποια μεταγενέστερη για αυτό το βιβλίο.\nRStudio\nΤο RStudio είναι ένα ολοκληρωμένο περιβάλλον ανάπτυξης (integrated development environment, ή IDE), για προγραμματισμό με R, το οποίο μπορείτε να κατεβάσετε από το https://posit.co/download/rstudio-desktop/. Το RStudio ενημερώνεται μερικές φορές το χρόνο και θα σας ενημερώνει αυτόματα όταν κυκλοφορήσει μία νέα έκδοση, επομένως δεν χρειάζεται να το ελέγξετε ξανά. Είναι καλή ιδέα να κάνετε συχνές αναβαθμίσεις για να επωφεληθείτε από τις πιο πρόσφατες και καλύτερες δυνατότητες. Για αυτό το βιβλίο, βεβαιωθείτε ότι έχετε τουλάχιστον το RStudio 2022.02.0.\nΌταν ανοίγετε το RStudio, Σχήμα 2, θα παρατηρήσετε στο περιβάλλον δύο βασικές περιοχές: το παράθυρο της κονσόλας και το παράθυρο εξόδου. Προς το παρόν, το μόνο που χρειάζεται να γνωρίζετε είναι ότι πληκτρολογείτε τον κώδικα σε R στο παράθυρο της κονσόλας και πατάτε enter για να τον εκτελέσετε. Θα μάθετε περισσότερα καθώς προχωράμε!1\n\n\n\n\n\n\n\nΣχήμα 2: Το περιβάλλον του Rstudio έχει δύο βασικές περιοχές: πληκτρολογήστε τον κώδικα σε R στο πεδίο της κονσόλας (Console) στα αριστερά, και παρατηρήστε τα διαγράμματα που έχουν δημιουργηθει στο πεδίο της εξόδου (Output) στα δεξιά.\n\n\n\n\nΤο tidyverse\nΘα χρειαστεί επίσης να εγκαταστήσετε μερικά πακέτα R. Ένα πακέτο είναι μία συλλογή συναρτήσεων, δεδομένων και εγχειριδίων που επεκτείνει τις βασικές δυνατότητες της R. Η χρήση πακέτων είναι το κλειδί για την επιτυχή χρήση της R. Η πλειοψηφία των πακέτων που θα μάθετε σε αυτό το βιβλίο είναι μέρος του λεγόμενου tidyverse. Όλα τα πακέτα στο tidyverse μοιράζονται μία κοινή φιλοσοφία τύπου δεδομένων και προγραμματισμού σε R και έχουν σχεδιαστεί για να μπορούν να συνδυαστούν.\nΜπορείτε να εγκαταστήσετε το πλήρες tidyverse με μία μόνο γραμμή κώδικα:\n\ninstall.packages(\"tidyverse\")\n\nΣτον υπολογιστή σας, πληκτρολογήστε αυτήν τη γραμμή κώδικα στην κονσόλα και στη συνέχεια πατήστε enter για να την εκτελέσετε. Η R θα κατεβάσει τα πακέτα από το CRAN και θα τα εγκαταστήσει στον υπολογιστή σας.\nΔεν θα μπορείτε να χρησιμοποιήσετε τις συναρτήσεις, τα αντικείμενα ή τα έγγραφα βοήθειας σε ένα πακέτο μέχρι να το φορτώσετε με τη συνάρτηση library(). Αφού εγκαταστήσετε ένα πακέτο, μπορείτε να το φορτώσετε χρησιμοποιώντας τη συνάρτηση library():\n\nlibrary(tidyverse)\n#&gt; ── Attaching core tidyverse packages ───────────────────── tidyverse 2.0.0 ──\n#&gt; ✔ dplyr     1.1.4     ✔ readr     2.1.5\n#&gt; ✔ forcats   1.0.0     ✔ stringr   1.5.1\n#&gt; ✔ ggplot2   3.5.0     ✔ tibble    3.2.1\n#&gt; ✔ lubridate 1.9.3     ✔ tidyr     1.3.1\n#&gt; ✔ purrr     1.0.2     \n#&gt; ── Conflicts ─────────────────────────────────────── tidyverse_conflicts() ──\n#&gt; ✖ dplyr::filter() masks stats::filter()\n#&gt; ✖ dplyr::lag()    masks stats::lag()\n#&gt; ℹ Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors\n\nΑυτό σας λέει ότι το tidyverse φορτώνει εννέα πακέτα: dplyr, forcats, ggplot2, lubridate, purrr, readr, stringr, tibble, tidyr. Αυτά θεωρούνται ο πυρήνας του tidyverse, καθώς θα τα χρησιμοποιείτε σχεδόν σε κάθε ανάλυση.\nΤα πακέτα στο tidyverse αλλάζουν αρκετά συχνά. Μπορείτε να δείτε εάν υπάρχουν διαθέσιμες ενημερώσεις εκτελώντας tidyverse_update().\nΆλλα πακέτα\nΥπάρχουν πολλά άλλα εξαιρετικά πακέτα που δεν αποτελούν μέρος του tidyverse μιας και επιλύουν προβλήματα που ανοίγουν σε διαφορετικούς τομείς ή έχουν σχεδιαστεί με ένα διαφορετικό σύνολο βασικών αρχών. Αυτό δεν τα κάνει καλύτερα ή χειρότερα - απλά τα κάνει διαφορετικά. Με άλλα λόγια, το συμπληρωματικό κομμάτι του tidyverse δεν είναι το messyverse, αλλά άλλοι κόσμοι (universes) αλληλένδετων πακέτων. Καθώς αντιμετωπίζετε περισσότερα έργα επιστήμης δεδομένων με την R, θα μάθετε νέα πακέτα και νέους τρόπους σκέψης που σχετίζονται με δεδομένα.\nΣε αυτό το βιβλίο θα χρησιμοποιήσουμε πολλά πακέτα εκτός του tidyverse. Για παράδειγμα, θα χρησιμοποιήσουμε τα ακόλουθα πακέτα επειδή παρέχουν ενδιαφέροντα σύνολα δεδομένων για τη διαδικασία εκμάθησης της R:\n\ninstall.packages(\n  c(\"arrow\", \"babynames\", \"curl\", \"duckdb\", \"gapminder\", \n    \"ggrepel\", \"ggridges\", \"ggthemes\", \"hexbin\", \"janitor\", \"Lahman\", \n    \"leaflet\", \"maps\", \"nycflights13\", \"openxlsx\", \"palmerpenguins\", \n    \"repurrrsive\", \"tidymodels\", \"writexl\")\n  )\n\nΘα χρησιμοποιήσουμε επίσης μία επιλογή από άλλα πακέτα για μεμονωμένα παραδείγματα. Δεν χρειάζεται να τα εγκαταστήσετε τώρα, απλά να θυμάστε ότι κάθε φορά που βλέπετε ένα σφάλμα όπως αυτό:\n\nlibrary(ggrepel)\n#&gt; Error in library(ggrepel) : there is no package called ‘ggrepel’\n\nΘα πρέπει να εκτελέσετε install.packages(\"ggrepel\") για να εγκαταστήσετε το πακέτο.",
    "crumbs": [
      "Εισαγωγή"
    ]
  },
  {
    "objectID": "intro.html#εκτελώντας-κώδικα-r",
    "href": "intro.html#εκτελώντας-κώδικα-r",
    "title": "Εισαγωγή",
    "section": "Εκτελώντας κώδικα R",
    "text": "Εκτελώντας κώδικα R\nΗ προηγούμενη ενότητα σας έδειξε αρκετά παραδείγματα εκτέλεσης κώδικα R. Ο κώδικας στο βιβλίο δείχνει κάπως έτσι:\n\n1 + 2\n#&gt; [1] 3\n\nΑν εκτελέσετε τον ίδιο κώδικα στο πεδίο της κονσόλας σας, θα δείχνει κάπως έτσι:\n&gt; 1 + 2\n[1] 3\nΥπάρχουν δύο βασικές διαφορές. Στην κονσόλα σας, πληκτρολογείτε (τον κώδικα) μετά το &gt;, που ονομάζεται εντολή. Δεν δείχνουμε την εντολή στο βιβλίο. Στο βιβλίο, η έξοδος αφαιρείται τοποθετώντας τη ως σχόλιο με #&gt;. Στην κονσόλα σας, εμφανίζεται αμέσως μετά τον κώδικά σας. Αυτές οι δύο διαφορές σημαίνουν ότι εάν εργάζεστε με μία ηλεκτρονική έκδοση του βιβλίου, μπορείτε εύκολα να αντιγράψετε κώδικα από το βιβλίο και να τον επικολλήσετε στην κονσόλα.\nΣε όλο το βιβλίο, χρησιμοποιούμε ένα συνεπές σύνολο κανόνων για να αναφερθούμε στον κώδικα:\n\nΟι συναρτήσεις εμφανίζονται σε μία γραμματοσειρά κώδικα και ακολουθούνται από παρενθέσεις, όπως sum() ή mean().\nΆλλα αντικείμενα R (όπως ορίσματα δεδομένων ή συναρτήσεων) είναι σε γραμματοσειρά κώδικα, χωρίς παρενθέσεις, όπως flights ή x.\nΜερικές φορές, για να ξεκαθαρίσουμε από ποιο πακέτο προέρχεται ένα αντικείμενο, θα χρησιμοποιήσουμε το όνομα του πακέτου ακολουθούμενο από δύο άνω και κάτω τελείες, όπως dplyr::mutate() ή nycflights13::flights. Αυτός ο κώδικας R είναι επίσης έγκυρος.",
    "crumbs": [
      "Εισαγωγή"
    ]
  },
  {
    "objectID": "intro.html#ευχαριστίες",
    "href": "intro.html#ευχαριστίες",
    "title": "Εισαγωγή",
    "section": "Ευχαριστίες",
    "text": "Ευχαριστίες\nΑυτό το βιβλίο δεν είναι μόνο προϊόν των Hadley, Mine και Garrett, αλλά είναι το αποτέλεσμα πολλών συζητήσεων (δια ζώσης και διαδικτυακών) που είχαμε με πολλά άτομα μέσα από την κοινότητα της R. Είμαστε απίστευτα ευγνώμονες για όλες τις συζητήσεις που είχαμε μαζί σας. Σας ευχαριστούμε πάρα πολύ!\nΑυτό το βιβλίο είναι γραμμένο απο κοινού με πολλά άτομα να έχουν συμβάλλει μέσω pull requests. Ένα μεγάλο ευχαριστώ σε όλους 259 εσάς που κατέθεσατε βελτιώσεις μέσω pull requests του GitHub (με αλφαβητική σειρα ανα όνομα χρήστη): @a-rosenberg, Tim Becker (@a2800276), Abinash Satapathy (@Abinashbunty), Adam Gruer (@adam-gruer), adi pradhan (@adidoit), A. s. (@Adrianzo), Aep Hidyatuloh (@aephidayatuloh), Andrea Gilardi (@agila5), Ajay Deonarine (@ajay-d), @AlanFeder, Daihe Sui (@alansuidaihe), @alberto-agudo, @AlbertRapp, @aleloi, pete (@alonzi), Alex (@ALShum), Andrew M. (@amacfarland), Andrew Landgraf (@andland), @andyhuynh92, Angela Li (@angela-li), Antti Rask (@AnttiRask), LOU Xun (@aquarhead), @ariespirgel, @august-18, Michael Henry (@aviast), Azza Ahmed (@azzaea), Steven Moran (@bambooforest), Brian G. Barkley (@BarkleyBG), Mara Averick (@batpigandme), Oluwafemi OYEDELE (@BB1464), Brent Brewington (@bbrewington), Bill Behrman (@behrman), Ben Herbertson (@benherbertson), Ben Marwick (@benmarwick), Ben Steinberg (@bensteinberg), Benjamin Yeh (@bentyeh), Betul Turkoglu (@betulturkoglu), Brandon Greenwell (@bgreenwell), Bianca Peterson (@BinxiePeterson), Birger Niklas (@BirgerNi), Brett Klamer (@bklamer), @boardtc, Christian (@c-hoh), Caddy (@caddycarine), Camille V Leonard (@camillevleonard), @canovasjm, Cedric Batailler (@cedricbatailler), Christina Wei (@christina-wei), Christian Mongeau (@chrMongeau), Cooper Morris (@coopermor), Colin Gillespie (@csgillespie), Rademeyer Vermaak (@csrvermaak), Chloe Thierstein (@cthierst), Chris Saunders (@ctsa), Abhinav Singh (@curious-abhinav), Curtis Alexander (@curtisalexander), Christian G. Warden (@cwarden), Charlotte Wickham (@cwickham), Kenny Darrell (@darrkj), David Kane (@davidkane9), David (@davidrsch), David Rubinger (@davidrubinger), David Clark (@DDClark), Derwin McGeary (@derwinmcgeary), Daniel Gromer (@dgromer), @Divider85, @djbirke, Danielle Navarro (@djnavarro), Russell Shean (@DOH-RPS1303), Zhuoer Dong (@dongzhuoer), Devin Pastoor (@dpastoor), @DSGeoff, Devarshi Thakkar (@dthakkar09), Julian During (@duju211), Dylan Cashman (@dylancashman), Dirk Eddelbuettel (@eddelbuettel), Edwin Thoen (@EdwinTh), Ahmed El-Gabbas (@elgabbas), Henry Webel (@enryH), Ercan Karadas (@ercan7), Eric Kitaif (@EricKit), Eric Watt (@ericwatt), Erik Erhardt (@erikerhardt), Etienne B. Racine (@etiennebr), Everett Robinson (@evjrob), @fellennert, Flemming Miguel (@flemmingmiguel), Floris Vanderhaeghe (@florisvdh), @funkybluehen, @gabrivera, Garrick Aden-Buie (@gadenbuie), Peter Ganong (@ganong123), Gerome Meyer (@GeroVanMi), Gleb Ebert (@gl-eb), Josh Goldberg (@GoldbergData), bahadir cankardes (@gridgrad), Gustav W Delius (@gustavdelius), Hao Chen (@hao-trivago), Harris McGehee (@harrismcgehee), @hendrikweisser, Hengni Cai (@hengnicai), Iain (@Iain-S), Ian Sealy (@iansealy), Ian Lyttle (@ijlyttle), Ivan Krukov (@ivan-krukov), Jacob Kaplan (@jacobkap), Jazz Weisman (@jazzlw), John Blischak (@jdblischak), John D. Storey (@jdstorey), Gregory Jefferis (@jefferis), Jeffrey Stevens (@JeffreyRStevens), 蒋雨蒙 (@JeldorPKU), Jennifer (Jenny) Bryan (@jennybc), Jen Ren (@jenren), Jeroen Janssens (@jeroenjanssens), @jeromecholewa, Janet Wesner (@jilmun), Jim Hester (@jimhester), JJ Chen (@jjchern), Jacek Kolacz (@jkolacz), Joanne Jang (@joannejang), @johannes4998, John Sears (@johnsears), @jonathanflint, Jon Calder (@jonmcalder), Jonathan Page (@jonpage), Jon Harmon (@jonthegeek), JooYoung Seo (@jooyoungseo), Justinas Petuchovas (@jpetuchovas), Jordan (@jrdnbradford), Jeffrey Arnold (@jrnold), Jose Roberto Ayala Solares (@jroberayalas), Joyce Robbins (@jtr13), @juandering, Julia Stewart Lowndes (@jules32), Sonja (@kaetschap), Kara Woo (@karawoo), Katrin Leinweber (@katrinleinweber), Karandeep Singh (@kdpsingh), Kevin Perese (@kevinxperese), Kevin Ferris (@kferris10), Kirill Sevastyanenko (@kirillseva), Jonathan Kitt (@KittJonathan), @koalabearski, Kirill Müller (@krlmlr), Rafał Kucharski (@kucharsky), Kevin Wright (@kwstat), Noah Landesberg (@landesbergn), Lawrence Wu (@lawwu), @lindbrook, Luke W Johnston (@lwjohnst86), Kara de la Marck (@MarckK), Kunal Marwaha (@marwahaha), Matan Hakim (@matanhakim), Matthias Liew (@MatthiasLiew), Matt Wittbrodt (@MattWittbrodt), Mauro Lepore (@maurolepore), Mark Beveridge (@mbeveridge), @mcewenkhundi, mcsnowface, PhD (@mcsnowface), Matt Herman (@mfherman), Michael Boerman (@michaelboerman), Mitsuo Shiota (@mitsuoxv), Matthew Hendrickson (@mjhendrickson), @MJMarshall, Misty Knight-Finley (@mkfin7), Mohammed Hamdy (@mmhamdy), Maxim Nazarov (@mnazarov), Maria Paula Caldas (@mpaulacaldas), Mustafa Ascha (@mustafaascha), Nelson Areal (@nareal), Nate Olson (@nate-d-olson), Nathanael (@nateaff), @nattalides, Ned Western (@NedJWestern), Nick Clark (@nickclark1000), @nickelas, Nirmal Patel (@nirmalpatel), Nischal Shrestha (@nischalshrestha), Nicholas Tierney (@njtierney), Jakub Nowosad (@Nowosad), Nick Pullen (@nstjhp), @olivier6088, Olivier Cailloux (@oliviercailloux), Robin Penfold (@p0bs), Pablo E. Garcia (@pabloedug), Paul Adamson (@padamson), Penelope Y (@penelopeysm), Peter Hurford (@peterhurford), Peter Baumgartner (@petzi53), Patrick Kennedy (@pkq), Pooya Taherkhani (@pooyataher), Y. Yu (@PursuitOfDataScience), Radu Grosu (@radugrosu), Ranae Dietzel (@Ranae), Ralph Straumann (@rastrau), Rayna M Harris (@raynamharris), @ReeceGoding, Robin Gertenbach (@rgertenbach), Jajo (@RIngyao), Riva Quiroga (@rivaquiroga), Richard Knight (@RJHKnight), Richard Zijdeman (@rlzijdeman), @robertchu03, Robin Kohrs (@RobinKohrs), Robin (@Robinlovelace), Emily Robinson (@robinsones), Rob Tenorio (@robtenorio), Rod Mazloomi (@RodAli), Rohan Alexander (@RohanAlexander), Romero Morais (@RomeroBarata), Albert Y. Kim (@rudeboybert), Saghir (@saghirb), Hojjat Salmasian (@salmasian), Jonas (@sauercrowd), Vebash Naidoo (@sciencificity), Seamus McKinsey (@seamus-mckinsey), @seanpwilliams, Luke Smith (@seasmith), Matthew Sedaghatfar (@sedaghatfar), Sebastian Kraus (@sekR4), Sam Firke (@sfirke), Shannon Ellis (@ShanEllis), @shoili, Christian Heinrich (@Shurakai), S’busiso Mkhondwane (@sibusiso16), SM Raiyyan (@sm-raiyyan), Jakob Krigovsky (@sonicdoe), Stephan Koenig (@stephan-koenig), Stephen Balogun (@stephenbalogun), Steven M. Mortimer (@StevenMMortimer), Stéphane Guillou (@stragu), Sulgi Kim (@sulgik), Sergiusz Bleja (@svenski), Tal Galili (@talgalili), Alec Fisher (@Taurenamo), Todd Gerarden (@tgerarden), Tom Godfrey (@thomasggodfrey), Tim Broderick (@timbroderick), Tim Waterhouse (@timwaterhouse), TJ Mahr (@tjmahr), Thomas Klebel (@tklebel), Tom Prior (@tomjamesprior), Terence Teo (@tteo), @twgardner2, Ulrik Lyngs (@ulyngs), Shinya Uryu (@uribo), Martin Van der Linden (@vanderlindenma), Walter Somerville (@waltersom), @werkstattcodes, Will Beasley (@wibeasley), Yihui Xie (@yihui), Yiming (Paul) Li (@yimingli), @yingxingwu, Hiroaki Yutani (@yutannihilation), Yu Yu Aung (@yuyu-aung), Zach Bogart (@zachbogart), @zeal626, Zeki Akyol (@zekiakyol).",
    "crumbs": [
      "Εισαγωγή"
    ]
  },
  {
    "objectID": "intro.html#κολοφώνας",
    "href": "intro.html#κολοφώνας",
    "title": "Εισαγωγή",
    "section": "Κολοφώνας",
    "text": "Κολοφώνας\nΜία ηλεκτρονική έκδοση αυτού του βιβλίου είναι διαθέσιμη στη διεύθυνση https://r4ds.hadley.nz. Θα συνεχίσει να εξελίσσεται μεταξύ των αναθεωρήσεων του φυσικού βιβλίου. Ο πηγαίος κώδικας του βιβλίου είναι διαθέσιμος στη διεύθυνση https://github.com/hadley/r4ds. Το βιβλίο δημιουργήθηκε με Quarto, το οποίο διευκολύνει τη σύνταξη βιβλίων που συνδυάζουν κείμενο και εκτελέσιμο κώδικα.",
    "crumbs": [
      "Εισαγωγή"
    ]
  },
  {
    "objectID": "intro.html#footnotes",
    "href": "intro.html#footnotes",
    "title": "Εισαγωγή",
    "section": "",
    "text": "Εάν θέλετε μία ολοκληρωμένη επισκόπηση όλων των δυνατοτήτων του RStudio, ανατρέξτε στον αντίστοιχο Οδηγό Χρήστη στη διεύθυνση https://docs.posit.co/ide/user.↩︎",
    "crumbs": [
      "Εισαγωγή"
    ]
  },
  {
    "objectID": "whole-game.html",
    "href": "whole-game.html",
    "title": "Η ολοκληρωμένη εικόνα",
    "section": "",
    "text": "Στόχος μας σε αυτό το μέρος του βιβλίου είναι να σας δώσουμε μία γρήγορη επισκόπηση των κύριων εργαλείων της επιστήμης των δεδομένων: εισαγωγή, τακτοποίηση, μετατροπή και οπτικοποίηση δεδομένων, όπως φαίνεται στο Σχήμα 1. Θέλουμε να σας παρουσιάσουμε την “ολοκληρωμένη εικόνα” της επιστήμης των δεδομένων δίνοντάς σας αρκετά από τα κύρια κομμάτια, ώστε να μπορείτε να αντιμετωπίσετε πραγματικά, αν και απλά, σύνολα δεδομένων. Τα τελευταία μέρη του βιβλίου θα αγγίξουν καθένα από αυτά τα θέματα σε μεγαλύτερο βάθος, αυξάνοντας το εύρος των προκλήσεων της επιστήμης των δεδομένων που μπορείτε να αντιμετωπίσετε.\n\n\n\n\n\n\n\nΣχήμα 1: Σε αυτό το μέρος του βιβλίου, θα μάθετε για την εισαγωγή, την τακοτποίηση, τον μετασχηματισμό και την οπτικοποίηση δεδομένων.\n\n\n\n\nΤέσσερα κεφάλαια εστιάζουν στα εργαλεία της επιστήμης των δεδομένων:\n\nΗ οπτικοποίηση αποτελεί ένα εξαιρετικό σημείο για να ξεκινήσουμε τον προγραμματισμό με R, καθώς η ανταμοιβή είναι ξεκάθαρη: δημιουργείτε κομψά και ενημερωτικά γραφήματα που βοηθούν στην κατανόηση των δεδομένων. Στο 1  Οπτικοποίηση δεδομένων θα εμβαθύνετε στην οπτικοποίηση, μαθαίνοντας τη βασική δομή ενός διαγράμματος ggplot2, καθώς και δημοφιλείς τεχνικές για τη μετατροπή των δεδομένων σε διαγράμματα.\nΗ οπτικοποίηση μόνη της δεν είναι αρκετή, οπότε στο 3  Μετασχηματισμός Δεδομένων, θα μάθετε τα βασικές συναρτήσεις που επιτρέπουν την επιλογή σημαντικών μεταβλητών, το φιλτράρισμα βασικών παρατηρήσεων, τη δημιουργία νέων μεταβλητών και τον υπολογισμό συγκεντρωτικών περιλήψεων.\nΣτο 5  Τακτοποίηση δεδομένων, θα μάθετε για τα τακτοποιημένα δεδομένα, έναν συνεπή τρόπο αποθήκευσης των δεδομένων, που κάνει το μετασχηματισμό, την οπτικοποίηση, και τη μοντελοποίηση ευκολότερη. Θα μάθετε τις βασικές αρχές και πώς να φέρνετε τα δεδομένα σε μία τακτοποιημένη μορφή.\nΠριν μετασχηματίσετε και οπτικοποιήσετε τα δεδομένα σας, θα πρέπει πρώτα να τα εισάγετε στην R. Στο 7  Εισαγωγή δεδομένων θα μάθετε τα βασικά για την εισαγωγή αρχείων .csv στην R.\n\nΑνάμεσα σε αυτά τα κεφάλαια υπάρχουν τέσσερα ακόμη άλλα κεφάλαια που εστιάζουν στη ροή εργασιών σας στην R. Στο 2  Ροή εργασιών: Bασικές αρχές, 4  Ροή εργασιών: πρότυπα γραφής κώδικα και 6  Ροή εργασιών: αρχεία κώδικα και projects θα μάθετε καλές πρακτικές ροής εργασιών ενώ γράφετε και οργανώνετε τον R κώδικα σας. Αυτές θα σας προετοιμάσουν για μία επιτυχημένη πορεία μακροπρόθεσμα, καθώς σας παρέχουν τα εργαλεία για να παραμείνετε οργανωμένοι ενώ αντιμετωπίζετε αληθινά έργα. Τέλος, το 8  Ροή εργασίας: αναζητώντας βοήθεια θα σας μάθει πως να βρίσκετε βοήθεια και να συνεχίσετε να μαθαίνετε.",
    "crumbs": [
      "Η ολοκληρωμένη εικόνα"
    ]
  },
  {
    "objectID": "data-visualize.html",
    "href": "data-visualize.html",
    "title": "1  Οπτικοποίηση δεδομένων",
    "section": "",
    "text": "1.1 Εισαγωγή\nΗ R διαθέτει αρκετά συστήματα για τη δημιουργία γραφημάτων, αλλά το πακέτο ggplot2 αποτελεί ένα από τα πιο κομψά και πολυδιάστατα. Η ggplot2 εφαρμόζει τη γραμματική των γραφικών, ένα συνεπές σύστημα για την περιγραφή και τη δημιουργία γραφημάτων. Με το πακέτο ggplot2, μπορείτε να κάνετε περισσότερα και πιο γρήγορα, μαθαίνοντας ένα σύστημα και εφαρμόζοντάς το σε πολλά σημεία.\nΑυτό το κεφάλαιο θα σας διδάξει πως να οπτικοποιείτε τα δεδομένα σας χρησιμοποιώντας την ggplot2. Θα ξεκινήσουμε δημιουργώντας ένα απλό διάγραμμα διασποράς και θα το χρησιμοποιήσουμε για να εισάγουμε αισθητικές αντιστοιχίες και γεωμετρικά αντικείμενα - τα βασικά δομικά στοιχεία της ggplot2. Στη συνέχεια θα προχωρήσουμε στην οπτικοποίηση κατανομών μεμονωμένων μεταβλητών, καθώς και στην οπτικοποίηση σχέσεων ανάμεσα σε δύο ή και περισσότερες μεταβλητές. Τέλος, θα κλείσουμε αποθηκεύοντας τα γραφήματα και δίνοντας συμβουλές για την αντιμετώπιση προβλημάτων.",
    "crumbs": [
      "Η ολοκληρωμένη εικόνα",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Οπτικοποίηση δεδομένων</span>"
    ]
  },
  {
    "objectID": "data-visualize.html#εισαγωγή",
    "href": "data-visualize.html#εισαγωγή",
    "title": "1  Οπτικοποίηση δεδομένων",
    "section": "",
    "text": "“Το απλό γράφημα έχει φέρει περισσότερες πληροφορίες στο μυαλό του αναλυτή δεδομένων από οποιαδήποτε άλλη συσκευή.” — John Tukey\n\n\n\n\n1.1.1 Προαπαιτούμενα\nΑυτό το κεφάλαιο επικεντρώνεται στο πακέτο ggplot2, ένα από τα κεντρικά πακέτα του tidyverse. Για να αποκτήσετε πρόσβαση στα δεδομένα, τις βοηθητικές σελίδες και τις συναρτήσεις που χρησιμοποιούνται σε αυτό το κεφάλαιο, φορτώστε το tidyverse τρέχοντας:\n\nlibrary(tidyverse)\n#&gt; ── Attaching core tidyverse packages ───────────────────── tidyverse 2.0.0 ──\n#&gt; ✔ dplyr     1.1.4     ✔ readr     2.1.5\n#&gt; ✔ forcats   1.0.0     ✔ stringr   1.5.1\n#&gt; ✔ ggplot2   3.5.0     ✔ tibble    3.2.1\n#&gt; ✔ lubridate 1.9.3     ✔ tidyr     1.3.1\n#&gt; ✔ purrr     1.0.2     \n#&gt; ── Conflicts ─────────────────────────────────────── tidyverse_conflicts() ──\n#&gt; ✖ dplyr::filter() masks stats::filter()\n#&gt; ✖ dplyr::lag()    masks stats::lag()\n#&gt; ℹ Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors\n\nΑυτή η μία γραμμή κώδικα φορτώνει τον κορμό του tidyverse, τα πακέτα που θα χρησιμοποιήσετε σχεδόν σε κάθε ανάλυση δεδομένων. Επίσης, σας ενημερώνει για το ποιες συναρτήσεις από το tidyverse συγκρούονται με συναρτήσεις του βασικού συνόλου λειτουργιών της R (ή από άλλα πακέτα που μπορεί να έχετε φορτώσει)1.\nΕάν τρέξετε την παραπάνω γραμμή κώδικα και πάρετε μήνυμα σφάλματος there is no package called 'tidyverse', θα πρέπει πρώτα να το εγκαταστήσετε και στη συνέχεια να τρέξετε ξανά την εντολή library().\n\ninstall.packages(\"tidyverse\")\nlibrary(tidyverse)\n\nΧρειάζεται να εγκαταστήσετε ένα πακέτο μόνο μία φορά, αλλά θα πρέπει να το φορτώνεται κάθε φορά που ξεκινάτε μία νέα συνεδρία (session).\nΜαζί με το tidyverse, θα χρησιμοποιήσουμε επίσης το πακέτο palmerpenguins, που περιλαμβάνει το σύνολο δεδομένων penguins, το οποίο περιέχει τις σωματικές μετρήσεις πιγκουίνων σε τρία νησιά του Αρχιπελάγους Πάλμερ και το πακέτο ggthemes, το οποίο προσφέρει μία χρωματική παλέτα ασφαλή για άτομα με αχρωματοψία.\n\nlibrary(palmerpenguins)\nlibrary(ggthemes)",
    "crumbs": [
      "Η ολοκληρωμένη εικόνα",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Οπτικοποίηση δεδομένων</span>"
    ]
  },
  {
    "objectID": "data-visualize.html#πρώτα-βήματα",
    "href": "data-visualize.html#πρώτα-βήματα",
    "title": "1  Οπτικοποίηση δεδομένων",
    "section": "\n1.2 Πρώτα βήματα",
    "text": "1.2 Πρώτα βήματα\nΟι πιγκουίνοι με μακρύτερα πτερύγια ζυγίζουν περισσότερο ή λιγότερο από πιγκουίνους με πιο κοντά πτερύγια; Πιθανότατα έχετε ήδη μία απάντηση, αλλά ας προσπαθήσουμε να κάνουμε την απάντηση μας πιο συγκεκριμένη. Πως δείχνει η σχέση ανάμεσα στο μήκος των πτερυγίων και τη μάζα του σώματος; Είναι θετική; Αρνητική; Γραμμική; Μη γραμμική; Μήπως διαφοροποιείται αυτή η σχέση ανάλογα με το είδος του πιγκουίνου; Ή ίσως με το νησί στο οποίο ο πιγκουίνος κατοικεί; Ας δημιουργήσουμε γραφήματα που μπορούμε να χρησιμοποιήσουμε για να απαντήσουμε αυτές τις ερωτήσεις.\n\n1.2.1 Το πλαίσιο δεδομένων penguins\n\nΜπορείτε να ελέγξετε τις απαντήσεις σας σε αυτές τις ερωτήσεις με το πλαίσιο δεδομένων penguins που περιέχεται στο palmerpenguins (δηλ. palmerpenguins::penguins). Ένα πλαίσιο δεδομένων είναι μία ορθογώνια συλλογή μεταβλητών (στις στήλες) και παρατηρήσεων (στις γραμμές). Το penguins περιέχει 344 παρατηρήσεις που έχουν συλλεχθεί και γίνει διαθέσιμες από την Δρ. Kristen Gorman και τον ερευνητικό σταθμό Πάλμερ, Antarctica LTER2.\nΓια να διευκολύνουμε τη συζήτηση, ας ορίσουμε μερικούς όρους:\n\nΜία μεταβλητή είναι μία ποσότητα, ποιότητα ή ιδιότητα την οποία μπορούμε να μετρήσουμε.\nΜία τιμή είναι η κατάσταση της μεταβλητής όταν την μετράμε. Η τιμή μιας μεταβλητής μπορεί να αλλάζει από μέτρηση σε μέτρηση.\nΜία παρατήρηση είναι ένα σύνολο μετρήσεων που έχουν προκύψει κάτω από παρόμοιες συνθήκες (συνήθως λαμβάνουμε όλες τις μετρήσεις που αντιστοιχούν σε μία παρατήρηση την ίδια στιγμή και στο ίδιο αντικείμενο). Μία παρατήρηση μπορεί να περιέχει αρκετές τιμές, κάθε μία από τις οποίες συνδέεται με μία διαφορετική μεταβλητή. Μερικές φορές θα αναφερόμαστε σε μία παρατήρηση ως ένα σημείο δεδομένων.\nΈνας πίνακας δεδομένων είναι ένα σύνολο τιμών, κάθε μία από τις οποίες συνδέεται με μία μεταβλητή και μία παρατήρηση. Δεδομένα σε μορφή πίνακα είναι τακτοποιημένα (tidy) εάν κάθε τιμή είναι τοποθετημένη στο δικό της “κελί”, κάθε μεταβλητή στη δική της στήλη και κάθε παρατήρηση στη δική της γραμμή.\n\nΣε αυτό το πλαίσιο, μία μεταβλητή αναφέρεται σε μία ιδιότητα που έχουν όλοι οι πιγκουίνοι, και μία παρατήρηση αναφέρεται σε όλες τις ιδιότητες που έχει ένας συγκεκριμένος πιγκουίνος.\nΠληκτρολογήστε το όνομα του πλαισίου δεδομένων στην κονσόλα και η R θα τυπώσει μία προεπισκόπηση των περιεχομένων του. Παρατηρήστε ότι πάνω από αυτήν την προεπισκόπηση γράφει tibble. Στο tidyverse, χρησιμοποιούμε ειδικά πλαίσια δεδομένων, τα οποία καλούνται tibbles και για τα οποία θα μάθετε περισσότερα σύντομα.\n\npenguins\n#&gt; # A tibble: 344 × 8\n#&gt;   species island    bill_length_mm bill_depth_mm flipper_length_mm\n#&gt;   &lt;fct&gt;   &lt;fct&gt;              &lt;dbl&gt;         &lt;dbl&gt;             &lt;int&gt;\n#&gt; 1 Adelie  Torgersen           39.1          18.7               181\n#&gt; 2 Adelie  Torgersen           39.5          17.4               186\n#&gt; 3 Adelie  Torgersen           40.3          18                 195\n#&gt; 4 Adelie  Torgersen           NA            NA                  NA\n#&gt; 5 Adelie  Torgersen           36.7          19.3               193\n#&gt; 6 Adelie  Torgersen           39.3          20.6               190\n#&gt; # ℹ 338 more rows\n#&gt; # ℹ 3 more variables: body_mass_g &lt;int&gt;, sex &lt;fct&gt;, year &lt;int&gt;\n\nΑυτό το πλαίσιο δεδομένων περιέχει 8 στήλες. Για μία εναλλακτική οπτική, στην οποία μπορείτε να δείτε όλες τις μεταβλητές και κάποιες από τις πρώτες παρατηρήσεις κάθε μεταβλητής, χρησιμοποιήστε την glimpse(). Ή, εάν είστε στο RStudio, τρέξτε View(penguins) για να ανοίξει μία διαδραστική προβολή των δεδομένων.\n\nglimpse(penguins)\n#&gt; Rows: 344\n#&gt; Columns: 8\n#&gt; $ species           &lt;fct&gt; Adelie, Adelie, Adelie, Adelie, Adelie, Adelie, A…\n#&gt; $ island            &lt;fct&gt; Torgersen, Torgersen, Torgersen, Torgersen, Torge…\n#&gt; $ bill_length_mm    &lt;dbl&gt; 39.1, 39.5, 40.3, NA, 36.7, 39.3, 38.9, 39.2, 34.…\n#&gt; $ bill_depth_mm     &lt;dbl&gt; 18.7, 17.4, 18.0, NA, 19.3, 20.6, 17.8, 19.6, 18.…\n#&gt; $ flipper_length_mm &lt;int&gt; 181, 186, 195, NA, 193, 190, 181, 195, 193, 190, …\n#&gt; $ body_mass_g       &lt;int&gt; 3750, 3800, 3250, NA, 3450, 3650, 3625, 4675, 347…\n#&gt; $ sex               &lt;fct&gt; male, female, female, NA, female, male, female, m…\n#&gt; $ year              &lt;int&gt; 2007, 2007, 2007, 2007, 2007, 2007, 2007, 2007, 2…\n\nΑνάμεσα στις μεταβλητές του penguins βρίσκονται οι:\n\nspecies: το είδος στο οποίο ανήκουν οι πιγκουίνοι (Adelie, Chinstrap, ή Gentoo).\nflipper_length_mm: το μήκος των φτερών κάθε πιγκουίνου, σε χιλιοστόμετρα.\nbody_mass_g: η μάζα του σώματος κάθε πιγκουίνου, σε γραμμάρια.\n\nΓια να μάθετε περισσότερα για το penguins, ανοίξτε τη βοηθητική σελίδα τρέχοντας ?penguins.\n\n1.2.2 Τελικός στόχος\n\n\n\n\n\n\n\n\n\n1.2.3 Δημιουργώντας ένα διάγραμμα ggplot\nΑς δημιουργήσουμε ξανά αυτό το διάγραμμα βήμα-βήμα.\nΜε το πακέτο ggplot2, ξεκινάτε το γράφημα με την συνάρτηση ggplot(), η οποία ορίζει ένα αντικείμενο γραφήματος και στη συνέχεια προσθέτετε επίπεδα (layers) σε αυτό. Το πρώτο όρισμα της ggplot() είναι το σύνολο δεδομένων που θα χρησιμοποιηθεί στο γράφημα, οπότε η εντολή ggplot(data = penguins) δημιουργεί ένα άδειο γράφημα που είναι προετοιμασμένο για να παρουσιάσει τα δεδομένα του penguins, αλλά μιας και δεν της έχουμε πει πως να τα οπτικοποιήσει ακόμη, προς το παρόν θα είναι άδειο. Αυτό δεν είναι ένα πολύ ενδιαφέρον διάγραμμα, αλλά μπορείτε να το σκέφτεστε σαν άδειο καμβά, πάνω στον οποίο θα ζωγραφίσετε τα υπόλοιπα επίπεδα του διαγράμματος σας.\n\nggplot(data = penguins)\n\n\n\n\n\n\n\nΣτη συνέχεια, πρέπει να πούμε στη ggplot() πως θέλουμε να αναπαρασταθεί γραφικά η πληροφορία που υπάρχει στα δεδομένα μας. Το όρισμα mapping της συνάρτησης ggplot() καθορίζει πως οι μεταβλητές από το δεδομένων σας αντιστοιχίζονται με οπτικές ιδιότητες (aesthetics ή αισθητικά στοιχεία) του γραφήματος σας. Το όρισμα mapping ορίζεται πάντα μέσα στην συνάρτηση aes(), και τα ορίσματα x και y της aes() προσδιορίζουν ποιες μεταβλητές θα αντιστοιχιστούν με τους άξονες x και y. Για την ώρα, θα αντιστοιχίσουμε μόνο το μήκος των φτερών στο αισθητικό στοιχείο x και τη μάζα σώματος στο y. Η ggplot2 αναζητά τις αντιστοιχισμένες μεταβλητές μέσα στο όρισμα data, που σε αυτή την περίπτωση είναι το σύνολο δεδομένων penguins.\nΤο ακόλουθο διάγραμμα δείχνει το αποτέλεσμα της προσθήκης αυτών των αντιστοιχίσεων.\n\nggplot(\n  data = penguins,\n  mapping = aes(x = flipper_length_mm, y = body_mass_g)\n)\n\n\n\n\n\n\n\nΟ άδειος καμβάς μας έχει πλέον περισσότερη δομή - είναι εμφανές το που θα απεικονίζεται το μήκος των πτερυγίων (στον άξονα των x) και που η μάζα σώματος (στον άξονα των y). Ωστόσο, οι πιγκουίνοι δεν είναι ακόμη στο γράφημα. Αυτό συμβαίνει γιατί δεν έχουμε ακόμη διατυπώσει, στον κώδικα μας, το πως να αναπαρασταθούν οι παρατηρήσεις του συνόλου δεδομένων μας στο γράφημα μας.\nΓια να το κάνουμε αυτό, πρέπει να ορίσουμε ένα geom: το γεωμετρικό αντικείμενο που το γράφημα μας χρησιμοποιεί για να αναπαραστήσει δεδομένα. Αυτά τα γεωμετρικά αντικείμενα είναι διαθέσιμα στο πακέτο ggplot2 μέσω συναρτήσεων που ξεκινάνε με το πρόθεμα geom_. Ο κόσμος συχνά περιγράφει τα διαγράμματα με τον τύπο του γεωγραφικού αντικειμένου που χρησιμοποιείται από το διάγραμμα. Για παράδειγμα, τα ραβδογράμματα χρησιμοποιούν το γεωμετρικό στοιχείο των ράβδων (geom_bar()), το γραφήματα γραμμών χρησιμοποιούν το γεωμετρικό στοιχείο των γραμμών (geom_line()), τα θηκογράμματα χρησιμοποιούν το γεωμετρικό στοιχείο των θηκογραμμάτων (geom_boxplot()), τα διαγράμματα διασποράς χρησιμοποιούν το γεωμετρικό στοιχείο των σημείων (geom_point()), και ούτως καθεξής.\nΗ συνάρτηση geom_point() προσθέτει ένα επίπεδο σημείων στο διάγραμμα σας, το οποίο δημιουργεί ένα διάγραμμα διασποράς. Η ggplot2 έρχεται με πολλές γεωμετρικές συναρτήσεις, κάθε μία από τις οποίες προσθέτει ένα διαφορετικό τύπο επιπέδου σε ένα διάγραμμα. Στη διάρκεια αυτού του βιβλίου θα μάθετε αρκετές από αυτές τις γεωμετρικές συναρτήσεις, ειδικά στο Κεφάλαιο 9.\n\nggplot(\n  data = penguins,\n  mapping = aes(x = flipper_length_mm, y = body_mass_g)\n) +\n  geom_point()\n#&gt; Warning: Removed 2 rows containing missing values or values outside the scale range\n#&gt; (`geom_point()`).\n\n\n\n\n\n\n\nΤώρα έχουμε κάτι που μοιάζει με αυτό που θα θεωρούσαμε ως ένα “διάγραμμα διασποράς”. Δεν ταιριάζει ακόμη με τον τελικό μας στόχο, ωστόσο χρησιμοποιώντας αυτό το διάγραμμα μπορούμε να αρχίσουμε να απαντάμε την ερώτηση που μας έδωσε το κίνητρο γι’ αυτήν την ανάλυση: “Πως δείχνει η σχέση ανάμεσα στο μήκος των πτερυγίων και τη μάζα σώματος;” Η σχέση αυτή φαίνεται να είναι θετική (όσο αυξάνει το μήκος πτερυγίων, το ίδιο κάνει κι η μάζα σώματος), σχετικά γραμμική (τα σημεία διατάσσονται γύρω από μία γραμμή αντί για μία καμπύλη), και μέτρια ισχυρή (δεν υπάρχει ιδιαίτερη διασπορά γύρω από μία τέτοια γραμμή). Πιγκουίνοι με μακρύτερα πτερύγια είναι γενικά μεγαλύτεροι από άποψη σωματικής μάζας.\nΠριν προσθέσουμε επιπλέον επίπεδα σε αυτό το διάγραμμα, ας σταματήσουμε για μία στιγμή για να εξετάσουμε το προειδοποιητικό μήνυμα που λάβαμε:\n\nRemoved 2 rows containing missing values (geom_point()).\n\nΟ λόγος που βλέπουμε αυτό το μήνυμα είναι επειδή υπάρχουν 2 πιγκουίνοι ανάμεσα στα δεδομένα μας με κενές τιμές μάζας σώματος και/ή μήκους πτερυγίων και το πακέτο ggplot2 δεν έχει τρόπο να τους αναπαραστήσει στο διάγραμμα χωρίς και τις δύο αυτές τιμές. Όπως και η R, έτσι και το πακέτο ggplot2 ακολουθεί τη φιλοσοφία ότι οι κενές τιμές δεν θα πρέπει ποτέ να εξαφανίζονται σιωπηλά. Αυτός ο τύπος της προειδοποίησης είναι ένα από το πιο συχνά προειδοποιητικά μηνύματα που θα δείτε όταν δουλεύετε με πραγματικά δεδομένα – οι κενές τιμές είναι ένα πολύ συχνό θέμα για το οποίο θα μάθετε περισσότερα στην πορεία αυτού του βιβλίου, ειδικά στο Κεφάλαιο 18. Για τα υπόλοιπα διαγράμματα σε αυτό το κεφάλαιο θα καταστείλουμε αυτήν την προειδοποίηση για να μην τυπώνεται μαζί με κάθε διάγραμμα που φτιάχνουμε.\n\n1.2.4 Προσθέτοντας αισθητικά στοιχεία και επίπεδα\nΤα διαγράμματα διασποράς είναι χρήσιμα για την αναπαράσταση της σχέσης ανάμεσα σε δύο αριθμητικές μεταβλητές, ωστόσο είναι πάντα μία καλή ιδέα να είστε επιφυλακτικοί όσον αφορά προφανείς σχέσεις ανάμεσα σε δύο μεταβλητές και να να αναρωτιέστε εάν μπορεί να υπάρχουν άλλες μεταβλητές που εξηγούν ή τροποποιούν τη φύση αυτής της προφανούς σχέσης.\nΓια παράδειγμα, η σχέση ανάμεσα στο μήκος των πτερυγίων και τη μάζα σώματος διαφέρει ανάλογα με το είδος; Ας ενσωματώσουμε το είδος στο διάγραμμα μας για να δούμε εάν αποκαλύπτει πρόσθετες πληροφορίες σχετικά με τη φαινομενική σχέση μεταξύ αυτών των μεταβλητών. Αυτό θα το κάνουμε αναπαριστώντας το είδος με σημεία διαφορετικού χρώματος.\nΓια να το πετύχουμε αυτό, θα χρειαστεί να τροποποιήσουμε τα αισθητικά στοιχεία ή την geom; Αν μαντέψατε “την αντιστοίχιση των αισθητικών στοιχείων, μέσα στην aes()”, έχετε ήδη αρχίσει να συνηθίζετε να δημιουργείτε οπτικοποιήσεις δεδομένων με ggplot2! Αν πάλι όχι, μην ανησυχείτε. Στην πορεία αυτού του βιβλίου θα δημιουργήσετε πολλά ακόμη διαγράμματα με την ggplot και θα έχετε πολλές ακόμη ευκαιρίες να τεστάρετε τη διαίσθηση σας καθώς τα δημιουργείτε.\n\nggplot(\n  data = penguins,\n  mapping = aes(x = flipper_length_mm, y = body_mass_g, color = species)\n) +\n  geom_point()\n\n\n\n\n\n\n\nΌταν μία κατηγορική μεταβλητή αντιστοιχίζεται με ένα αισθητικό στοιχείο, το πακέτο ggplot2 θα αναθέσει αυτόματα μία μοναδική τιμή αυτού του αισθητικού στοιχείου (σε αυτή την περίπτωση ένα μοναδικό χρώμα) σε κάθε μοναδικό επίπεδο της μεταβλητής (κάθε ένα από τρία είδη), μία διαδικασία γνωστή ως κλιμάκωση (scaling). Η ggplot2 θα προσθέσει επίσης ένα υπόμνημα που εξηγεί ποιες τιμές αντιστοιχούν σε ποια επίπεδα.\nΤώρα, ας προσθέσουμε ακόμη ένα επίπεδο: μία ομαλή καμπύλη που αναπαριστά τη σχέση ανάμεσα στη μάζα σώματος και το μήκος φτερών. Πριν προχωρήσετε, δείτε ξανά τον παραπάνω κώδικα και σκεφτείτε πως μπορούμε να κάνουμε αυτή την προσθήκη στον ήδη υπάρχον κώδικα μας.\nΜιας και αυτό είναι ένα νέο γεωμετρικό στοιχείο που αντιπροσωπεύει τα δεδομένα μας, θα προσθέσουμε ένα νέο geom ως επιπλέον επίπεδο, πάνω από το geom των μεμονωμένων σημείων: geom_smooth().\nΕπίσης, θα ορίσουμε ότι θέλουμε να σχεδιάσουμε τη γραμμή καλύτερης προσαρμογής σύμφωνα με ένα γραμμικό μοντέλο (linear mode), χρησιμοποιώντας το όρισμα method = \"lm\".\n\n\nggplot(\n  data = penguins,\n  mapping = aes(x = flipper_length_mm, y = body_mass_g, color = species)\n) +\n  geom_point() +\n  geom_smooth(method = \"lm\")\n\n\n\n\n\n\n\nΈχουμε προσθέσει επιτυχώς γραμμές, αλλά το διάγραμμα δεν μοιάζει με το διάγραμμα από την Ενότητα 1.2.2, το οποίο έχει μόνο μία γραμμή για ολόκληρο το σύνολο δεδομένων αντί για ξεχωριστές γραμμές για κάθε ένα από τα είδη πιγκουίνων.\nΌταν οι αισθητικές αντιστοιχίσεις ορίζονται στην ggplot(), σε global (καθολικό) επίπεδο, μεταβιβάζονται σε κάθε ένα από τα επόμενα geom επίπεδα του διάγραμμα. Ωστόσο, κάθε geom συνάρτηση στο πακέτο ggplot2 μπορεί επίσης να λάβει ένα mapping όρισμα, το οποίο επιτρέπει αισθητικές αντιστοιχίσεις σε local (τοπικό) επίπεδο που προστίθενται σε αυτές που κληρονομήθηκαν από το καθολικό επίπεδο. Μιας και θέλουμε τα σημεία να χρωματίζονται με βάση το είδος, αλλά δεν θέλουμε οι γραμμές γι’ αυτά να διαχωρίζονται, θα πρέπει να ορίσουμε την παράμετρο color = species μόνο για το στοιχείο geom_point().\n\nggplot(\n  data = penguins,\n  mapping = aes(x = flipper_length_mm, y = body_mass_g)\n) +\n  geom_point(mapping = aes(color = species)) +\n  geom_smooth(method = \"lm\")\n\n\n\n\n\n\n\nVoila! Έχουμε κάτι που μοιάζει αρκετά με τον τελικό μας στόχο, αν και δεν είναι ακόμα τέλειο. Πρέπει ακόμα να χρησιμοποιήσουμε διαφορετικά σχήματα για κάθε είδος πιγκουίνων και να βελτιώσουμε τις ετικέτες.\nΓενικά δεν είναι καλή ιδέα να αναπαριστούμε πληροφορίες χρησιμοποιώντας μόνο χρώματα σε ένα διάγραμμα, μιας και οι άνθρωποι αντιλαμβάνονται τα χρώματα διαφορετικά λόγω αχρωματοψίας ή άλλων διαφορών στην έγχρωμη όραση. Επομένως, εκτός από το χρώμα, μπορούμε επίσης να αντιστοιχίσουμε το είδος (species) με την αισθητικό στοιχείο του σχήματος (shape).\n\nggplot(\n  data = penguins,\n  mapping = aes(x = flipper_length_mm, y = body_mass_g)\n) +\n  geom_point(mapping = aes(color = species, shape = species)) +\n  geom_smooth(method = \"lm\")\n\n\n\n\n\n\n\nΣημειώστε ότι το υπόμνημα ενημερώνεται αυτόματα για να αντικατοπτρίζει και τα διαφορετικά σχήματα των σημείων.\nΤέλος, μπορούμε να βελτιώσουμε τις ετικέτες του σχεδίου μας χρησιμοποιώντας τη συνάρτηση labs() σε ένα νέο επίπεδο. Μερικά από τα ορίσματα του labs() μπορεί να είναι αυτονόητα: το title προσθέτει έναν τίτλο και το subtitle προσθέτει έναν υπότιτλο στο διάγραμμα. Άλλα ορίσματα ταιριάζουν με τις αισθητικές αντιστοιχίσεις, το x είναι η ετικέτα του άξονα των x, το y είναι η ετικέτα του άξονα των y και τα color και το shape ορίζουν την ετικέτα για το υπόμνημα. Επιπλέον, μπορούμε να βελτιώσουμε την χρωματική παλέτα ώστε να είναι ασφαλής για άτομα με αχρωματοψία, χρησιμοποιώντας τη συνάρτηση scale_color_colorblind()από το πακέτο ggthemes.\n\nggplot(\n  data = penguins,\n  mapping = aes(x = flipper_length_mm, y = body_mass_g)\n) +\n  geom_point(aes(color = species, shape = species)) +\n  geom_smooth(method = \"lm\") +\n  labs(\n    title = \"Body mass and flipper length\",\n    subtitle = \"Dimensions for Adelie, Chinstrap, and Gentoo Penguins\",\n    x = \"Flipper length (mm)\", y = \"Body mass (g)\",\n    color = \"Species\", shape = \"Species\"\n  ) +\n  scale_color_colorblind()\n\n\n\n\n\n\n\nΕπιτέλους έχουμε ένα διάγραμμα που ταιριάζει τέλεια με τον “απόλυτο στόχο” μας!\n\n1.2.5 Ασκήσεις\n\nΠόσες γραμμές υπάρχουν στο penguins; Πόσες στήλες;\nΤι περιγράφει η μεταβλητή bill_depth_mm στο πλαίσιο δεδομένων penguins; Διαβάστε to κείμενο βοήθειας για το ?penguins για να βρείτε την απάντηση.\nΔημιουργήστε ένα διάγραμμα διασποράς της μεταβλητής bill_depth_mm έναντι της bill_length_mm. Πιο συγκεκριμένα, δημιουργήστε ένα διάγραμμα διασποράς με την μεταβλητή bill_depth_mm στον y άξονα και την bill_length_mm στον x άξονα. Περιγράψτε τη σχέση ανάμεσα στις δύο αυτές μεταβλητές.\nΤι συμβαίνει εάν δημιουργήσετε ένα διάγραμμα διασποράς της μεταβλητής species εναντίον της bill_depth_mm; Ποια θα ήταν καλύτερη επιλογή ως στοιχείο geom;\n\nΓιατί το ακόλουθο κομμάτι κώδικα επιστρέφει σφάλμα και πως θα το διορθώνατε;\n\nggplot(data = penguins) + \n  geom_point()\n\n\nΤι κάνει το όρισμα na.rm στην geom_point(); Ποια είναι η προεπιλεγμένη τιμή του ορίσματος; Δημιουργήστε ένα διάγραμμα διασποράς όπου χρησιμοποιείται το όρισμα αυτό με τιμή TRUE.\nΠροσθέστε το ακόλουθο επεξηγηματικό κείμενο στο διάγραμμα που δημιουργήσατε στην προηγούμενη άσκηση: “Τα δεδομένα προέρχονται από το πακέτο palmerpenguins” (“Data come from the palmerpenguins package.”) Υπόδειξη: Δείτε την τεκμηρίωση της labs().\n\nΑναδημιουργήστε την ακόλουθη οπτικοποίηση. Σε ποιο αισθητικό στοιχείο θα έπρεπε να αντιστοιχιστεί η μεταβλητή bill_depth_mm; Θα πρέπει να ορισθεί σε καθολικό επίπεδο ή στο επίπεδο των στοιχείων geom;\n\n\n\n\n\n\n\n\n\n\nΕκτελέστε νοητικά τον παρακάτω κώδικα και προβλέψτε πως θα δείχνει το αποτέλεσμα. Στη συνέχεια, εκτελέστε τον κώδικα στην R και συγκρίνετε τις προβλέψεις σας.\n\nggplot(\n  data = penguins,\n  mapping = aes(x = flipper_length_mm, y = body_mass_g, color = island)\n) +\n  geom_point() +\n  geom_smooth(se = FALSE)\n\n\n\nΘα δείχνουν διαφορετικά αυτά τα δύο γραφήματα; Γιατί ναι ή όχι;\n\nggplot(\n  data = penguins,\n  mapping = aes(x = flipper_length_mm, y = body_mass_g)\n) +\n  geom_point() +\n  geom_smooth()\n\nggplot() +\n  geom_point(\n    data = penguins,\n    mapping = aes(x = flipper_length_mm, y = body_mass_g)\n  ) +\n  geom_smooth(\n    data = penguins,\n    mapping = aes(x = flipper_length_mm, y = body_mass_g)\n  )",
    "crumbs": [
      "Η ολοκληρωμένη εικόνα",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Οπτικοποίηση δεδομένων</span>"
    ]
  },
  {
    "objectID": "data-visualize.html#sec-ggplot2-calls",
    "href": "data-visualize.html#sec-ggplot2-calls",
    "title": "1  Οπτικοποίηση δεδομένων",
    "section": "\n1.3 Καλώντας το πακέτο ggplot2",
    "text": "1.3 Καλώντας το πακέτο ggplot2\nΚαθώς προχωράμε από αυτές τις εισαγωγικές ενότητες, θα μεταβούμε σε μία πιο συνοπτική έκφραση του κώδικα της ggplot2. Ως τώρα ήμασταν ιδιαίτερα σαφείς, κάτι που είναι βοηθητικό όταν μαθαίνετε:\n\nggplot(\n  data = penguins,\n  mapping = aes(x = flipper_length_mm, y = body_mass_g)\n) +\n  geom_point()\n\nΣυνήθως, τα πρώτα ένα ή δύο ορίσματα μιας συνάρτησης είναι τόσο σημαντικά που θα πρέπει να τα γνωρίζετε απ’ έξω. Τα δύο πρώτα ορίσματα της ggplot() είναι τα data και mapping, και στο υπόλοιπο βιβλίο, δεν θα παρέχουμε αυτά τα ονόματα. Αυτό εξοικονομεί από την πληκτρολόγηση, και μειώνοντας τον όγκο του επιπλέον κειμένου, διευκολύνει τον εντοπισμό διαφορών μεταξύ διαγραμμάτων. Αυτή είναι μία πολύ σημαντική προγραμματιστική ανησυχία στην οποία θα επανέλθουμε στο Κεφάλαιο 25.\nΞαναγράφοντας το προηγούμενο διάγραμμα πιο συνοπτικά οδηγεί στο:\n\nggplot(penguins, aes(x = flipper_length_mm, y = body_mass_g)) + \n  geom_point()\n\nΣτο μέλλον, θα μάθετε επίσης για το pipe, |&gt;, που θα σας επιτρέψει να δημιουργήσετε αυτό το διάγραμμα με:\n\npenguins |&gt; \n  ggplot(aes(x = flipper_length_mm, y = body_mass_g)) + \n  geom_point()",
    "crumbs": [
      "Η ολοκληρωμένη εικόνα",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Οπτικοποίηση δεδομένων</span>"
    ]
  },
  {
    "objectID": "data-visualize.html#αναπαριστώντας-κατανομές",
    "href": "data-visualize.html#αναπαριστώντας-κατανομές",
    "title": "1  Οπτικοποίηση δεδομένων",
    "section": "\n1.4 Αναπαριστώντας κατανομές",
    "text": "1.4 Αναπαριστώντας κατανομές\nΤο πως θα αναπαραστήσετε την κατανομή μιας μεταβλητής εξαρτάται από τον τύπο της μεταβλητής: κατηγορική ή αριθμητική.\n\n1.4.1 Μία κατηγορική μεταβλητή\nΜία μεταβλητή είναι κατηγορική εάν μπορεί να πάρει τιμές από ένα μικρό σύνολο τιμών. Για να μελετήσετε την κατανομή μιας κατηγορικής μεταβλητής, μπορείτε να χρησιμοποιήσετε το ραβδόγραμμα. Το ύψος των ράβδων αναπαριστά το πλήθος των παρατηρήσεων που έχουν κάθε τιμή x.\n\nggplot(penguins, aes(x = species)) +\n  geom_bar()\n\n\n\n\n\n\n\nΣε ραβδογράμματα κατηγορικών μεταβλητών με μη διατεταγμένα επίπεδα, όπως το είδος πιγκουίνου (species) παραπάνω, είναι συχνά προτιμότερο να αναδιατάσσονται οι ράβδοι με βάση τις συχνότητές τους. Για να γίνει αυτό, απαιτείται η μετατροπή της μεταβλητής σε παράγοντα (ο τρόπος με τον οποίο η R χειρίζεται κατηγορηματικά δεδομένα) και στη συνέχεια η αναδιάταξη των επιπέδων αυτού του παράγοντα.\n\nggplot(penguins, aes(x = fct_infreq(species))) +\n  geom_bar()\n\n\n\n\n\n\n\nΘα μάθετε περισσότερα για παράγοντες και συναρτήσεις για να χειρίζεστε παράγοντες (όπως η fct_infreq() που παρουσιάζεται παραπάνω) στο Κεφάλαιο 16.\n\n1.4.2 Μία αριθμητική μεταβλητή\nΜία μεταβλητή είναι αριθμητική (ή ποσοτική) εάν μπορεί να πάρει ένα ευρύ φάσμα αριθμητικών τιμών και είναι λογικό να προσθέτουμε, αφαιρούμε ή να υπολογίζουμε μέσους όρους από αυτές τις τιμές. Οι αριθμητικές μεταβλητές μπορούν να είναι συνεχείς ή διακριτές.\nΜία κοινώς χρησιμοποιούμενη οπτικοποίηση για κατανομές συνεχών μεταβλητών είναι το ιστόγραμμα.\n\nggplot(penguins, aes(x = body_mass_g)) +\n  geom_histogram(binwidth = 200)\n\n\n\n\n\n\n\nΈνα ιστόγραμμα χωρίζει τον x άξονα σε ισαπέχουσες κλάσεις (bins) και στη συνέχεια χρησιμοποιεί το ύψος μιας ράβδου για να εμφανίσει τον αριθμό των παρατηρήσεων που εμπίπτουν σε κάθε κλάση.\nΣτο παραπάνω γράφημα, η ψηλότερη ράβδος δείχνει ότι 39 παρατηρήσεις έχουν τιμή body_mass_g μεταξύ 3.500 και 3.700 γραμμαρίων, που είναι η αριστερή και η δεξιά άκρη της ράβδου.\nΜπορείτε να ορίσετε το πλάτος των διαστημάτων σε ένα ιστόγραμμα με το όρισμα binwidth, το οποίο έχει τις ίδιες μονάδες μέτρησης με τη μεταβλητής x.\nΘα πρέπει πάντα να εξερευνάτε μία ποικιλία ευρών για τις κλάσεις όταν εργάζεστε με ιστογράμματα, καθώς διαφορετικές τιμές του binwidth μπορεί να αποκαλύπτουν διαφορετικά μοτίβα.\nΣτα παρακάτω διαγράμματα, ένα binwidth 20 είναι πολύ στενό, οδηγώντας σε πάρα πολλές ράβδους και καθιστώντας δύσκολο τον προσδιορισμό του σχήματος της κατανομής.\nΠαρομοίως, ένα binwidth 2.000 είναι πολύ μεγάλο, με αποτέλεσμα όλα τα δεδομένα να τοποθετούνται μόνο σε τρεις ράβδους, ενώ παράλληλα καθιστά δύσκολο τον προσδιορισμό του σχήματος της διανομής. Μία τιμή binwidth ίση με 200 παρέχει μία λογική ισορροπία.\nggplot(penguins, aes(x = body_mass_g)) +\n  geom_histogram(binwidth = 20)\nggplot(penguins, aes(x = body_mass_g)) +\n  geom_histogram(binwidth = 2000)\n\n\n\n\n\n\n\n\n\n\nΜία εναλλακτική οπτικοποίηση για κατανομές αριθμητικών μεταβλητών είναι το διάγραμμα πυκνότητας. Ένα διάγραμμα πυκνότητας είναι μία εξομαλοποιημένη εκδοχή του ιστογράμματος και μία πρακτική εναλλακτική, ειδικά για συνεχή δεδομένα που προέρχονται από υποκείμενες ομαλές κατανομές. Δεν θα αναφερθούμε στο πως η geom_density() υπολογίζει την πυκνότητα (μπορείτε να διαβάσετε περισσότερα γι’ αυτήν στην αντίστοιχη τεκμηρίωση), αλλά ας εξηγήσουμε πως σχεδιάζεται η καμπύλη πυκνότητας χρησιμοποιώντας μία αναλογία. Φανταστείτε ένα ιστόγραμμα από ξύλινα τουβλάκια. Στη συνέχεια, φανταστείτε ότι ρίχνετε ένα μαγειρεμένο μακαρόνι από πάνω τους. Το σχήμα που θα πάρει το μακαρόνι, καθώς πέφτει πάνω από τα τουβλάκια, μπορεί να θεωρηθεί ότι είναι το σχήμα της καμπύλης πυκνότητας. Δίνει λιγότερες λεπτομέρειες από το ιστόγραμμα αλλά μπορεί μπορεί να διευκολύνει τη γρήγορη κατανόηση του σχήματος της κατανομής, ειδικά όσον αφορά την επικρατούσα τιμή και τη λοξότητα της.\n\nggplot(penguins, aes(x = body_mass_g)) +\n  geom_density()\n#&gt; Warning: Removed 2 rows containing non-finite outside the scale range\n#&gt; (`stat_density()`).\n\n\n\n\n\n\n\n\n1.4.3 Ασκήσεις\n\nΔημιουργήστε ένα ραβδόγραμμα της μεταβλητής species του συνόλου δεδομένων penguins, όπου ορίζετε την species ως y αισθητικό στοιχείο. Πως διαφέρει αυτό το διάγραμμα;\n\nΠως διαφέρουν τα δύο παρακάτω διαγράμματα; Ποιο αισθητικό στοιχείο, το color ή το fill, είναι πιο χρήσιμο για την αλλαγή του χρώματος των ράβδων;\n\nggplot(penguins, aes(x = species)) +\n  geom_bar(color = \"red\")\n\nggplot(penguins, aes(x = species)) +\n  geom_bar(fill = \"red\")\n\n\nΠοιος είναι ο ρόλος του ορίσματος bins στη συνάρτηση geom_histogram();\nΔημιουργήστε ένα ιστόγραμμα της μεταβλητής carat στο σύνολο δεδομένων diamonds που είναι διαθέσιμο όταν φορτώνετε το πακέτο tidyverse. Πειραματιστείτε με διαφορετικές τιμές του binwidth. Ποια τιμή binwidth αποκαλύπτει τα πιο ενδιαφέρονται μοτίβα;",
    "crumbs": [
      "Η ολοκληρωμένη εικόνα",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Οπτικοποίηση δεδομένων</span>"
    ]
  },
  {
    "objectID": "data-visualize.html#οπτικοποιώντας-σχέσεις",
    "href": "data-visualize.html#οπτικοποιώντας-σχέσεις",
    "title": "1  Οπτικοποίηση δεδομένων",
    "section": "\n1.5 Οπτικοποιώντας σχέσεις",
    "text": "1.5 Οπτικοποιώντας σχέσεις\nΓια να οπτικοποιήσουμε μία σχέση πρέπει να έχουμε τουλάχιστον δύο μεταβλητές, που έχουν αντιστοιχιστεί σε αισθητικά στοιχεία ενός διαγράμματος. Στις επόμενες ενότητες θα μάθετε για τις γραφικές παραστάσεις που χρησιμοποιούνται συνήθως για την οπτικοποίηση των σχέσεων μεταξύ δύο ή περισσότερων μεταβλητών και τα γεωμετρικά στοιχεία που χρησιμοποιούνται για τη δημιουργία τους.\n\n1.5.1 Μία αριθμητική και μία κατηγορική μεταβλητή\nΓια την οπτικοποίηση των σχέσεων ανάμεσα σε μία αριθμητική και μία κατηγορική μεταβλητή μπορούμε να χρησιμοποιήσουμε θηκογράμματα τοποθετημένα δίπλα-δίπλα. Ένα θηκόγραμμα είναι ένας τύπος οπτικής συντομογραφίας για μέτρα θέσης (εκατοστημόρια) που περιγράφουν μία κατανομή. Είναι επίσης χρήσιμο για το εντοπισμό πιθανών ακραίων τιμών. Όπως φαίνεται στο Σχήμα 1.1, κάθε θηκόγραμμα αποτελείται από:\n\nΈνα κουτί που υποδεικνύει το εύρος τιμών του κεντρικού μισού όγκου των δεδομένων, μία απόσταση που είναι γνωστή ως το ενδοτεταρτημοριακό εύρος (interquartile range, IQR), που εκτείνεται από το 25ο εκατοστημόριο της κατανομής ως το 75ο εκατοστημόριο. Στο μέσο του κουτιού υπάρχει μία γραμμή που παρουσιάζει τη διάμεσο, δηλαδή το 50ο εκατοστημόριο της κατανομής. Αυτές οι τρεις γραμμές δίνουν μία αίσθηση της διασποράς της κατανομή και του εάν η κατανομή είναι συμμετρική γύρω από τη διάμεσο ή συγκεντρώνεται προς τη μία πλευρά.\nΟπτικά σημεία που αναπαριστούν παρατηρήσεις που εκτείνονται πάνω από 1.5 φορές το IQR από οποιαδήποτε από τα άκρα του κουτιού. Αυτά τα ακραία σημεία είναι ασυνήθιστα, οπότε εμφανίζονται μεμονωμένα στο διάγραμμα.\nΜία γραμμή (ή whisker) που εκτείνεται από κάθε ένα από τα άκρα του κουτιού και φτάνει μέχρι το πιο μακρινό σημείο της κατανομής που δεν αντιστοιχεί σε ακραίο σημείο.\n\n\n\n\n\n\n\n\nΣχήμα 1.1: Διάγραμμα που απεικονίζει πώς δημιουργείται ένα θηκόγραμμα.\n\n\n\n\nΑς παρατηρήσουμε την κατανομή της μάζας σώματος σύμφωνα με το είδος, χρησιμοποιώντας τη συνάρτηση geom_boxplot():\n\nggplot(penguins, aes(x = species, y = body_mass_g)) +\n  geom_boxplot()\n\n\n\n\n\n\n\nΕναλλακτικά, μπορούμε να φτιάξουμε ένα διάγραμμα πυκνότητας με την geom_density().\n\nggplot(penguins, aes(x = body_mass_g, color = species)) +\n  geom_density(linewidth = 0.75)\n\n\n\n\n\n\n\nΈχουμε επίσης εξατομικεύσει το πάχος των γραμμών χρησιμοποιώντας το όρισμα linewidth ώστε να τις κάνουμε να ξεχωρίζουν λίγο περισσότερο από το υπόβαθρο.\nΕπιπλέον, μπορούμε να αντιστοιχίσουμε τη μεταβλητή species στα αισθητικά στοιχεία color και fill και να χρησιμοποιήσουμε το αισθητικό στοιχείο alpha για να προσθέσουμε διαφάνεια στις καμπύλες πυκνότητας που έχουν προκύψει. Αυτό το στοιχείο παίρνει τιμές μεταξύ του 0 (απόλυτα διαυγές) και του 1 (απόλυτα αδιαφανές, πυκνό χρώμα). Στο ακόλουθο διάγραμμα η τιμή του ορίζεται στο 0.5.\n\nggplot(penguins, aes(x = body_mass_g, color = species, fill = species)) +\n  geom_density(alpha = 0.5)\n\n\n\n\n\n\n\nΠαρατηρήστε την ορολογία που έχουμε χρησιμοποιήσει ως εδώ:\n\n\nΑντιστοιχίζουμε μεταβλητές σε αισθητικά στοιχεία εάν θέλουμε οι οπτικές ιδιότητες που αντιπροσωπεύουν αυτά τα στοιχεία να διαφέρουν ανάλογα με τις τιμές των αντίστοιχων μεταβλητών.\nΕναλλακτικά, ορίζουμε την τιμή ενός αισθητικού στοιχείου.\n\n1.5.2 Δύο κατηγορικές μεταβλητές\nΜπορούμε να χρησιμοποιήσουμε δύο στοιβαγμένα ραβδογράμματα για να οπτικοποιήσουμε τη σχέση ανάμεσα σε δύο κατηγορικές μεταβλητές. Για παράδειγμα, τα ακόλουθα δύο στοιβαγμένα ραβδογράμματα παρουσιάζουν τη σχέση ανάμεσα στις μεταβλητές island και species, ή πιο συγκεκριμένα, οπτικοποιούν την κατανομή του species σε κάθε νησί.\nΤο πρώτο διάγραμμα δείχνει τις συχνότητες κάθε είδους πιγκουίνων σε κάθε νησί. Το διάγραμμα των συχνοτήτων δείχνει ότι υπάρχει ίσος αριθμός Adelies σε κάθε νησί. Ωστόσο, δεν έχουμε ακόμη μία καλή αίσθηση του ποσοστού ισορροπίας μέσα σε κάθε νησί.\n\nggplot(penguins, aes(x = island, fill = species)) +\n  geom_bar()\n\n\n\n\n\n\n\nΤο δεύτερο διάγραμμα, ένα διάγραμμα σχετικής συχνότητας που δημιουργείται ορίζοντας position = \"fill\" στο geom στοιχείο, και είναι πιο χρήσιμη για τη σύγκριση της κατανομής των διαφόρων ειδών στα νησιά, καθώς δεν επηρεάζεται από τον άνισο αριθμό πιγκουίνων στα νησιά. Χρησιμοποιώντας αυτό το διάγραμμα μπορούμε να παρατηρήσουμε ότι οι πιγκουίνοι Gentoo ζουν όλοι στο νησί Biscoe και αποτελούν περίπου το 75% των πιγκουίνων σε αυτό το νησί, οι Chinstrap ζουν όλοι στο νησί Dream και αποτελούν περίπου το 50% των πιγκουίνων σε αυτό το νησί και οι Adelie ζουν στο και τα τρία νησιά και αποτελούν όλους τους πιγκουίνους στο Torgersen.\n\nggplot(penguins, aes(x = island, fill = species)) +\n  geom_bar(position = \"fill\")\n\n\n\n\n\n\n\nΚατά τη δημιουργία αυτών των ραβδογραμμάτων, αντιστοιχίζουμε τη μεταβλητή που θα χωριστεί σε ράβδους με το αισθητικό στοιχείο x και τη μεταβλητή που θα αλλάζει τα χρώματα μέσα στις ράβδους στο αισθητικό στοιχείο fill.\n\n1.5.3 Δύο αριθμητικές μεταβλητές\nΜέχρι στιγμής έχετε μάθει για τα διαγράμματα διασποράς (δημιουργούνται με τη συνάρτηση geom_point()) και τις ομαλές καμπύλες (δημιουργούνται με την geom_smooth()) για την οπτικοποίηση της σχέσης μεταξύ δύο αριθμητικών μεταβλητών. Το διάγραμμα διασποράς είναι ίσως το πιο συχνά χρησιμοποιούμενο διάγραμμα για την απεικόνιση της σχέσης μεταξύ δύο αριθμητικών μεταβλητών.\n\nggplot(penguins, aes(x = flipper_length_mm, y = body_mass_g)) +\n  geom_point()\n\n\n\n\n\n\n\n\n1.5.4 Τρεις ή περισσότερες μεταβλητές\nΌπως είδαμε στην Ενότητα 1.2.4, μπορούμε να ενσωματώσουμε περισσότερες μεταβλητές σε ένα διάγραμμα αντιστοιχίζοντας τες σε πρόσθετα αισθητικά στοιχεία. Για παράδειγμα, στο παρακάτω διάγραμμα διασποράς τα χρώματα των σημείων αντιπροσωπεύουν είδη και τα σχήματα των σημείων αντιπροσωπεύουν νησιά.\n\nggplot(penguins, aes(x = flipper_length_mm, y = body_mass_g)) +\n  geom_point(aes(color = species, shape = island))\n\n\n\n\n\n\n\nΩστόσο, η προσθήκη πάρα πολλών αισθητικών αντιστοιχίσεων σε ένα διάγραμμα το κάνει ακατάστατο και δυσνόητο. Ένας άλλος τρόπος, που είναι ιδιαίτερα χρήσιμος για κατηγορικές μεταβλητές, είναι να χωρίσετε το διάγραμμα σας σε όψεις (facets), υπο-διαγράμματα, κάθε ένα από τα οποία απεικονίζει ένα υποσύνολο των δεδομένων.\nΓια να προσαρμόσετε το διάγραμμα με μία μόνο μεταβλητή, χρησιμοποιήστε τη συνάρτηση facet_wrap(). Το πρώτο όρισμα του facet_wrap() είναι μία φόρμουλα3, η οποία δημιουργείτε με το ~ ακολουθούμενο από το όνομα μιας μεταβλητής. Η μεταβλητή που εισάγεται στο facet_wrap() πρέπει να είναι κατηγορική.\n\nggplot(penguins, aes(x = flipper_length_mm, y = body_mass_g)) +\n  geom_point(aes(color = species, shape = species)) +\n  facet_wrap(~island)\n\n\n\n\n\n\n\nΘα μάθετε για πολλά άλλα γεωμετρικά στοιχεία για την οπτικοποίηση των κατανομών μεταβλητών και των μεταξύ του σχέσεων στο Κεφάλαιο 9.\n\n1.5.5 Ασκήσεις\n\nΤο σύνολο δεδομένων mpg που είναι ενσωματωμένο στο πακέτο ggplot2 περιέχει 234 παρατηρήσεις που έχουν συλλεχθεί από την Αμερικανική Υπηρεσία Προστασίας του Περιβάλλοντος (US Environmental Protection Agency) από 38 μοντέλα αυτοκινήτων. Ποιες μεταβλητές στο mpg είναι κατηγορικές; Ποιες μεταβλητές είναι αριθμητικές; (Υπόδειξη: Πληκτρολογήστε ?mpg για να διαβάσετε την τεκμηρίωση αυτού του συνόλου δεδομένων.) Πως μπορείτε να δείτε αυτή την πληροφορία όταν εκτελείτε mpg στην κονσόλα;\nΔημιουργήστε ένα διάγραμμα διασποράς της μεταβλητής hwy έναντι της displ χρησιμοποιώντας το πλαίσιο δεδομένων mpg. Στη συνέχεια, αντιστοιχίστε μία τρίτη, αριθμητική μεταβλητή στο color, στη συνέχεια στο size, μετά και στο color και στο size, και τέλος στο shape. Πως συμπεριφέρονται διαφορετικά αυτά τα αισθητικά στοιχεία για κατηγορικές, σε σχέση με αριθμητικές μεταβλητές;\nΣτο διάγραμμα διασποράς της hwy έναντι της displ, τι συμβαίνει εάν αντιστοιχίσετε μία τρίτη μεταβλητή στο linewidth;\nΤι συμβαίνει εάν αντιστοιχίσετε την ίδια μεταβλητή σε πολλαπλά αισθητικά στοιχεία;\nΔημιουργήστε ένα διάγραμμα διασποράς της bill_depth_mm έναντι της bill_length_mm και χρωματίστε τα σημεία σύμφωνα με τη μεταβλητή species. Τι αποκαλύπτει η προσθήκη χρώματος σύμφωνα με το είδος για τη σχέση αυτών των δύο μεταβλητών; Και αντίστοιχα τι αποκαλύπτει η δημιουργία διαφορετικών όψεων με βάση την species;\n\nΓιατί ο παρακάτω κώδικας δημιουργεί δύο ξεχωριστά υπομνήματα; Πως θα το διορθώνατε ώστε να συνδυάζονται;\n\nggplot(\n  data = penguins,\n  mapping = aes(\n    x = bill_length_mm, y = bill_depth_mm, \n    color = species, shape = species\n  )\n) +\n  geom_point() +\n  labs(color = \"Species\")\n\n\n\nΔημιουργήστε τα ακόλουθα στοιβαγμένα ραβδογράμματα. Ποια ερώτηση μπορείτε να απαντήσετε με το πρώτο; Ποια ερώτηση μπορείτε να απαντήσετε με το δεύτερο;\n\nggplot(penguins, aes(x = island, fill = species)) +\n  geom_bar(position = \"fill\")\nggplot(penguins, aes(x = species, fill = island)) +\n  geom_bar(position = \"fill\")",
    "crumbs": [
      "Η ολοκληρωμένη εικόνα",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Οπτικοποίηση δεδομένων</span>"
    ]
  },
  {
    "objectID": "data-visualize.html#sec-ggsave",
    "href": "data-visualize.html#sec-ggsave",
    "title": "1  Οπτικοποίηση δεδομένων",
    "section": "\n1.6 Αποθηκεύοντας τα διαγράμματά σας",
    "text": "1.6 Αποθηκεύοντας τα διαγράμματά σας\nΜόλις έχετε δημιουργήσει ένα διάγραμμα, μπορεί να θέλετε να το εξάγετε από την R, αποθηκεύοντας το σαν εικόνα, την οποία μπορείτε να χρησιμοποιήσετε οπουδήποτε αλλού. Αυτή είναι η δουλειά που εκτελεί η συνάρτηση ggsave(), η οποία θα αποθηκεύσει το πιο πρόσφατο διάγραμμα που έχει δημιουργηθεί στο δίσκο:\n\nggplot(penguins, aes(x = flipper_length_mm, y = body_mass_g)) +\n  geom_point()\nggsave(filename = \"penguin-plot.png\")\n\nΑυτό ο κώδικας θα αποθηκεύσει το διάγραμμα σας στο μονοπάτι εργασία σας, μία έννοια για την οποία θα μάθετε περισσότερα στο Κεφάλαιο 6.\nΕαν δεν προσδιορίσετε τις παραμέτρους width και height, τότε αυτές θα προκύψουν από τις διαστάσεις της τρέχουσας συσκευής δημιουργίας διαγραμμάτων. Για να μπορεί ο κώδικάς σας να αναπαραχθεί στο μέλλον, θα ήταν καλύτερο να τις προσδιορίσετε. Μπορείτε να μάθετε περισσότερα για την ggsave() στην τεκμηρίωσή της.\nΓενικά, ωστόσο, συνιστούμε να “συναρμολογείτε” τις τελικές αναφορές σας χρησιμοποιώντας το Quarto, ένα αναπαράξιμο σύστημα συγγραφής που σας επιτρέπει να ενθέσετε τον κώδικα και τον γραπτό λόγο σας και να συμπεριλαμβάνετε αυτόματα τα διαγράμματα σας στις αναφορές σας. Θα μάθετε περισσότερα για το Quarto στο Κεφάλαιο 28.\n\n1.6.1 Ασκήσεις\n\n\nΤρέξτε τις ακόλουθες γραμμές κώδικα. Ποιο από τα δύο διαγράμματα αποθηκεύεται ως mpg-plot.png; Γιατί;\n\nggplot(mpg, aes(x = class)) +\n  geom_bar()\nggplot(mpg, aes(x = cty, y = hwy)) +\n  geom_point()\nggsave(\"mpg-plot.png\")\n\n\nΤι πρέπει να αλλάξετε στον παραπάνω κώδικα για να αποθηκεύει το διάγραμμα ως PDF αντί για PNG; Πως μπορείτε να γνωρίζετε τι τύπου αρχεία εικόνων μπορούν να δουλέψουν με την ggsave();",
    "crumbs": [
      "Η ολοκληρωμένη εικόνα",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Οπτικοποίηση δεδομένων</span>"
    ]
  },
  {
    "objectID": "data-visualize.html#συχνά-προβλήματα",
    "href": "data-visualize.html#συχνά-προβλήματα",
    "title": "1  Οπτικοποίηση δεδομένων",
    "section": "\n1.7 Συχνά προβλήματα",
    "text": "1.7 Συχνά προβλήματα\nΚαθώς ξεκινάτε να εκτελείτε κώδικα R, είναι πιθανό να αντιμετωπίσετε προβλήματα. Μην ανησυχείτε — συμβαίνει σε όλους. Όλοι γράφουμε κώδικα R εδώ και χρόνια, αλλά καθημερινά γράφουμε κώδικα που δεν λειτουργεί με την πρώτη προσπάθεια!\nΞεκινήστε συγκρίνοντας προσεκτικά τον κώδικα που εκτελείτε με τον κώδικα που αναφέρεται στο βιβλίο. Η R είναι εξαιρετικά επιλεκτική και ένας άστοχος χαρακτήρας μπορεί να κάνει τη διαφορά. Βεβαιωθείτε ότι κάθε ( αντιστοιχίζεται με ένα ) και κάθε \" αντιστοιχίζεται με ένα άλλο \". Μερικές φορές θα εκτελείτε τον κώδικα και τίποτα δεν θα συμβαίνει. Ελέγξτε το αριστερό μέρος της κονσόλας σας: αν είναι +, σημαίνει ότι η R δεν πιστεύει ότι έχετε πληκτρολογήσει μία πλήρη έκφραση και σας περιμένει να την ολοκληρώσετε. Σε αυτήν την περίπτωση, είναι συνήθως εύκολο να ξεκινήσετε ξανά από την αρχή πατώντας το ESCAPE για να διακόψετε την επεξεργασία της τρέχουσας εντολής.\nΈνα κοινό πρόβλημα κατά τη δημιουργία γραφικών με το πακέτο ggplot2 είναι να τοποθετήσετε το + σε λάθος θέση: πρέπει να έρχεται στο τέλος της γραμμής, όχι στην αρχή. Με άλλα λόγια, βεβαιωθείτε ότι δεν έχετε γράψει κατά λάθος κώδικα ως εξής:\n\nggplot(data = mpg) \n+ geom_point(mapping = aes(x = displ, y = hwy))\n\nΕάν εξακολουθείτε να έχετε κολλήσει, δοκιμάστε τη βοήθεια. Μπορείτε να λάβετε βοήθεια σχετικά με οποιαδήποτε συνάρτηση R εκτελώντας ?function_name στην κονσόλα ή επισημαίνοντας το όνομα της συνάρτησης και πατώντας το F1 στο RStudio. Μην ανησυχείτε εάν η βοήθεια δεν σας φαίνεται τόσο χρήσιμη - αντ’ αυτού μεταβείτε στα παραδείγματα και αναζητήστε κώδικα που να ταιριάζει με αυτό που προσπαθείτε να κάνετε.\nΕάν αυτό δεν βοηθήσει, διαβάστε προσεκτικά το μήνυμα σφάλματος. Μερικές φορές η απάντηση θα είναι κρυμμένη εκεί! Όταν είστε νέοι στην R, ακόμα κι αν η απάντηση βρίσκεται στο μήνυμα σφάλματος, μπορεί να μην ξέρετε ακόμα πώς να το καταλάβετε. Ένα άλλο εξαιρετικό εργαλείο είναι η μηχανή αναζήτησης της Google: δοκιμάστε να γκουγκλάρετε το μήνυμα σφάλματος, καθώς είναι πιθανό κάποιος άλλος να αντιμετώπισε το ίδιο πρόβλημα και να έχει βρει βοήθεια στο διαδίκτυο.",
    "crumbs": [
      "Η ολοκληρωμένη εικόνα",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Οπτικοποίηση δεδομένων</span>"
    ]
  },
  {
    "objectID": "data-visualize.html#σύνοψη",
    "href": "data-visualize.html#σύνοψη",
    "title": "1  Οπτικοποίηση δεδομένων",
    "section": "\n1.8 Σύνοψη",
    "text": "1.8 Σύνοψη\nΣε αυτό το κεφάλαιο, μάθατε τα βασικά σημεία της οπτικοποίησης δεδομένων με το πακέτο ggplot2. Ξεκινήσαμε με τη βασική ιδέα που θεμελιώνει το πακέτο ggplot2: μία οπτικοποίηση είναι μία αντιστοίχιση από μεταβλητές των δεδομένα σας σε αισθητικές ιδιότητες όπως η θέση, το χρώμα, το μέγεθος και το σχήμα. Στη συνέχεια μάθατε για την αύξηση της πολυπλοκότητας και τη βελτίωση της παρουσίασης των διαγραμμάτων σας επίπεδο-προς-επίπεδο. Μάθατε επίσης για τα διαγράμματα που χρησιμοποιούνται συνήθως για την οπτικοποίηση της κατανομής μιας μεμονωμένης μεταβλητής, καθώς και για την οπτικοποίηση σχέσεων μεταξύ δύο ή περισσότερων μεταβλητών, αξιοποιώντας πρόσθετες αισθητικές αντιστοιχίσεις ή/και χωρίζοντας το διάγραμμα σας σε μικρά πολλαπλάσια χρησιμοποιώντας όψεις.\nΘα χρησιμοποιήσουμε οπτικοποιήσεις ξανά και ξανά στην πορεία αυτού του βιβλίου, εισάγοντας νέες τεχνικές, καθώς και μία εμβάθυνση στη δημιουργία οπτικοποιήσεων με το πακέτο ggplot2 από το Κεφάλαιο 9 μέχρι το Κεφάλαιο 11.\nΈχοντας τα βασικά της οπτικοποίησης, στο επόμενο κεφάλαιο θα αλλάξουμε λίγο ρυθμό και θα σας δώσουμε μερικές πρακτικές συμβουλές για τη ροή εργασίας. Δίνουμε συμβουλές ροής εργασίας με εργαλεία επιστήμης δεδομένων σε όλα τα μέρη του βιβλίου, μιας και θα σας βοηθήσουν να παραμείνετε οργανωμένοι καθώς γράφετε κώδικα σε R ολοένα και περισσότερο.",
    "crumbs": [
      "Η ολοκληρωμένη εικόνα",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Οπτικοποίηση δεδομένων</span>"
    ]
  },
  {
    "objectID": "data-visualize.html#footnotes",
    "href": "data-visualize.html#footnotes",
    "title": "1  Οπτικοποίηση δεδομένων",
    "section": "",
    "text": "Μπορείετε να εξαλείψετε αυτό το μήνυμα και να αναγκάσετε την επίλυση συγκρούσεων να συμβαίνει κατ’ απαίτηση χρησιμοποιώντας το συγκρουόμενο πακέτο, το οποίο γίνεται όλο και πιο σημαντικό καθώς φορτώνετε περισσότερα πακέτα. Μπορείτε να μάθετε περισσότερα για τις συγκρούσεις συναρτήσεων στο https://conflicted.r-lib.org.↩︎\nHorst AM, Hill AP, Gorman KB (2020). palmerpenguins: Δεδομένα πιγκουίνων από το Αρχιπέλαγος Πάλμερ (Ανταρκτική). R package version 0.1.0. https://allisonhorst.github.io/palmerpenguins/. doi: 10.5281/zenodo.3960218.↩︎\nΕδώ “formula” είναι το όνομα του αποτελέσματος που προκύπτει από το ~, κι όχι συνώνυμο για τη λέξη “εξίσωση”.↩︎",
    "crumbs": [
      "Η ολοκληρωμένη εικόνα",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Οπτικοποίηση δεδομένων</span>"
    ]
  },
  {
    "objectID": "workflow-basics.html",
    "href": "workflow-basics.html",
    "title": "2  Ροή εργασιών: Bασικές αρχές",
    "section": "",
    "text": "2.1 Βασικές αρχές προγραμματισμού\nΑς εξετάσουμε ορισμένα βασικά στοιχεία που έχουμε παραλείψει μέχρι στιγμής, προς όφελος του να σας βοηθήσουμε να αρχίσετε να δημιουργείτε διαγράμματα όσον το δυνατόν συντομότερα. Μπορείτε να χρησιμοποιήσετε την R για να κάνετε βασικούς μαθηματικούς υπολογισμούς:\n1 / 200 * 30\n#&gt; [1] 0.15\n(59 + 73 + 2) / 3\n#&gt; [1] 44.66667\nsin(pi / 2)\n#&gt; [1] 1\nΜπορείτε να δημιουργήσετε νέα αντικείμενα με τον τελεστή ανάθεσης &lt;-:\nx &lt;- 3 * 4\nΠαρατηρήστε ότι η τιμή του x δεν τυπώνεται, απλά αποθηκεύεται. Εάν θέλετε να δείτε την τιμή του, πληκτρολογήστε x στην κονσόλα.\nΜπορείτε να συνδυάσετε (combine) πολλαπλά στοιχεία σε ένα διάνυσμα με τη συνάρτηση c():\nprimes &lt;- c(2, 3, 5, 7, 11, 13)\nΟι βασικές αριθμητικές πράξεις για διανύσματα εφαρμόζονται σε κάθε στοιχείο του διανύσματος ξεχωριστά:\nprimes * 2\n#&gt; [1]  4  6 10 14 22 26\nprimes - 1\n#&gt; [1]  1  2  4  6 10 12\nΌλες οι δηλώσεις στην R με τις οποίες μπορείτε να δημιουργήσετε αντικείμενα, γνωστές ως δηλώσεις ανάθεσης, έχουν την ίδια μορφή:\nobject_name &lt;- value\nΔιαβάζοντας αυτόν τον κώδικα, μπορείτε να σκέφτεστε “το αντικείμενο object_name παίρνει τιμή value”.\nΘα κάνετε πολλές αναθέσεις και ο τελεστής &lt;- δεν είναι ό,τι πιο βολικό όταν πληκτρολογείτε. Μπορείτε να κερδίσετε χρόνο χρησιμοποιώντας την ακόλουθη συντόμευση πληκτρολογίου του RStudio: Alt + - (το σύμβολο του μείον). Παρατηρήστε ότι το RStudio περιβάλλει αυτόματα το &lt;- με κενά, κάτι που γενικά είναι καλή πρακτική μορφοποίησης κώδικα. Ακόμη και σε μία καλή μέρα, το να διαβάζετε κώδικα μπορεί να είναι κουραστικό, οπότε κάντεένακαλόγιατονεαυτόσαας και χρησιμοποιήστε κενά.",
    "crumbs": [
      "Η ολοκληρωμένη εικόνα",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Ροή εργασιών: Bασικές αρχές</span>"
    ]
  },
  {
    "objectID": "workflow-basics.html#σχόλια",
    "href": "workflow-basics.html#σχόλια",
    "title": "2  Ροή εργασιών: Bασικές αρχές",
    "section": "\n2.2 Σχόλια",
    "text": "2.2 Σχόλια\nΗ R θα αγνοήσει οποιοδήποτε κείμενο βρίσκεται μετά από τον χαρακτήρα # σε μία γραμμή. Αυτό σας επιτρέπει να γράφετε σχόλια, κείμενο δηλαδή που αγνοείται από την R αλλά διαβάζεται από άλλους ανθρώπους. Μερικές φορές θα συμπεριλαμβάνουμε σχόλια στα παραδείγματα μας για να εξηγούμε τι συμβαίνει στον κώδικα.\nΤα σχόλια μπορούν να είναι χρήσιμα για να περιγράψουν εν συντομία τι κάνει ο παρακάτω κώδικας.\n\n# Δημιουργήστε ένα διάνυσμα με πρώτους αριθμούς\nprimes &lt;- c(2, 3, 5, 7, 11, 13)\n\n# Πολλαπλασιάστε τους πρώτους αριθμούς με το 2\nprimes * 2\n#&gt; [1]  4  6 10 14 22 26\n\nΜε μικρά κομμάτια κώδικα όπως αυτό, μπορεί να μην είναι απαραίτητο να αφήνετε κάποιο σχόλιο για κάθε γραμμή κώδικα. Αλλά καθώς ο κώδικας που γράφετε γίνεται πιο περίπλοκος, τα σχόλια μπορούν να σας εξοικονομήσουν πολύ χρόνο (και στους συνεργάτες σας) για να καταλάβετε τι έγινε στον κώδικα.\nΧρησιμοποιήστε σχόλια για να εξηγήσετε το γιατί του κώδικά σας, όχι το πώς ή το τι. Το τι και το πώς του κώδικά σας είναι πάντα δυνατό να καταλάβετε, ακόμα κι αν είναι κουραστικό, διαβάζοντάς τον προσεκτικά. Εάν περιγράφετε κάθε βήμα στα σχόλια και, στη συνέχεια, αλλάξετε τον κώδικα, θα πρέπει να θυμάστε να ενημερώσετε και τα σχόλια, διαφορετικά θα δημιουργηθεί σύγχυση όταν επιστρέψετε στον κώδικά σας στο μέλλον.\nΤο να καταλάβετε γιατί έγινε κάτι είναι πολύ πιο δύσκολο, αν όχι αδύνατο. Για παράδειγμα, η geom_smooth() έχει ένα όρισμα που ονομάζεται span, το οποίο ελέγχει την ομαλότητα της καμπύλης, με μεγαλύτερες τιμές να παράγουν μία πιο ομαλή καμπύλη. Ας υποθέσουμε ότι αποφασίζετε να αλλάξετε την τιμή του span από την προεπιλογή του 0,75 σε 0,9: είναι εύκολο για έναν μελλοντικό αναγνώστη να καταλάβει τι συμβαίνει, αλλά αν δεν σημειώσετε τη σκέψη σας σε ένα σχόλιο, κανείς δεν θα καταλάβει γιατί αλλάξατε την προεπιλεγμένη τιμή.\nΜέσα σε κώδικα ανάλυσης δεδομένων, χρησιμοποιήστε σχόλια για να εξηγήσετε το συνολικό σας σχέδιο δράσης και να καταγράψετε σημαντικές πληροφορίες καθώς τις συναντάτε. Δεν υπάρχει τρόπος να βρείτε ξανά αυτή τη γνώση μόνο από τον κώδικα.",
    "crumbs": [
      "Η ολοκληρωμένη εικόνα",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Ροή εργασιών: Bασικές αρχές</span>"
    ]
  },
  {
    "objectID": "workflow-basics.html#sec-whats-in-a-name",
    "href": "workflow-basics.html#sec-whats-in-a-name",
    "title": "2  Ροή εργασιών: Bασικές αρχές",
    "section": "\n2.3 Τι περιέχει ένα όνομα;",
    "text": "2.3 Τι περιέχει ένα όνομα;\nΤα ονόματα των αντικειμένων πρέπει να ξεκινούν με ένα γράμμα και μπορούν να περιέχουν μόνο γράμματα, αριθμούς, _ και .. Ο στόχος είναι τα ονόματα των αντικειμένων σας να είναι περιγραφικά, οπότε θα πρέπει να υιοθετήσετε έναν κανόνα για πολλές λέξεις. Συνιστούμε το snake_case, όπου χρησιμοποιείται το _ για να διαχωρίσετε τις πεζές λέξεις.\n\ni_use_snake_case\notherPeopleUseCamelCase\nsome.people.use.periods\nAnd_aFew.People_RENOUNCEconvention\n\nΘα επιστρέψουμε ξανά στα ονόματα όταν συζητάμε το στυλ γραφής κώδικα στο Κεφάλαιο 4.\nΜπορείτε να επιθεωρήσετε ένα αντικείμενο πληκτρολογώντας το όνομα του:\n\nx\n#&gt; [1] 12\n\nΑς κάνουμε άλλη μία ανάθεση:\n\nthis_is_a_really_long_name &lt;- 2.5\n\nΓια να επιθεωρήσετε αυτό το αντικείμενο, δοκιμάστε τη δυνατότητα συμπλήρωσης του RStudio: πληκτρολογήστε “this”, πατήστε TAB, προσθέστε χαρακτήρες μέχρι να έχετε ένα μοναδικό πρόθεμα και, στη συνέχεια, πατήστε return.\nΑς υποθέσουμε ότι κάνατε λάθος και ότι η τιμή του this_is_a_really_long_name θα πρέπει να είναι 3.5 και όχι 2.5. Μπορείτε να χρησιμοποιήσετε μία άλλη συντόμευση πληκτρολογίου για να τη διορθώσετε. Για παράδειγμα, μπορείτε να πατήσετε ↑ για να φέρετε την τελευταία εντολή που πληκτρολογήσατε και να την επεξεργαστείτε. Ή, πληκτρολογήστε “this” και, στη συνέχεια, πατήστε Cmd/Ctrl + ↑ για να εμφανίσετε όλες τις εντολές που έχετε πληκτρολογήσει και ξεκινούν με αυτά τα γράμματα. Χρησιμοποιήστε τα πλήκτρα βέλους για πλοήγηση και, στη συνέχεια, πατήστε enter για να πληκτρολογήσετε ξανά την εντολή. Αλλάξτε το 2.5 σε 3.5 και εκτελέστε ξανά.\nΚαι ακόμη μία ανάθεση:\n\nr_rocks &lt;- 2^3\n\nΑς δοκιμάσουμε να επιθεωρήσουμε αυτό το αντικείμενο:\n\nr_rock\n#&gt; Error: object 'r_rock' not found\nR_rocks\n#&gt; Error: object 'R_rocks' not found\n\nΤο αποτέλεσμα αντικατοπτρίζει την συμφωνία που υπονοείται ανάμεσα σε εσάς και την R: η R θα κάνει τους κουραστικούς υπολογισμούς για εσάς, αλλά σε αντάλλαγμα, πρέπει να είστε απόλυτα ακριβείς στις οδηγίες σας. Εάν όχι, είναι πιθανό να λάβετε ένα σφάλμα που λέει ότι το αντικείμενο που αναζητάτε δεν βρέθηκε. Τα τυπογραφικά λάθη έχουν σημασία. Η R δεν μπορεί να διαβάσει το μυαλό σας και να πει, “α, μάλλον εννοούσαν r_rocks όταν πληκτρολογούσαν r_rock”. Και ο τρόπος γραφής έχει σημασία. Ομοίως, η R δεν μπορεί να διαβάσει το μυαλό σας και να πει, “α, μάλλον εννοούσαν r_rocks όταν πληκτρολογούσαν R_rocks”.",
    "crumbs": [
      "Η ολοκληρωμένη εικόνα",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Ροή εργασιών: Bασικές αρχές</span>"
    ]
  },
  {
    "objectID": "workflow-basics.html#καλώντας-συναρτήσεις",
    "href": "workflow-basics.html#καλώντας-συναρτήσεις",
    "title": "2  Ροή εργασιών: Bασικές αρχές",
    "section": "\n2.4 Καλώντας συναρτήσεις",
    "text": "2.4 Καλώντας συναρτήσεις\nΗ R διαθέτει μία πλούσια συλλογή ενσωματωμένων συναρτήσεων, τις οποίες μπορούμε να καλέσουμε ως εξής:\n\nfunction_name(argument1 = value1, argument2 = value2, ...)\n\nΑς δοκιμάσουμε να χρησιμοποιήσουμε τη συνάρτηση seq(), η οποίο δημιουργεί κανονικές ακολουθίες (sequences) αριθμών, και όσο το κάνουμε αυτό, ας μάθουμε περισσότερες χρήσιμες λειτουργίες του RStudio. Πληκτρολογήστε se και πατήστε TAB. Ένα αναδυόμενο παράθυρο εμφανίζει πιθανές ολοκληρώσεις. Καθορίστε την seq() πληκτρολογώντας περισσότερους χαρακτήρες (ένα q ακόμη) για να είναι πιο ξεκάθαρο από τις άλλες εναλλακτικές, ή χρησιμοποιώντας τα βέλη ↑/↓ για επιλογή. Παρατηρήστε την αιωρούμενη επεξήγηση που εμφανίζεται, υπενθυμίζοντας σας τα ορίσματα και τον σκοπό της συνάρτησης. Εάν θέλετε περισσότερη βοήθεια, πατήστε F1 για να δείτε όλες τις λεπτομέρειες στην καρτέλα βοήθεια στο κάτω δεξιό τμήμα του πλαισίου\nΌταν επιλέξετε τη συνάρτηση που θέλετε, πατήστε ξανά το TAB. Το RStudio θα προσθέσει αντίστοιχες παρενθέσεις ανοίγματος (() και κλεισίματος ()) για εσάς. Πληκτρολογήστε το όνομα του πρώτου ορίσματος, from (από) και ορίστε το ίσο με 1. Στη συνέχεια, πληκτρολογήστε το όνομα του δεύτερου ορίσματος, to (προς) και ορίστε το ίσο με 10. Τέλος, πατήστε το πλήκτρο return.\n\nseq(from = 1, to = 10)\n#&gt;  [1]  1  2  3  4  5  6  7  8  9 10\n\nΣυχνά παραλείπουμε τα ονόματα των πρώτων ορισμάτων όταν καλούμε συναρτήσεις, οπότε ο παραπάνω κώδικας μπορεί να γραφεί και ως:\n\nseq(1, 10)\n#&gt;  [1]  1  2  3  4  5  6  7  8  9 10\n\nΠληκτρολογήστε τον ακόλουθο κώδικα και παρατηρήστε ότι το RStudio προσφέρει παρόμοια βοήθεια με τα διπλά εισαγωγικά:\n\nx &lt;- \"hello world\"\n\nΤα εισαγωγικά και οι παρενθέσεις πρέπει πάντα να έρχονται σε ζεύγη. Το RStudio κάνει το καλύτερο που μπορεί για να σας βοηθήσει, αλλά εξακολουθεί να είναι πιθανό να μπερδευτείτε και να καταλήξετε με κάτι που δεν είναι συμβατό. Εάν συμβεί αυτό, η R θα σας δείξει τον χαρακτήρα συνέχισης “+”:\n&gt; x &lt;- \"hello\n+\nΤο + σας υποδεικνύει ότι η R περιμένει για περισσότερες πληροφορίες, καθώς δεν πιστευτεί ότι έχετε ολοκληρώσει αυτό που θέλετε να κάνετε. Συνήθως, αυτό σημαίνει ότι έχετε ξεχάσει είτε ένα \" είτε ένα ). Σε αυτή την περίπτωση, είτε προσθέστε το ζεύγος που λείπει είτε πατήστε ESCAPE για να ακυρώσετε την έκφραση και δοκιμάστε ξανά.\nΣημειώστε ότι η καρτέλα περιβάλλοντος στο επάνω δεξιό πλαίσιο εμφανίζει όλα τα αντικείμενα που έχετε δημιουργήσει:",
    "crumbs": [
      "Η ολοκληρωμένη εικόνα",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Ροή εργασιών: Bασικές αρχές</span>"
    ]
  },
  {
    "objectID": "workflow-basics.html#ασκήσεις",
    "href": "workflow-basics.html#ασκήσεις",
    "title": "2  Ροή εργασιών: Bασικές αρχές",
    "section": "\n2.5 Ασκήσεις",
    "text": "2.5 Ασκήσεις\n\n\nΓιατί δεν δουλεύει ο ακόλουθος κώδικας;\n\nmy_variable &lt;- 10\nmy_varıable\n#&gt; Error in eval(expr, envir, enclos): object 'my_varıable' not found\n\nΠαρατηρήστε προσεκτικά! (Αυτή η άσκηση μπορεί να φαντάζει ανούσια, ωστόσο το να εκπαιδεύετε το μυαλό σας να παρατηρεί ακόμη και τις πιο μικρές διαφορές θα σας ανταμείψει όταν γράφετε κώδικα.)\n\n\nΠειράξτε τις παρακάτω εντολές R ώστε ο κώδικας να τρέχει σωστά:\n\nlibary(todyverse)\n\nggplot(dTA = mpg) + \n  geom_point(maping = aes(x = displ y = hwy)) +\n  geom_smooth(method = \"lm)\n\n\nΠατήστε Option + Shift + K / Alt + Shift + K. Τι συμβαίνει; Πώς μπορείτε να πετύχετε το ίδιο αποτέλεσμα χρησιμοποιώντας τα μενού επιλογών;\n\nΑς ξαναδούμε μία άσκηση από την Ενότητα 1.6. Εκτελέστε τις ακόλουθες γραμμές κώδικα. Ποιο από τα δύο διαγράμματα αποθηκεύεται ως mpg-plot.png; Γιατί;\n\nmy_bar_plot &lt;- ggplot(mpg, aes(x = class)) +\n  geom_bar()\nmy_scatter_plot &lt;- ggplot(mpg, aes(x = cty, y = hwy)) +\n  geom_point()\nggsave(filename = \"mpg-plot.png\", plot = my_bar_plot)",
    "crumbs": [
      "Η ολοκληρωμένη εικόνα",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Ροή εργασιών: Bασικές αρχές</span>"
    ]
  },
  {
    "objectID": "workflow-basics.html#σύνοψη",
    "href": "workflow-basics.html#σύνοψη",
    "title": "2  Ροή εργασιών: Bασικές αρχές",
    "section": "\n2.6 Σύνοψη",
    "text": "2.6 Σύνοψη\nΤώρα έχετε μάθει λίγα περισσότερα για το πώς λειτουργεί ο κώδικας σε R, καθώς και μερικές συμβουλές που θα σας βοηθήσουν να κατανοήσετε τον κώδικά σας όταν επιστρέψετε σε αυτόν στο μέλλον. Στο επόμενο κεφάλαιο, θα συνεχίσουμε το ταξίδι σας στην επιστήμη δεδομένων διδάσκοντας σας για το πακέτο dplyr, το πακέτο του tidyverse που σας βοηθά να μετασχηματίζετε δεδομένα, είτε πρόκειται για το να επιλέγετε σημαντικές μεταβλητές, να φιλτράρισμα τις γραμμές που σας ενδιαφέρουν ή να υπολογίζετε περιληπτικά στατιστικά μέτρα.",
    "crumbs": [
      "Η ολοκληρωμένη εικόνα",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Ροή εργασιών: Bασικές αρχές</span>"
    ]
  },
  {
    "objectID": "data-transform.html",
    "href": "data-transform.html",
    "title": "3  Μετασχηματισμός Δεδομένων",
    "section": "",
    "text": "3.1 Εισαγωγή\nΗ οπτικοποίηση είναι ένα σημαντικό εργαλείο για τη δημιουργία γνώσης, αλλά είναι σπάνιο να λαμβάνετε τα δεδομένα ακριβώς με τη σωστή μορφή που χρειάζεστε για να δημιουργήσετε το διάγραμμα που θέλετε. Συχνά θα χρειαστεί να δημιουργήσετε μερικές νέες μεταβλητές ή συνόψεις για να απαντήσετε τις ερωτήσεις σας με τα δεδομένα σας ή ίσως απλώς θέλετε να μετονομάσετε τις μεταβλητές ή να αναδιατάξετε τις παρατηρήσεις για να κάνετε τα δεδομένα λίγο πιο εύκολα στο χειρισμό. Θα μάθετε πώς να τα κάνετε όλα αυτά (και πολλά άλλα!) σε αυτό το κεφάλαιο, το οποίο θα σας δώσει μία εισαγωγή στον μετασχηματισμό δεδομένων χρησιμοποιώντας το πακέτο dplyr και ένα νέο σύνολο δεδομένων με πτήσεις που αναχώρησαν από τη Νέα Υόρκη το 2013.\nΟ στόχος αυτού του κεφαλαίου είναι να σας δώσει μία επισκόπηση όλων των βασικών εργαλείων για τη μετατροπή ενός πλαισίου δεδομένων. Θα ξεκινήσουμε με συναρτήσεις που εφαρμόζονται σε γραμμές και στη συνέχεια σε στήλες ενός πλαισίου δεδομένων και, στη συνέχεια, θα επιστρέψουμε για να μιλήσουμε περισσότερο για το pipe, ένα σημαντικό εργαλείο που χρησιμοποιείτε για να συνδυάσετε συναρτήσεις. Στη συνέχεια θα εισαγάγουμε την ικανότητα εργασίας με ομάδες δεδομένων. Θα τελειώσουμε το κεφάλαιο με μία μελέτη περίπτωσης που παρουσιάζει αυτές τις συναρτήσεις εν δράση και θα επανέλθουμε στις συναρτήσεις με περισσότερες λεπτομέρειες σε επόμενα κεφάλαια, καθώς θα αρχίζουμε να εξερευνούμε συγκεκριμένους τύπους δεδομένων (π.χ. αριθμούς, συμβολοσειρές, ημερομηνίες).",
    "crumbs": [
      "Η ολοκληρωμένη εικόνα",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Μετασχηματισμός Δεδομένων</span>"
    ]
  },
  {
    "objectID": "data-transform.html#εισαγωγή",
    "href": "data-transform.html#εισαγωγή",
    "title": "3  Μετασχηματισμός Δεδομένων",
    "section": "",
    "text": "3.1.1 Προαπαιτούμενα\nΣε αυτό το κεφάλαιο θα επικεντρωθούμε στο πακέτο dplyr, ακόμη ένα βασικό μέλος του tidyverse. Θα παρουσιάσουμε τις βασικές ιδέες χρησιμοποιώντας δεδομένα από το πακέτο nycflights13 και θα χρησιμοποιήσουμε το πακέτο ggplot2 για να μας βοηθήσει να κατανοήσουμε τα δεδομένα.\n\nlibrary(nycflights13)\nlibrary(tidyverse)\n#&gt; ── Attaching core tidyverse packages ───────────────────── tidyverse 2.0.0 ──\n#&gt; ✔ dplyr     1.1.4     ✔ readr     2.1.5\n#&gt; ✔ forcats   1.0.0     ✔ stringr   1.5.1\n#&gt; ✔ ggplot2   3.5.0     ✔ tibble    3.2.1\n#&gt; ✔ lubridate 1.9.3     ✔ tidyr     1.3.1\n#&gt; ✔ purrr     1.0.2     \n#&gt; ── Conflicts ─────────────────────────────────────── tidyverse_conflicts() ──\n#&gt; ✖ dplyr::filter() masks stats::filter()\n#&gt; ✖ dplyr::lag()    masks stats::lag()\n#&gt; ℹ Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors\n\nΠαρατηρήστε προσεκτικά το μήνυμα συγκρούσεων που εκτυπώνεται όταν φορτώνετε το tidyverse. Σας λέει ότι το πακέτο dplyr αντικαθιστά ορισμένες συναρτήσεις από το βασικό σύνολο λειτουργιών της R. Εάν θέλετε να χρησιμοποιήσετε τη βασική έκδοση αυτών των συναρτήσεων μετά τη φόρτωση της dplyr, θα πρέπει να χρησιμοποιήσετε τα πλήρη ονόματά τους: stats::filter() και stats::lag(). Μέχρι στιγμής έχουμε αγνοήσει από ποιο πακέτο προέρχεται μία συνάρτηση γιατί τις περισσότερες φορές δεν έχει σημασία. Ωστόσο, η γνώση του πακέτου μπορεί να σας βοηθήσει να αναζητήσετε βοήθεια και να βρείτε σχετικές συναρτήσεις, οπότε όταν πρέπει να είμαστε ακριβείς σχετικά με το πακέτο από το οποίο προέρχεται μία συνάρτηση, θα χρησιμοποιήσουμε την ίδια σύνταξη με την R: packagename::functionname().\n\n3.1.2 nycflights13\nΓια να εξερευνήσουμε τις βασικές συναρτήσεις της dplyr, θα χρησιμοποιήσουμε το σύνολο δεδομένων nycflights13::flights. Αυτό περιέχει όλες τις 336,776 πτήσεις που αναχώρησαν από την πόλη της Νέας Υόρκης το 2013. Αυτά τα δεδομένα προέρχονται από το Γραφείο Στατιστικών Μεταφορών των ΗΠΑ και τεκμηριώνονται στο ?flights.\n\nflights\n#&gt; # A tibble: 336,776 × 19\n#&gt;    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n#&gt;   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;\n#&gt; 1  2013     1     1      517            515         2      830            819\n#&gt; 2  2013     1     1      533            529         4      850            830\n#&gt; 3  2013     1     1      542            540         2      923            850\n#&gt; 4  2013     1     1      544            545        -1     1004           1022\n#&gt; 5  2013     1     1      554            600        -6      812            837\n#&gt; 6  2013     1     1      554            558        -4      740            728\n#&gt; # ℹ 336,770 more rows\n#&gt; # ℹ 11 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;, …\n\nΤο flights είναι ένα tibble, ένας ειδικός τύπος πλαισίου δεδομένων που χρησιμοποιείται από το tidyverse για να αποφευχθούν ορισμένες συχνές προκλήσεις. Η πιο σημαντική διαφορά μεταξύ των tibbles και των πλαισίων δεδομένων είναι ο τρόπος εκτύπωσης των tibbles. Τα πρώτα έχουν σχεδιαστεί για μεγάλα σύνολα δεδομένων, επομένως εμφανίζουν μόνο τις πρώτες λίγες σειρές και μόνο τις στήλες που χωρούν σε μία οθόνη. Υπάρχουν μερικές επιλογές για να δείτε τα πάντα. Εάν χρησιμοποιείτε το RStudio, το πιο βολικό είναι ίσως το View(flights), το οποίο θα ανοίξει μία διαδραστική προβολή με δυνατότητα κύλισης και φιλτραρίσματος. Διαφορετικά, μπορείτε να χρησιμοποιήσετε την print(flights, width = Inf) για να εμφανίσετε όλες τις στήλες ή να χρησιμοποιήσετε την glimpse():\n\nglimpse(flights)\n#&gt; Rows: 336,776\n#&gt; Columns: 19\n#&gt; $ year           &lt;int&gt; 2013, 2013, 2013, 2013, 2013, 2013, 2013, 2013, 2013…\n#&gt; $ month          &lt;int&gt; 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1…\n#&gt; $ day            &lt;int&gt; 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1…\n#&gt; $ dep_time       &lt;int&gt; 517, 533, 542, 544, 554, 554, 555, 557, 557, 558, 55…\n#&gt; $ sched_dep_time &lt;int&gt; 515, 529, 540, 545, 600, 558, 600, 600, 600, 600, 60…\n#&gt; $ dep_delay      &lt;dbl&gt; 2, 4, 2, -1, -6, -4, -5, -3, -3, -2, -2, -2, -2, -2,…\n#&gt; $ arr_time       &lt;int&gt; 830, 850, 923, 1004, 812, 740, 913, 709, 838, 753, 8…\n#&gt; $ sched_arr_time &lt;int&gt; 819, 830, 850, 1022, 837, 728, 854, 723, 846, 745, 8…\n#&gt; $ arr_delay      &lt;dbl&gt; 11, 20, 33, -18, -25, 12, 19, -14, -8, 8, -2, -3, 7,…\n#&gt; $ carrier        &lt;chr&gt; \"UA\", \"UA\", \"AA\", \"B6\", \"DL\", \"UA\", \"B6\", \"EV\", \"B6\"…\n#&gt; $ flight         &lt;int&gt; 1545, 1714, 1141, 725, 461, 1696, 507, 5708, 79, 301…\n#&gt; $ tailnum        &lt;chr&gt; \"N14228\", \"N24211\", \"N619AA\", \"N804JB\", \"N668DN\", \"N…\n#&gt; $ origin         &lt;chr&gt; \"EWR\", \"LGA\", \"JFK\", \"JFK\", \"LGA\", \"EWR\", \"EWR\", \"LG…\n#&gt; $ dest           &lt;chr&gt; \"IAH\", \"IAH\", \"MIA\", \"BQN\", \"ATL\", \"ORD\", \"FLL\", \"IA…\n#&gt; $ air_time       &lt;dbl&gt; 227, 227, 160, 183, 116, 150, 158, 53, 140, 138, 149…\n#&gt; $ distance       &lt;dbl&gt; 1400, 1416, 1089, 1576, 762, 719, 1065, 229, 944, 73…\n#&gt; $ hour           &lt;dbl&gt; 5, 5, 5, 5, 6, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 5, 6, 6…\n#&gt; $ minute         &lt;dbl&gt; 15, 29, 40, 45, 0, 58, 0, 0, 0, 0, 0, 0, 0, 0, 0, 59…\n#&gt; $ time_hour      &lt;dttm&gt; 2013-01-01 05:00:00, 2013-01-01 05:00:00, 2013-01-0…\n\nΚαι στις δύο όψεις, τα ονόματα των μεταβλητών ακολουθούνται από συντομογραφίες που σας λένε τον τύπο κάθε μεταβλητής: το &lt;int&gt; είναι συντομογραφία για ακέραιους αριθμούς, το &lt;dbl&gt; για πραγματικούς αριθμούς, το &lt;chr&gt; για χαρακτήρες (γνωστοί και ως συμβολοσειρές) και το &lt;dttm&gt; για ημερομηνίες-ώρα. Όλα αυτά είναι σημαντικά επειδή οι χειρισμοί που μπορείτε να εφαρμόσετε σε μία στήλη εξαρτώνται πολύ από τον “τύπο” της.\n\n3.1.3 Βασικές αρχές της dplyr\nΑκολουθούν οι κύριες συναρτήσεις της dplyr που θα σας επιτρέψουν να λύσετε τη συντριπτική πλειονότητα των προκλήσεων χειρισμού δεδομένων που θα συναντήσετε. Αλλά πριν συζητήσουμε τις μεμονωμένες διαφορές τους, αξίζει να αναφέρουμε τι κοινό έχουν:\n\nΤο πρώτο τους όρισμα είναι πάντα ένα πλαίσιο δεδομένων.\nΤα επόμενα ορίσματα συνήθως περιγράφουν σε ποιες στήλες θα λειτουργήσουν, χρησιμοποιώντας τα ονόματα των μεταβλητών (χωρίς εισαγωγικά).\nΗ έξοδος είναι πάντα ένα νέο πλαίσιο δεδομένων.\n\nΕπειδή κάθε συνάρτηση κάνει ένα πράγμα καλά, η επίλυση σύνθετων προβλημάτων συνήθως απαιτεί συνδυασμό πολλών συναρτήσεων, και αυτό θα το κάνουμε με το pipe, |&gt;. Θα συζητήσουμε το pipe περισσότερο στην Ενότητα 3.4, αλλά εν συντομία, παίρνει ό,τι υπάρχει στα αριστερά του και το περνά στη συνάρτηση στα δεξιά του, έτσι ώστε το x |&gt; f(y) να είναι ισοδύναμο με f(x, y), και το x |&gt; f(y) |&gt; g(z) ισοδυναμεί με g(f(x, y), z). Ο ευκολότερος τρόπος για να περιγράψετε το pipe είναι με τη λέξη “τότε”. Αυτό καθιστά δυνατό να αποκτήσετε μία αίσθηση του παρακάτω κώδικα, παρόλο που δεν έχετε μάθει ακόμη τις λεπτομέρειες:\n\nflights |&gt;\n  filter(dest == \"IAH\") |&gt; \n  group_by(year, month, day) |&gt; \n  summarize(\n    arr_delay = mean(arr_delay, na.rm = TRUE)\n  )\n\nΟι συναρτήσεις της dplyr οργανώνονται σε τέσσερις ομάδες με βάση το σε τι εφαρμόζονται: γραμμές, στήλες, ομάδες ή πίνακες. Στις επόμενες ενότητες θα μάθετε τις πιο σημαντικές συναρτήσεις για γραμμές, στήλες και ομάδες και, στη συνέχεια, θα επιστρέψουμε στις συναρτήσεις join που λειτουργούν σε πίνακες στο Κεφάλαιο 19. Ας αρχίσουμε!",
    "crumbs": [
      "Η ολοκληρωμένη εικόνα",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Μετασχηματισμός Δεδομένων</span>"
    ]
  },
  {
    "objectID": "data-transform.html#γραμμές",
    "href": "data-transform.html#γραμμές",
    "title": "3  Μετασχηματισμός Δεδομένων",
    "section": "\n3.2 Γραμμές",
    "text": "3.2 Γραμμές\nΟι πιο σημαντικές συναρτήσεις που λειτουργούν στις γραμμές ενός συνόλου δεδομένων είναι η filter(), η οποία αλλάζει το ποιες γραμμές θα παρουσιάζονται χωρίς να αλλάξει τη σειρά τους και η arrange(), η οποία αλλάζει τη σειρά των γραμμών χωρίς να αλλάζει ποιες υπάρχουν. Και οι δύο συναρτήσεις επηρεάζουν μόνο τις γραμμές και οι στήλες παραμένουν αμετάβλητες. Θα συζητήσουμε επίσης και την distinct() που βρίσκει γραμμές με μοναδικές τιμές αλλά σε αντίθεση με την arrange() και την filter() μπορεί επίσης να τροποποιήσει προαιρετικά τις στήλες.\n\n3.2.1 filter()\n\nΗ filter() σας επιτρέπει να διατηρείτε γραμμές με βάση τις τιμές των στηλών1. Το πρώτο όρισμα είναι το πλαίσιο δεδομένων. Το δεύτερο και τα επόμενα ορίσματα είναι οι συνθήκες που πρέπει να ισχύουν για να διατηρηθεί η σειρά. Για παράδειγμα, θα μπορούσαμε να βρούμε όλες τις πτήσεις που αναχώρησαν με καθυστέρηση μεγαλύτερη των 120 λεπτών (δύο ώρες):\n\nflights |&gt; \n  filter(dep_delay &gt; 120)\n#&gt; # A tibble: 9,723 × 19\n#&gt;    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n#&gt;   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;\n#&gt; 1  2013     1     1      848           1835       853     1001           1950\n#&gt; 2  2013     1     1      957            733       144     1056            853\n#&gt; 3  2013     1     1     1114            900       134     1447           1222\n#&gt; 4  2013     1     1     1540           1338       122     2020           1825\n#&gt; 5  2013     1     1     1815           1325       290     2120           1542\n#&gt; 6  2013     1     1     1842           1422       260     1958           1535\n#&gt; # ℹ 9,717 more rows\n#&gt; # ℹ 11 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;, …\n\nΕκτός από το &gt; (μεγαλύτερο από), μπορείτε να χρησιμοποιήσετε και το &gt;= (μεγαλύτερο ή ίσο με), το&lt; (μικρότερο από), το &lt;=(μικρότερο από ή ίσο με), το == (ίσο με), και το != (διαφορετικό). Μπορείτε επίσης να συνδυάσετε συνθήκες με & ή , για να υποδείξετε το “και” (έλεγχος και για τις δύο συνθήκες) ή με | για να υποδείξετε το “ή” (έλεγχος για οποιαδήποτε από τις δύο συνθήκες):\n\n# Πτήσεις που αναχώρησαν την 1η Ιανουαρίου\nflights |&gt; \n  filter(month == 1 & day == 1)\n#&gt; # A tibble: 842 × 19\n#&gt;    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n#&gt;   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;\n#&gt; 1  2013     1     1      517            515         2      830            819\n#&gt; 2  2013     1     1      533            529         4      850            830\n#&gt; 3  2013     1     1      542            540         2      923            850\n#&gt; 4  2013     1     1      544            545        -1     1004           1022\n#&gt; 5  2013     1     1      554            600        -6      812            837\n#&gt; 6  2013     1     1      554            558        -4      740            728\n#&gt; # ℹ 836 more rows\n#&gt; # ℹ 11 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;, …\n\n# Πτήσεις που αναχώρησαν τον Ιανουάριο ή τον Φεβρουάριο\nflights |&gt; \n  filter(month == 1 | month == 2)\n#&gt; # A tibble: 51,955 × 19\n#&gt;    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n#&gt;   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;\n#&gt; 1  2013     1     1      517            515         2      830            819\n#&gt; 2  2013     1     1      533            529         4      850            830\n#&gt; 3  2013     1     1      542            540         2      923            850\n#&gt; 4  2013     1     1      544            545        -1     1004           1022\n#&gt; 5  2013     1     1      554            600        -6      812            837\n#&gt; 6  2013     1     1      554            558        -4      740            728\n#&gt; # ℹ 51,949 more rows\n#&gt; # ℹ 11 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;, …\n\nΥπάρχει μία χρήσιμη συντόμευση όταν συνδυάζετε τα | και ==: το %in%. Διατηρεί γραμμές όπου η μεταβλητή ισούται με μία από τις τιμές στα δεξιά:\n\n# Ένας πιο σύντομος τρόπος για να επιλέξετε πτήσεις που αναχώρησαν τον Ιανουάριο ή τον Φεβρουάριο\nflights |&gt; \n  filter(month %in% c(1, 2))\n#&gt; # A tibble: 51,955 × 19\n#&gt;    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n#&gt;   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;\n#&gt; 1  2013     1     1      517            515         2      830            819\n#&gt; 2  2013     1     1      533            529         4      850            830\n#&gt; 3  2013     1     1      542            540         2      923            850\n#&gt; 4  2013     1     1      544            545        -1     1004           1022\n#&gt; 5  2013     1     1      554            600        -6      812            837\n#&gt; 6  2013     1     1      554            558        -4      740            728\n#&gt; # ℹ 51,949 more rows\n#&gt; # ℹ 11 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;, …\n\nΘα επανέλθουμε σε αυτές τις συγκρίσεις και τους λογικούς τελεστές με περισσότερες λεπτομέρειες στο Κεφάλαιο 12.\nΌταν εκτελείτε την filter(), το πακέτο dplyr εκτελεί τη λειτουργία φιλτραρίσματος, δημιουργώντας ένα νέο πλαίσιο δεδομένων και, στη συνέχεια, το εκτυπώνει. Δεν τροποποιεί το υπάρχον σύνολο δεδομένων flights, επειδή οι συναρτήσεις της dplyr δεν τροποποιούν ποτέ τις εισόδους τους. Για να αποθηκεύσετε το αποτέλεσμα, πρέπει να χρησιμοποιήσετε τον τελεστή ανάθεσης, &lt;-:\n\njan1 &lt;- flights |&gt; \n  filter(month == 1 & day == 1)\n\n\n3.2.2 Συχνά λάθη\nΌταν ξεκινάτε με την R, το πιο εύκολο λάθος που μπορείτε να κάνετε είναι να χρησιμοποιήσετε το = αντί για το == όταν ελέγχετε για ισότητα. Η filter() θα σας ενημερώσει όταν συμβεί αυτό:\n\nflights |&gt; \n  filter(month = 1)\n#&gt; Error in `filter()`:\n#&gt; ! We detected a named input.\n#&gt; ℹ This usually means that you've used `=` instead of `==`.\n#&gt; ℹ Did you mean `month == 1`?\n\nΆλλο ένα κοινό λάθος είναι ότι γράφετε “or” δηλώσεις όπως θα κάνατε στα αγγλικά:\n\nflights |&gt; \n  filter(month == 1 | 2)\n\nΟ παραπάνω κώδικας “δουλεύει”, με την έννοια ότι δεν επιστρέφει σφάλμα, αλλά δεν κάνει αυτό που θέλετε επειδή το | ελέγχει πρώτα τη συνθήκη month == 1 και μετά ελέγχει τη συνθήκη 2, η οποία δεν είναι μία λογική συνθήκη για έλεγχο. Θα μάθουμε περισσότερα για το τι συμβαίνει εδώ και γιατί στην Ενότητα 15.6.2.\n\n3.2.3 arrange()\n\nΗ arrange() αλλάζει τη σειρά των γραμμών με βάση την τιμή των στηλών. Δέχεται σαν ορίσματα ένα πλαίσιο δεδομένων και ένα σύνολο ονομάτων στηλών (ή πιο περίπλοκων εκφράσεων) για να τα ταξινομήσετε. Εάν παρέχετε περισσότερα από ένα ονόματα στηλών, κάθε πρόσθετη στήλη θα χρησιμοποιηθεί για την επίλυση ισοπαλιών στις τιμές των προηγούμενων στηλών. Για παράδειγμα, ο παρακάτω κώδικας ταξινομεί τις γραμμές με βάση την ώρα αναχώρησης, η οποία κατανέμεται σε τέσσερις στήλες. Πρώτα παίρνουμε τα πιο πρόσφατα χρόνια, και στη συνέχεια ανάμεσα σε ένα χρόνο τους πρώτους μήνες κ.ο.κ.\n\nflights |&gt; \n  arrange(year, month, day, dep_time)\n#&gt; # A tibble: 336,776 × 19\n#&gt;    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n#&gt;   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;\n#&gt; 1  2013     1     1      517            515         2      830            819\n#&gt; 2  2013     1     1      533            529         4      850            830\n#&gt; 3  2013     1     1      542            540         2      923            850\n#&gt; 4  2013     1     1      544            545        -1     1004           1022\n#&gt; 5  2013     1     1      554            600        -6      812            837\n#&gt; 6  2013     1     1      554            558        -4      740            728\n#&gt; # ℹ 336,770 more rows\n#&gt; # ℹ 11 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;, …\n\nΜπορείτε να χρησιμοποιήσετε το όρισμα desc() σε μία στήλη μέσα στην arrange() για να αναδιατάξετε το πλαίσιο δεδομένων με βάση αυτή τη στήλη με φθίνουσα σειρά (μεγαλύτερο προς μικρότερο). Για παράδειγμα, ο ακόλουθος κώδικας διατάσσει τις πτήσεις ανάλογα με την καθυστέρηση που έχουν σημειώσει, από τις μεγαλύτερες έως τις μικρότερες:\n\nflights |&gt; \n  arrange(desc(dep_delay))\n#&gt; # A tibble: 336,776 × 19\n#&gt;    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n#&gt;   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;\n#&gt; 1  2013     1     9      641            900      1301     1242           1530\n#&gt; 2  2013     6    15     1432           1935      1137     1607           2120\n#&gt; 3  2013     1    10     1121           1635      1126     1239           1810\n#&gt; 4  2013     9    20     1139           1845      1014     1457           2210\n#&gt; 5  2013     7    22      845           1600      1005     1044           1815\n#&gt; 6  2013     4    10     1100           1900       960     1342           2211\n#&gt; # ℹ 336,770 more rows\n#&gt; # ℹ 11 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;, …\n\nΣημειώστε ότι ο αριθμός των γραμμών δεν έχει αλλάξει – τακτοποιούμε μόνο τα δεδομένα, δεν τα φιλτράρουμε.\n\n3.2.4 distinct()\n\nΗ distinct() βρίσκει όλες τις μοναδικές γραμμές σε ένα σύνολο δεδομένων, επομένως από τεχνική άποψη, λειτουργεί κυρίως στις γραμμές. Τις περισσότερες φορές, ωστόσο, θα θέλετε τον διακριτό συνδυασμό ορισμένων μεταβλητών, οπότε μπορείτε επίσης να παρέχετε προαιρετικά ονόματα στηλών:\n\n# Αφαιρέστε τις διπλότυπες γραμμές, εάν υπάρχουν\nflights |&gt; \n  distinct()\n#&gt; # A tibble: 336,776 × 19\n#&gt;    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n#&gt;   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;\n#&gt; 1  2013     1     1      517            515         2      830            819\n#&gt; 2  2013     1     1      533            529         4      850            830\n#&gt; 3  2013     1     1      542            540         2      923            850\n#&gt; 4  2013     1     1      544            545        -1     1004           1022\n#&gt; 5  2013     1     1      554            600        -6      812            837\n#&gt; 6  2013     1     1      554            558        -4      740            728\n#&gt; # ℹ 336,770 more rows\n#&gt; # ℹ 11 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;, …\n\n# Βρείτε όλα τα μοναδικά ζεύγη προέλευσης και προορισμού\nflights |&gt; \n  distinct(origin, dest)\n#&gt; # A tibble: 224 × 2\n#&gt;   origin dest \n#&gt;   &lt;chr&gt;  &lt;chr&gt;\n#&gt; 1 EWR    IAH  \n#&gt; 2 LGA    IAH  \n#&gt; 3 JFK    MIA  \n#&gt; 4 JFK    BQN  \n#&gt; 5 LGA    ATL  \n#&gt; 6 EWR    ORD  \n#&gt; # ℹ 218 more rows\n\nΕναλλακτικά, εάν θέλετε να διατηρήσετε άλλες στήλες κατά το φιλτράρισμα για μοναδικές γραμμές, μπορείτε να χρησιμοποιήσετε την επιλογή .keep_all = TRUE.\n\nflights |&gt; \n  distinct(origin, dest, .keep_all = TRUE)\n#&gt; # A tibble: 224 × 19\n#&gt;    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n#&gt;   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;\n#&gt; 1  2013     1     1      517            515         2      830            819\n#&gt; 2  2013     1     1      533            529         4      850            830\n#&gt; 3  2013     1     1      542            540         2      923            850\n#&gt; 4  2013     1     1      544            545        -1     1004           1022\n#&gt; 5  2013     1     1      554            600        -6      812            837\n#&gt; 6  2013     1     1      554            558        -4      740            728\n#&gt; # ℹ 218 more rows\n#&gt; # ℹ 11 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;, …\n\nΔεν είναι τυχαίο ότι όλες αυτές οι ξεχωριστές πτήσεις πραγματοποιούνται την 1η Ιανουαρίου: Η distinct() θα βρει την πρώτη εμφάνιση μιας μοναδικής γραμμής στο σύνολο δεδομένων και θα απορρίψει τις υπόλοιπες.\nΕάν θέλετε να βρείτε τον αριθμό των εμφανίσεων, καλύτερα να αντικαταστήσετε την distinct() με την count(), ενώ χρησιμοποιώντας το όρισμα sort = TRUE μπορείτε να τις διατάξετε σε φθίνουσα σειρά σύμφωνα με τον αριθμό εμφανίσεων. Θα μάθετε περισσότερα για τα αθροίσματα στην Ενότητα 13.3.\n\nflights |&gt;\n  count(origin, dest, sort = TRUE)\n#&gt; # A tibble: 224 × 3\n#&gt;   origin dest      n\n#&gt;   &lt;chr&gt;  &lt;chr&gt; &lt;int&gt;\n#&gt; 1 JFK    LAX   11262\n#&gt; 2 LGA    ATL   10263\n#&gt; 3 LGA    ORD    8857\n#&gt; 4 JFK    SFO    8204\n#&gt; 5 LGA    CLT    6168\n#&gt; 6 EWR    ORD    6100\n#&gt; # ℹ 218 more rows\n\n\n3.2.5 Ασκήσεις\n\n\nΣε μία μόνο ροή για κάθε συνθήκη, βρείτε όλες τις πτήσεις που πληρούν την προϋπόθεση:\n\nΝα είχε καθυστέρηση άφιξης δύο ή περισσότερων ωρών\nΝα πέταξε στο Χιούστον («IAH» ή «HOU»)\nΝα λειτουργούσαν από τις αεροπορικές εταιρείες United, American ή Delta\nΝα αναχώρησε το καλοκαίρι (Ιούλιο, Αύγουστο και Σεπτέμβριο)\nΝα έφτασε με περισσότερο από δύο ώρες καθυστέρηση, αλλά δεν αναχώρησε με καθυστέρηση\nΝα καθυστέρησαν τουλάχιστον μία ώρα, αλλά συμπληρώθηκαν πάνω από 30 λεπτά κατά την πτήση\n\n\nΤαξινομήστε το flights για να βρείτε τις πτήσεις με τις μεγαλύτερες καθυστερήσεις αναχώρησης. Βρείτε τις πτήσεις που έφυγαν πιο νωρίς το πρωί.\nΤαξινομήστε το flights για να βρείτε τις ταχύτερες πτήσεις. (Υπόδειξη: Δοκιμάστε να συμπεριλάβετε έναν μαθηματικό υπολογισμό μέσα στη συνάρτησή σας.)\nΥπήρχε πτήση κάθε μέρα του 2013;\nΠοιες πτήσεις διένυσαν τη μεγαλύτερη απόσταση; Ποιο ταξίδεψε τη λιγότερη απόσταση;\nΈχει σημασία με ποια σειρά χρησιμοποιήσατε την filter() και την arrange() εάν χρησιμοποιείτε και τις δύο; Γιατί/γιατί όχι? Σκεφτείτε τα αποτελέσματα και πόση δουλειά θα πρέπει να κάνουν αυτές οι συναρτήσεις.",
    "crumbs": [
      "Η ολοκληρωμένη εικόνα",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Μετασχηματισμός Δεδομένων</span>"
    ]
  },
  {
    "objectID": "data-transform.html#στήλες",
    "href": "data-transform.html#στήλες",
    "title": "3  Μετασχηματισμός Δεδομένων",
    "section": "\n3.3 Στήλες",
    "text": "3.3 Στήλες\nΥπάρχουν τέσσερις σημαντικές συναρτήσεις που επηρεάζουν τις στήλες χωρίς να αλλάζουν τις γραμμές: η mutate() δημιουργεί νέες στήλες που προέρχονται από τις ήδη υπάρχουσες στήλες, η select() που αλλάζει τις στήλες που είναι παρούσες, η rename() που αλλάζει τα ονόματα των στηλών και η relocate() που αλλάζει τις θέσεις των στηλών.\n\n3.3.1 mutate()\n\nΗ δουλειά της mutate() είναι να προσθέτει νέες στήλες που υπολογίζονται από τις υπάρχουσες. Στα κεφάλαια του μετασχηματισμού δεδομένων, θα μάθετε ένα μεγάλο σύνολο συναρτήσεων το οποίο μπορείτε να χρησιμοποιήσετε για να χειριστείτε διαφορετικούς τύπους μεταβλητών. Προς το παρόν, θα παραμείνουμε στη βασική άλγεβρα, η οποία μας επιτρέπει να υπολογίσουμε το κέρδος (gain), τον χρόνο που έχει περάσει στον αέρα μία καθυστερημένη πτήση, και την ταχύτητα (speed) σε μίλια ανά ώρα:\n\nflights |&gt; \n  mutate(\n    gain = dep_delay - arr_delay,\n    speed = distance / air_time * 60\n  )\n#&gt; # A tibble: 336,776 × 21\n#&gt;    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n#&gt;   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;\n#&gt; 1  2013     1     1      517            515         2      830            819\n#&gt; 2  2013     1     1      533            529         4      850            830\n#&gt; 3  2013     1     1      542            540         2      923            850\n#&gt; 4  2013     1     1      544            545        -1     1004           1022\n#&gt; 5  2013     1     1      554            600        -6      812            837\n#&gt; 6  2013     1     1      554            558        -4      740            728\n#&gt; # ℹ 336,770 more rows\n#&gt; # ℹ 13 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;, …\n\nΑπό προεπιλογή, η mutate() προσθέτει νέες στήλες στη δεξιά πλευρά του συνόλου δεδομένων σας, γεγονός που καθιστά δύσκολο να δείτε τι έχει συμβεί. Γι’ αυτό μπορούμε να χρησιμοποιήσουμε το όρισμα .before για να προσθέσουμε τις μεταβλητές στην αριστερή πλευρά2:\n\nflights |&gt; \n  mutate(\n    gain = dep_delay - arr_delay,\n    speed = distance / air_time * 60,\n    .before = 1\n  )\n#&gt; # A tibble: 336,776 × 21\n#&gt;    gain speed  year month   day dep_time sched_dep_time dep_delay arr_time\n#&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;\n#&gt; 1    -9  370.  2013     1     1      517            515         2      830\n#&gt; 2   -16  374.  2013     1     1      533            529         4      850\n#&gt; 3   -31  408.  2013     1     1      542            540         2      923\n#&gt; 4    17  517.  2013     1     1      544            545        -1     1004\n#&gt; 5    19  394.  2013     1     1      554            600        -6      812\n#&gt; 6   -16  288.  2013     1     1      554            558        -4      740\n#&gt; # ℹ 336,770 more rows\n#&gt; # ℹ 12 more variables: sched_arr_time &lt;int&gt;, arr_delay &lt;dbl&gt;, …\n\nΤο . υποδεικνύει ότι το .before είναι ένα όρισμα στη συνάρτηση, και όχι το όνομα μιας τρίτης νέας μεταβλητής που θα δημιουργήσουμε. Μπορείτε επίσης να χρησιμοποιήσετε το όρισμα .after για να προσθέσετε τη νέα στήλη μετά από μία συγκεκριμένη μεταβλητή, ενώ τόσο στο όρισμα .before όσο και στο .after μπορείτε να χρησιμοποιήσετε το όνομα της μεταβλητής αντί για τη θέση της. Για παράδειγμα, θα μπορούσαμε να προσθέσουμε τις νέες μεταβλητές μετά την day:\n\nflights |&gt; \n  mutate(\n    gain = dep_delay - arr_delay,\n    speed = distance / air_time * 60,\n    .after = day\n  )\n\nΕναλλακτικά, μπορείτε να ελέγξετε ποιες μεταβλητές θα διατηρηθούν με το όρισμα .keep. Ένα ιδιαίτερα χρήσιμο όρισμα είναι το \"used\" που προσδιορίζει ότι θέλουμε να διατηρήσουμε μόνο τις στήλες που εμπλέκονται ή δημιουργήθηκαν στο βήμα της mutate(). Για παράδειγμα, η ακόλουθη έξοδος θα περιέχει μόνο τις μεταβλητές dep_delay, arr_delay, air_time, gain, hours, και gain_per_hour.\n\nflights |&gt; \n  mutate(\n    gain = dep_delay - arr_delay,\n    hours = air_time / 60,\n    gain_per_hour = gain / hours,\n    .keep = \"used\"\n  )\n\nΈχετε υπόψη ότι επειδή δεν έχουμε αναθέσει το αποτέλεσμα του παραπάνω υπολογισμού πίσω στις flights, οι νέες μεταβλητές gain, hours, και gain_per_hour θα τυπωθούν αλλά δεν θα αποθηκευτούν σε ένα πλαίσιο δεδομένων. Εάν θέλουμε να είναι διαθέσιμα σε ένα πλαίσιο δεδομένων για μελλοντική χρήση, θα πρέπει να σκεφτούμε προσεκτικά εάν θέλουμε το αποτέλεσμα να ανατεθεί ξανά στο flights, αντικαθιστώντας το αρχικό πλαίσιο δεδομένων με πολλές περισσότερες μεταβλητές ή σε ένα νέο αντικείμενο . Συχνά, η σωστή απάντηση είναι ένα νέο αντικείμενο που ονομάζεται με τρόπο που υποδεικνύει το περιεχόμενό του, π.χ. delay_gain, αλλά μπορεί επίσης να έχετε καλούς λόγους για την αντικατάσταση του flights.\n\n3.3.2 select()\n\nΔεν είναι ασυνήθιστο να λαμβάνετε σύνολα δεδομένων με εκατοντάδες ή και χιλιάδες μεταβλητές. Σε αυτήν την περίπτωση, η πρώτη πρόκληση είναι συχνά απλώς να εστιάσετε στις μεταβλητές που σας ενδιαφέρουν. Η select() επιτρέπει να εστιάζεται γρήγορα σε ένα χρήσιμο υποσύνολο χρησιμοποιώντας λειτουργίες που βασίζονται στα ονόματα των μεταβλητών:\n\n\nΕπιλογή στηλών με το όνομα τους:\n\nflights |&gt; \n  select(year, month, day)\n\n\n\nΕπιλογή όλων των στηλών που βρίσκονται ανάμεσα στις στήλες year και day (συμπερίληψη):\n\nflights |&gt; \n  select(year:day)\n\n\n\nΕπιλογή όλων των μεταβλητών εκτός αυτών που βρίσκονται ανάμεσα στις στήλες year και day (αποκλεισμός):\n\nflights |&gt; \n  select(!year:day)\n\nΙστορικά, αυτή η εργασία γινόταν με το - αντί για το !, οπότε είναι πιθανό να το συναντήσετε εκεί έξω. Αυτοί οι δύο χειριστές υπηρετούν τον ίδιο σκοπό, με μικρές διαφορές ως προς τη συμπεριφορά τους. Συνιστούμε να χρησιμοποιείτε το ! μιας και διαβάζεται ως “όχι”, και συνδυάζεται καλά με τα & και |.\n\n\nΕπιλέξτε όλες τις στήλες που είναι χαρακτήρες:\n\nflights |&gt; \n  select(where(is.character))\n\n\n\nΥπάρχει ένας αριθμός βοηθητικών συναρτήσεων που μπορείτε να χρησιμοποιήσετε μέσα στη select():\n\n\nstarts_with(\"abc\"): επιλέγει στήλες των οποίων τα ονόματα ξεκινούν με “abc”.\n\nends_with(\"xyz\"): επιλέγει στήλες των οποίων τα ονόματα τελειώνουν σε “xyz”.\n\ncontains(\"ijk\"): επιλέγει στήλες των οποίων τα ονόματα περιέχουν το “ijk”.\n\nNum_range(\"x\", 1:3): επιλέγει τις στήλες x1, x2 και x3.\n\nΔείτε την εντολή ?select για περισσότερες λεπτομέρειες. Μόλις μάθετε για τις κανονικές εκφράσεις (το αντικείμενο στο Κεφάλαιο 15), θα μπορείτε επίσης να χρησιμοποιήσετε την matches() για να επιλέξετε μεταβλητές που ταιριάζουν σε ένα μοτίβο.\nΜπορείτε να μετονομάσετε τις μεταβλητές καθώς τις επιλέγετε με την select() χρησιμοποιώντας το =. Το νέο όνομα εμφανίζεται στην αριστερή πλευρά του = και η παλιά μεταβλητή στη δεξιά πλευρά:\n\nflights |&gt; \n  select(tail_num = tailnum)\n#&gt; # A tibble: 336,776 × 1\n#&gt;   tail_num\n#&gt;   &lt;chr&gt;   \n#&gt; 1 N14228  \n#&gt; 2 N24211  \n#&gt; 3 N619AA  \n#&gt; 4 N804JB  \n#&gt; 5 N668DN  \n#&gt; 6 N39463  \n#&gt; # ℹ 336,770 more rows\n\n\n3.3.3 rename()\n\nΕάν θέλετε να διατηρήσετε όλες τις υπάρχουσες μεταβλητές και απλώς να μετονομάσετε μερικές, μπορείτε να χρησιμοποιήσετε την rename() αντί για την select():\n\nflights |&gt; \n  rename(tail_num = tailnum)\n#&gt; # A tibble: 336,776 × 19\n#&gt;    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n#&gt;   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;\n#&gt; 1  2013     1     1      517            515         2      830            819\n#&gt; 2  2013     1     1      533            529         4      850            830\n#&gt; 3  2013     1     1      542            540         2      923            850\n#&gt; 4  2013     1     1      544            545        -1     1004           1022\n#&gt; 5  2013     1     1      554            600        -6      812            837\n#&gt; 6  2013     1     1      554            558        -4      740            728\n#&gt; # ℹ 336,770 more rows\n#&gt; # ℹ 11 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;, …\n\nΕάν έχετε ένα σωρό στήλες με ασυνεπή ονόματα, τις οποίες θα ήταν επώδυνο να διορθώσετε όλες με το χέρι, ανατρέξτε στην janitor::clean_names() η οποία παρέχει χρήσιμες δυνατότητες αυτοματοποιημένου καθαρισμού των δεδομένων.\n\n3.3.4 relocate()\n\nΧρησιμοποιήστε την relocate() για να αλλάξετε θέση στις μεταβλητές. Μπορεί να θέλετε να συλλέξετε σχετικές μεταβλητές μαζί ή να μετακινήσετε σημαντικές μεταβλητές στο μπροστινό μέρος. Ως προεπιλογή η relocate() μετακινεί τις μεταβλητές στην αρχή του πλαισίου δεδομένων:\n\nflights |&gt; \n  relocate(time_hour, air_time)\n#&gt; # A tibble: 336,776 × 19\n#&gt;   time_hour           air_time  year month   day dep_time sched_dep_time\n#&gt;   &lt;dttm&gt;                 &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;\n#&gt; 1 2013-01-01 05:00:00      227  2013     1     1      517            515\n#&gt; 2 2013-01-01 05:00:00      227  2013     1     1      533            529\n#&gt; 3 2013-01-01 05:00:00      160  2013     1     1      542            540\n#&gt; 4 2013-01-01 05:00:00      183  2013     1     1      544            545\n#&gt; 5 2013-01-01 06:00:00      116  2013     1     1      554            600\n#&gt; 6 2013-01-01 05:00:00      150  2013     1     1      554            558\n#&gt; # ℹ 336,770 more rows\n#&gt; # ℹ 12 more variables: dep_delay &lt;dbl&gt;, arr_time &lt;int&gt;, …\n\nΜπορείτε επίσης να καθορίσετε το πού θα τοποθετήσετε τις στήλες χρησιμοποιώντας τα ορίσματα .before και .after, όπως ακριβώς στην mutate():\n\nflights |&gt; \n  relocate(year:dep_time, .after = time_hour)\nflights |&gt; \n  relocate(starts_with(\"arr\"), .before = dep_time)\n\n\n3.3.5 Ασκήσεις\n\nΣυγκρίνετε τις μεταβλητές dep_time, sched_dep_time, και dep_delay. Πώς θα περιμένατε να σχετίζονται αυτοί οι τρεις αριθμοί;\nΒρείτε όσο το δυνατόν περισσότερους τρόπους για να επιλέξετε τις μεταβλητές dep_time, dep_delay, arr_time, και arr_delay από το flights\nΤι συμβαίνει εάν καθορίσετε το όνομα της ίδιας μεταβλητής πολλές φορές σε μία κλήση της select();\n\nΤι κάνει η συνάρτηση any_of(); Γιατί μπορεί να είναι χρήσιμη σε συνδυασμό με το παρακάτω διάνυσμα;\n\nvariables &lt;- c(\"year\", \"month\", \"day\", \"dep_delay\", \"arr_delay\")\n\n\n\nΣας εκπλήσσει το αποτέλεσμα της εκτέλεσης του παρακάτω κώδικα; Πώς αντιμετωπίζουν τα κεφαλαία και τα πεζά από προεπιλογή οι βοηθητικές συναρτήσεις της select(); Πώς μπορείτε να αλλάξετε αυτήν την προεπιλογή;\n\nflights |&gt; select(contains(\"TIME\"))\n\n\nΜετονομάστε την air_time σε air_time_min για να υποδείξετε τις μονάδες μέτρησης και μετακινήστε την στην αρχή του πλαισίου δεδομένων.\n\nΓιατί δεν λειτουργεί ο παρακάτω κώδικας και τι σημαίνει το σφάλμα;\n\nflights |&gt; \n  select(tailnum) |&gt; \n  arrange(arr_delay)\n#&gt; Error in `arrange()`:\n#&gt; ℹ In argument: `..1 = arr_delay`.\n#&gt; Caused by error:\n#&gt; ! object 'arr_delay' not found",
    "crumbs": [
      "Η ολοκληρωμένη εικόνα",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Μετασχηματισμός Δεδομένων</span>"
    ]
  },
  {
    "objectID": "data-transform.html#sec-the-pipe",
    "href": "data-transform.html#sec-the-pipe",
    "title": "3  Μετασχηματισμός Δεδομένων",
    "section": "\n3.4 Το pipe",
    "text": "3.4 Το pipe\nΠαραπάνω σας δείξαμε απλά παραδείγματα του pipe, αλλά η πραγματική του δύναμη προκύπτει όταν αρχίσετε να συνδυάζετε πολλές συναρτήσεις μαζί. Για παράδειγμα, φανταστείτε ότι θέλετε να βρείτε τις πιο γρήγορες πτήσεις προς το αεροδρόμιο IAH του Χιούστον: πρέπει να συνδυάσετε τις filter(), mutate(), select(), και arrange():\n\nflights |&gt; \n  filter(dest == \"IAH\") |&gt; \n  mutate(speed = distance / air_time * 60) |&gt; \n  select(year:day, dep_time, carrier, flight, speed) |&gt; \n  arrange(desc(speed))\n#&gt; # A tibble: 7,198 × 7\n#&gt;    year month   day dep_time carrier flight speed\n#&gt;   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt; &lt;chr&gt;    &lt;int&gt; &lt;dbl&gt;\n#&gt; 1  2013     7     9      707 UA         226  522.\n#&gt; 2  2013     8    27     1850 UA        1128  521.\n#&gt; 3  2013     8    28      902 UA        1711  519.\n#&gt; 4  2013     8    28     2122 UA        1022  519.\n#&gt; 5  2013     6    11     1628 UA        1178  515.\n#&gt; 6  2013     8    27     1017 UA         333  515.\n#&gt; # ℹ 7,192 more rows\n\nΠαρόλο που αυτή η ροή έχει τέσσερα βήματα, είναι εύκολο να την διαβάσετε γρήγορα, μιας και οι συναρτήσεις εμφανίζονται στην αρχή κάθε γραμμής: ξεκινήστε με τα δεδομένα του flights, μετά φιλτράρετε, μετά δημιουργείστε, μετά επιλέξτε και μετά διατάξτε τα δεδομένα.\nΤι θα γινόταν αν δεν είχαμε το pipe; Θα μπορούσαμε να ενσωματώσουμε κάθε κλήση συνάρτησης μέσα στην προηγούμενη κλήση:\n\narrange(\n  select(\n    mutate(\n      filter(\n        flights, \n        dest == \"IAH\"\n      ),\n      speed = distance / air_time * 60\n    ),\n    year:day, dep_time, carrier, flight, speed\n  ),\n  desc(speed)\n)\n\nΉ θα μπορούσαμε να δημιουργήσουμε ένα σωρό ενδιάμεσα αντικείμενα:\n\nflights1 &lt;- filter(flights, dest == \"IAH\")\nflights2 &lt;- mutate(flights1, speed = distance / air_time * 60)\nflights3 &lt;- select(flights2, year:day, dep_time, carrier, flight, speed)\narrange(flights3, desc(speed))\n\nΕνώ και οι δύο επιλογές έχουν τον χρόνο και τον τόπο τους, το pipe γενικά παράγει κώδικα ανάλυσης δεδομένων που είναι ευκολότερο να γραφτεί και να διαβαστεί.\nΓια να προσθέσετε το pipe στον κώδικά σας, συνιστούμε να χρησιμοποιήσετε την ενσωματωμένη συντόμευση πληκτρολογίου Ctrl/Cmd + Shift + M. Θα χρειαστεί να κάνετε μία αλλαγή στις επιλογές του RStudio για να χρησιμοποιήσετε το |&gt; αντί για το %&gt;% όπως φαίνεται στο Σχήμα 3.1, ενώ θα δούμε περισσότερα για το %&gt;% σύντομα.\n\n\n\n\n\n\n\nΣχήμα 3.1: Για να εισάγετε το |&gt;, βεβαιωθείτε ότι η επιλογή “Use native pipe operator” είναι ενεργοποιημένη.\n\n\n\n\n\n\n\n\n\n\nmagrittr\n\n\n\nΕάν χρησιμοποιείτε το tidyverse για κάποιο καιρό, ίσως να είστε εξοικειωμένοι με το %&gt;% που παρέχεται από το πακέτο magrittr. Το πακέτο magrittr περιλαμβάνεται στο tidyverse, ώστε να μπορείτε να χρησιμοποιείτε το %&gt;% κάθε φορά που φορτώνετε το tidyverse:\n\nlibrary(tidyverse)\n\nmtcars %&gt;% \n  group_by(cyl) %&gt;%\n  summarize(n = n())\n\nΓια απλές περιπτώσεις, τα |&gt; και %&gt;% συμπεριφέρονται πανομοιότυπα. Γιατί λοιπόν προτείνουμε τον βασικό pipe; Πρώτον, επειδή είναι μέρος του βασικού συνόλου συναρτήσεων της R, είναι πάντα διαθέσιμο για χρήση, ακόμα και όταν δεν χρησιμοποιείτε το tidyverse. Δεύτερον, το |&gt; είναι αρκετά πιο απλό από το %&gt;%: στο διάστημα μεταξύ της εφεύρεσης του %&gt;% το 2014 και της συμπερίληψης του |&gt; στην έκδοση 4.1.0 της R το 2021, κερδίσαμε μία καλύτερη κατανόηση του pipe. Αυτό επέτρεψε στην βασική εφαρμογή (|&gt;) να απορρίψει σπάνια χρησιμοποιούμενα και λιγότερο σημαντικά χαρακτηριστικά.",
    "crumbs": [
      "Η ολοκληρωμένη εικόνα",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Μετασχηματισμός Δεδομένων</span>"
    ]
  },
  {
    "objectID": "data-transform.html#ομάδες",
    "href": "data-transform.html#ομάδες",
    "title": "3  Μετασχηματισμός Δεδομένων",
    "section": "\n3.5 Ομάδες",
    "text": "3.5 Ομάδες\nΜέχρι στιγμής έχετε μάθει για συναρτήσεις που λειτουργούν σε γραμμές και στήλες. Η dplyr γίνεται ακόμα πιο ισχυρή όταν προσθέτετε τη δυνατότητα εργασίας με ομάδες. Σε αυτήν την ενότητα, θα επικεντρωθούμε στις πιο σημαντικές συναρτήσεις: group_by(), summarize(), και την οικογένεια συναρτήσεων slice.\n\n3.5.1 group_by()\n\nΧρησιμοποιήστε την group_by() για να διαιρέσετε το σύνολο δεδομένων σας σε ομάδες που βγάζουν νόημα για την ανάλυσή σας.\n\nflights |&gt; \n  group_by(month)\n#&gt; # A tibble: 336,776 × 19\n#&gt; # Groups:   month [12]\n#&gt;    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n#&gt;   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;\n#&gt; 1  2013     1     1      517            515         2      830            819\n#&gt; 2  2013     1     1      533            529         4      850            830\n#&gt; 3  2013     1     1      542            540         2      923            850\n#&gt; 4  2013     1     1      544            545        -1     1004           1022\n#&gt; 5  2013     1     1      554            600        -6      812            837\n#&gt; 6  2013     1     1      554            558        -4      740            728\n#&gt; # ℹ 336,770 more rows\n#&gt; # ℹ 11 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;, …\n\nΗ group_by() δεν αλλάζει τα δεδομένα, αλλά, αν κοιτάξετε προσεκτικά την έξοδο, θα παρατηρήσετε ότι η έξοδος υποδεικνύει ότι είναι “ομαδοποιημένη με βάση” το μήνα (Groups: month [12]). Αυτό σημαίνει ότι οι επόμενες συναρτήσεις θα εφαρμόζονται πλέον “ανά μήνα”. Η group_by() προσθέτει αυτό το ομαδοποιημένο χαρακτηριστικό (που αναφέρεται ως κλάση) στο πλαίσιο δεδομένων, το οποίο αλλάζει τη συμπεριφορά των επόμενων συναρτήσεων που εφαρμόζονται στα δεδομένα.\n\n3.5.2 summarize()\n\nΗ πιο σημαντική ομαδοποιημένη λειτουργία είναι μία σύνοψη, η οποία, εάν χρησιμοποιηθεί για τον υπολογισμό ενός μόνο συνοπτικού στατιστικού, μειώνει το πλαίσιο δεδομένων ώστε να έχει μία μόνο γραμμή για κάθε ομάδα. Στο πακέτο dplyr, αυτή η λειτουργία εκτελείται από την summarize()3, όπως φαίνεται στο ακόλουθο παράδειγμα, το οποίο υπολογίζει τη μέση καθυστέρηση αναχώρησης ανά μήνα:\n\nflights |&gt; \n  group_by(month) |&gt; \n  summarize(\n    avg_delay = mean(dep_delay)\n  )\n#&gt; # A tibble: 12 × 2\n#&gt;   month avg_delay\n#&gt;   &lt;int&gt;     &lt;dbl&gt;\n#&gt; 1     1        NA\n#&gt; 2     2        NA\n#&gt; 3     3        NA\n#&gt; 4     4        NA\n#&gt; 5     5        NA\n#&gt; 6     6        NA\n#&gt; # ℹ 6 more rows\n\nΩχ! Κάτι πήγε στραβά και όλα τα αποτελέσματά μας είναι NA (προφέρεται “N-A”), το σύμβολο R για τις ελλιπής τιμές. Αυτό συνέβη επειδή ορισμένες από τις παρατηρούμενες πτήσεις είχαν κενές τιμές στη στήλη delay, και έτσι, όταν υπολογίσαμε τη μέση τιμή, συμπεριλαμβανομένων αυτών των τιμών, πήραμε ένα αποτέλεσμα NA. Θα επανέλθουμε για να συζητήσουμε λεπτομερώς τις κενές τιμές στο Κεφάλαιο 18, αλλά προς το παρόν θα πούμε στη συνάρτηση mean() να αγνοήσει όλες τις κενές τιμές θέτοντας το όρισμα na.rm ως TRUE:\n\nflights |&gt; \n  group_by(month) |&gt; \n  summarize(\n    avg_delay = mean(dep_delay, na.rm = TRUE)\n  )\n#&gt; # A tibble: 12 × 2\n#&gt;   month avg_delay\n#&gt;   &lt;int&gt;     &lt;dbl&gt;\n#&gt; 1     1      10.0\n#&gt; 2     2      10.8\n#&gt; 3     3      13.2\n#&gt; 4     4      13.9\n#&gt; 5     5      13.0\n#&gt; 6     6      20.8\n#&gt; # ℹ 6 more rows\n\nΜπορείτε να δημιουργήσετε οποιονδήποτε αριθμό συνόψεων σε μία μόνο κλήση τις summarize(). Θα μάθετε διάφορες χρήσιμες συνόψεις στα επόμενα κεφάλαια, αλλά μία πολύ χρήσιμη περίληψη είναι η n(), η οποία επιστρέφει τον αριθμό των γραμμών σε κάθε ομάδα:\n\nflights |&gt; \n  group_by(month) |&gt; \n  summarize(\n    avg_delay = mean(dep_delay, na.rm = TRUE), \n    n = n()\n  )\n#&gt; # A tibble: 12 × 3\n#&gt;   month avg_delay     n\n#&gt;   &lt;int&gt;     &lt;dbl&gt; &lt;int&gt;\n#&gt; 1     1      10.0 27004\n#&gt; 2     2      10.8 24951\n#&gt; 3     3      13.2 28834\n#&gt; 4     4      13.9 28330\n#&gt; 5     5      13.0 28796\n#&gt; 6     6      20.8 28243\n#&gt; # ℹ 6 more rows\n\nΟι μέσες τιμές και οι μετρήσεις μπορούν να σας βοηθήσουν να πάτε αρκετά μακρυά στην επιστήμη των δεδομένων!\n\n3.5.3 Οι συναρτήσεις της οικογένειας slice_\n\nΥπάρχουν πέντε χρήσιμες συναρτήσεις που σας επιτρέπουν να εξάγετε συγκεκριμένες γραμμές μέσα σε κάθε ομάδα:\n\nΤο df |&gt; slice_head(n = 1) παίρνει την πρώτη γραμμή από κάθε ομάδα.\nΤο df |&gt; slice_tail(n = 1) παίρνει την τελευταία γραμμή σε κάθε ομάδα.\nΤο df |&gt; slice_min(x, n = 1) παίρνει τη γραμμή με τη μικρότερη τιμή στη στήλη x.\nΤο df |&gt; slice_max(x, n = 1) παίρνει τη σειρά με τη μεγαλύτερη τιμή στη στήλη x.\nΤο df |&gt; slice_sample(n = 1) παίρνει μία τυχαία γραμμή\n\nΜπορείτε να αλλάξετε το n για να επιλέξετε περισσότερες από μία γραμμές ή αντί για το n =, ενώ μπορείτε να χρησιμοποιήσετε το prop = 0.1 για να επιλέξετε (π.χ.) το 10% των γραμμών σε κάθε ομάδα. Για παράδειγμα, ο παρακάτω κώδικας βρίσκει τις πτήσεις που καθυστερούν περισσότερο κατά την άφιξη τους σε κάθε προορισμό:\n\nflights |&gt; \n  group_by(dest) |&gt; \n  slice_max(arr_delay, n = 1) |&gt;\n  relocate(dest)\n#&gt; # A tibble: 108 × 19\n#&gt; # Groups:   dest [105]\n#&gt;   dest   year month   day dep_time sched_dep_time dep_delay arr_time\n#&gt;   &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;\n#&gt; 1 ABQ    2013     7    22     2145           2007        98      132\n#&gt; 2 ACK    2013     7    23     1139            800       219     1250\n#&gt; 3 ALB    2013     1    25      123           2000       323      229\n#&gt; 4 ANC    2013     8    17     1740           1625        75     2042\n#&gt; 5 ATL    2013     7    22     2257            759       898      121\n#&gt; 6 AUS    2013     7    10     2056           1505       351     2347\n#&gt; # ℹ 102 more rows\n#&gt; # ℹ 11 more variables: sched_arr_time &lt;int&gt;, arr_delay &lt;dbl&gt;, …\n\nΣημειώστε ότι υπάρχουν 105 προορισμοί, αλλά εδώ έχουμε 108 γραμμές. Τι συμβαίνει λοιπόν; Η slice_min() και η slice_max() διατηρούν ισοδύναμες τιμές, επομένως το n = 1 σημαίνει “δώσε όλες τις γραμμές με την υψηλότερη τιμή”. Εάν θέλετε ακριβώς μία γραμμή ανά ομάδα, μπορείτε να ορίσετε with_ties = FALSE.\nΑυτό είναι παρόμοιο με τον υπολογισμό της μέγιστης καθυστέρησης με τη summarize(), αλλά λαμβάνετε ολόκληρη την αντίστοιχη γραμμή (ή τις γραμμές εάν υπάρχει ισοπαλία) αντί για το μεμονωμένο συνοπτικό στατιστικό.\n\n3.5.4 Ομαδοποίηση κατά πολλαπλές μεταβλητές\nΜπορείτε να δημιουργήσετε ομάδες χρησιμοποιώντας περισσότερες από μία μεταβλητές. Για παράδειγμα, θα μπορούσαμε να φτιάξουμε μία ομάδα για κάθε ημερομηνία.\n\ndaily &lt;- flights |&gt;  \n  group_by(year, month, day)\ndaily\n#&gt; # A tibble: 336,776 × 19\n#&gt; # Groups:   year, month, day [365]\n#&gt;    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n#&gt;   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;\n#&gt; 1  2013     1     1      517            515         2      830            819\n#&gt; 2  2013     1     1      533            529         4      850            830\n#&gt; 3  2013     1     1      542            540         2      923            850\n#&gt; 4  2013     1     1      544            545        -1     1004           1022\n#&gt; 5  2013     1     1      554            600        -6      812            837\n#&gt; 6  2013     1     1      554            558        -4      740            728\n#&gt; # ℹ 336,770 more rows\n#&gt; # ℹ 11 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;, …\n\nΌταν συνοψίζετε ένα tibble ομαδοποιημένο με περισσότερες από μία μεταβλητές, κάθε σύνοψη αφαιρεί την τελευταία ομάδα. Εκ των υστέρων, αυτός δεν ήταν ένας εξαιρετικός τρόπος για να λειτουργήσει αυτή η συνάρτηση, αλλά είναι δύσκολο να αλλάξει χωρίς να σπάσει τον υπάρχοντα κώδικα. Για να είναι προφανές τι συμβαίνει, το πακέτο dplyr εμφανίζει ένα μήνυμα που σας λέει πώς μπορείτε να αλλάξετε αυτήν τη συμπεριφορά:\n\ndaily_flights &lt;- daily |&gt; \n  summarize(n = n())\n#&gt; `summarise()` has grouped output by 'year', 'month'. You can override using\n#&gt; the `.groups` argument.\n\nΕάν είστε ευχαριστημένοι με αυτήν τη συμπεριφορά, μπορείτε να το ζητήσετε ρητά για να αποκρυφθεί αυτό το μήνυμα:\n\ndaily_flights &lt;- daily |&gt; \n  summarize(\n    n = n(), \n    .groups = \"drop_last\"\n  )\n\nΕναλλακτικά, αλλάξτε την προεπιλεγμένη συμπεριφορά ορίζοντας μία διαφορετική τιμή, π.χ. \"drop\" για απόρριψη όλων των ομάδων ή \"keep\"για διατήρηση των ίδιων ομάδων.\n\n3.5.5 Κατάργηση της ομαδοποίησης\nΜπορεί επίσης να θέλετε να καταργήσετε την ομαδοποίηση από ένα πλαίσιο δεδομένων χωρίς τη χρήση της summarize(). Αυτό μπορείτε να το κάνετε με την ungroup().\n\ndaily |&gt; \n  ungroup()\n#&gt; # A tibble: 336,776 × 19\n#&gt;    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n#&gt;   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;\n#&gt; 1  2013     1     1      517            515         2      830            819\n#&gt; 2  2013     1     1      533            529         4      850            830\n#&gt; 3  2013     1     1      542            540         2      923            850\n#&gt; 4  2013     1     1      544            545        -1     1004           1022\n#&gt; 5  2013     1     1      554            600        -6      812            837\n#&gt; 6  2013     1     1      554            558        -4      740            728\n#&gt; # ℹ 336,770 more rows\n#&gt; # ℹ 11 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;, …\n\nΤώρα ας δούμε τι συμβαίνει όταν συνοψίζετε ένα μη ομαδοποιημένο πλαίσιο δεδομένων.\n\ndaily |&gt; \n  ungroup() |&gt;\n  summarize(\n    avg_delay = mean(dep_delay, na.rm = TRUE), \n    flights = n()\n  )\n#&gt; # A tibble: 1 × 2\n#&gt;   avg_delay flights\n#&gt;       &lt;dbl&gt;   &lt;int&gt;\n#&gt; 1      12.6  336776\n\nΣαν αποτέλεσμα παίρνετε μία μόνο γραμμή επειδή το πακέτο dplyr αντιμετωπίζει όλες τις γραμμές σε ένα μη ομαδοποιημένο πλαίσιο δεδομένων σαν να ανήκουν σε μία ομάδα.\n\n3.5.6 .by\n\nΗ dplyr 1.1.0 περιλαμβάνει ένα νέο, πειραματικό συντακτικό για την ομαδοποίηση ανά λειτουργία, το όρισμα .by. Οι group_by() και ungroup() δεν εξαφανίζονται, αλλά τώρα μπορείτε επίσης να χρησιμοποιήσετε το όρισμα .by για ομαδοποίηση μέσα σε μία λειτουργία:\n\nflights |&gt; \n  summarize(\n    delay = mean(dep_delay, na.rm = TRUE), \n    n = n(),\n    .by = month\n  )\n\nΉ εάν θέλετε να ομαδοποιήσετε κατά πολλές μεταβλητές:\n\nflights |&gt; \n  summarize(\n    delay = mean(dep_delay, na.rm = TRUE), \n    n = n(),\n    .by = c(origin, dest)\n  )\n\nΤο .by λειτουργεί με όλα τις συναρτήσεις και έχει το πλεονέκτημα ότι δεν χρειάζεται να χρησιμοποιήσετε το όρισμα .groups για να αποκρύψετε το μήνυμα ομαδοποίησης ή την ungroup() όταν τελειώσετε.\nΔεν επικεντρωθήκαμε σε αυτή τη σύνταξη σε αυτό το κεφάλαιο γιατί ήταν αρκετά νέα όταν γράφαμε το βιβλίο. Θέλαμε όμως να το αναφέρουμε γιατί πιστεύουμε ότι έχει προοπτικές και είναι πιθανό να είναι αρκετά δημοφιλές. Μπορείτε να μάθετε περισσότερα σχετικά με αυτό στο dplyr 1.1.0 blog post.\n\n3.5.7 Ασκήσεις\n\nΠοια αεροπορική εταιρεία έχει τις χειρότερες μέσες καθυστερήσεις; Πρόκληση: μπορείτε να ξεχωρίσετε τις επιπτώσεις των κακών αεροδρομίων έναντι των κακών αερομεταφορέων; Γιατί/γιατί όχι; (Υπόδειξη: σκεφτείτε το flights |&gt; group_by(carrier, dest) |&gt; summarize(n()))\nΒρείτε τις πτήσεις που καθυστερούν περισσότερο κατά την αναχώρηση από κάθε προορισμό.\nΠώς ποικίλλουν οι καθυστερήσεις κατά τη διάρκεια της ημέρας. Αποτυπώστε την απάντησή σας σε ένα διάγραμμα.\nΤι θα συμβεί αν δώσετε αρνητικές τιμές στο όρισμα n μέσα στη slice_min() και τις σχετικές συναρτήσεις;\nΕξηγήστε τι κάνει η count() όσον αφορά τις συναρτήσεις της dplyr που μόλις μάθατε. Τι κάνει το όρισμα sort στην count();\n\nΑς υποθέσουμε ότι έχουμε το ακόλουθο μικροσκοπικό πλαίσιο δεδομένων:\n\ndf &lt;- tibble(\n  x = 1:5,\n  y = c(\"a\", \"b\", \"a\", \"a\", \"b\"),\n  z = c(\"K\", \"K\", \"L\", \"L\", \"K\")\n)\n\n\n\nΓράψτε πώς πιστεύετε ότι θα μοιάζει η έξοδος, στη συνέχεια ελέγξτε αν η σκέψη σας ήταν σωστή και περιγράψτε τι κάνει η group_by().\n\ndf |&gt;\n  group_by(y)\n\n\n\nΓράψτε πώς πιστεύετε ότι θα μοιάζει η έξοδος, στη συνέχεια ελέγξτε αν η σκέψη σας ήταν σωστή και περιγράψτε τι κάνει η arrange(). Σχολιάστε επίσης πώς διαφέρει από τη group_by() στο μέρος (a);\n\ndf |&gt;\n  arrange(y)\n\n\n\nΓράψτε πώς πιστεύετε ότι θα μοιάζει η έξοδος, στη συνέχεια ελέγξτε αν η σκέψη σας ήταν σωστή και περιγράψτε τι κάνει η ακόλουθη ροή.\n\ndf |&gt;\n  group_by(y) |&gt;\n  summarize(mean_x = mean(x))\n\n\n\nΓράψτε πώς πιστεύετε ότι θα μοιάζει η έξοδος και, στη συνέχεια, ελέγξτε αν η σκέψη σας ήταν σωστή και περιγράψτε τι κάνει η ακόλουθη ροή. Στη συνέχεια, σχολιάστε τι λέει το μήνυμα.\n\ndf |&gt;\n  group_by(y, z) |&gt;\n  summarize(mean_x = mean(x))\n\n\n\nΓράψτε πώς πιστεύετε ότι θα μοιάζει η έξοδος και, στη συνέχεια, εελέγξτε αν η σκέψη σας ήταν σωστή και περιγράψτε τι κάνει η ακόλουθη ροή. Σε τι διαφέρει η έξοδος από αυτή του μέρους (d).\n\ndf |&gt;\n  group_by(y, z) |&gt;\n  summarize(mean_x = mean(x), .groups = \"drop\")\n\n\n\nΓράψτε πώς πιστεύετε ότι θα μοιάζουν τα αποτελέσματα, στη συνέχεια ελέγξτε αν η σκέψη σας ήταν σωστή και περιγράψτε τι κάνει κάθε ροή. Πώς διαφέρουν οι έξοδοι των δύο ροών;\n\ndf |&gt;\n  group_by(y, z) |&gt;\n  summarize(mean_x = mean(x))\n\ndf |&gt;\n  group_by(y, z) |&gt;\n  mutate(mean_x = mean(x))",
    "crumbs": [
      "Η ολοκληρωμένη εικόνα",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Μετασχηματισμός Δεδομένων</span>"
    ]
  },
  {
    "objectID": "data-transform.html#sec-sample-size",
    "href": "data-transform.html#sec-sample-size",
    "title": "3  Μετασχηματισμός Δεδομένων",
    "section": "\n3.6 Μελέτη περίπτωσης: συγκεντρωτικά στοιχεία και μέγεθος δείγματος",
    "text": "3.6 Μελέτη περίπτωσης: συγκεντρωτικά στοιχεία και μέγεθος δείγματος\nΚάθε φορά που κάνετε οποιαδήποτε σύνοψη, είναι πάντα καλή ιδέα να συμπεριλάβετε μία καταμέτρηση (n()). Με αυτόν τον τρόπο, μπορείτε να διασφαλίσετε ότι δεν βγάζετε συμπεράσματα με βάση πολύ μικρές ποσότητες δεδομένων. Θα το δείξουμε με δεδομένα σχετικά με το μπέιζμπολ από το πακέτο Lahman. Συγκεκριμένα, θα συγκρίνουμε το ποσοστό των φορών που ένας παίκτης δέχεται ένα χτύπημα (H) με τον αριθμό των φορών που προσπαθεί να επαναφέρει την μπάλα στο παιχνίδι (AB):\n\nbatters &lt;- Lahman::Batting |&gt; \n  group_by(playerID) |&gt; \n  summarize(\n    performance = sum(H, na.rm = TRUE) / sum(AB, na.rm = TRUE),\n    n = sum(AB, na.rm = TRUE)\n  )\nbatters\n#&gt; # A tibble: 20,469 × 3\n#&gt;   playerID  performance     n\n#&gt;   &lt;chr&gt;           &lt;dbl&gt; &lt;int&gt;\n#&gt; 1 aardsda01      0          4\n#&gt; 2 aaronha01      0.305  12364\n#&gt; 3 aaronto01      0.229    944\n#&gt; 4 aasedo01       0          5\n#&gt; 5 abadan01       0.0952    21\n#&gt; 6 abadfe01       0.111      9\n#&gt; # ℹ 20,463 more rows\n\nΌταν σχεδιάζουμε την ικανότητα του παίκτη του μπέιζμπολ (μετρούμενη με τον μέσο όρο των χτυπημάτων, βάσει της μεταβλητής performance) σε σχέση με τον αριθμό των ευκαιριών να χτυπήσει την μπάλα (μετρούμενη με το πλήθος των ευκαιριών, n), παρατηρείτε δύο μοτίβα:\n\nΗ διακύμανση στις τιμές της μεταβλητής performance είναι μεγαλύτερη μεταξύ των παικτών με λιγότερες ευκαιρίες. Το σχήμα αυτού του διαγράμματος είναι πολύ χαρακτηριστικό: κάθε φορά που σχεδιάζετε έναν μέσο όρο (ή άλλα συνοπτικά στατιστικά στοιχεία) έναντι του μεγέθους της ομάδας, θα παρατηρείται ότι η διακύμανση μειώνεται καθώς αυξάνεται το μέγεθος του δείγματος4.\nΥπάρχει μία θετική συσχέτιση μεταξύ της ικανότητας (performance) του παίκτη και των ευκαιριών να χτυπήσει την μπάλα (n), επειδή οι ομάδες θέλουν να δώσουν στους καλύτερους παίκτες τους τις περισσότερες ευκαιρίες για να χτυπήσουν την μπάλα.\n\n\nbatters |&gt; \n  filter(n &gt; 100) |&gt; \n  ggplot(aes(x = n, y = performance)) +\n  geom_point(alpha = 1 / 10) + \n  geom_smooth(se = FALSE)\n\n\n\n\n\n\n\nΣημειώστε το χρήσιμο μοτίβο για το συνδυασμό ggplot2 και dplyr. Απλώς πρέπει να θυμάστε να μεταβείτε από το |&gt;, για την επεξεργασία δεδομένων, στο + για την προσθήκη επιπέδων στο διάγραμμα σας.\nΟ τρόπος που θα διατάξετε τα δεδομένα είναι επίσης σημαντικός. Αν αφελώς ταξινομήσετε σύμφωνα με την dec(performance), τα άτομα με τους καλύτερους μέσους όρους είναι σαφώς αυτοί που προσπάθησαν να βάλουν την μπάλα στο παιχνίδι πολύ λίγες φορές και έτυχε να χτυπήσουν, και δεν είναι απαραίτητα οι πιο ικανοί παίκτες:\n\nbatters |&gt; \n  arrange(desc(performance))\n#&gt; # A tibble: 20,469 × 3\n#&gt;   playerID  performance     n\n#&gt;   &lt;chr&gt;           &lt;dbl&gt; &lt;int&gt;\n#&gt; 1 abramge01           1     1\n#&gt; 2 alberan01           1     1\n#&gt; 3 banisje01           1     1\n#&gt; 4 bartocl01           1     1\n#&gt; 5 bassdo01            1     1\n#&gt; 6 birasst01           1     2\n#&gt; # ℹ 20,463 more rows\n\nΜπορείτε να βρείτε μία καλή εξήγηση για αυτό το πρόβλημα και πώς να το ξεπεράσετε στα http://varianceexplained.org/r/empirical_bayes_baseball/ και https://www.evanmiller.org/how-not-to-sort-by-average-rating.html.",
    "crumbs": [
      "Η ολοκληρωμένη εικόνα",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Μετασχηματισμός Δεδομένων</span>"
    ]
  },
  {
    "objectID": "data-transform.html#σύνοψη",
    "href": "data-transform.html#σύνοψη",
    "title": "3  Μετασχηματισμός Δεδομένων",
    "section": "\n3.7 Σύνοψη",
    "text": "3.7 Σύνοψη\nΣε αυτό το κεφάλαιο, μάθατε τα εργαλεία που παρέχει το πακέτο dplyr για την εργασία μας με πλαίσια δεδομένων. Τα εργαλεία ομαδοποιούνται χονδρικά σε τρεις κατηγορίες: αυτά που χειρίζονται τις γραμμές (όπως οι filter() και arrange(), αυτά που χειρίζονται τις στήλες (όπως οι select() και mutate()) και αυτά που χειρίζονται ομάδες (όπως οι group_by() και summarize()). Σε αυτό το κεφάλαιο, έχουμε επικεντρωθεί στα εργαλεία “ολόκληρου πλαισίου δεδομένων”, αλλά δεν έχετε μάθει ακόμα πολλά για το τι μπορείτε να κάνετε με μεμονωμένες μεταβλητές. Θα επανέλθουμε σε αυτό στο μέρος Μετασχηματισμός του βιβλίου, όπου κάθε κεφάλαιο θα σας παρέχει εργαλεία για έναν συγκεκριμένο τύπο μεταβλητής.\nΣτο επόμενο κεφάλαιο, θα επιστρέψουμε στη ροή εργασιών για να συζητήσουμε τη σημασία του τρόπου γραφής κώδικα, διατηρώντας τον κώδικά σας καλά οργανωμένο, ώστε να είναι εύκολο για εσάς και τους άλλους να διαβάσουν και να κατανοήσουν τον κώδικά σας.",
    "crumbs": [
      "Η ολοκληρωμένη εικόνα",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Μετασχηματισμός Δεδομένων</span>"
    ]
  },
  {
    "objectID": "data-transform.html#footnotes",
    "href": "data-transform.html#footnotes",
    "title": "3  Μετασχηματισμός Δεδομένων",
    "section": "",
    "text": "Αργότερα, θα μάθετε για την οικογένεια slice_*() που σας επιτρέπει να επιλέγετε γραμμές με βάση τις θέσεις τους.↩︎\nΘυμηθείτε ότι στο RStudio, ο ευκολότερος τρόπος για να δείτε ένα σύνολο δεδομένων με πολλές στήλες είναι η εντολή View().↩︎\nΉ summarise(), εαν προτιμάτε βρετανικά αγγλικά.↩︎\n*βήχας* ο νόμος των μεγάλων αριθμών *βήχας*.↩︎",
    "crumbs": [
      "Η ολοκληρωμένη εικόνα",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Μετασχηματισμός Δεδομένων</span>"
    ]
  },
  {
    "objectID": "workflow-style.html",
    "href": "workflow-style.html",
    "title": "4  Ροή εργασιών: πρότυπα γραφής κώδικα",
    "section": "",
    "text": "4.1 Ονόματα\nΜιλήσαμε εν συντομία για ονόματα στην Ενότητα 2.3. Να θυμάστε ότι τα ονόματα μεταβλητών (αυτά που δημιουργούνται από το &lt;- και αυτά που δημιουργούνται από τη mutate()) θα πρέπει να χρησιμοποιούν μόνο πεζά γράμματα, αριθμούς και _. Μέσα σε ένα όνομα χρησιμοποιούμε το _ για να διαχωρίσουμε λέξεις μεταξύ τους.\n# Προσπαθήστε για:\nshort_flights &lt;- flights |&gt; filter(air_time &lt; 60)\n\n# Αποφύγετε:\nSHORTFLIGHTS &lt;- flights |&gt; filter(air_time &lt; 60)\nΩς γενικός εμπειρικός κανόνας, είναι καλύτερο να προτιμάτε μεγάλα, περιγραφικά ονόματα που είναι εύκολα κατανοητά παρά συνοπτικά ονόματα που είναι γρήγορα στην πληκτρολόγηση. Τα σύντομα ονόματα εξοικονομούν σχετικά λίγο χρόνο κατά τη σύνταξη κώδικα (ειδικά επειδή η αυτόματη συμπλήρωση θα σας βοηθήσει να ολοκληρώσετε την πληκτρολόγηση), αλλά μπορεί να είναι χρονοβόρο να αποκρυπτογραφήσετε τι εννοούσατε όταν επιστρέψετε σε παλιό κώδικα.\nΕάν έχετε ένα σωρό ονόματα για σχετικά πράγματα, προσπαθήστε να είστε συνεπείς. Είναι εύκολο να προκύψουν ασυνέπειες όταν ξεχνάτε έναν προηγούμενο κανόνα, οπότε μην αισθάνεστε άσχημα αν πρέπει να επιστρέψετε και να μετονομάσετε κάποια πράγματα. Γενικά, αν έχετε ένα σύνολο μεταβλητών που αποτελούν παραλλαγή ενός θέματος, είναι προτιμότερο να τους δώσετε ένα κοινό πρόθεμα αντί για ένα κοινό επίθημα, επειδή η αυτόματη συμπλήρωση λειτουργεί καλύτερα στην αρχή μιας μεταβλητής.",
    "crumbs": [
      "Η ολοκληρωμένη εικόνα",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Ροή εργασιών: πρότυπα γραφής κώδικα</span>"
    ]
  },
  {
    "objectID": "workflow-style.html#διαστήματα",
    "href": "workflow-style.html#διαστήματα",
    "title": "4  Ροή εργασιών: πρότυπα γραφής κώδικα",
    "section": "\n4.2 Διαστήματα",
    "text": "4.2 Διαστήματα\nΤοποθετήστε κενά σε κάθε πλευρά των μαθηματικών τελεστών εκτός από το ^ (δηλαδή στα +, -, ==, &lt;, …) και γύρω από τον τελεστή ανάθεσης (&lt;-).\n\n# Προσπαθήστε για:\nz &lt;- (a + b)^2 / d\n\n# Αποφύγετε:\nz&lt;-( a + b ) ^ 2/d\n\nΜην βάζετε κενά μέσα ή έξω από παρενθέσεις για κανονικές κλήσεις συναρτήσεων. Να βάζετε πάντα ένα κενό μετά το κόμμα, όπως και στα ελληνικά.\n\n# Προσπαθήστε για:\nmean(x, na.rm = TRUE)\n\n# Αποφύγετε:\nmean (x ,na.rm=TRUE)\n\nΕίναι εντάξει να προσθέσετε επιπλέον κενά εάν αυτό βελτιώνει τη διάταξη του κώδικα. Για παράδειγμα, εάν δημιουργείτε πολλές μεταβλητές στη mutate(), ίσως θέλετε να προσθέσετε κενά έτσι ώστε όλα τα = να ευθυγραμμιστούν.1 Αυτό διευκολύνει το γρήγορο διάβασμα του κώδικα.\n\nflights |&gt; \n  mutate(\n    speed      = distance / air_time,\n    dep_hour   = dep_time %/% 100,\n    dep_minute = dep_time %%  100\n  )",
    "crumbs": [
      "Η ολοκληρωμένη εικόνα",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Ροή εργασιών: πρότυπα γραφής κώδικα</span>"
    ]
  },
  {
    "objectID": "workflow-style.html#sec-pipes",
    "href": "workflow-style.html#sec-pipes",
    "title": "4  Ροή εργασιών: πρότυπα γραφής κώδικα",
    "section": "\n4.3 Pipes",
    "text": "4.3 Pipes\nΤο |&gt; θα πρέπει πάντα να έχει ένα κενό πριν από αυτό και θα πρέπει να είναι το τελευταίο πράγμα σε μία γραμμή. Αυτό διευκολύνει την προσθήκη νέων βημάτων, την αναδιάταξη των υπαρχόντων βημάτων, την τροποποίηση στοιχείων μέσα σε ένα βήμα και τη λήψη μιας προβολής 10.000 ποδιών, διαβάζοντας γρήγορα τις συναρτήσεις στην αριστερή πλευρά.\n\n# Προσπαθήστε για: \nflights |&gt;  \n  filter(!is.na(arr_delay), !is.na(tailnum)) |&gt; \n  count(dest)\n\n# Αποφύγετε:\nflights|&gt;filter(!is.na(arr_delay), !is.na(tailnum))|&gt;count(dest)\n\nΕάν η συνάρτηση στην οποία εισάγετε έχει ορίσματα με όνομα (όπως οι mutate() ή summarize(), βάλτε κάθε όρισμα σε μία νέα γραμμή. Εάν η συνάρτηση δεν έχει ορίσματα με όνομα (όπως οι select() ή filter()), κρατήστε τα πάντα σε μία γραμμή εκτός εάν δεν χωράνε, οπότε θα πρέπει να βάλετε κάθε όρισμα στη δική του γραμμή.\n\n# Προσπαθήστε για:\nflights |&gt;  \n  group_by(tailnum) |&gt; \n  summarize(\n    delay = mean(arr_delay, na.rm = TRUE),\n    n = n()\n  )\n\n# Αποφύγετε:\nflights |&gt;\n  group_by(\n    tailnum\n  ) |&gt; \n  summarize(delay = mean(arr_delay, na.rm = TRUE), n = n())\n\nΜετά το πρώτο βήμα της διαδικασίας, εισάγετε σε κάθε γραμμή μία εσοχή, προσθέτοντας δύο κενά. Το RStudio θα τοποθετήσει αυτόματα τα κενά για εσάς κατά την αλλαγή γραμμής μετά από ένα |&gt; . Εάν τοποθετείτε κάθε όρισμα στη δική του γραμμή, αυξήστε την εσοχή κατά δύο επιπλέον κενά. Βεβαιωθείτε ότι το ) βρίσκεται στη δική του γραμμή και δεν έχει εσοχές ώστε να ταιριάζει με την οριζόντια θέση του ονόματος της συνάρτησης.\n\n# Προσπαθήστε για: \nflights |&gt;  \n  group_by(tailnum) |&gt; \n  summarize(\n    delay = mean(arr_delay, na.rm = TRUE),\n    n = n()\n  )\n\n# Αποφύγετε:\nflights|&gt;\n  group_by(tailnum) |&gt; \n  summarize(\n             delay = mean(arr_delay, na.rm = TRUE), \n             n = n()\n           )\n\n# Αποφύγετε:\nflights|&gt;\n  group_by(tailnum) |&gt; \n  summarize(\n  delay = mean(arr_delay, na.rm = TRUE), \n  n = n()\n  )\n\nΕίναι εντάξει να αποφύγετε μερικούς από αυτούς τους κανόνες, εάν η διαδικασία που θέλετε να εκτελέσετε ταιριάζει εύκολα σε μία γραμμή. Ωστόσο, στη συλλογική μας εμπειρία, είναι σύνηθες τα μικρά αποσπάσματα κώδικα να μεγαλώνουν περισσότερο, επομένως συνήθως θα εξοικονομείτε χρόνο μακροπρόθεσμα ξεκινώντας με όλο τον κατακόρυφο χώρο που χρειάζεστε.\n\n# Αυτό χωράει καλά σε μια γραμμή\ndf |&gt; mutate(y = x + 1)\n\n# Αυτό, αν και καταλαμβάνει 4 φορές περισσότερες γραμμές, μελλοντικά, \n# επεκτείνεται πιο εύκολα σε περισσότερες μεταβλητές και περισσότερα βήματα\ndf |&gt; \n  mutate(\n    y = x + 1\n  )\n\nΤέλος, να είστε προσεκτικοί όταν γράφετε εκτεταμένους συνδυασμούς συναρτήσεων που συνδέονται με pipes, για παράδειγμα πάνω από 10-15 γραμμές. Προσπαθήστε να τις χωρίσετε σε μικρότερες δευτερεύουσες εργασίες, δίνοντας σε κάθε εργασία ένα ενημερωτικό όνομα. Τα ονόματα θα βοηθήσουν τον αναγνώστη να καταλάβει τι συμβαίνει και θα διευκολύνει τον έλεγχο του ότι τα ενδιάμεσα αποτελέσματα είναι τα αναμενόμενα. Είναι καλό να δίνετε σε κάτι ένα ενημερωτικό όνομα κάθε φορά που έχετε αυτή τη δυνατότητα, για παράδειγμα όταν αλλάζετε ριζικά τη δομή των δεδομένων, π.χ. μετά από την δημιουργία κάποιου συγκεντρωτικού πίνακα ή σύνοψης. Μην περιμένετε να το κάνετε σωστά την πρώτη φορά! Αυτό σημαίνει διάλυση μεγάλων ροών σε περίπτωση που υπάρχουν ενδιάμεσες καταστάσεις που μπορούν να λάβουν καλά ονόματα.",
    "crumbs": [
      "Η ολοκληρωμένη εικόνα",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Ροή εργασιών: πρότυπα γραφής κώδικα</span>"
    ]
  },
  {
    "objectID": "workflow-style.html#ggplot2",
    "href": "workflow-style.html#ggplot2",
    "title": "4  Ροή εργασιών: πρότυπα γραφής κώδικα",
    "section": "\n4.4 ggplot2",
    "text": "4.4 ggplot2\nΟι ίδιοι βασικοί κανόνες που ισχύουν για τις συναρτήσεις που συνδέονται με pipes ισχύουν και στην περίπτωση της ggplot2. Απλώς αντιμετωπίστε το + με τον ίδιο τρόπο όπως και το |&gt;.\n\nflights |&gt; \n  group_by(month) |&gt; \n  summarize(\n    delay = mean(arr_delay, na.rm = TRUE)\n  ) |&gt; \n  ggplot(aes(x = month, y = delay)) +\n  geom_point() + \n  geom_line()\n\nΚαι πάλι, εάν δεν μπορείτε να χωρέσετε όλα τα ορίσματα μιας συνάρτησης σε μία γραμμή, βάλτε κάθε όρισμα στη δική του γραμμή:\n\nflights |&gt; \n  group_by(dest) |&gt; \n  summarize(\n    distance = mean(distance),\n    speed = mean(distance / air_time, na.rm = TRUE)\n  ) |&gt; \n  ggplot(aes(x = distance, y = speed)) +\n  geom_smooth(\n    method = \"loess\",\n    span = 0.5,\n    se = FALSE, \n    color = \"white\", \n    linewidth = 4\n  ) +\n  geom_point()\n\nΠαρακολουθήστε τη μετάβαση από το |&gt; στο +. Μακάρι αυτή η μετάβαση να μην ήταν απαραίτητη, αλλά δυστυχώς, το πακέτο ggplot2 γράφτηκε πριν την εισαγωγή του pipe.",
    "crumbs": [
      "Η ολοκληρωμένη εικόνα",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Ροή εργασιών: πρότυπα γραφής κώδικα</span>"
    ]
  },
  {
    "objectID": "workflow-style.html#τμηματοποίηση-σχολίων",
    "href": "workflow-style.html#τμηματοποίηση-σχολίων",
    "title": "4  Ροή εργασιών: πρότυπα γραφής κώδικα",
    "section": "\n4.5 Τμηματοποίηση σχολίων",
    "text": "4.5 Τμηματοποίηση σχολίων\nΚαθώς τα αρχεία κώδικα σας μεγαλώνουν, μπορείτε να χρησιμοποιήσετε σχόλια τμηματοποίησης για να χωρίσετε το αρχείο σας σε διαχειρίσιμα κομμάτια:\n\n# Load data --------------------------------------\n\n# Plot data --------------------------------------\n\nΤο RStudio παρέχει μία συντόμευση για τη δημιουργία αυτών των κεφαλίδων (Cmd/Ctrl + Shift + R) και θα τις εμφανίσει στο αναπτυσσόμενο μενού πλοήγησης κώδικα στο κάτω αριστερό μέρος του προγράμματος επεξεργασίας, όπως φαίνεται στο Σχήμα 4.2.\n\n\n\n\n\n\n\nΣχήμα 4.2: Αφού προσθέσετε σχόλια για την εισαγωγή ενοτήτων στο αρχείο κώδικά σας, μπορείτε να πλοηγηθείτε εύκολα σε αυτές χρησιμοποιώντας το εργαλείο πλοήγησης στο κάτω αριστερό τμήμα του παραθύρου επεξεργασίας κώδικα.",
    "crumbs": [
      "Η ολοκληρωμένη εικόνα",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Ροή εργασιών: πρότυπα γραφής κώδικα</span>"
    ]
  },
  {
    "objectID": "workflow-style.html#ασκήσεις",
    "href": "workflow-style.html#ασκήσεις",
    "title": "4  Ροή εργασιών: πρότυπα γραφής κώδικα",
    "section": "\n4.6 Ασκήσεις",
    "text": "4.6 Ασκήσεις\n\n\nΠροσαρμόστε τις ακόλουθες ροές εργασιών, ακολουθώντας τις παραπάνω οδηγίες.\n\nflights|&gt;filter(dest==\"IAH\")|&gt;group_by(year,month,day)|&gt;summarize(n=n(),\ndelay=mean(arr_delay,na.rm=TRUE))|&gt;filter(n&gt;10)\n\nflights|&gt;filter(carrier==\"UA\",dest%in%c(\"IAH\",\"HOU\"),sched_dep_time&gt;\n0900,sched_arr_time&lt;2000)|&gt;group_by(flight)|&gt;summarize(delay=mean(\narr_delay,na.rm=TRUE),cancelled=sum(is.na(arr_delay)),n=n())|&gt;filter(n&gt;10)",
    "crumbs": [
      "Η ολοκληρωμένη εικόνα",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Ροή εργασιών: πρότυπα γραφής κώδικα</span>"
    ]
  },
  {
    "objectID": "workflow-style.html#σύνοψη",
    "href": "workflow-style.html#σύνοψη",
    "title": "4  Ροή εργασιών: πρότυπα γραφής κώδικα",
    "section": "\n4.7 Σύνοψη",
    "text": "4.7 Σύνοψη\nΣε αυτό το κεφάλαιο, έχετε μάθει τις πιο σημαντικές αρχές οργάνωσης του κώδικα σας. Αυτοί μπορεί να φαίνονται σαν ένα σύνολο αυθαίρετων κανόνων για αρχή (γιατί είναι!), αλλά με την πάροδο του χρόνου, καθώς γράφετε περισσότερο κώδικα και μοιράζεστε κώδικα με περισσότερα άτομα, θα δείτε πόσο σημαντικό είναι ένα σταθερό στυλ/τρόπος γραφής. Και μην ξεχνάτε το πακέτο styler: είναι ένας πολύ καλός τρόπος για να βελτιώσετε γρήγορα την ποιότητα κακοδομημένου κώδικα.\nΣτο επόμενο κεφάλαιο, επιστρέφουμε στα εργαλεία που χρησιμοποιούνται στην επιστήμη δεδομένων, μαθαίνοντας για τα τακτοποιημένα (tidy) δεδομένα. Τα τακτοποιημένα δεδομένα είναι ένας συνεπής τρόπος οργάνωσης των πλαισίων δεδομένων σας που χρησιμοποιείται στο tidyverse. Αυτή η συνέπεια κάνει τη ζωή σας πιο εύκολη, επειδή μόλις έχετε τακτοποιημένα δεδομένα, είναι συμβατά με τη συντριπτική πλειοψηφία των συναρτήσεων του tidyverse. Φυσικά, η ζωή δεν είναι ποτέ εύκολη και τα περισσότερα σύνολα δεδομένων που συναντάτε δεν θα είναι ήδη τακτοποιημένα. Έτσι, θα σας μάθουμε επίσης πώς να χρησιμοποιείτε το πακέτο tidyr για να τακτοποιείτε τα ακατάστατα δεδομένα σας.",
    "crumbs": [
      "Η ολοκληρωμένη εικόνα",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Ροή εργασιών: πρότυπα γραφής κώδικα</span>"
    ]
  },
  {
    "objectID": "workflow-style.html#footnotes",
    "href": "workflow-style.html#footnotes",
    "title": "4  Ροή εργασιών: πρότυπα γραφής κώδικα",
    "section": "",
    "text": "Μιας και η dep_time είναι σε μορφή HMM ή HHMM, χρησιμοποιούμε διαίρεση ακέραιων αριθμών (%/%) για να λάβουμε ώρες και το υπόλοιπο (επίσης γνωστό ως modulo, %%) για να πάρετε λεπτά.↩︎",
    "crumbs": [
      "Η ολοκληρωμένη εικόνα",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Ροή εργασιών: πρότυπα γραφής κώδικα</span>"
    ]
  },
  {
    "objectID": "data-tidy.html",
    "href": "data-tidy.html",
    "title": "5  Τακτοποίηση δεδομένων",
    "section": "",
    "text": "5.1 Εισαγωγή\nΣε αυτό το κεφάλαιο, θα μάθετε έναν συνεπή τρόπο οργάνωσης των δεδομένων σας στην R χρησιμοποιώντας ένα σύστημα που ονομάζεται τακτοποιημένα δεδομένα (tidy data). Η μετατροπή των δεδομένων σας σε αυτήν τη μορφή απαιτεί εκ των προτέρων λίγη δουλειά , η οποία όμως αποδίδει μακροπρόθεσμα. Μόλις έχετε τακτοποιημένα δεδομένα και τα τακτοποιημένα εργαλεία που παρέχονται από τα πακέτα του tidyverse, θα ξοδεύετε πολύ λιγότερο χρόνο για να μετατρέπετε δεδομένα από τη μία αναπαράσταση στην άλλη, επιτρέποντάς σας να αφιερώνετε περισσότερο χρόνο στην απάντηση των ερωτημάτων που σας ενδιαφέρουν.\nΣε αυτό το κεφάλαιο, θα μάθετε πρώτα τον ορισμό των τακτοποιημένων δεδομένων και θα δείτε την εφαρμογή τους σε ένα απλό σύνολο δεδομένων. Στη συνέχεια, θα εξετάσουμε το κύριο εργαλείο που θα χρησιμοποιήσετε για την τακτοποίηση των δεδομένων: την περιστροφή (pivoting). Η περιστροφή σας επιτρέπει να αλλάξετε τη μορφή των δεδομένων σας χωρίς να αλλάξετε καμία από τις τιμές του.",
    "crumbs": [
      "Η ολοκληρωμένη εικόνα",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Τακτοποίηση δεδομένων</span>"
    ]
  },
  {
    "objectID": "data-tidy.html#εισαγωγή",
    "href": "data-tidy.html#εισαγωγή",
    "title": "5  Τακτοποίηση δεδομένων",
    "section": "",
    "text": "“Όλες οι ευτυχισμένες οικογένειες μοιάζουν. Κάθε δυστυχισμένη οικογένεια είναι δυστυχισμένη με το δικό της τρόπο.”\n— Leo Tolstoy\n\n\n“Όλα τα τακτοποιημένα σύνολα δεδομένων μοιάζουν, αλλά κάθε ακατάστατο σύνολο δεδομένων είναι ακατάστατο με το δικό του τρόπο.”\n— Hadley Wickham\n\n\n\n\n5.1.1 Προαπαιτούμενα\nΣε αυτό το κεφάλαιο, θα επικεντρωθούμε στο tidyr, ένα πακέτο που παρέχει μία δέσμη εργαλείων που θα σας βοηθήσουν να τακτοποιήσετε τα ακατάστατα σύνολα δεδομένων σας. Το tidyr είναι μέλος του tidyverse.\n\nlibrary(tidyverse)\n\nΑπό αυτό το κεφάλαιο και μετά, θα καταστείλουμε το μήνυμα φόρτωσης από την εντολή library(tidyverse).",
    "crumbs": [
      "Η ολοκληρωμένη εικόνα",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Τακτοποίηση δεδομένων</span>"
    ]
  },
  {
    "objectID": "data-tidy.html#sec-tidy-data",
    "href": "data-tidy.html#sec-tidy-data",
    "title": "5  Τακτοποίηση δεδομένων",
    "section": "\n5.2 Τακτοποιημένα δεδομένα",
    "text": "5.2 Τακτοποιημένα δεδομένα\nΤα ίδια δεδομένα μπορούν να αναπαρασταθούν με πολλούς τρόπους. Το παρακάτω παράδειγμα δείχνει τα ίδια δεδομένα οργανωμένα με τρεις διαφορετικούς τρόπους. Κάθε σύνολο δεδομένων εμφανίζει τις ίδιες τιμές τεσσάρων μεταβλητών: country, year, population και αριθμός καταγεγραμμένων παρατηρήσεων φυματίωσης (TB, tuberculosis), αλλά κάθε σύνολο δεδομένων οργανώνει τις αντίστοιχες τιμές του με διαφορετικό τρόπο.\n\ntable1\n#&gt; # A tibble: 6 × 4\n#&gt;   country      year  cases population\n#&gt;   &lt;chr&gt;       &lt;dbl&gt;  &lt;dbl&gt;      &lt;dbl&gt;\n#&gt; 1 Afghanistan  1999    745   19987071\n#&gt; 2 Afghanistan  2000   2666   20595360\n#&gt; 3 Brazil       1999  37737  172006362\n#&gt; 4 Brazil       2000  80488  174504898\n#&gt; 5 China        1999 212258 1272915272\n#&gt; 6 China        2000 213766 1280428583\n\ntable2\n#&gt; # A tibble: 12 × 4\n#&gt;   country      year type           count\n#&gt;   &lt;chr&gt;       &lt;dbl&gt; &lt;chr&gt;          &lt;dbl&gt;\n#&gt; 1 Afghanistan  1999 cases            745\n#&gt; 2 Afghanistan  1999 population  19987071\n#&gt; 3 Afghanistan  2000 cases           2666\n#&gt; 4 Afghanistan  2000 population  20595360\n#&gt; 5 Brazil       1999 cases          37737\n#&gt; 6 Brazil       1999 population 172006362\n#&gt; # ℹ 6 more rows\n\ntable3\n#&gt; # A tibble: 6 × 3\n#&gt;   country      year rate             \n#&gt;   &lt;chr&gt;       &lt;dbl&gt; &lt;chr&gt;            \n#&gt; 1 Afghanistan  1999 745/19987071     \n#&gt; 2 Afghanistan  2000 2666/20595360    \n#&gt; 3 Brazil       1999 37737/172006362  \n#&gt; 4 Brazil       2000 80488/174504898  \n#&gt; 5 China        1999 212258/1272915272\n#&gt; 6 China        2000 213766/1280428583\n\nΌλα αυτά είναι αναπαραστάσεις των ίδιων υποκείμενων δεδομένων, αλλά δεν είναι εξίσου εύχρηστα. Ένα από αυτά, το table1, θα είναι πολύ πιο εύκολο να το δουλέψετε μέσα στο tidyverse επειδή είναι τακτοποιημένο (tidy).\nΥπάρχουν τρεις αλληλένδετοι κανόνες που κάνουν ένα σύνολο δεδομένων τακτοποιημένο:\n\nΚάθε μεταβλητή είναι μία στήλη. Κάθε στήλη είναι μία μεταβλητή.\nΚάθε παρατήρηση είναι μία γραμμή. Κάθε γραμμή είναι μία παρατήρηση.\nΚάθε τιμή είναι ένα κελί. Κάθε κελί είναι μία ενιαία τιμή.\n\nΤο Σχήμα 5.1 δείχνει τους κανόνες οπτικά.\n\n\n\n\n\n\n\nΣχήμα 5.1: Οι ακόλουθοι τρεις κανόνες κάνουν ένα σύνολο δεδομένων τακτοποιημένο: οι μεταβλητές είναι στήλες, οι παρατηρήσεις είναι σειρές και οι τιμές είναι κελιά.\n\n\n\n\nΓιατί να βεβαιωθείτε ότι τα δεδομένα σας είναι τακτοποιημένα; Υπάρχουν δύο βασικά πλεονεκτήματα:\n\nΥπάρχει ένα γενικό πλεονέκτημα στην επιλογή ενός συνεπούς τρόπου αποθήκευσης δεδομένων. Εάν έχετε μία συνεπή δομή δεδομένων, είναι πιο εύκολο να μάθετε τα εργαλεία που λειτουργούν με αυτήν, επειδή έχουν μία υποκείμενη ομοιομορφία.\nΥπάρχει ένα συγκεκριμένο πλεονέκτημα στην τοποθέτηση μεταβλητών σε στήλες επειδή επιτρέπει στη διανυσματική φύση της R να φανεί στο προσκήνιο. Όπως μάθατε στην Ενότητα 3.3.1 και στην Ενότητα 3.5.2, οι περισσότερες ενσωματωμένες συναρτήσεις της R λειτουργούν με διανύσματα τιμών. Αυτό κάνει τον μετασχηματισμό τακτοποιημένων δεδομένων να φαίνεται ιδιαίτερα φυσικός.\n\nΟι dplyr, ggplot2 και όλα τα άλλα πακέτα του tidyverse έχουν σχεδιαστεί για να λειτουργούν με τακτοποιημένα δεδομένα. Ακολουθούν μερικά μικρά παραδείγματα που δείχνουν πώς μπορείτε να εργαστείτε με τον table1.\n\n# Υπολογίστε τον ρυθμό (rate) ανά 10.000\ntable1 |&gt;\n  mutate(rate = cases / population * 10000)\n#&gt; # A tibble: 6 × 5\n#&gt;   country      year  cases population  rate\n#&gt;   &lt;chr&gt;       &lt;dbl&gt;  &lt;dbl&gt;      &lt;dbl&gt; &lt;dbl&gt;\n#&gt; 1 Afghanistan  1999    745   19987071 0.373\n#&gt; 2 Afghanistan  2000   2666   20595360 1.29 \n#&gt; 3 Brazil       1999  37737  172006362 2.19 \n#&gt; 4 Brazil       2000  80488  174504898 4.61 \n#&gt; 5 China        1999 212258 1272915272 1.67 \n#&gt; 6 China        2000 213766 1280428583 1.67\n\n# Υπολογίστε τις συνολικές περιπτώσεις (cases) ανά χρόνο\ntable1 |&gt; \n  group_by(year) |&gt; \n  summarize(total_cases = sum(cases))\n#&gt; # A tibble: 2 × 2\n#&gt;    year total_cases\n#&gt;   &lt;dbl&gt;       &lt;dbl&gt;\n#&gt; 1  1999      250740\n#&gt; 2  2000      296920\n\n# Οπτικοποιήστε τις αλλαγές ανά χρονική περίοδο\nggplot(table1, aes(x = year, y = cases)) +\n  geom_line(aes(group = country), color = \"grey50\") +\n  geom_point(aes(color = country, shape = country)) +\n  scale_x_continuous(breaks = c(1999, 2000)) # x-axis breaks at 1999 and 2000\n\n\n\n\n\n\n\n\n5.2.1 Ασκήσεις\n\nΓια καθέναν από τους πίνακες δεδομένων που χρησιμεύουν σαν δείγματα, περιγράψτε τι αντιπροσωπεύει κάθε παρατήρηση και κάθε στήλη.\n\nΣχεδιάστε τη διαδικασία που θα χρησιμοποιούσατε για να υπολογίσετε το rate για τον table2 και τον table3. Θα χρειαστεί να εκτελέσετε τέσσερις λειτουργίες:\n\nΝα εξάγετε τον αριθμό των περιπτώσεων φυματίωσης ανά χώρα ανά έτος.\nΝα εξάγετε τον αντίστοιχο πληθυσμό ανά χώρα ανά έτος.\nΝα διαιρέστε τις περιπτώσεις ανά πληθυσμό και πολλαπλασιάστε με το 10000.\nΝα αποθηκεύστε ξανά το αποτέλεσμα στο κατάλληλο μέρος.\n\nΔεν έχετε μάθει ακόμη όλες τις συναρτήσεις που χρειάζεστε για να εκτελέσετε πραγματικά αυτές τις λειτουργίες, αλλά θα πρέπει όμως να είστε σε θέση να σκεφτείτε τους μετασχηματισμούς που θα χρειαστείτε.",
    "crumbs": [
      "Η ολοκληρωμένη εικόνα",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Τακτοποίηση δεδομένων</span>"
    ]
  },
  {
    "objectID": "data-tidy.html#sec-pivoting",
    "href": "data-tidy.html#sec-pivoting",
    "title": "5  Τακτοποίηση δεδομένων",
    "section": "\n5.3 Επιμήκυνση δεδομένων",
    "text": "5.3 Επιμήκυνση δεδομένων\nΟι αρχές των τακτοποιημένων δεδομένων μπορεί να φαίνονται τόσο προφανείς που αναρωτιέστε αν θα συναντήσετε ποτέ ένα σύνολο δεδομένων που δεν είναι τακτοποιημένο. Δυστυχώς, ωστόσο, τα περισσότερα πραγματικά δεδομένα είναι ακατάστατα. Υπάρχουν δύο βασικοί λόγοι:\n\nΤα δεδομένα συχνά οργανώνονται για να διευκολύνουν κάποιον άλλο στόχο εκτός από την ανάλυση. Για παράδειγμα, είναι σύνηθες τα δεδομένα να είναι δομημένα ώστε να διευκολύνουν την εισαγωγή δεδομένων και όχι την ανάλυση.\nΟι περισσότεροι άνθρωποι δεν είναι εξοικειωμένοι με τις αρχές των τακτοποιημένων δεδομένων και είναι δύσκολο να τις εξάγετε μόνοι σας, εκτός εάν αφιερώσετε πολύ χρόνο να εργάζεστε με δεδομένα.\n\nΑυτό σημαίνει ότι οι περισσότερες πραγματικές αναλύσεις θα απαιτήσουν τουλάχιστον λίγη τακτοποίηση. Θα ξεκινήσετε ανακαλύπτοντας ποιες είναι οι υποκείμενες μεταβλητές και οι παρατηρήσεις. Μερικές φορές αυτό είναι εύκολο. άλλες φορές θα χρειαστεί να συμβουλευτείτε τα άτομα που δημιούργησαν αρχικά τα δεδομένα. Στη συνέχεια, θα περιστρέψετε (pivot) τα δεδομένα σας σε μία τακτοποιημένη μορφή, με μεταβλητές στις στήλες και παρατηρήσεις στις γραμμές.\nΤο tidyr παρέχει δύο συναρτήσεις για την περιστροφή δεδομένων: τις pivot_longer() και pivot_wider(). Αρχικά θα ξεκινήσουμε με την pivot_longer() επειδή είναι η πιο συνηθισμένη περίπτωση. Ας δούμε μερικά παραδείγματα.\n\n5.3.1 Δεδομένα σε ονόματα στηλών\nΤο σύνολο δεδομένων billboard καταγράφει την κατάταξη των τραγουδιών στον πίνακα διαφημίσεων το έτος 2000:\n\nbillboard\n#&gt; # A tibble: 317 × 79\n#&gt;   artist       track               date.entered   wk1   wk2   wk3   wk4   wk5\n#&gt;   &lt;chr&gt;        &lt;chr&gt;               &lt;date&gt;       &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n#&gt; 1 2 Pac        Baby Don't Cry (Ke… 2000-02-26      87    82    72    77    87\n#&gt; 2 2Ge+her      The Hardest Part O… 2000-09-02      91    87    92    NA    NA\n#&gt; 3 3 Doors Down Kryptonite          2000-04-08      81    70    68    67    66\n#&gt; 4 3 Doors Down Loser               2000-10-21      76    76    72    69    67\n#&gt; 5 504 Boyz     Wobble Wobble       2000-04-15      57    34    25    17    17\n#&gt; 6 98^0         Give Me Just One N… 2000-08-19      51    39    34    26    26\n#&gt; # ℹ 311 more rows\n#&gt; # ℹ 71 more variables: wk6 &lt;dbl&gt;, wk7 &lt;dbl&gt;, wk8 &lt;dbl&gt;, wk9 &lt;dbl&gt;, …\n\nΣε αυτό το σύνολο δεδομένων, κάθε παρατήρηση είναι ένα τραγούδι. Οι τρεις πρώτες στήλες (artist, track και date.entered) είναι μεταβλητές που περιγράφουν το τραγούδι. Στη συνέχεια, έχουμε 76 στήλες (wk1-wk76) που περιγράφουν την κατάταξη του τραγουδιού κάθε εβδομάδα1. Εδώ, τα ονόματα στηλών είναι μία μεταβλητή (η week) και οι τιμές των κελιών είναι μία άλλη (η rank).\nΓια να τακτοποιήσουμε αυτά τα δεδομένα, θα χρησιμοποιήσουμε την pivot_longer():\n\nbillboard |&gt; \n  pivot_longer(\n    cols = starts_with(\"wk\"), \n    names_to = \"week\", \n    values_to = \"rank\"\n  )\n#&gt; # A tibble: 24,092 × 5\n#&gt;    artist track                   date.entered week   rank\n#&gt;    &lt;chr&gt;  &lt;chr&gt;                   &lt;date&gt;       &lt;chr&gt; &lt;dbl&gt;\n#&gt;  1 2 Pac  Baby Don't Cry (Keep... 2000-02-26   wk1      87\n#&gt;  2 2 Pac  Baby Don't Cry (Keep... 2000-02-26   wk2      82\n#&gt;  3 2 Pac  Baby Don't Cry (Keep... 2000-02-26   wk3      72\n#&gt;  4 2 Pac  Baby Don't Cry (Keep... 2000-02-26   wk4      77\n#&gt;  5 2 Pac  Baby Don't Cry (Keep... 2000-02-26   wk5      87\n#&gt;  6 2 Pac  Baby Don't Cry (Keep... 2000-02-26   wk6      94\n#&gt;  7 2 Pac  Baby Don't Cry (Keep... 2000-02-26   wk7      99\n#&gt;  8 2 Pac  Baby Don't Cry (Keep... 2000-02-26   wk8      NA\n#&gt;  9 2 Pac  Baby Don't Cry (Keep... 2000-02-26   wk9      NA\n#&gt; 10 2 Pac  Baby Don't Cry (Keep... 2000-02-26   wk10     NA\n#&gt; # ℹ 24,082 more rows\n\nΑμέσως μετά την αναφορά των δεδομένων, υπάρχουν τρία βασικά ορίσματα:\n\nΤο cols καθορίζει ποιες στήλες πρέπει να περιστραφούν, δηλαδή ποιες στήλες δεν είναι μεταβλητές. Αυτό το όρισμα χρησιμοποιεί την ίδια σύνταξη όπως στην select() επομένως εδώ θα μπορούσαμε να χρησιμοποιήσουμε το !c(artist, track, date.ented) ή starts_with(\"wk\").\nΤο names_to ορίζει τη μεταβλητή στην οποία είναι αποθηκευμένη στα ονόματα των στηλών, σε αυτή την περίπτωση ονομάσαμε αυτήν τη μεταβλητή week.\nΤο values_to ορίζει τη μεταβλητή στην οποία είναι αποθηκευμένη οι τιμές των κελιών, σε αυτή την περίπτωση η rank.\n\nΣημειώστε ότι στον κώδικα οι \"week\" και \"rank\" βρίσκονται μέσα σε εισαγωγικά επειδή πρόκειται για νέες μεταβλητές που δημιουργούμε - δεν υπάρχουν ακόμα στα δεδομένα μας όταν εκτελούμε την pivot_longer().\nΤώρα ας στρέψουμε την προσοχή μας στο μακρύτερο πλαίσιο δεδομένων που προκύπτει. Τι συμβαίνει αν ένα τραγούδι είναι στα 100 καλύτερα για λιγότερο από 76 εβδομάδες; Πάρτε για παράδειγμα το “Baby Don’t Cry” του 2Pac. Το παραπάνω αποτέλεσμα υποδηλώνει ότι ήταν μόνο στις 100 πρώτες θέσεις για 7 εβδομάδες και όλες οι υπόλοιπες εβδομάδες συμπληρώνονται κενές τιμές. Αυτά τα NA δεν αντιπροσωπεύουν πραγματικά άγνωστες παρατηρήσεις. Αναγκάστηκαν να υπάρχουν λόγω της δομής του συνόλου δεδομένων2, επομένως μπορούμε να ζητήσουμε από την pivot_longer() να απαλλαγεί από αυτά ορίζοντας values_drop_na = TRUE:\n\nbillboard |&gt; \n  pivot_longer(\n    cols = starts_with(\"wk\"), \n    names_to = \"week\", \n    values_to = \"rank\",\n    values_drop_na = TRUE\n  )\n#&gt; # A tibble: 5,307 × 5\n#&gt;   artist track                   date.entered week   rank\n#&gt;   &lt;chr&gt;  &lt;chr&gt;                   &lt;date&gt;       &lt;chr&gt; &lt;dbl&gt;\n#&gt; 1 2 Pac  Baby Don't Cry (Keep... 2000-02-26   wk1      87\n#&gt; 2 2 Pac  Baby Don't Cry (Keep... 2000-02-26   wk2      82\n#&gt; 3 2 Pac  Baby Don't Cry (Keep... 2000-02-26   wk3      72\n#&gt; 4 2 Pac  Baby Don't Cry (Keep... 2000-02-26   wk4      77\n#&gt; 5 2 Pac  Baby Don't Cry (Keep... 2000-02-26   wk5      87\n#&gt; 6 2 Pac  Baby Don't Cry (Keep... 2000-02-26   wk6      94\n#&gt; # ℹ 5,301 more rows\n\nΟ αριθμός των γραμμών είναι τώρα πολύ μικρότερος, υποδεικνύοντας ότι πολλές γραμμές με τιμές NA απορρίφθηκαν.\nΜπορεί επίσης να αναρωτιέστε τι συμβαίνει εάν ένα τραγούδι είναι στα 100 καλύτερα για περισσότερες από 76 εβδομάδες; Δεν μπορούμε να πούμε από αυτά τα δεδομένα, αλλά μπορείτε να μαντέψετε ότι οι επιπλέον στήλες wk77, wk78, … θα προστεθούν στο σύνολο δεδομένων.\nΑυτά τα δεδομένα είναι πλέον τακτοποιημένα, αλλά θα μπορούσαμε να κάνουμε τον μελλοντικό υπολογισμό λίγο πιο εύκολο μετατρέποντας τις τιμές της week από συμβολοσειρές χαρακτήρων σε αριθμούς χρησιμοποιώντας τις mutate() και readr::parse_number(). Η parse_number() είναι μία εύχρηστη συνάρτηση που εξάγει τον πρώτο αριθμό από μία συμβολοσειρά, αγνοώντας όλο το υπόλοιπο κείμενο.\n\nbillboard_longer &lt;- billboard |&gt; \n  pivot_longer(\n    cols = starts_with(\"wk\"), \n    names_to = \"week\", \n    values_to = \"rank\",\n    values_drop_na = TRUE\n  ) |&gt; \n  mutate(\n    week = parse_number(week)\n  )\nbillboard_longer\n#&gt; # A tibble: 5,307 × 5\n#&gt;   artist track                   date.entered  week  rank\n#&gt;   &lt;chr&gt;  &lt;chr&gt;                   &lt;date&gt;       &lt;dbl&gt; &lt;dbl&gt;\n#&gt; 1 2 Pac  Baby Don't Cry (Keep... 2000-02-26       1    87\n#&gt; 2 2 Pac  Baby Don't Cry (Keep... 2000-02-26       2    82\n#&gt; 3 2 Pac  Baby Don't Cry (Keep... 2000-02-26       3    72\n#&gt; 4 2 Pac  Baby Don't Cry (Keep... 2000-02-26       4    77\n#&gt; 5 2 Pac  Baby Don't Cry (Keep... 2000-02-26       5    87\n#&gt; 6 2 Pac  Baby Don't Cry (Keep... 2000-02-26       6    94\n#&gt; # ℹ 5,301 more rows\n\nΤώρα που έχουμε όλους τους αριθμούς της εβδομάδας σε μία μεταβλητή και όλες τις τιμές κατάταξης σε μία άλλη, είμαστε σε καλή θέση να οπτικοποιήσουμε πώς τροποποιούνται οι κατατάξεις των τραγουδιών με την πάροδο του χρόνου. Ο κώδικας που χρησιμοποιήσαμε φαίνεται παρακάτω και το αποτέλεσμα είναι στο Σχήμα 5.2. Μπορούμε να δούμε ότι πολύ λίγα τραγούδια παραμένουν στα 100 καλύτερα για περισσότερες από 20 εβδομάδες.\n\nbillboard_longer |&gt; \n  ggplot(aes(x = week, y = rank, group = track)) + \n  geom_line(alpha = 0.25) + \n  scale_y_reverse()\n\n\n\n\n\n\nΣχήμα 5.2: Ένα διάγραμμα γραμμών που αναπαριστά πως η κατάταξη ενός τραγουδιού αλλάζει με την πάροδο του χρόνου.\n\n\n\n\n\n5.3.2 Πώς λειτουργεί η περιστροφή;\nΤώρα που είδατε πώς μπορούμε να χρησιμοποιήσουμε την περιστροφή για να αναμορφώσουμε τα δεδομένα μας, ας αφιερώσουμε λίγο χρόνο για να αποκτήσουμε μία πρώτη διαίσθηση σχετικά με το τι κάνει η περιστροφή στα δεδομένα. Ας ξεκινήσουμε με ένα πολύ απλό σύνολο δεδομένων για να είναι πιο εύκολο να δούμε τι συμβαίνει. Ας υποθέσουμε ότι έχουμε τρεις ασθενείς με αναγνωριστικά (ids) A, B και C, και κάνουμε δύο μετρήσεις αρτηριακής πίεσης σε κάθε ασθενή. Θα δημιουργήσουμε τα δεδομένα με την tribble(), μία εύχρηστη συνάρτηση για την κατασκευή μικρών tibbles με το χέρι:\n\ndf &lt;- tribble(\n  ~id,  ~bp1, ~bp2,\n   \"A\",  100,  120,\n   \"B\",  140,  115,\n   \"C\",  120,  125\n)\n\nΘέλουμε το νέο μας σύνολο δεδομένων να έχει τρεις μεταβλητές: id (υπάρχει ήδη), measurement (τα ονόματα των στηλών) και value (τις τιμές των κελιών). Για να το πετύχουμε αυτό, πρέπει να περιστρέψουμε το df ώστε να γίνει μακρύτερο:\n\ndf |&gt; \n  pivot_longer(\n    cols = bp1:bp2,\n    names_to = \"measurement\",\n    values_to = \"value\"\n  )\n#&gt; # A tibble: 6 × 3\n#&gt;   id    measurement value\n#&gt;   &lt;chr&gt; &lt;chr&gt;       &lt;dbl&gt;\n#&gt; 1 A     bp1           100\n#&gt; 2 A     bp2           120\n#&gt; 3 B     bp1           140\n#&gt; 4 B     bp2           115\n#&gt; 5 C     bp1           120\n#&gt; 6 C     bp2           125\n\nΠώς λειτουργεί η αναδιάταξη αυτή; Είναι πιο εύκολο να το καταλάβουμε αν το φανταστούμε στήλη προς στήλη. Όπως φαίνεται στο Σχήμα 5.3, οι τιμές σε μία στήλη που ήταν ήδη μεταβλητή στο αρχικό σύνολο δεδομένων (id) πρέπει να επαναληφθούν, μία φορά για κάθε στήλη που περιστρέφεται.\n\n\n\n\n\n\n\nΣχήμα 5.3: Στήλες που είναι ήδη μεταβλητές πρέπει να επαναληφθούν, μία φορά για κάθε μία από τις στήλες που περιστρέφεται.\n\n\n\n\nΤα ονόματα των στηλών γίνονται τιμές σε μία νέα μεταβλητή, το όνομα της οποίας ορίζεται από το όρισμα names_to, όπως φαίνεται στο Σχήμα 5.4. Πρέπει να επαναληφθούν μία φορά για κάθε γραμμή στο αρχικό σύνολο δεδομένων.\n\n\n\n\n\n\n\nΣχήμα 5.4: Τα ονόματα των στηλών που έχουν περιστραφεί μετατρέπονται σε τιμές σε μια νέα στήλη. Οι τιμές επαναλαμβάνονται μία φορά κάθε γραμμή του αρχικού συνόλου δεδομένων.\n\n\n\n\nΟι τιμές των κελιών γίνονται επίσης τιμές σε μία νέα μεταβλητή, με ένα όνομα που ορίζεται από το όρισμα values_to. Και αυτές ξετυλίγονται γραμμή-προς-γραμμή. Το Σχήμα 5.5 απεικονίζει τη διαδικασία.\n\n\n\n\n\n\n\nΣχήμα 5.5: Ο αριθμός των τιμών διατηρείται (δεν επαναλαμβάνεται), απλώς τα δεδομένα ξετυλίγονται γραμμή-προς-γραμμή.\n\n\n\n\n\n5.3.3 Πολλές μεταβλητές στα ονόματα στηλών\nΜία πιο δύσκολη κατάσταση προκύπτει όταν έχετε πολλές πληροφορίες στριμωγμένες στα ονόματα των στηλών και θέλετε να τις αποθηκεύσετε σε ξεχωριστές νέες μεταβλητές. Για παράδειγμα, πάρτε το σύνολο δεδομένων who2, την πηγή του table1 και των σχετικών συνόλων δεδομένων που είδατε παραπάνω:\n\nwho2\n#&gt; # A tibble: 7,240 × 58\n#&gt;   country      year sp_m_014 sp_m_1524 sp_m_2534 sp_m_3544 sp_m_4554\n#&gt;   &lt;chr&gt;       &lt;dbl&gt;    &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;\n#&gt; 1 Afghanistan  1980       NA        NA        NA        NA        NA\n#&gt; 2 Afghanistan  1981       NA        NA        NA        NA        NA\n#&gt; 3 Afghanistan  1982       NA        NA        NA        NA        NA\n#&gt; 4 Afghanistan  1983       NA        NA        NA        NA        NA\n#&gt; 5 Afghanistan  1984       NA        NA        NA        NA        NA\n#&gt; 6 Afghanistan  1985       NA        NA        NA        NA        NA\n#&gt; # ℹ 7,234 more rows\n#&gt; # ℹ 51 more variables: sp_m_5564 &lt;dbl&gt;, sp_m_65 &lt;dbl&gt;, sp_f_014 &lt;dbl&gt;, …\n\nΑυτό το σύνολο δεδομένων, που συλλέγεται από τον Παγκόσμιο Οργανισμό Υγείας, καταγράφει πληροφορίες σχετικά με τις διαγνώσεις φυματίωσης. Υπάρχουν δύο στήλες που είναι ήδη μεταβλητές και είναι εύκολο να ερμηνευτούν: οι country και year. Ακολουθούνται από 56 στήλες όπως οι sp_m_014, ep_m_4554, και rel_m_3544. Αν κοιτάξετε αυτές τις στήλες για αρκετή ώρα, θα παρατηρήσετε ότι υπάρχει ένα μοτίβο. Κάθε όνομα στήλης αποτελείται από τρία κομμάτια που χωρίζονται με _. Το πρώτο κομμάτι, sp/rel/ep, περιγράφει τη μέθοδο που χρησιμοποιείται για τη διάγνωση, το δεύτερο κομμάτι, m/f είναι το φύλο - gender (κωδικοποιημένο ως δυαδική μεταβλητή σε αυτό το σύνολο δεδομένων) , και το τρίτο κομμάτι, 014/1524/2534/3544/4554/5564/65 είναι το εύρος age (για παράδειγμα, το 014 αντιπροσωπεύει 0-14).\nΈτσι σε αυτή την περίπτωση έχουμε έξι πληροφορίες που καταγράφονται στο who2: τη χώρα και το έτος (είναι ήδη στήλες στα δεδομένα μας) - τη μέθοδο διάγνωσης, την κατηγορία του φύλου και την κατηγορία ηλικιακού εύρους (που περιέχονται στα ονόματα των υπόλοιπων στηλών) - και τον αριθμό των ασθενών αυτής της κατηγορίας (τιμές κυττάρων). Για να οργανώσουμε αυτά τα έξι τμήματα πληροφοριών σε έξι ξεχωριστές στήλες, χρησιμοποιούμε την pivot_longer() με ένα διάνυσμα ονομάτων στηλών για το names_to και οδηγίες για τον διαχωρισμό των αρχικών ονομάτων μεταβλητών σε κομμάτια στο names_sep καθώς και ένα όνομα στήλης για το όρισμα values_to:\n\nwho2 |&gt; \n  pivot_longer(\n    cols = !(country:year),\n    names_to = c(\"diagnosis\", \"gender\", \"age\"), \n    names_sep = \"_\",\n    values_to = \"count\"\n  )\n#&gt; # A tibble: 405,440 × 6\n#&gt;   country      year diagnosis gender age   count\n#&gt;   &lt;chr&gt;       &lt;dbl&gt; &lt;chr&gt;     &lt;chr&gt;  &lt;chr&gt; &lt;dbl&gt;\n#&gt; 1 Afghanistan  1980 sp        m      014      NA\n#&gt; 2 Afghanistan  1980 sp        m      1524     NA\n#&gt; 3 Afghanistan  1980 sp        m      2534     NA\n#&gt; 4 Afghanistan  1980 sp        m      3544     NA\n#&gt; 5 Afghanistan  1980 sp        m      4554     NA\n#&gt; 6 Afghanistan  1980 sp        m      5564     NA\n#&gt; # ℹ 405,434 more rows\n\nΜία εναλλακτική του names_sep είναι το names_pattern, το οποίο μπορείτε να χρησιμοποιήσετε για να εξάγετε μεταβλητές από πιο περίπλοκες περιπτώσεις, αφού μάθετε για τις κανονικές εκφράσεις στο Κεφάλαιο 15.\nΕννοιολογικά, αυτή είναι μόνο μία μικρή παραλλαγή στην απλούστερη περίπτωση που έχετε ήδη δει. Το Σχήμα 5.6 δείχνει τη βασική ιδέα: τώρα, αντί τα ονόματα των στηλών να περιστρέφονται σε μία στήλη, περιστρέφονται σε πολλές στήλες. Μπορείτε να φανταστείτε ότι αυτό συμβαίνει σε δύο βήματα (πρώτα περιστρέφοντας τις στήλες και στη συνέχεια τις χωρίζετε) αλλά στην πραγματικότητα αυτό συμβαίνει σε ένα μόνο βήμα, καθώς είναι πιο γρήγορο.\n\n\n\n\n\n\n\nΣχήμα 5.6: Με την περιστροφή στηλών τα ονόματα των οποίων περιέχουν πολλαπλά στοιχεία, κάθε όνομα στήλης θα καταλαμβάνει πλέον τιμές σε πολλαπλές στήλες εξόδου.\n\n\n\n\n\n5.3.4 Δεδομένα και ονόματα μεταβλητών στις κεφαλίδες στηλών\nΤο επόμενο βήμα στην πολυπλοκότητα είναι όταν τα ονόματα στηλών περιλαμβάνουν έναν συνδυασμό τιμών μεταβλητών και ονομάτων μεταβλητών. Για παράδειγμα, πάρτε το σύνολο δεδομένων household:\n\nhousehold\n#&gt; # A tibble: 5 × 5\n#&gt;   family dob_child1 dob_child2 name_child1 name_child2\n#&gt;    &lt;int&gt; &lt;date&gt;     &lt;date&gt;     &lt;chr&gt;       &lt;chr&gt;      \n#&gt; 1      1 1998-11-26 2000-01-29 Susan       Jose       \n#&gt; 2      2 1996-06-22 NA         Mark        &lt;NA&gt;       \n#&gt; 3      3 2002-07-11 2004-04-05 Sam         Seth       \n#&gt; 4      4 2004-10-10 2009-08-27 Craig       Khai       \n#&gt; 5      5 2000-12-05 2005-02-28 Parker      Gracie\n\nΑυτό το σύνολο δεδομένων περιέχει δεδομένα για πέντε οικογένειες, με ονόματα και ημερομηνίες γέννησης έως και δύο παιδιών. Η νέα πρόκληση σε αυτό το σύνολο δεδομένων είναι ότι τα ονόματα στηλών περιέχουν τα ονόματα δύο μεταβλητών (dob, name) και τις τιμές μιας άλλη μεταβλητής (child, με τιμές 1 ή 2). Για να λύσουμε αυτό το πρόβλημα πρέπει και πάλι να δώσουμε ένα διάνυσμα στο names_to αλλά αυτή τη φορά χρησιμοποιούμε το .value“. Αυτό δεν είναι το όνομα μιας μεταβλητής, αλλά μία μοναδική τιμή που λέει στην pivot_longer() να κάνει κάτι διαφορετικό. Αυτό παρακάμπτει το συνηθισμένο όρισμα values_to ώστε να χρησιμοποιηθεί το πρώτο στοιχείο του ονόματος της περιστρεφόμενης στήλης ως όνομα μεταβλητής στην έξοδο.\n\nhousehold |&gt; \n  pivot_longer(\n    cols = !family, \n    names_to = c(\".value\", \"child\"), \n    names_sep = \"_\", \n    values_drop_na = TRUE\n  )\n#&gt; # A tibble: 9 × 4\n#&gt;   family child  dob        name \n#&gt;    &lt;int&gt; &lt;chr&gt;  &lt;date&gt;     &lt;chr&gt;\n#&gt; 1      1 child1 1998-11-26 Susan\n#&gt; 2      1 child2 2000-01-29 Jose \n#&gt; 3      2 child1 1996-06-22 Mark \n#&gt; 4      3 child1 2002-07-11 Sam  \n#&gt; 5      3 child2 2004-04-05 Seth \n#&gt; 6      4 child1 2004-10-10 Craig\n#&gt; # ℹ 3 more rows\n\nΧρησιμοποιούμε ξανά το values_drop_na = TRUE, καθώς το σχήμα της εισόδου αναγκάζει τη δημιουργία ρητών μεταβλητών που είναι ελλιπής (π.χ. για οικογένειες με ένα μόνο παιδί).\nΤο Σχήμα 5.7 παρουσιάζει τη βασική ιδέα με ένα απλούστερο παράδειγμα. Όταν χρησιμοποιείτε το \".value\" στο names_to, τα ονόματα στηλών στην είσοδο συνεισφέρουν τόσο στις τιμές όσο και στα ονόματα των μεταβλητών στην έξοδο.\n\n\n\n\n\n\n\nΣχήμα 5.7: Θέτοντας το όρισμα names_to = c(\".value\", \"num\") κατά την περιστροφή, τα ονόματα των στηλών χωρίζονται σε δύο μέρη: το πρώτο καθορίζει το όνομα της στήλης εξόδου (x or y), και το δεύτερο την τιμή της στήλης num.",
    "crumbs": [
      "Η ολοκληρωμένη εικόνα",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Τακτοποίηση δεδομένων</span>"
    ]
  },
  {
    "objectID": "data-tidy.html#διεύρυνση-δεδομένων",
    "href": "data-tidy.html#διεύρυνση-δεδομένων",
    "title": "5  Τακτοποίηση δεδομένων",
    "section": "\n5.4 Διεύρυνση δεδομένων",
    "text": "5.4 Διεύρυνση δεδομένων\nΜέχρι στιγμής χρησιμοποιήσαμε την pivot_longer() για να λύσουμε μία κοινή κατηγορία προβλημάτων όπου οι τιμές έχουν καταλήξει σε ονόματα στηλών. Στη συνέχεια θα στραφούμε στην pivot_wider(), η οποία κάνει τα σύνολα δεδομένων ευρύτερα (wider) αυξάνοντας τις στήλες και μειώνοντας τις γραμμές και βοηθά όταν μία παρατήρηση κατανέμεται σε πολλές σειρές. Αυτό φαίνεται να εμφανίζεται λιγότερο συχνά στη φύση, αλλά συναντάται πολύ όταν ασχολούμαστε με κυβερνητικά δεδομένα.\nΘα ξεκινήσουμε εξετάζοντας το cms_patient_experience, ένα σύνολο δεδομένων από τα Κέντρα Medicare και τις υπηρεσίες Medicaid που συλλέγει δεδομένα σχετικά με τις εμπειρίες ασθενών:\n\ncms_patient_experience\n#&gt; # A tibble: 500 × 5\n#&gt;   org_pac_id org_nm                     measure_cd   measure_title   prf_rate\n#&gt;   &lt;chr&gt;      &lt;chr&gt;                      &lt;chr&gt;        &lt;chr&gt;              &lt;dbl&gt;\n#&gt; 1 0446157747 USC CARE MEDICAL GROUP INC CAHPS_GRP_1  CAHPS for MIPS…       63\n#&gt; 2 0446157747 USC CARE MEDICAL GROUP INC CAHPS_GRP_2  CAHPS for MIPS…       87\n#&gt; 3 0446157747 USC CARE MEDICAL GROUP INC CAHPS_GRP_3  CAHPS for MIPS…       86\n#&gt; 4 0446157747 USC CARE MEDICAL GROUP INC CAHPS_GRP_5  CAHPS for MIPS…       57\n#&gt; 5 0446157747 USC CARE MEDICAL GROUP INC CAHPS_GRP_8  CAHPS for MIPS…       85\n#&gt; 6 0446157747 USC CARE MEDICAL GROUP INC CAHPS_GRP_12 CAHPS for MIPS…       24\n#&gt; # ℹ 494 more rows\n\nΗ βασική μονάδα που μελετάται είναι ένας οργανισμός, αλλά κάθε οργανισμός κατανέμεται σε έξι σειρές, με μία σειρά για κάθε μέτρηση που λαμβάνεται στον οργανισμό έρευνας. Μπορούμε να δούμε το πλήρες σύνολο τιμών για τις measure_cd και measure_title χρησιμοποιώντας την distinct():\n\ncms_patient_experience |&gt; \n  distinct(measure_cd, measure_title)\n#&gt; # A tibble: 6 × 2\n#&gt;   measure_cd   measure_title                                                 \n#&gt;   &lt;chr&gt;        &lt;chr&gt;                                                         \n#&gt; 1 CAHPS_GRP_1  CAHPS for MIPS SSM: Getting Timely Care, Appointments, and In…\n#&gt; 2 CAHPS_GRP_2  CAHPS for MIPS SSM: How Well Providers Communicate            \n#&gt; 3 CAHPS_GRP_3  CAHPS for MIPS SSM: Patient's Rating of Provider              \n#&gt; 4 CAHPS_GRP_5  CAHPS for MIPS SSM: Health Promotion and Education            \n#&gt; 5 CAHPS_GRP_8  CAHPS for MIPS SSM: Courteous and Helpful Office Staff        \n#&gt; 6 CAHPS_GRP_12 CAHPS for MIPS SSM: Stewardship of Patient Resources\n\nΚαμία από αυτές τις στήλες δεν θα δημιουργήσει ιδιαίτερα χρήσιμα ονόματα μεταβλητών: η measure_cd δεν υποδηλώνει τη σημασία της μεταβλητής και η measure_title είναι μία μεγάλη πρόταση που περιέχει κενά. Προς το παρόν, θα χρησιμοποιήσουμε τη measure_cd ως πηγή για τα νέα ονόματα στηλών, αλλά σε μία πραγματική ανάλυση ίσως θελήσετε να δημιουργήσετε τα δικά σας ονόματα μεταβλητών που να είναι σύντομα και ουσιαστικά.\nΗ pivot_wider() έχει την αντίθετη διεπαφή από την pivot_longer(): αντί να επιλέξουμε νέα ονόματα στηλών, πρέπει να παρέχουμε τις υπάρχουσες στήλες που ορίζουν τις τιμές (values_from) και το όνομα της στήλης (names_from):\n\ncms_patient_experience |&gt; \n  pivot_wider(\n    names_from = measure_cd,\n    values_from = prf_rate\n  )\n#&gt; # A tibble: 500 × 9\n#&gt;   org_pac_id org_nm                   measure_title   CAHPS_GRP_1 CAHPS_GRP_2\n#&gt;   &lt;chr&gt;      &lt;chr&gt;                    &lt;chr&gt;                 &lt;dbl&gt;       &lt;dbl&gt;\n#&gt; 1 0446157747 USC CARE MEDICAL GROUP … CAHPS for MIPS…          63          NA\n#&gt; 2 0446157747 USC CARE MEDICAL GROUP … CAHPS for MIPS…          NA          87\n#&gt; 3 0446157747 USC CARE MEDICAL GROUP … CAHPS for MIPS…          NA          NA\n#&gt; 4 0446157747 USC CARE MEDICAL GROUP … CAHPS for MIPS…          NA          NA\n#&gt; 5 0446157747 USC CARE MEDICAL GROUP … CAHPS for MIPS…          NA          NA\n#&gt; 6 0446157747 USC CARE MEDICAL GROUP … CAHPS for MIPS…          NA          NA\n#&gt; # ℹ 494 more rows\n#&gt; # ℹ 4 more variables: CAHPS_GRP_3 &lt;dbl&gt;, CAHPS_GRP_5 &lt;dbl&gt;, …\n\nΗ έξοδος δεν φαίνεται ιδιαίτερα σωστή. Εξακολουθούμε να έχουμε πολλές σειρές για κάθε οργανισμό. Αυτό συμβαίνει επειδή, πρέπει επίσης να πούμε στην pivot_wider() ποια στήλη ή στήλες έχουν τιμές που προσδιορίζουν μοναδικά κάθε γραμμή - σε αυτήν την περίπτωση αυτές είναι οι μεταβλητές που ξεκινούν με \"org\":\n\ncms_patient_experience |&gt; \n  pivot_wider(\n    id_cols = starts_with(\"org\"),\n    names_from = measure_cd,\n    values_from = prf_rate\n  )\n#&gt; # A tibble: 95 × 8\n#&gt;   org_pac_id org_nm           CAHPS_GRP_1 CAHPS_GRP_2 CAHPS_GRP_3 CAHPS_GRP_5\n#&gt;   &lt;chr&gt;      &lt;chr&gt;                  &lt;dbl&gt;       &lt;dbl&gt;       &lt;dbl&gt;       &lt;dbl&gt;\n#&gt; 1 0446157747 USC CARE MEDICA…          63          87          86          57\n#&gt; 2 0446162697 ASSOCIATION OF …          59          85          83          63\n#&gt; 3 0547164295 BEAVER MEDICAL …          49          NA          75          44\n#&gt; 4 0749333730 CAPE PHYSICIANS…          67          84          85          65\n#&gt; 5 0840104360 ALLIANCE PHYSIC…          66          87          87          64\n#&gt; 6 0840109864 REX HOSPITAL INC          73          87          84          67\n#&gt; # ℹ 89 more rows\n#&gt; # ℹ 2 more variables: CAHPS_GRP_8 &lt;dbl&gt;, CAHPS_GRP_12 &lt;dbl&gt;\n\nΑυτό μας δίνει το αποτέλεσμα που αναζητούμε.\n\n5.4.1 Πώς λειτουργεί η pivot_wider();\nΓια να κατανοήσουμε πώς λειτουργεί η pivot_wider(), ας ξεκινήσουμε πάλι με ένα πολύ απλό σύνολο δεδομένων. Αυτή τη φορά έχουμε δύο ασθενείς με id’s A και B, έχουμε τρεις μετρήσεις αρτηριακής πίεσης στον ασθενή Α και δύο στον ασθενή Β:\n\ndf &lt;- tribble(\n  ~id, ~measurement, ~value,\n  \"A\",        \"bp1\",    100,\n  \"B\",        \"bp1\",    140,\n  \"B\",        \"bp2\",    115, \n  \"A\",        \"bp2\",    120,\n  \"A\",        \"bp3\",    105\n)\n\nΘα πάρουμε τις τιμές από τη στήλη value και τα ονόματα από τη στήλη measurement:\n\ndf |&gt; \n  pivot_wider(\n    names_from = measurement,\n    values_from = value\n  )\n#&gt; # A tibble: 2 × 4\n#&gt;   id      bp1   bp2   bp3\n#&gt;   &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n#&gt; 1 A       100   120   105\n#&gt; 2 B       140   115    NA\n\nΓια να ξεκινήσει η διαδικασία pivot_wider() πρέπει πρώτα να καταλάβουμε ποια πληροφορία θα πάει στις γραμμές και τις στήλες. Τα νέα ονόματα στηλών θα είναι οι μοναδικές τιμές της measurement.\n\ndf |&gt; \n  distinct(measurement) |&gt; \n  pull()\n#&gt; [1] \"bp1\" \"bp2\" \"bp3\"\n\nΑπό προεπιλογή, οι γραμμές στην έξοδο καθορίζονται από όλες τις μεταβλητές που δεν περιλαμβάνονται στα νέα ονόματα ή τις τιμές. Αυτές ονομάζονται id_cols. Εδώ υπάρχει μόνο μία στήλη, αλλά γενικά μπορεί να υπάρχει οποιοσδήποτε αριθμός.\n\ndf |&gt; \n  select(-measurement, -value) |&gt; \n  distinct()\n#&gt; # A tibble: 2 × 1\n#&gt;   id   \n#&gt;   &lt;chr&gt;\n#&gt; 1 A    \n#&gt; 2 B\n\nΗ pivot_wider() συνδυάζει αυτά τα αποτελέσματα για να παράγει ένα άδειο σύνολο δεδομένων:\n\ndf |&gt; \n  select(-measurement, -value) |&gt; \n  distinct() |&gt; \n  mutate(x = NA, y = NA, z = NA)\n#&gt; # A tibble: 2 × 4\n#&gt;   id    x     y     z    \n#&gt;   &lt;chr&gt; &lt;lgl&gt; &lt;lgl&gt; &lt;lgl&gt;\n#&gt; 1 A     NA    NA    NA   \n#&gt; 2 B     NA    NA    NA\n\nΣτη συνέχεια, συμπληρώνει όλες τις τιμές που λείπουν χρησιμοποιώντας τα δεδομένα στην είσοδο. Σε αυτήν την περίπτωση, δεν έχει κάθε κελί στην έξοδο αντίστοιχη τιμή στην είσοδο, καθώς δεν υπάρχει τρίτη μέτρηση της αρτηριακής πίεσης για τον ασθενή Β, οπότε αυτό το κελί θα λείπει. Θα επανέλθουμε σε αυτήν την ιδέα ότι η pivot_wider() μπορεί να “δημιουργήσει” κενές τιμές στο Κεφάλαιο 18.\nΜπορεί επίσης να αναρωτιέστε τι συμβαίνει εάν υπάρχουν πολλές γραμμές στην είσοδο που αντιστοιχούν σε ένα κελί στην έξοδο. Το παρακάτω παράδειγμα έχει δύο γραμμές που αντιστοιχούν στο συνδυασμό του id “A” και measurement “bp1”:\n\ndf &lt;- tribble(\n  ~id, ~measurement, ~value,\n  \"A\",        \"bp1\",    100,\n  \"A\",        \"bp1\",    102,\n  \"A\",        \"bp2\",    120,\n  \"B\",        \"bp1\",    140, \n  \"B\",        \"bp2\",    115\n)\n\nΕάν προσπαθήσουμε να το περιστρέψουμε, θα λάβουμε μία έξοδο που περιέχει στήλες που είναι λίστες, για τις οποίες θα μάθετε περισσότερα στο Κεφάλαιο 23:\n\ndf |&gt;\n  pivot_wider(\n    names_from = measurement,\n    values_from = value\n  )\n#&gt; Warning: Values from `value` are not uniquely identified; output will contain\n#&gt; list-cols.\n#&gt; • Use `values_fn = list` to suppress this warning.\n#&gt; • Use `values_fn = {summary_fun}` to summarise duplicates.\n#&gt; • Use the following dplyr code to identify duplicates.\n#&gt;   {data} |&gt;\n#&gt;   dplyr::summarise(n = dplyr::n(), .by = c(id, measurement)) |&gt;\n#&gt;   dplyr::filter(n &gt; 1L)\n#&gt; # A tibble: 2 × 3\n#&gt;   id    bp1       bp2      \n#&gt;   &lt;chr&gt; &lt;list&gt;    &lt;list&gt;   \n#&gt; 1 A     &lt;dbl [2]&gt; &lt;dbl [1]&gt;\n#&gt; 2 B     &lt;dbl [1]&gt; &lt;dbl [1]&gt;\n\nΜιας και δεν γνωρίζετε ακόμη πώς να εργαστείτε με αυτού του είδους τα δεδομένα, θα πρέπει να ακολουθήσετε την υπόδειξη στο προειδοποιητικό μήνυμα για να καταλάβετε πού βρίσκεται το πρόβλημα:\n\ndf |&gt; \n  group_by(id, measurement) |&gt; \n  summarize(n = n(), .groups = \"drop\") |&gt; \n  filter(n &gt; 1)\n#&gt; # A tibble: 1 × 3\n#&gt;   id    measurement     n\n#&gt;   &lt;chr&gt; &lt;chr&gt;       &lt;int&gt;\n#&gt; 1 A     bp1             2\n\nΣτη συνέχεια, είναι στο χέρι σας να καταλάβετε τι πήγε στραβά με τα δεδομένα σας και είτε να διορθώσετε το πρόβλημα είτε να χρησιμοποιήσετε τις δεξιότητές σας στην ομαδοποίηση και σύνοψη για να διασφαλίσετε ότι κάθε συνδυασμός τιμών γραμμής και στήλης έχει μόνο μία γραμμή.",
    "crumbs": [
      "Η ολοκληρωμένη εικόνα",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Τακτοποίηση δεδομένων</span>"
    ]
  },
  {
    "objectID": "data-tidy.html#σύνοψη",
    "href": "data-tidy.html#σύνοψη",
    "title": "5  Τακτοποίηση δεδομένων",
    "section": "\n5.5 Σύνοψη",
    "text": "5.5 Σύνοψη\nΣε αυτό το κεφάλαιο μάθατε για τα τακτοποιημένα δεδομένα: δεδομένα που έχουν μεταβλητές στις στήλες και παρατηρήσεις σε γραμμές. Τα τακτοποιημένα δεδομένα διευκολύνουν την εργασία στο tidyverse, καθώς ακολουθούν μία συνεπή δομή κατανοητή από τις περισσότερες συναρτήσεις. Η κύρια πρόκληση είναι να μετατρέψετε τα δεδομένα από οποιαδήποτε μορφή κι αν τα λαμβάνετε σε μία τακτοποιημένη μορφή. Για το σκοπό αυτό, μάθατε για τις pivot_longer() και pivot_wider() που σας επιτρέπουν να τακτοποιήσετε αρκετά ακατάστατα σύνολα δεδομένων. Τα παραδείγματα που παρουσιάσαμε εδώ είναι μία επιλογή από αυτά από το vignette(\"pivot\", package = \"tidyr\"), οπότε αν αντιμετωπίσετε κάποιο πρόβλημα στο οποίο αυτό το κεφάλαιο δεν σας βοηθά, αυτός ο οδηγός είναι ένα καλό μέρος για να δοκιμάσετε σαν επόμενο βήμα.\nΜία άλλη πρόκληση είναι ότι, για ένα σύνολο δεδομένων, μπορεί να είναι αδύνατο να χαρακτηριστεί η μακρύτερη ή η ευρύτερη έκδοση ως “τακτοποιημένη”. Αυτό είναι εν μέρει μία αντανάκλαση του ορισμού μας για τα τακτοποιημένα δεδομένα, όπου είπαμε ότι τα τακτοποιημένα δεδομένα έχουν μία μεταβλητή σε κάθε στήλη, αλλά στην πραγματικότητα δεν ορίσαμε τι είναι μία μεταβλητή (και είναι παράδοξα δύσκολο να το κάνουμε). Είναι πολύ καλό να είστε ρεαλιστές και να ορίζετε μία μεταβλητή ως ό,τι κάνει την ανάλυσή σας πιο εύκολη. Επομένως, εάν έχετε κολλήσει στο πως θα κάνετε κάποιους υπολογισμούς, εξετάστε το ενδεχόμενο να αλλάξετε την οργάνωση των δεδομένων σας. Μην φοβάστε να τακτοποιήσετε, να μεταμορφώσετε και τακτοποιήσετε ξανά όσο χρειάζεται!\nΕάν σας άρεσε αυτό το κεφάλαιο και θέλετε να μάθετε περισσότερα για την θεωρία πίσω από όλα αυτά, μπορείτε να μάθετε περισσότερα για την ιστορία και τις θεωρητικές βάσεις στο Tidy Data που δημοσιεύτηκε στο Journal of Statistical Software.\nΤώρα που γράφετε μία σημαντική ποσότητα κώδικα R, ήρθε η ώρα να μάθετε περισσότερα σχετικά με την οργάνωση του κώδικά σας σε αρχεία και καταλόγους. Στο επόμενο κεφάλαιο, θα μάθετε τα πάντα για τα πλεονεκτήματα των αρχείων κώδικα και των R projects, καθώς και μερικά από τα πολλά εργαλεία που παρέχουν για να κάνουν τη ζωή σας πιο εύκολη.",
    "crumbs": [
      "Η ολοκληρωμένη εικόνα",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Τακτοποίηση δεδομένων</span>"
    ]
  },
  {
    "objectID": "data-tidy.html#footnotes",
    "href": "data-tidy.html#footnotes",
    "title": "5  Τακτοποίηση δεδομένων",
    "section": "",
    "text": "Το τραγούδι θα συμπεριληφθεί εφόσο ήταν στα 100 καλύτερα κάποια στιγμή το 2000 και παρακολουθείται για έως και 72 εβδομάδες μετά την εμφάνισή του.↩︎\nΘα επανέλθουμε σε αυτήν την ιδέα στο Κεφάλαιο 18.↩︎",
    "crumbs": [
      "Η ολοκληρωμένη εικόνα",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Τακτοποίηση δεδομένων</span>"
    ]
  },
  {
    "objectID": "workflow-scripts.html",
    "href": "workflow-scripts.html",
    "title": "6  Ροή εργασιών: αρχεία κώδικα και projects",
    "section": "",
    "text": "6.1 Αρχεία κώδικα\nΜέχρι στιγμής, για να εκτελείτε κώδικα χρησιμοποιείτε την κονσόλα. Αυτό είναι ένα εξαιρετικό μέρος για να ξεκινήσετε, αλλά θα διαπιστώσετε ότι η κονσόλα γεμίζει με κώδικα αρκετά γρήγορα καθώς δημιουργείτε πιο περίπλοκα γραφικά ggplot2 και μεγαλύτερες ροές dplyr. Για να δώσετε στον εαυτό σας περισσότερο χώρο για να δουλέψει, χρησιμοποιήστε το πρόγραμμα επεξεργασίας αρχείων κώδικα. Ανοίξτε το κάνοντας κλικ στο μενού Αρχεία (File), επιλέγοντας Νέο αρχείο (New File) και μετά R script (αρχείο κώδικα R) ή χρησιμοποιώντας τη συντόμευση πληκτρολογίου Cmd/Ctrl + Shift + N. Τώρα θα δείτε τέσσερα παράθυρα, όπως στο Σχήμα 6.1. Το πρόγραμμα επεξεργασίας αρχείων κώδικα είναι ένα εξαιρετικό μέρος για να πειραματιστείτε με τον κώδικά σας. Όταν θέλετε να αλλάξετε κάτι, δεν χρειάζεται να πληκτρολογήσετε ξανά τα πάντα, μπορείτε απλώς να επεξεργαστείτε το αρχείο και να το εκτελέσετε ξανά. Και αφού έχετε γράψει κώδικα που λειτουργεί και κάνει αυτό που θέλετε, μπορείτε να τον αποθηκεύσετε ως αρχείο κώδικα για να επιστρέψετε εύκολα αργότερα.\nΣχήμα 6.1: Το άνοιγμα της προβολής επεξεργασίας αρχείων κώδικα (script editor) προσθέτει ένα νέο παράθυρο στο επάνω αριστερό μέρος του RStudio.",
    "crumbs": [
      "Η ολοκληρωμένη εικόνα",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Ροή εργασιών: αρχεία κώδικα και projects</span>"
    ]
  },
  {
    "objectID": "workflow-scripts.html#αρχεία-κώδικα",
    "href": "workflow-scripts.html#αρχεία-κώδικα",
    "title": "6  Ροή εργασιών: αρχεία κώδικα και projects",
    "section": "",
    "text": "6.1.1 Εκτελώντας κώδικα\nΤο πρόγραμμα επεξεργασίας αρχείων κώδικα είναι ένα εξαιρετικό μέρος για τη δημιουργία πολύπλοκων διαγραμμάτων ggplot2 ή μεγάλων ροών χειρισμών δεδομένων με συναρτήσεις της dplyr. Το κλειδί για την αποτελεσματική χρήση του προγράμματος επεξεργασίας αρχείων κώδικα είναι να απομνημονεύσετε μία από τις πιο σημαντικές συντομεύσεις πληκτρολογίου: Cmd/Ctrl + Enter. Αυτό εκτελεί την τρέχουσα έκφραση R στην κονσόλα. Για παράδειγμα, πάρτε τον παρακάτω κώδικα.\n\nlibrary(dplyr)\nlibrary(nycflights13)\n\nnot_cancelled &lt;- flights |&gt; \n  filter(!is.na(dep_delay)█, !is.na(arr_delay))\n\nnot_cancelled |&gt; \n  group_by(year, month, day) |&gt; \n  summarize(mean = mean(dep_delay))\n\nΕάν ο κέρσορας σας βρίσκεται στο █, πατώντας Cmd/Ctrl + Enter θα εκτελεστεί η πλήρης εντολή που δημιουργεί το not_cancelled. Θα μετακινήσει επίσης τον κέρσορα στην ακόλουθη δήλωση (που ξεκινά με not_cancelled |&gt;). Αυτό καθιστά εύκολο να προχωρήσετε σε ολόκληρο το αρχείο σας πατώντας επανειλημμένα Cmd/Ctrl + Enter.\nΑντί να εκτελείτε την έκφραση του κώδικα ανά έκφραση, μπορείτε επίσης να εκτελέσετε όλον τον κώδικα σε αυτό το αρχείο σε ένα βήμα με τη συντόμευση Cmd/Ctrl + Shift + S. Με το να το κάνετε αυτό τακτικά μπορείτε να διασφαλίσετε ότι έχετε καταγράψει όλα τα σημαντικά μέρη του κώδικά σας στο αρχείο σας.\nΣας συνιστούμε να ξεκινάτε πάντα το αρχείο κώδικα σας με τα πακέτα που χρειάζεστε. Με αυτόν τον τρόπο, εάν μοιράζεστε τον κώδικα σας με άλλους, μπορούν εύκολα να δουν ποια πακέτα πρέπει να εγκαταστήσουν. Σημειώστε, ωστόσο, ότι δεν πρέπει ποτέ να συμπεριλάβετε την install.packages() σε ένα αρχείο κώδικα που μοιράζεστε. Είναι απερίσκεπτο να τους δώσετε ένα αρχείο κώδικα που θα αλλάξει κάτι στον υπολογιστή τους αν δεν είναι προσεκτικοί!\nΚαθώς θα εργάζεστε στα μελλοντικά κεφάλαια, συνιστούμε ανεπιφύλακτα να ξεκινήσετε από το πρόγραμμα επεξεργασίας αρχείων κώδικα και να εξασκήσετε τις συντομεύσεις πληκτρολογίου σας. Με τον καιρό, η αποστολή κώδικα στην κονσόλα με αυτόν τον τρόπο θα γίνει τόσο φυσιολογική που δεν θα το σκέφτεστε καν.\n\n6.1.2 Διάγνωση προβλημάτων στο RStudio\nΣτο πρόγραμμα επεξεργασίας αρχείων κώδικα, το RStudio θα επισημάνει τα συντακτικά σφάλματα με μία κόκκινη στρεβλή γραμμή και ένα σύμβολο χι στην πλαϊνή γραμμή:\n\n\n\n\n\n\n\n\nΤοποθετήστε το δείκτη του ποντικιού πάνω από το σύμβολο για να δείτε ποιο φαίνεται να είναι το πρόβλημα:\n\n\n\n\n\n\n\n\nΤο RStudio θα σας ενημερώνει επίσης για πιθανά προβλήματα:\n\n\n\n\n\n\n\n\n\n6.1.3 Αποθηκεύοντας και ονομάζοντας αρχεία\nΤο RStudio αποθηκεύει αυτόματα τα περιεχόμενα του προγράμματος επεξεργασίας αρχείων κώδικα όταν το τερματίζετε και το φορτώνει ξανά αυτόματα όταν το ανοίξετε ξανά. Ωστόσο, είναι καλή ιδέα να αποφεύγετε τα Untitled1, Untitled2, Untitled3 και ούτω καθεξής ονόματα και να αποθηκεύστε τα αρχεία κώδικα σας, δίνοντας τους ενημερωτικά ονόματα.\nΜπορεί να είναι δελεαστικό να ονομάσετε τα αρχεία σας ως code.R ή myscript.R, αλλά θα πρέπει να σκεφτείτε λίγο περισσότερο πριν επιλέξετε ένα όνομα για το αρχείο σας. Τρεις σημαντικές αρχές για την ονομασία αρχείων είναι οι εξής:\n\nΤα ονόματα αρχείων πρέπει να είναι αναγνώσιμα από τον υπολογιστή: αποφύγετε κενά, σύμβολα και ειδικούς χαρακτήρες. Μην βασίζεστε στην ευαισθησία πεζών-κεφαλαίων για να διακρίνετε αρχεία.\nΤα ονόματα αρχείων πρέπει να είναι αναγνώσιμα από τον άνθρωπο: χρησιμοποιήστε ονόματα που περιγράφουν τι υπάρχει στο αρχείο.\nΤα ονόματα αρχείων πρέπει να επιτρέπουν την ταξινόμηση: ξεκινήστε τα ονόματα αρχείων με αριθμούς, ώστε η αλφαβητική ταξινόμηση να τα βάζει με τη σειρά με την οποία χρησιμοποιούνται.\n\nΓια παράδειγμα, ας υποθέσουμε ότι έχετε τα ακόλουθα αρχεία στο φάκελο κάποιου project στο οποίο εργάζεστε.\nalternative model.R\ncode for exploratory analysis.r\nfinalreport.qmd\nFinalReport.qmd\nfig 1.png\nFigure_02.png\nmodel_first_try.R\nrun-first.r\ntemp.txt\nΕδώ υπάρχει μία σειρά από προβλήματα: είναι δύσκολο να βρείτε ποιο αρχείο να εκτελέσετε πρώτο, τα ονόματα αρχείων περιέχουν κενά, υπάρχουν δύο αρχεία με το ίδιο όνομα αλλά διαφορετική χρήση κεφαλαίων-πεζών (finalreport έναντι FinalReport[^workflow-scripts-1 ]), και ορισμένα ονόματα δεν περιγράφουν το περιεχόμενό τους (run-first και temp).\nΑκολουθεί ένας καλύτερος τρόπος για να ονομάσετε και να οργανώσετε το ίδιο σύνολο αρχείων:\n01-load-data.R\n02-exploratory-analysis.R\n03-model-approach-1.R\n04-model-approach-2.R\nfig-01.png\nfig-02.png\nreport-2022-03-20.qmd\nreport-2022-04-02.qmd\nreport-draft-notes.txt\nΗ αρίθμηση των βασικών αρχείων κώδικα καθιστά προφανές με ποια σειρά εκτελούνται και ένα συνεπές σχήμα ονοματοθεσίας καθιστά ευκολότερο να δούμε τι διαφέρει. Επιπλέον, οι εικόνες επισημαίνονται με παρόμοιο τρόπο, οι αναφορές διακρίνονται από τις ημερομηνίες που περιλαμβάνονται στα ονόματα των αρχείων και το temp μετονομάστηκε σε report-draft-notes για να περιγράψει καλύτερα τα περιεχόμενά του. Εάν έχετε πολλά αρχεία σε έναν κατάλογο, συνιστάται να πάτε την οργάνωση ένα βήμα παραπέρα και να τοποθετήσετε διαφορετικούς τύπους αρχείων (αρχεία κώδικα, εικόνες κ.λπ.) σε διαφορετικούς καταλόγους (ή αλλιώς μονοπάτια).",
    "crumbs": [
      "Η ολοκληρωμένη εικόνα",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Ροή εργασιών: αρχεία κώδικα και projects</span>"
    ]
  },
  {
    "objectID": "workflow-scripts.html#projects",
    "href": "workflow-scripts.html#projects",
    "title": "6  Ροή εργασιών: αρχεία κώδικα και projects",
    "section": "\n6.2 Projects",
    "text": "6.2 Projects\nΜία μέρα, θα χρειαστεί να αφήσετε την R, να κάνετε κάτι άλλο και να επιστρέψετε στην ανάλυσή σας αργότερα. Μία μέρα, θα εργάζεστε σε πολλαπλές αναλύσεις ταυτόχρονα και θέλετε να τις κρατήσετε ξεχωριστές. Μία μέρα, θα χρειαστεί να φέρετε δεδομένα από τον έξω κόσμο στην R και να στείλετε αριθμητικά αποτελέσματα και εικόνες από την R πίσω στον κόσμο.\nΓια να χειριστείτε αυτές τις πραγματικές καταστάσεις, πρέπει να πάρετε δύο αποφάσεις:\n\nΠοια είναι η πηγή της αλήθειας σας; Τι θα αποθηκεύσετε ως το τελικό αρχείο που εξηγεί τι συνέβη;\nΠού θα βρίσκεται η ανάλυσή σας;\n\n\n6.2.1 Ποια είναι η πηγή της αλήθειας σας;\nΩς αρχάριος, είναι εντάξει να βασίζεστε στο τρέχον περιβάλλον σας (Environment) ώστε να περιέχει όλα τα αντικείμενα που έχετε δημιουργήσει στην ανάλυσή σας. Ωστόσο, για να διευκολύνετε την εργασία σε μεγαλύτερα projects ή τη συνεργασία με άλλους, η πηγή της αλήθειας σας θα πρέπει να είναι τα αρχεία κώδικα R. Με αυτά (και τα αρχεία δεδομένων σας), μπορείτε να αναδημιουργήσετε το περιβάλλον. Μόνο με το περιβάλλον σας, είναι πολύ πιο δύσκολο να αναδημιουργήσετε τα αρχεία κώδικα σας: είτε θα πρέπει να πληκτρολογήσετε ξανά πολύ κώδικα μνημονικά (και αναπόφευκτα να κάνετε λάθη στην πορεία) είτε θα πρέπει να βρείτε με προσοχή το ιστορικό σας από την R.\nΓια να διατηρήσετε τα αρχεία κώδικα R ως την πηγή της αλήθειας για την ανάλυσή σας, συνιστούμε ιδιαίτερα να δώσετε εντολή στο RStudio να μην διατηρεί τον χώρο εργασίας σας μεταξύ των περιόδων σύνδεσης. Μπορείτε να το κάνετε είτε εκτελώντας το usethis::use_blank_slate()1 είτε μιμούμενοι τις επιλογές που εμφανίζονται στο Σχήμα 6.2. Αυτό θα σας ταλαιπωρήσει σύντομα, καθώς τώρα όταν κάνετε επανεκκίνηση του RStudio, δεν θα θυμάται πλέον τον κώδικα που εκτελέσατε την τελευταία φορά, ούτε τα αντικείμενα που δημιουργήσατε, ούτε τα σύνολα δεδομένων που διαβάσατε θα είναι διαθέσιμα για χρήση. Αλλά αυτή η βραχυπρόθεσμη δυσκολία, σας γλιτώνει από μακροπρόθεσμη αγωνία γιατί σας αναγκάζει να καταγράψετε όλες τις σημαντικές διαδικασίες στον κώδικά σας. Δεν υπάρχει τίποτα χειρότερο από το να ανακαλύψετε τρεις μήνες μετά ότι έχετε αποθηκεύσει μόνο τα αποτελέσματα ενός σημαντικού υπολογισμού στο περιβάλλον σας και όχι τον ίδιο τον υπολογισμό στον κώδικά σας.\n\n\n\n\n\n\n\nΣχήμα 6.2: Αντιγράψτε αυτές τις επιλογές στο δικό σας RStudio έτσι ώστε κάθε συνεδρία, κατά το άνοιγμα του RStudio, να ξεκινά απο την αρχή.\n\n\n\n\nΥπάρχει ένας υπέροχος συνδυασμός συντομεύσεων που δουλεύουν καλά μαζί για να βεβαιωθείτε ότι έχετε καταγράψει τα σημαντικά μέρη του κώδικά σας στο πρόγραμμα επεξεργασίας:\n\nΠατήστε Cmd/Ctrl + Shift + 0/F10 για επανεκκίνηση της R.\nΠατήστε Cmd/Ctrl + Shift + S για να εκτελέσετε ξανά το τρέχον αρχείο κώδικα.\n\nΧρησιμοποιούμε συλλογικά αυτό το μοτίβο εκατοντάδες φορές την εβδομάδα.\nΕναλλακτικά, εάν δεν χρησιμοποιείτε συντομεύσεις πληκτρολογίου, μπορείτε να μεταβείτε στο Session &gt; Restart R και, στη συνέχεια, να επισημάνετε και να εκτελέσετε ξανά το τρέχον αρχείο κώδικα\n\n\n\n\n\n\nΔιακομιστής RStudio\n\n\n\nΕάν χρησιμοποιείτε διακομιστή (server) RStudio, η συνεδρία R δεν επανεκκινείται ποτέ από προεπιλογή. Όταν κλείνετε την καρτέλα του διακομιστή RStudio, μπορεί να νιώθετε σαν να κλείνετε την R, αλλά ο διακομιστής την διατηρεί στην πραγματικότητα σε λειτουργία στο παρασκήνιο. Την επόμενη φορά που θα επιστρέψετε, θα είστε ακριβώς στο ίδιο μέρος που φύγατε. Αυτό καθιστά ακόμη πιο σημαντική την τακτική επανεκκίνηση της R, έτσι ώστε να ξεκινάτε εκ νέου.\n\n\n\n6.2.2 Πού θα βρίσκεται η ανάλυσή σας;\nΗ R έχει μία ισχυρή έννοια, αυτή του μονοπατιού εργασίας. Αυτό είναι το μέρος όπου η R αναζητά τα αρχεία που της ζητάτε να φορτώσει και που τοποθετεί τα αρχεία που της ζητήσετε να αποθηκεύσει. Το RStudio εμφανίζει το τρέχον μονοπάτι εργασίας σας στο επάνω μέρος της κονσόλας:\n\n\n\n\n\n\n\n\nΚαι αυτό μπορείτε να το εκτυπώσετε σε κώδικα R εκτελώντας το getwd():\n\ngetwd()\n#&gt; [1] \"/Users/hadley/Documents/r4ds\"\n\nΣε αυτήν την περίοδο λειτουργίας της R, το τρέχον μονοπάτι εργασίας (σκεφτείτε το ως “home”) βρίσκεται στο φάκελο Documents του Hadley, σε έναν υποφάκελο που ονομάζεται r4ds. Αυτός ο κώδικας θα επιστρέψει διαφορετικό αποτέλεσμα όταν τον εκτελέσετε, καθώς ο υπολογιστής σας έχει διαφορετική δομή καταλόγου από αυτή του Hadley!\nΩς αρχάριος χρήστης της R, είναι εντάξει να χρησιμοποιήσετε ως κατάλογο εργασίας σας τον αρχικό σας κατάλογο (home directory), τον κατάλογο εγγράφων ή οποιοσδήποτε άλλο περίεργο κατάλογο στον υπολογιστή σας. Ωστόσο, έχετε δει πλέον αρκετά κεφάλαια αυτού του βιβλίου και δεν είστε πλέον αρχάριοι. Πολύ σύντομα θα πρέπει να εξελιχθείτε ώστε να οργανώνετε τα projects σας σε καταλόγους και, όταν εργάζεστε σε ένα project, να ορίζετε τον κατάλογο εργασίας της R ως τον σχετικό κατάλογο.\nΜπορείτε να ορίσετε τον κατάλογο εργασίας μέσα από την R, αλλά εμείς δεν το συνιστούμε:\n\nsetwd(\"/path/to/my/CoolProject\")\n\nΥπάρχει καλύτερος τρόπος. ένας τρόπος που σας βάζει επίσης στο δρόμο για τη διαχείριση της εργασίας σας στην R σαν ειδικός. Αυτός ο τρόπος είναι το RStudio project.\n\n6.2.3 RStudio projects\nΗ διατήρηση όλων των αρχείων που σχετίζονται με ένα συγκεκριμένο project (δεδομένα εισόδου, αρχεία κώδικα R, αναλυτικά αποτελέσματα και εικόνες) μαζί σε έναν κατάλογο είναι μία τόσο καλή και κοινή πρακτική που το RStudio έχει ενσωματωμένη υποστήριξη για αυτό μέσω των projects. Ας δημιουργήσουμε ένα project για να το χρησιμοποιήσετε ενώ εργάζεστε στο υπόλοιπο αυτού του βιβλίου. Κάντε κλικ στο File &gt; New Project και, στη συνέχεια, ακολουθήστε τα βήματα που παρουσιάζονται στο Σχήμα 6.3.\n\n\n\n\n\n\n\nΣχήμα 6.3: Για να δημιουργήσετε New Project: (επάνω) κάντε πρώτα κλικ στο New Directory, μετά (στη μέση) κάντε κλικ στο New Project, μετά (κάτω) συμπληρώστε το όνομα του καταλόγου (project), επιλέξτε έναν καλό υποκατάλογο για να αποθηκευτεί και κάντε κλικ στο Create project\n\n\n\n\nΟνομάστε το project σας r4ds και σκεφτείτε προσεκτικά σε ποιον υποκατάλογο τοποθετείτε το project. Εάν δεν το αποθηκεύσετε σε κάποιο λογικό μέρος, θα είναι δύσκολο να το βρείτε στο μέλλον!\nΜόλις ολοκληρωθεί αυτή η διαδικασία, θα λάβετε ένα νέο RStudio project, μόνο για αυτό το βιβλίο. Ελέγξτε ότι το “home” του project σας είναι το τρέχον μονοπάτι εργασίας:\n\ngetwd()\n#&gt; [1] /Users/hadley/Documents/r4ds\n\nΤώρα πληκτρολογήστε τις ακόλουθες εντολές στο πρόγραμμα επεξεργασίας αρχείων κώδικα και αποθηκεύστε το αρχείο, ονομάζοντάς το “diamonds.R”. Στη συνέχεια, δημιουργήστε έναν νέο φάκελο που ονομάζεται “data”. Μπορείτε να το κάνετε αυτό κάνοντας κλικ στο κουμπί “Νέος φάκελος” (“New Folder”) στο παράθυρο των Αρχείων (Files) στο RStudio. Τέλος, εκτελέστε το πλήρες αρχείο κώδικα που θα αποθηκεύσει ένα αρχείο PNG και CSV στο κατάλογο (φάκελο) του project σας. Μην ανησυχείτε για τις λεπτομέρειες, θα τις μάθετε αργότερα στο βιβλίο.\n\nlibrary(tidyverse)\n\nggplot(diamonds, aes(x = carat, y = price)) + \n  geom_hex()\nggsave(\"diamonds.png\")\n\nwrite_csv(diamonds, \"data/diamonds.csv\")\n\nΚλείστε το RStudio. Επιθεωρήστε το φάκελο που σχετίζεται με το project σας — παρατηρήστε το αρχείο .Rproj. Κάντε διπλό κλικ σε αυτό το αρχείο για να ανοίξετε ξανά το project. Παρατηρήστε ότι επιστρέφετε στο σημείο που σταματήσατε: είναι το ίδιο μονοπάτι εργασίας, ενώ το ιστορικό εντολών και όλα τα αρχεία στα οποία εργαζόσασταν εξακολουθούν να είναι ανοιχτά. Επειδή ακολουθήσατε τις παραπάνω οδηγίες μας, θα έχετε, ωστόσο, ένα εντελώς φρέσκο περιβάλλον.\nΜε τον αγαπημένο σας, ειδικά για το λειτουργικό σας σύστημα τρόπο, αναζητήστε τον υπολογιστή σας για «diamonds.png» και θα βρείτε το PNG (καμία έκπληξη) αλλά και το αρχείο κώδικα που το δημιούργησε («diamonds.R»). Αυτή είναι μία τεράστια νίκη! Μία μέρα, θα θελήσετε να δημιουργήσετε ξανά μία εικόνα ή απλά να καταλάβετε από πού προήλθε. Εάν αποθηκεύετε αυστηρά εικόνες σε αρχεία χρησιμοποιώντας κώδικα R και ποτέ με το ποντίκι ή το πρόχειρο (clipboard), θα μπορείτε να αναπαράγετε παλιά δουλειά με ευκολία!\n\n6.2.4 Σχετικά και απόλυτα μονοπάτια\nΜόλις είστε μέσα σε ένα project, θα πρέπει να χρησιμοποιείτε μόνο σχετικά μονοπάτια και όχι απόλυτα. Ποια είναι η διαφορά; Ένα σχετικό μονοπάτι είναι σχετικό με τον κατάλογο εργασίας, δηλαδή το σπίτι του project. Όταν ο Hadley έγραψε data/diamonds.csv παραπάνω, αυτό το μονοπάτι ήταν μία συντόμευση για το /Users/hadley/Documents/r4ds/data/diamonds.csv. Αλλά είναι σημαντικό, εάν η Mine έτρεχε αυτόν τον κωδικό στον υπολογιστή της, αυτό το μονοπάτι θα έδειχνε στο /Users/Mine/Documents/r4ds/data/diamonds.csv. Αυτός είναι ο λόγος για τον οποίο τα σχετικά μονοπάτια είναι σημαντικά: θα λειτουργούν ανεξάρτητα από το πού καταλήγει ο φάκελος του project R.\nΤα απόλυτα μονοπάτια οδηγούν στο ίδιο μέρος ανεξάρτητα από το μονοπάτι εργασίας σας. Επίσης, φαίνονται λίγο διαφορετικά ανάλογα με το λειτουργικό σας σύστημα. Στα Windows ξεκινούν με ένα γράμμα μονάδας δίσκου (π.χ. C:) ή δύο ανάστροφες κάθετες (π.χ., \\\\servername), ενώ στα Mac/Linux ξεκινούν με μία κάθετο “/” (π.χ. /users/hadley ). Δεν πρέπει ποτέ να χρησιμοποιείτε απόλυτες διαδρομές στα αρχεία κώδικα σας, γιατί εμποδίζουν την κοινή χρήση: κανένας άλλος δεν θα έχει ακριβώς την ίδια διαμόρφωση καταλόγου με εσάς.\nΥπάρχει ακόμη μία σημαντική διαφορά μεταξύ των λειτουργικών συστημάτων: το πώς διαχωρίζετε τα στοιχεία του μονοπατιού. Τα Mac και Linux χρησιμοποιούν κάθετες (π.χ. data/diamonds.csv), ενώ τα Windows χρησιμοποιούν ανάστροφες κάθετες (π.χ. data\\diamonds.csv). Η R μπορεί να λειτουργήσει με οποιονδήποτε τύπο (ανεξάρτητα από την πλατφόρμα που χρησιμοποιείτε αυτήν τη στιγμή), αλλά δυστυχώς, οι ανάστροφες κάθετες σημαίνουν κάτι ιδιαίτερο στην R, και για να λάβετε μία μόνο ανάστροφη κάθετο στη διαδρομή, πρέπει να πληκτρολογήσετε δύο! Αυτό δημιουργεί σύγχυση, γι’ αυτό συνιστούμε να χρησιμοποιείτε πάντα το στυλ των Linux/Mac με κάθετες προς τα εμπρός.",
    "crumbs": [
      "Η ολοκληρωμένη εικόνα",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Ροή εργασιών: αρχεία κώδικα και projects</span>"
    ]
  },
  {
    "objectID": "workflow-scripts.html#ασκήσεις",
    "href": "workflow-scripts.html#ασκήσεις",
    "title": "6  Ροή εργασιών: αρχεία κώδικα και projects",
    "section": "\n6.3 Ασκήσεις",
    "text": "6.3 Ασκήσεις\n\nΜεταβείτε στον λογαριασμό Twitter RStudio Tips, https://twitter.com/rstudiotips και βρείτε μία συμβουλή που σας φαίνεται ενδιαφέρουσα. Εξασκηθείτε στη χρήση της!\nΠοια άλλα κοινά λάθη θα αναφέρει το RStudio diagnostics; Διαβάστε το https://support.posit.co/hc/en-us/articles/205753617-Code-Diagnostics για να μάθετε.",
    "crumbs": [
      "Η ολοκληρωμένη εικόνα",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Ροή εργασιών: αρχεία κώδικα και projects</span>"
    ]
  },
  {
    "objectID": "workflow-scripts.html#σύνοψη",
    "href": "workflow-scripts.html#σύνοψη",
    "title": "6  Ροή εργασιών: αρχεία κώδικα και projects",
    "section": "\n6.4 Σύνοψη",
    "text": "6.4 Σύνοψη\nΣε αυτό το κεφάλαιο, μάθατε πώς να οργανώνετε τον κώδικα R σε αρχεία κώδικα (μεμονωμένα αρχεία) και projects (καταλόγους ή φακέλους). Όπως και οι οδηγίες για την οργάνωση του τρόπου γραφής του κώδικα σας, αυτό μπορεί να φαίνεται σαν ταλαιπωρία στην αρχή. Ωστόσο, καθώς συγκεντρώνετε περισσότερο κώδικα σε πολλαπλά projects, θα μάθετε να εκτιμάτε πώς λίγη οργάνωση στην αρχή μπορεί να σας εξοικονομήσει πολύ χρόνο στην πορεία.\nΣυνοπτικά, τα αρχεία κώδικα και τα projects σας προσφέρουν μία σταθερή ροή εργασίας που θα σας εξυπηρετήσει στο μέλλον:\n\nΔημιουργήστε ένα project RStudio για κάθε έργο ανάλυσης δεδομένων.\nΑποθηκεύστε τα αρχεία κώδικα σας (με ενημερωτικά ονόματα) στο project, επεξεργαστείτε τα, εκτελέστε τα σε κομμάτια ή ως σύνολο. Κάντε συχνά επανεκκίνηση της R για να βεβαιωθείτε ότι έχετε καταγράψει τα πάντα στα σενάρια σας.\nΧρησιμοποιήστε πάντα μόνο σχετικά μονοπάτια, όχι απόλυτα.\n\nΤότε όλα όσα χρειάζεστε είναι σε ένα μέρος και καθαρά διαχωρισμένα από όλα τα άλλα projects στα οποία εργάζεστε.\nΜέχρι στιγμής, έχουμε εργαστεί με σύνολα δεδομένων ομαδοποιημένα μέσα σε πακέτα R. Αυτό διευκολύνει την εξάσκηση σε προπαρασκευασμένα δεδομένα, αλλά προφανώς τα δεδομένα σας δεν θα είναι διαθέσιμα με αυτόν τον τρόπο. Έτσι, στο επόμενο κεφάλαιο, θα μάθετε πώς να φορτώνετε δεδομένα από το δίσκο στη συνεδρία R χρησιμοποιώντας το πακέτο readr.",
    "crumbs": [
      "Η ολοκληρωμένη εικόνα",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Ροή εργασιών: αρχεία κώδικα και projects</span>"
    ]
  },
  {
    "objectID": "workflow-scripts.html#footnotes",
    "href": "workflow-scripts.html#footnotes",
    "title": "6  Ροή εργασιών: αρχεία κώδικα και projects",
    "section": "",
    "text": "Εάν δεν έχετε εγκαταστήσει το πακέτο usethis, μπορείτε να το εγκαταστήσετε με την εντολή install.packages(\"usethis\").↩︎",
    "crumbs": [
      "Η ολοκληρωμένη εικόνα",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Ροή εργασιών: αρχεία κώδικα και projects</span>"
    ]
  },
  {
    "objectID": "data-import.html",
    "href": "data-import.html",
    "title": "7  Εισαγωγή δεδομένων",
    "section": "",
    "text": "7.1 Εισαγωγή\nΗ εργασία με δεδομένα που παρέχονται από πακέτα της R είναι ένας πολύ καλός τρόπος για να μάθετε τα εργαλεία επιστήμης δεδομένων, αλλά κάποια στιγμή θα θέλετε να εφαρμόσετε ό,τι έχετε μάθει στα δικά σας δεδομένα. Σε αυτό το κεφάλαιο, θα μάθετε τα βασικά για την ανάγνωση αρχείων δεδομένων στην R.\nΣυγκεκριμένα, αυτό το κεφάλαιο θα επικεντρωθεί στην ανάγνωση ορθογώνιων αρχείων απλού κειμένου. Θα ξεκινήσουμε με πρακτικές συμβουλές για το χειρισμό διαφόρων στοιχείων, όπως ονόματα στηλών, τύποι και ελλιπή δεδομένα. Στη συνέχεια θα μάθετε για την ανάγνωση δεδομένων από πολλά αρχεία ταυτόχρονα και την εγγραφή δεδομένων από την R σε ένα αρχείο. Τέλος, θα μάθετε πώς να δημιουργείτε τα δικά σας πλαίσια δεδομένων στην R.",
    "crumbs": [
      "Η ολοκληρωμένη εικόνα",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Εισαγωγή δεδομένων</span>"
    ]
  },
  {
    "objectID": "data-import.html#εισαγωγή",
    "href": "data-import.html#εισαγωγή",
    "title": "7  Εισαγωγή δεδομένων",
    "section": "",
    "text": "7.1.1 Προαπαιτούμενα\nΣε αυτό το κεφάλαιο, θα μάθετε πώς να διαβάζετε απλά αρχεία στην R με το πακέτο readr, το οποίο αποτελεί μέρος του βασικού tidyverse.\n\nlibrary(tidyverse)",
    "crumbs": [
      "Η ολοκληρωμένη εικόνα",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Εισαγωγή δεδομένων</span>"
    ]
  },
  {
    "objectID": "data-import.html#ανάγνωση-δεδομένων-από-ένα-αρχείο",
    "href": "data-import.html#ανάγνωση-δεδομένων-από-ένα-αρχείο",
    "title": "7  Εισαγωγή δεδομένων",
    "section": "\n7.2 Ανάγνωση δεδομένων από ένα αρχείο",
    "text": "7.2 Ανάγνωση δεδομένων από ένα αρχείο\nΑρχικά, θα επικεντρωθούμε στον πιο συνηθισμένο ορθογώνιο τύπο αρχείου δεδομένων: το CSV, που είναι συντομογραφία για τιμές διαχωρισμένες με κόμμα (comma separated values). Παρακάτω βλέπουμε πώς μοιάζει ένα απλό αρχείο CSV. Η πρώτη γραμμή, που συνήθως ονομάζεται γραμμή κεφαλίδας, δίνει τα ονόματα των στηλών και οι ακόλουθες έξι γραμμές παρέχουν τα δεδομένα. Οι στήλες οριοθετούνται με κόμμα.\n\nStudent ID,Full Name,favourite.food,mealPlan,AGE\n1,Sunil Huffmann,Strawberry yoghurt,Lunch only,4\n2,Barclay Lynn,French fries,Lunch only,5\n3,Jayendra Lyne,N/A,Breakfast and lunch,7\n4,Leon Rossini,Anchovies,Lunch only,\n5,Chidiegwu Dunkel,Pizza,Breakfast and lunch,five\n6,Güvenç Attila,Ice cream,Lunch only,6\n\nΟ Πίνακας 7.1 δείχνει μία αναπαράσταση των ίδιων δεδομένων ως πίνακα.\n\n\n\nΠίνακας 7.1: Data from the students.csv file as a table.\n\n\n\n\n\n\n\n\n\n\n\nStudent ID\nFull Name\nfavourite.food\nmealPlan\nAGE\n\n\n\n1\nSunil Huffmann\nStrawberry yoghurt\nLunch only\n4\n\n\n2\nBarclay Lynn\nFrench fries\nLunch only\n5\n\n\n3\nJayendra Lyne\nN/A\nBreakfast and lunch\n7\n\n\n4\nLeon Rossini\nAnchovies\nLunch only\nNA\n\n\n5\nChidiegwu Dunkel\nPizza\nBreakfast and lunch\nfive\n\n\n6\nGüvenç Attila\nIce cream\nLunch only\n6\n\n\n\n\n\n\n\n\nΜπορούμε να διαβάσουμε αυτό το αρχείο στην R χρησιμοποιώντας την read_csv(). Το πρώτο όρισμα είναι και το πιο σημαντικό: το μονοπάτι προς το αρχείο. Μπορείτε να φανταστείτε το μονοπάτι ως τη διεύθυνση του αρχείου: το αρχείο ονομάζεται students.csv και βρίσκεται στο φάκελο data.\n\nstudents &lt;- read_csv(\"data/students.csv\")\n#&gt; Rows: 6 Columns: 5\n#&gt; ── Column specification ─────────────────────────────────────────────────────\n#&gt; Delimiter: \",\"\n#&gt; chr (4): Full Name, favourite.food, mealPlan, AGE\n#&gt; dbl (1): Student ID\n#&gt; \n#&gt; ℹ Use `spec()` to retrieve the full column specification for this data.\n#&gt; ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\nΟ παραπάνω κώδικας θα λειτουργήσει εάν έχετε το αρχείο students.csv μέσα σε έναν φάκελο που ονομάζεται data στο project σας. Μπορείτε να κατεβάσετε το αρχείο students.csv από το https://pos.it/r4ds-students-csv ή μπορείτε να το διαβάσετε απευθείας από αυτήν τη διεύθυνση URL με:\n\nstudents &lt;- read_csv(\"https://pos.it/r4ds-students-csv\")\n\nΌταν εκτελείτε την read_csv(), εκτυπώνεται ένα μήνυμα που σας λέει τον αριθμό των γραμμών και των στηλών των δεδομένων, τον οριοθέτη που χρησιμοποιήθηκε και τις προδιαγραφές στηλών (ονόματα στηλών που οργανώνονται ανάλογα με τον τύπο δεδομένων που περιέχει η στήλη). Εκτυπώνει επίσης ορισμένες πληροφορίες σχετικά με την ανάκτηση της πλήρους προδιαγραφής των στηλών, καθώς και τον τρόπο σίγασης αυτού του μηνύματος. Αυτό το μήνυμα είναι αναπόσπαστο μέρος του πακέτου readr και θα επιστρέψουμε σε αυτό στην Ενότητα 7.3.\n\n7.2.1 Μία πρακτική συμβουλή\nΜόλις διαβάσετε δεδομένα, το πρώτο βήμα συνήθως περιλαμβάνει το μετασχηματισμό τους με κάποιο τρόπο για να διευκολύνετε την εργασία σας στην υπόλοιπη ανάλυσή σας. Ας ρίξουμε μία άλλη ματιά στα δεδομένα students έχοντας αυτό κατά νου.\n\nstudents\n#&gt; # A tibble: 6 × 5\n#&gt;   `Student ID` `Full Name`      favourite.food     mealPlan            AGE  \n#&gt;          &lt;dbl&gt; &lt;chr&gt;            &lt;chr&gt;              &lt;chr&gt;               &lt;chr&gt;\n#&gt; 1            1 Sunil Huffmann   Strawberry yoghurt Lunch only          4    \n#&gt; 2            2 Barclay Lynn     French fries       Lunch only          5    \n#&gt; 3            3 Jayendra Lyne    N/A                Breakfast and lunch 7    \n#&gt; 4            4 Leon Rossini     Anchovies          Lunch only          &lt;NA&gt; \n#&gt; 5            5 Chidiegwu Dunkel Pizza              Breakfast and lunch five \n#&gt; 6            6 Güvenç Attila    Ice cream          Lunch only          6\n\nΣτη στήλη favourite.food, υπάρχουν διάφορα τρόφιμα και, στη συνέχεια, η συμβολοσειρά χαρακτήρων N/A, η οποία θα έπρεπε να ήταν ένα πραγματικό NA, το οποίο η R θα αναγνωρίσει ως “μη διαθέσιμη τιμή”. Αυτό είναι κάτι που μπορούμε να αντιμετωπίσουμε χρησιμοποιώντας το όρισμα na. Από προεπιλογή, η read_csv() αναγνωρίζει μόνο κενές συμβολοσειρές (\"\") σε αυτό το σύνολο δεδομένων ως NAs, ενώ εμείς θέλουμε να αναγνωρίζει επίσης τη συμβολοσειρά χαρακτήρων \"N/A\".\n\nstudents &lt;- read_csv(\"data/students.csv\", na = c(\"N/A\", \"\"))\n\nstudents\n#&gt; # A tibble: 6 × 5\n#&gt;   `Student ID` `Full Name`      favourite.food     mealPlan            AGE  \n#&gt;          &lt;dbl&gt; &lt;chr&gt;            &lt;chr&gt;              &lt;chr&gt;               &lt;chr&gt;\n#&gt; 1            1 Sunil Huffmann   Strawberry yoghurt Lunch only          4    \n#&gt; 2            2 Barclay Lynn     French fries       Lunch only          5    \n#&gt; 3            3 Jayendra Lyne    &lt;NA&gt;               Breakfast and lunch 7    \n#&gt; 4            4 Leon Rossini     Anchovies          Lunch only          &lt;NA&gt; \n#&gt; 5            5 Chidiegwu Dunkel Pizza              Breakfast and lunch five \n#&gt; 6            6 Güvenç Attila    Ice cream          Lunch only          6\n\nΜπορεί επίσης να παρατηρήσετε ότι οι στήλες Student ID και Full Name περιβάλλονται από backticks. Αυτό συμβαίνει επειδή περιέχουν κενά, παραβιάζοντας τους συνήθεις κανόνες της R για τα επιτρεπτά ονόματα μεταβλητών - αυτά είναι μη συντακτικά ονόματα. Για να αναφερθείτε σε αυτές τις μεταβλητές, πρέπει να τις περιβάλλετε με `:\n\nstudents |&gt; \n  rename(\n    student_id = `Student ID`,\n    full_name = `Full Name`\n  )\n#&gt; # A tibble: 6 × 5\n#&gt;   student_id full_name        favourite.food     mealPlan            AGE  \n#&gt;        &lt;dbl&gt; &lt;chr&gt;            &lt;chr&gt;              &lt;chr&gt;               &lt;chr&gt;\n#&gt; 1          1 Sunil Huffmann   Strawberry yoghurt Lunch only          4    \n#&gt; 2          2 Barclay Lynn     French fries       Lunch only          5    \n#&gt; 3          3 Jayendra Lyne    &lt;NA&gt;               Breakfast and lunch 7    \n#&gt; 4          4 Leon Rossini     Anchovies          Lunch only          &lt;NA&gt; \n#&gt; 5          5 Chidiegwu Dunkel Pizza              Breakfast and lunch five \n#&gt; 6          6 Güvenç Attila    Ice cream          Lunch only          6\n\nΜία εναλλακτική προσέγγιση είναι να χρησιμοποιήσετε τη συνάρτηση janitor::clean_names() για να χρησιμοποιήσετε κάποιους ευρετικούς κανόνες για να αντικαταστήσετε τα κενά με κάτω παύλες (snake case)1.\n\nstudents |&gt; janitor::clean_names()\n#&gt; # A tibble: 6 × 5\n#&gt;   student_id full_name        favourite_food     meal_plan           age  \n#&gt;        &lt;dbl&gt; &lt;chr&gt;            &lt;chr&gt;              &lt;chr&gt;               &lt;chr&gt;\n#&gt; 1          1 Sunil Huffmann   Strawberry yoghurt Lunch only          4    \n#&gt; 2          2 Barclay Lynn     French fries       Lunch only          5    \n#&gt; 3          3 Jayendra Lyne    &lt;NA&gt;               Breakfast and lunch 7    \n#&gt; 4          4 Leon Rossini     Anchovies          Lunch only          &lt;NA&gt; \n#&gt; 5          5 Chidiegwu Dunkel Pizza              Breakfast and lunch five \n#&gt; 6          6 Güvenç Attila    Ice cream          Lunch only          6\n\nΜία άλλη κοινή εργασία μετά την ανάγνωση δεδομένων είναι η εξέταση του τύπου των μεταβλητών. Για παράδειγμα, το meal_plan είναι μία κατηγορική μεταβλητή με ένα γνωστό σύνολο πιθανών τιμών, η οποία στην R θα πρέπει να αντιπροσωπεύεται ως παράγοντας:\n\nstudents |&gt;\n  janitor::clean_names() |&gt;\n  mutate(meal_plan = factor(meal_plan))\n#&gt; # A tibble: 6 × 5\n#&gt;   student_id full_name        favourite_food     meal_plan           age  \n#&gt;        &lt;dbl&gt; &lt;chr&gt;            &lt;chr&gt;              &lt;fct&gt;               &lt;chr&gt;\n#&gt; 1          1 Sunil Huffmann   Strawberry yoghurt Lunch only          4    \n#&gt; 2          2 Barclay Lynn     French fries       Lunch only          5    \n#&gt; 3          3 Jayendra Lyne    &lt;NA&gt;               Breakfast and lunch 7    \n#&gt; 4          4 Leon Rossini     Anchovies          Lunch only          &lt;NA&gt; \n#&gt; 5          5 Chidiegwu Dunkel Pizza              Breakfast and lunch five \n#&gt; 6          6 Güvenç Attila    Ice cream          Lunch only          6\n\nΣημειώστε ότι οι τιμές στη μεταβλητή meal_plan έχουν παραμείνει ίδιες, αλλά ο τύπος της μεταβλητής που υποδεικνύεται κάτω από το όνομα της μεταβλητής έχει αλλάξει από χαρακτήρα (&lt;chr&gt;) σε παράγοντα (&lt;fct&gt;). Θα μάθετε περισσότερα σχετικά με τους παράγοντες στο Κεφάλαιο 16.\nΠροτού αναλύσετε αυτά τα δεδομένα, θα πρέπει πιθανώς να διορθώσετε τις στήλες age και id. Επί του παρόντος, η age είναι μία μεταβλητή χαρακτήρων επειδή μία από τις παρατηρήσεις πληκτρολογείται ως five αντί για το αριθμητικό 5. Θα συζητήσουμε τις λεπτομέρειες της επίλυσης αυτού του ζητήματος στο Κεφάλαιο 20.\n\nstudents &lt;- students |&gt;\n  janitor::clean_names() |&gt;\n  mutate(\n    meal_plan = factor(meal_plan),\n    age = parse_number(if_else(age == \"five\", \"5\", age))\n  )\n\nstudents\n#&gt; # A tibble: 6 × 5\n#&gt;   student_id full_name        favourite_food     meal_plan             age\n#&gt;        &lt;dbl&gt; &lt;chr&gt;            &lt;chr&gt;              &lt;fct&gt;               &lt;dbl&gt;\n#&gt; 1          1 Sunil Huffmann   Strawberry yoghurt Lunch only              4\n#&gt; 2          2 Barclay Lynn     French fries       Lunch only              5\n#&gt; 3          3 Jayendra Lyne    &lt;NA&gt;               Breakfast and lunch     7\n#&gt; 4          4 Leon Rossini     Anchovies          Lunch only             NA\n#&gt; 5          5 Chidiegwu Dunkel Pizza              Breakfast and lunch     5\n#&gt; 6          6 Güvenç Attila    Ice cream          Lunch only              6\n\nΜία νέα συνάρτηση εδώ είναι η if_else(), η οποία διαθέτει τρία ορίσματα. Το πρώτο όρισμα test πρέπει να είναι ένα λογικό διάνυσμα. Το αποτέλεσμα θα περιέχει την τιμή του δεύτερου ορίσματος, yes, όταν το test είναι TRUE και την τιμή του τρίτου ορίσματος, no, όταν είναι FALSE. Εδώ λέμε αν η μεταβλητή age είναι η συμβολοσειρά χαρακτήρων \"five\", κάνε την \"5\" και, αν όχι, άφησέ την ως την αντίστοιχη τιμή της age. Θα μάθετε περισσότερα για την if_else() και τα λογικά διανύσματα στο Κεφάλαιο 12.\n\n7.2.2 Άλλα ορίσματα\nΥπάρχουν μερικά άλλα σημαντικά ορίσματα που πρέπει να αναφέρουμε και θα είναι πιο εύκολο να τα δείξουμε αν πρώτα σας δείξουμε ένα εύχρηστο κόλπο: η read_csv() μπορεί να διαβάσει συμβολοσειρές κειμένου που έχετε δημιουργήσει και μορφοποιήσει ως αρχείο CSV:\n\nread_csv(\n  \"a,b,c\n  1,2,3\n  4,5,6\"\n)\n#&gt; # A tibble: 2 × 3\n#&gt;       a     b     c\n#&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n#&gt; 1     1     2     3\n#&gt; 2     4     5     6\n\nΣυνήθως, η read_csv() χρησιμοποιεί την πρώτη γραμμή των δεδομένων ως ονόματα των στηλών, κάτι που αποτελεί μία πολύ κοινή πρακτική. Ωστόσο, δεν είναι ασυνήθιστο να περιλαμβάνονται μερικές γραμμές μεταδεδομένων στην κορυφή του αρχείου. Μπορείτε να χρησιμοποιήσετε το skip = n για να παραλείψετε τις πρώτες n γραμμές ή να χρησιμοποιήσετε το comment = \"#\" για να απορρίψετε όλες τις γραμμές που ξεκινούν με (π.χ.) #:\n\nread_csv(\n  \"The first line of metadata\n  The second line of metadata\n  x,y,z\n  1,2,3\",\n  skip = 2\n)\n#&gt; # A tibble: 1 × 3\n#&gt;       x     y     z\n#&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n#&gt; 1     1     2     3\n\nread_csv(\n  \"# A comment I want to skip\n  x,y,z\n  1,2,3\",\n  comment = \"#\"\n)\n#&gt; # A tibble: 1 × 3\n#&gt;       x     y     z\n#&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n#&gt; 1     1     2     3\n\nΣε άλλες περιπτώσεις, τα δεδομένα ενδέχεται να μην έχουν ονόματα στηλών. Μπορείτε να χρησιμοποιήσετε το col_names = FALSE για να πείτε στη read_csv() να μην αντιμετωπίζει την πρώτη σειρά ως επικεφαλίδες και αντ’ αυτού να τις επισημαίνει διαδοχικά ξεκινώντας από το X1 έως το Xn:\n\nread_csv(\n  \"1,2,3\n  4,5,6\",\n  col_names = FALSE\n)\n#&gt; # A tibble: 2 × 3\n#&gt;      X1    X2    X3\n#&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n#&gt; 1     1     2     3\n#&gt; 2     4     5     6\n\nΕναλλακτικά, μπορείτε να εισάγετε στο col_names ένα διάνυσμα χαρακτήρων που οι τιμές του οποίου θα χρησιμοποιηθούν ως ονόματα στηλών:\n\nread_csv(\n  \"1,2,3\n  4,5,6\",\n  col_names = c(\"x\", \"y\", \"z\")\n)\n#&gt; # A tibble: 2 × 3\n#&gt;       x     y     z\n#&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n#&gt; 1     1     2     3\n#&gt; 2     4     5     6\n\nΑυτά τα ορίσματα είναι όλα όσα πρέπει να γνωρίζετε για να διαβάσετε τα περισσότερα αρχεία CSV που θα συναντήσετε στην πράξη. (Για τα υπόλοιπα, θα πρέπει να επιθεωρήσετε προσεκτικά το αρχείο .csv που έχετε στα χέρια σας και να διαβάσετε το εγχειρίδιο της read_csv() όπου θα βρείτε πολλά ακόμη ορίσματα.)\n\n7.2.3 Άλλοι τύποι αρχείων\nΜόλις κατακτήσετε την read_csv(), η χρήση των άλλων συναρτήσεων του πακέτου readr γίνεται απλή. Είναι απλώς θέμα του να γνωρίζουμε ποια συνάρτηση να χρησιμοποίησοθμε:\n\nΗ read_csv2() διαβάζει αρχεία οριοθετημένα με ελληνικό ερωτηματικό. Αυτά χρησιμοποιούν ; αντί για , για να διαχωρίσουν πεδία και είναι κοινά σε χώρες που χρησιμοποιούν το , ως δείκτη των δεκαδικών.\nΗ read_tsv() διαβάζει αρχεία οριοθετημένα με στηλοθέτες.\nΗ read_delim() διαβάζει αρχεία με οποιονδήποτε οριοθέτη, προσπαθώντας να μαντέψει αυτόματα τον οριοθέτη εάν δεν τον καθορίσετε.\nΗ read_fwf() διαβάζει αρχεία σταθερού πλάτους. Μπορείτε να καθορίσετε τα πεδία με το πλάτος τους, χρησιμοποιώντας το fwf_widths() ή με τις θέσεις τους με το fwf_positions().\nΗ read_table() διαβάζει μία κοινή παραλλαγή αρχείων σταθερού πλάτους όπου οι στήλες χωρίζονται με απλό διάστημα.\nΗ read_log() διαβάζει αρχεία καταγραφής τύπου Apache.\n\n7.2.4 Ασκήσεις\n\nΠοια συνάρτηση θα χρησιμοποιούσατε για να διαβάσετε ένα αρχείο όπου τα πεδία ήταν διαχωρισμένα με “|”;\nΕκτός από τα file, skip, και comment, ποια άλλα ορίσματα είναι κοινά στην read_csv() και την read_tsv();\nΠοια είναι τα πιο σημαντικά ορίσματα για την read_fwf();\n\nΟρισμένες φορές οι συμβολοσειρές σε ένα αρχείο CSV περιέχουν κόμματα. Για να μην προκαλούν προβλήματα, πρέπει να περιβάλλονται από έναν χαρακτήρα εισαγωγικού, όπως το \" ή το '. Από προεπιλογή, η read_csv() υποθέτει ότι ο χαρακτήρας εισαγωγικού θα είναι \". Για να διαβάσετε το ακόλουθο κείμενο σε ένα πλαίσιο δεδομένων, ποιο όρισμα της read_csv() πρέπει να καθορίσετε;\n\n\"x,y\\n1,'a,b'\"\n\n\n\nΠροσδιορίστε ποιο είναι το πρόβλημα σε κάθε ένα από τα ακόλουθα ενσωματωμένα αρχεία CSV. Τι συμβαίνει όταν εκτελείτε τον κώδικα;\n\nread_csv(\"a,b\\n1,2,3\\n4,5,6\")\nread_csv(\"a,b,c\\n1,2\\n1,2,3,4\")\nread_csv(\"a,b\\n\\\"1\")\nread_csv(\"a,b\\n1,2\\na,b\")\nread_csv(\"a;b\\n1;3\")\n\n\n\nΕξασκηθείτε στην αναφορά μη συντακτικών ονομάτων στο ακόλουθο πλαίσιο δεδομένων:\n\nΕξάγοντας τη μεταβλητή που ονομάζεται 1.\n\nΣχεδιάζοντας ένα διάγραμμα διασποράς της 1 έναντι της 2.\n\nΔημιουργώντας μιας νέας στήλης που ονομάζεται 3, η οποία περιέχει το αποτέλεσμα της διαίρεσης της 2 με την 1.\n\nΜετονομάζοντας τις στήλες σε one, two, και three.\n\n\nannoying &lt;- tibble(\n  `1` = 1:10,\n  `2` = `1` * 2 + rnorm(length(`1`))\n)",
    "crumbs": [
      "Η ολοκληρωμένη εικόνα",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Εισαγωγή δεδομένων</span>"
    ]
  },
  {
    "objectID": "data-import.html#sec-col-types",
    "href": "data-import.html#sec-col-types",
    "title": "7  Εισαγωγή δεδομένων",
    "section": "\n7.3 Ελέγχοντας τον τύπο των στηλών",
    "text": "7.3 Ελέγχοντας τον τύπο των στηλών\nΈνα αρχείο CSV δεν περιέχει πληροφορίες σχετικά με τον τύπο κάθε μεταβλητής (δηλαδή εάν είναι λογική, αριθμός, συμβολοσειρά κ.λπ.), επομένως το πακέτο readr θα προσπαθήσει να μαντέψει τον τύπο. Αυτή η ενότητα περιγράφει πώς λειτουργεί αυτή η διαδικασία εικασίας, πώς να επιλύσετε ορισμένα κοινά προβλήματα που προκαλούν την αποτυχία της και, εάν χρειαστεί, πώς να παρέχετε μόνοι σας τους τύπους στηλών. Τέλος, θα αναφέρουμε μερικές γενικές στρατηγικές που είναι χρήσιμες όταν το πακέτο readr αποτυγχάνει παταγωδώς και πρέπει να αποκτήσετε περισσότερες πληροφορίες σχετικά με τη δομή του αρχείου σας.\n\n7.3.1 Εικάζοντας τύπους στηλών\nΗ readr χρησιμοποιεί ευρετικούς κανόνες για να προσδιορίσει τους τύπους στηλών. Για κάθε στήλη, κρατάει τις τιμές 1.000 γραμμών2 με ομοιόμορφη απόσταση από την πρώτη γραμμή μέχρι την τελευταία, αγνοώντας τις κενές τιμές. Στη συνέχεια εξετάζει τις ακόλουθες ερωτήσεις:\n\nΤο δείγμα περιέχει μόνο F, T, FALSE, ή TRUE (παραβλέποντας πεζά-κεφαλαία); Αν ναι, η στήλη είναι λογική.\nΤο δείγμα περιέχει μόνο αριθμούς (π.χ. 1, -4.5, 5e6, Inf); Αν ναι, η στήλη είναι αριθμητική.\nΤο δείγμα ταιριάζει με το πρότυπο ISO8601; Αν ναι, η αντίστοιχη στήλη περιέχει ημερομηνίες ή ημερομηνίες-ώρες. (Θα επιστρέψουμε στις ημερομηνίες-ώρες με περισσότερες λεπτομέρειες στην Ενότητα 17.2).\nΔιαφορετικά, η στήλη πρέπει να είναι τύπου συμβολοσειράς.\n\nΜπορείτε να δείτε αυτή τη συμπεριφορά σε δράση σε αυτό το απλό παράδειγμα:\n\nread_csv(\"\n  logical,numeric,date,string\n  TRUE,1,2021-01-15,abc\n  false,4.5,2021-02-15,def\n  T,Inf,2021-02-16,ghi\n\")\n#&gt; # A tibble: 3 × 4\n#&gt;   logical numeric date       string\n#&gt;   &lt;lgl&gt;     &lt;dbl&gt; &lt;date&gt;     &lt;chr&gt; \n#&gt; 1 TRUE        1   2021-01-15 abc   \n#&gt; 2 FALSE       4.5 2021-02-15 def   \n#&gt; 3 TRUE      Inf   2021-02-16 ghi\n\nΑυτό λειτουργεί καλά εάν έχετε ένα καθαρό σύνολο δεδομένων, αλλά στην πραγματική ζωή, θα συναντήσετε έναν συνδυασμό από περίεργες και όμορφες αποτυχίες.\n\n7.3.2 Κενές τιμές, τύποι στηλών και προβλήματα\nΟ πιο συνηθισμένος τρόπος με τον οποίο αποτυγχάνει η ανίχνευση του τύπου μιας στήλης είναι όταν η στήλη περιέχει μη αναμενόμενες τιμές, οπότε λαμβάνετε μία στήλη χαρακτήρων αντί για έναν πιο συγκεκριμένο τύπο. Μία από τις πιο συνηθισμένες αιτίες για αυτό είναι μία τιμή που λείπει, η οποία καταγράφεται χρησιμοποιώντας κάτι διαφορετικό από το NA που αναμένει το πακέτο readr.\nΠάρτε σαν παράδειγμα αυτό το απλό αρχείο CSV που περιέχει μόνο 1 στήλη:\n\nsimple_csv &lt;- \"\n  x\n  10\n  .\n  20\n  30\"\n\nΑν το διαβάσουμε αυτό χωρίς πρόσθετα ορίσματα, το x μετατρέπεται σε στήλη χαρακτήρων:\n\nread_csv(simple_csv)\n#&gt; # A tibble: 4 × 1\n#&gt;   x    \n#&gt;   &lt;chr&gt;\n#&gt; 1 10   \n#&gt; 2 .    \n#&gt; 3 20   \n#&gt; 4 30\n\nΣε αυτήν την πολύ μικρή περίπτωση, μπορείτε εύκολα να δείτε την τιμή που λείπει ως .. Τι συμβαίνει όμως εάν έχετε χιλιάδες γραμμές με λίγες μόνο κενές τιμές και οι οποίες αντιπροσωπεύονται από ., διάσπαρτες ανάμεσα σε συμπληρωμένες τιμές; Μία προσέγγιση είναι να πείτε στην readr ότι το x είναι μία αριθμητική στήλη και στη συνέχεια να δείτε σε ποιο σημείο αποτυγχάνει. Αυτό μπορείτε να το κάνετε με το όρισμα col_types, το οποίο δέχεται μία λίστα με ονόματα, όπου τα ονόματα ταιριάζουν με τα ονόματα στηλών στο αρχείο CSV:\n\ndf &lt;- read_csv(\n  simple_csv, \n  col_types = list(x = col_double())\n)\n#&gt; Warning: One or more parsing issues, call `problems()` on your data frame for\n#&gt; details, e.g.:\n#&gt;   dat &lt;- vroom(...)\n#&gt;   problems(dat)\n\nΤώρα η read_csv() αναφέρει ότι υπήρξε πρόβλημα και μας λέει ότι μπορούμε να μάθουμε περισσότερα χρησιμοποιώντας την problems():\n\nproblems(df)\n#&gt; # A tibble: 1 × 5\n#&gt;     row   col expected actual file                            \n#&gt;   &lt;int&gt; &lt;int&gt; &lt;chr&gt;    &lt;chr&gt;  &lt;chr&gt;                           \n#&gt; 1     3     1 a double .      /tmp/RtmpJ3Kqkc/file1daf3bc7fc39\n\nΑυτό μας λέει ότι βρέθηκε ένα πρόβλημα στη γραμμή 3 και στήλη 1 όπου το πακέτο readr περίμενε έναν πραγματικό αριθμό αλλά εντόπισε ένα .. Αυτό υποδηλώνει ότι αυτό το σύνολο δεδομένων χρησιμοποιεί . για τιμές που λείπουν. Στη συνέχεια, ορίζουμε na = \".\", και η αυτόματη εικασία επιτυγχάνει, δίνοντάς μας την αριθμητική στήλη που θέλουμε:\n\nread_csv(simple_csv, na = \".\")\n#&gt; # A tibble: 4 × 1\n#&gt;       x\n#&gt;   &lt;dbl&gt;\n#&gt; 1    10\n#&gt; 2    NA\n#&gt; 3    20\n#&gt; 4    30\n\n\n7.3.3 Τύποι στηλών\nΗ readr παρέχει συνολικά εννέα τύπους στηλών που μπορούμε να χρησιμοποιήσουμε:\n\nΟι col_logical() και col_double() διαβάζουν στήλες με λογικές τιμές και πραγματικούς αριθμούς αντίστοιχα. Η χρήση τους απαιτείται σχετικά σπάνια (εκτός από παραπάνω), μιας και το πακέτο readr συνήθως μαντεύει αντίστοιχες στήλες για εσάς.\nΗ col_integer() διαβάζει ακέραιους αριθμούς. Σπάνια κάνουμε διάκριση ανάμεσα σε ακέραιους και πραγματικούς αριθμούς σε αυτό το βιβλίο επειδή είναι λειτουργικά ισοδύναμοι, ωστόσο, η ρητή ανάγνωση ακεραίων μπορεί περιστασιακά να είναι χρήσιμη επειδή καταλαμβάνουν τη μισή μνήμη από τους πραγματικούς.\nΗ col_character() διαβάζει συμβολοσειρές. Αυτό μπορεί να είναι χρήσιμο για να προσδιορίσετε ρητά όταν έχετε μία στήλη που είναι ένα αριθμητικό αναγνωριστικό, δηλαδή μεγάλη σειρά ψηφίων που προσδιορίζει ένα αντικείμενο, αλλά δεν έχει νόημα να εφαρμόσετε μαθηματικές πράξεις σε αυτό. Παραδείγματα περιλαμβάνουν αριθμούς τηλεφώνου, αριθμούς κοινωνικής ασφάλισης, αριθμούς πιστωτικών καρτών κ.λπ.\nΟι col_factor(), col_date() και col_datetime() δημιουργούν παράγοντες, ημερομηνίες και ημερομηνίες-ώρες αντίστοιχα. θα μάθετε περισσότερα για αυτούς όταν φτάσουμε σε αυτούς τους τύπους δεδομένων στα κεφάλαια Κεφάλαιο 16 και Κεφάλαιο 17.\nΗ col_number() χρησιμοποιείται για το διάβασμα αριθμητικών στηλών, αγνοώντας μη αριθμητικά στοιχεία, επιτρέποντας μεγαλύτερη ευελιξία, και είναι χρήσιμη για νομισματικές ισοδυναμίες. Περισσότερα γι’ αυτό θα μάθετε στο Κεφάλαιο 13.\nΗ col_skip() παρακάμπτει μία στήλη, ώστε να μην περιλαμβάνεται στο αποτέλεσμα, κάτι που μπορεί να είναι χρήσιμο για την επιτάχυνση της ανάγνωσης των δεδομένων, εάν έχετε ένα μεγάλο αρχείο CSV και θέλετε να χρησιμοποιήσετε μερικές μόνο από τις στήλες.\n\nΕίναι επίσης δυνατό να παρακάμψετε την προεπιλεγμένη στήλη μεταβαίνοντας από την list() σε cols() και θέτοντας το όρισμα .default:\n\nanother_csv &lt;- \"\nx,y,z\n1,2,3\"\n\nread_csv(\n  another_csv, \n  col_types = cols(.default = col_character())\n)\n#&gt; # A tibble: 1 × 3\n#&gt;   x     y     z    \n#&gt;   &lt;chr&gt; &lt;chr&gt; &lt;chr&gt;\n#&gt; 1 1     2     3\n\nΜία άλλη χρήσιμη βοηθητική συνάρτηση είναι η cols_only() που θα διαβάζει μόνο στις στήλες που καθορίζετε:\n\nread_csv(\n  another_csv,\n  col_types = cols_only(x = col_character())\n)\n#&gt; # A tibble: 1 × 1\n#&gt;   x    \n#&gt;   &lt;chr&gt;\n#&gt; 1 1",
    "crumbs": [
      "Η ολοκληρωμένη εικόνα",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Εισαγωγή δεδομένων</span>"
    ]
  },
  {
    "objectID": "data-import.html#sec-readr-directory",
    "href": "data-import.html#sec-readr-directory",
    "title": "7  Εισαγωγή δεδομένων",
    "section": "\n7.4 Διαβάζοντας δεδομένα από πολλαπλά αρχεία",
    "text": "7.4 Διαβάζοντας δεδομένα από πολλαπλά αρχεία\nΜερικές φορές τα δεδομένα σας χωρίζονται σε πολλά αρχεία αντί να περιέχονται σε ένα μόνο αρχείο. Για παράδειγμα, μπορεί να έχετε δεδομένα πωλήσεων για πολλούς μήνες, με τα δεδομένα κάθε μήνα σε ξεχωριστό αρχείο: 01-sales.csv για τον Ιανουάριο, 02-sales.csv για το Φεβρουάριο και 03-sales.csv για το Μάρτιο. Με την read_csv() μπορείτε να διαβάσετε αυτά τα δεδομένα ταυτόχρονα και να τα στοιβάξετε το ένα πάνω στο άλλο, δημιουργώντας ένα συγκεντρωτικό πλαίσιο δεδομένων.\n\nsales_files &lt;- c(\"data/01-sales.csv\", \"data/02-sales.csv\", \"data/03-sales.csv\")\nread_csv(sales_files, id = \"file\")\n#&gt; # A tibble: 19 × 6\n#&gt;   file              month    year brand  item     n\n#&gt;   &lt;chr&gt;             &lt;chr&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n#&gt; 1 data/01-sales.csv January  2019     1  1234     3\n#&gt; 2 data/01-sales.csv January  2019     1  8721     9\n#&gt; 3 data/01-sales.csv January  2019     1  1822     2\n#&gt; 4 data/01-sales.csv January  2019     2  3333     1\n#&gt; 5 data/01-sales.csv January  2019     2  2156     9\n#&gt; 6 data/01-sales.csv January  2019     2  3987     6\n#&gt; # ℹ 13 more rows\n\nΓια ακόμη μία φορά, ο παραπάνω κώδικας θα δουλέψει εάν έχετε τα CSV αρχεία σας σε έναν data φάκελο στο project σας. Μπορείτε να κατεβάσετε αυτά τα αρχεία από τα https://pos.it/r4ds-01-sales, https://pos.it/r4ds-02-sales, και https://pos.it/r4ds-03-sales ή μπορείτε να διαβάσετε απευθείας, όπως φαίνεται παρακάτω:\n\nsales_files &lt;- c(\n  \"https://pos.it/r4ds-01-sales\",\n  \"https://pos.it/r4ds-02-sales\",\n  \"https://pos.it/r4ds-03-sales\"\n)\nread_csv(sales_files, id = \"file\")\n\nΤο όρισμα id προσθέτει μία νέα στήλη που ονομάζεται file στο προκύπτον πλαίσιο δεδομένων και η οποία προσδιορίζει το αρχείο από το οποίο προέρχονται τα δεδομένα. Αυτό είναι ιδιαίτερα χρήσιμο σε περιπτώσεις όπου τα αρχεία που διαβάζετε δεν έχουν μία στήλη αναγνώρισης που μπορεί να σας βοηθήσει να συνδέσετε τις παρατηρήσεις με τις αρχικές τους πηγές.\nΕάν έχετε πολλά αρχεία τα οποία θέλετε να διαβάσετε, μπορεί να είναι δύσκολο να γράψετε τα ονόματά τους ως μία λίστα. Αντίθετα, μπορείτε να χρησιμοποιήσετε τη συνάρτηση του βασικού συνόλου λειτουργιών της R, list.files() για να βρει τα αρχεία για εσάς, χρησιμοποιώντας ένα μοτίβο στα ονόματα των αρχείων. Θα μάθετε περισσότερα για αυτά τα μοτίβα στο Κεφάλαιο 15.\n\nsales_files &lt;- list.files(\"data\", pattern = \"sales\\\\.csv$\", full.names = TRUE)\nsales_files\n#&gt; [1] \"data/01-sales.csv\" \"data/02-sales.csv\" \"data/03-sales.csv\"",
    "crumbs": [
      "Η ολοκληρωμένη εικόνα",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Εισαγωγή δεδομένων</span>"
    ]
  },
  {
    "objectID": "data-import.html#sec-writing-to-a-file",
    "href": "data-import.html#sec-writing-to-a-file",
    "title": "7  Εισαγωγή δεδομένων",
    "section": "\n7.5 Γράφοντας δεδομένα σε ένα αρχείο",
    "text": "7.5 Γράφοντας δεδομένα σε ένα αρχείο\nΗ readr διαθέτει επίσης δύο χρήσιμες λειτουργίες για την εγγραφή δεδομένων πίσω στο δίσκο: την write_csv() και την write_tsv(). Τα πιο σημαντικά ορίσματα σε αυτές τις συναρτήσεις είναι το x (το πλαίσιο δεδομένων προς αποθήκευση) και το file (η τοποθεσία που θα χρησιμοποιηθεί για την αποθήκευση). Μπορείτε επίσης να καθορίσετε πώς γράφονται οι τιμές που λείπουν με το όρισμα na, και εάν θέλετε να προσαρτήσετε το πλαίσιο δεδομένων σας σε ένα υπάρχον αρχείο.\n\nwrite_csv(students, \"students.csv\")\n\nΤώρα ας διαβάσουμε ξανά αυτό το αρχείο csv. Σημειώστε ότι οι πληροφορίες τύπου μεταβλητής που μόλις ρυθμίσατε χάνονται όταν τις αποθηκεύετε στο CSV, επειδή ξεκινάτε ξανά με την ανάγνωση από ένα αρχείο απλού κειμένου:\n\nstudents\n#&gt; # A tibble: 6 × 5\n#&gt;   student_id full_name        favourite_food     meal_plan             age\n#&gt;        &lt;dbl&gt; &lt;chr&gt;            &lt;chr&gt;              &lt;fct&gt;               &lt;dbl&gt;\n#&gt; 1          1 Sunil Huffmann   Strawberry yoghurt Lunch only              4\n#&gt; 2          2 Barclay Lynn     French fries       Lunch only              5\n#&gt; 3          3 Jayendra Lyne    &lt;NA&gt;               Breakfast and lunch     7\n#&gt; 4          4 Leon Rossini     Anchovies          Lunch only             NA\n#&gt; 5          5 Chidiegwu Dunkel Pizza              Breakfast and lunch     5\n#&gt; 6          6 Güvenç Attila    Ice cream          Lunch only              6\nwrite_csv(students, \"students-2.csv\")\nread_csv(\"students-2.csv\")\n#&gt; # A tibble: 6 × 5\n#&gt;   student_id full_name        favourite_food     meal_plan             age\n#&gt;        &lt;dbl&gt; &lt;chr&gt;            &lt;chr&gt;              &lt;chr&gt;               &lt;dbl&gt;\n#&gt; 1          1 Sunil Huffmann   Strawberry yoghurt Lunch only              4\n#&gt; 2          2 Barclay Lynn     French fries       Lunch only              5\n#&gt; 3          3 Jayendra Lyne    &lt;NA&gt;               Breakfast and lunch     7\n#&gt; 4          4 Leon Rossini     Anchovies          Lunch only             NA\n#&gt; 5          5 Chidiegwu Dunkel Pizza              Breakfast and lunch     5\n#&gt; 6          6 Güvenç Attila    Ice cream          Lunch only              6\n\nΑυτό καθιστά τα CSV αρχεία λίγο αναξιόπιστα για την προσωρινή αποθήκευση ενδιάμεσων αποτελεσμάτων — θα πρέπει να δημιουργείτε εκ νέου τις προδιαγραφές των στηλών κάθε φορά που φορτώνετε τα δεδομένα. Υπάρχουν δύο βασικές εναλλακτικές:\n\n\nΟι write_rds() και read_rds() είναι ομοιόμορφα περιτυλίγματα κώδικα (wrappers) γύρω από τις βασικές συναρτήσεις readRDS() και saveRDS(). Αυτές αποθηκεύουν δεδομένα στην προσαρμοσμένη δυαδική μορφή της R που ονομάζεται RDS. Αυτό σημαίνει ότι όταν φορτώνετε ξανά το αντικείμενο, φορτώνετε το ακριβώς το ίδιο αντικείμενο R που αποθηκεύσατε.\n\nwrite_rds(students, \"students.rds\")\nread_rds(\"students.rds\")\n#&gt; # A tibble: 6 × 5\n#&gt;   student_id full_name        favourite_food     meal_plan             age\n#&gt;        &lt;dbl&gt; &lt;chr&gt;            &lt;chr&gt;              &lt;fct&gt;               &lt;dbl&gt;\n#&gt; 1          1 Sunil Huffmann   Strawberry yoghurt Lunch only              4\n#&gt; 2          2 Barclay Lynn     French fries       Lunch only              5\n#&gt; 3          3 Jayendra Lyne    &lt;NA&gt;               Breakfast and lunch     7\n#&gt; 4          4 Leon Rossini     Anchovies          Lunch only             NA\n#&gt; 5          5 Chidiegwu Dunkel Pizza              Breakfast and lunch     5\n#&gt; 6          6 Güvenç Attila    Ice cream          Lunch only              6\n\n\n\nΤο πακέτο arrow σας επιτρέπει να διαβάζετε και να γράφετε αρχεία parquet, μία γρήγορη μορφή δυαδικού αρχείου που μπορεί να διαμοιραστεί σε διάφορες γλώσσες προγραμματισμού. Θα επιστρέψουμε στο arrow σε μεγαλύτερο βάθος στο Κεφάλαιο 22.\n\nlibrary(arrow)\nwrite_parquet(students, \"students.parquet\")\nread_parquet(\"students.parquet\")\n#&gt; # A tibble: 6 × 5\n#&gt;   student_id full_name        favourite_food     meal_plan             age\n#&gt;        &lt;dbl&gt; &lt;chr&gt;            &lt;chr&gt;              &lt;fct&gt;               &lt;dbl&gt;\n#&gt; 1          1 Sunil Huffmann   Strawberry yoghurt Lunch only              4\n#&gt; 2          2 Barclay Lynn     French fries       Lunch only              5\n#&gt; 3          3 Jayendra Lyne    NA                 Breakfast and lunch     7\n#&gt; 4          4 Leon Rossini     Anchovies          Lunch only             NA\n#&gt; 5          5 Chidiegwu Dunkel Pizza              Breakfast and lunch     5\n#&gt; 6          6 Güvenç Attila    Ice cream          Lunch only              6\n\n\n\nΤα αρχεία parquet τείνουν να είναι πολύ πιο γρήγορα από τα RDS και μπορεί να χρησιμοποιηθούν και εκτός της R, αλλά απαιτούν το πακέτο arrow.",
    "crumbs": [
      "Η ολοκληρωμένη εικόνα",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Εισαγωγή δεδομένων</span>"
    ]
  },
  {
    "objectID": "data-import.html#εισαγωγή-δεδομένων",
    "href": "data-import.html#εισαγωγή-δεδομένων",
    "title": "7  Εισαγωγή δεδομένων",
    "section": "\n7.6 Εισαγωγή δεδομένων",
    "text": "7.6 Εισαγωγή δεδομένων\nΜερικές φορές θα χρειαστεί να συναρμολογήσετε ένα tibble “με το χέρι” κάνοντας μία μικρή εισαγωγή δεδομένων στο αρχείο R κώδικα σας. Υπάρχουν δύο χρήσιμες συναρτήσεις που σας βοηθούν να το κάνετε αυτό, οι οποίες διαφέρουν ως προς το αν σχεδιάζετε το tibble κατά στήλες ή κατά γραμμές. Η tibble() λειτουργεί ανά στήλες:\n\ntibble(\n  x = c(1, 2, 5), \n  y = c(\"h\", \"m\", \"g\"),\n  z = c(0.08, 0.83, 0.60)\n)\n#&gt; # A tibble: 3 × 3\n#&gt;       x y         z\n#&gt;   &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt;\n#&gt; 1     1 h      0.08\n#&gt; 2     2 m      0.83\n#&gt; 3     5 g      0.6\n\nΗ διάταξη των δεδομένων ανά στήλες μπορεί να δυσκολέψει τον τρόπο με τον οποίο συσχετίζονται οι γραμμές, επομένως μία εναλλακτική είναι η tribble(), συντομογραφία για το transposed tibble, η οποία σας επιτρέπει να τοποθετήσετε τα δεδομένα σας γραμμή προς γραμμή. Η tribble() προσαρμόζεται για την εισαγωγή δεδομένων στον κώδικα: οι επικεφαλίδες στηλών ξεκινούν με ~ και οι εγγραφές διαχωρίζονται με κόμμα. Αυτό καθιστά δυνατή τη διάταξη μικρών ποσοτήτων δεδομένων σε μία ευανάγνωστη μορφή:\n\ntribble(\n  ~x, ~y, ~z,\n  1, \"h\", 0.08,\n  2, \"m\", 0.83,\n  5, \"g\", 0.60\n)\n#&gt; # A tibble: 3 × 3\n#&gt;       x y         z\n#&gt;   &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt;\n#&gt; 1     1 h      0.08\n#&gt; 2     2 m      0.83\n#&gt; 3     5 g      0.6",
    "crumbs": [
      "Η ολοκληρωμένη εικόνα",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Εισαγωγή δεδομένων</span>"
    ]
  },
  {
    "objectID": "data-import.html#σύνοψη",
    "href": "data-import.html#σύνοψη",
    "title": "7  Εισαγωγή δεδομένων",
    "section": "\n7.7 Σύνοψη",
    "text": "7.7 Σύνοψη\nΣε αυτό το κεφάλαιο, μάθατε πώς να φορτώνετε αρχεία CSV με την read_csv() και να κάνετε τη δική σας εισαγωγή δεδομένων με τις tibble() και tribble(). Έχετε μάθει πώς λειτουργούν τα αρχεία csv, μερικά από τα προβλήματα που ενδέχεται να αντιμετωπίσετε και πώς να τα ξεπεράσετε. Θα επανέλθουμε στην εισαγωγή δεδομένων μερικές ακόμη φορές σε αυτό το βιβλίο: το Κεφάλαιο 20 θα σας δείξει πώς να φορτώνετε δεδομένα από το Excel και τα Google Sheets, το Κεφάλαιο 21 θα σας δείξει πώς να φορτώνετε δεδομένα από βάσεις δεδομένων, το Κεφάλαιο 22 από αρχεία parquet, το Κεφάλαιο 23 από JSON και το Κεφάλαιο 24 από ιστοτόπους.\nΒρισκόμαστε ακριβώς στο τέλος αυτής της ενότητας του βιβλίου, αλλά υπάρχει ένα σημαντικό τελευταίο θέμα που πρέπει να καλυφθεί: πώς να λάβετε βοήθεια. Έτσι, στο επόμενο κεφάλαιο, θα μάθετε μερικά καλά μέρη για να αναζητήσετε βοήθεια, πώς να δημιουργήσετε ένα reprex (αναπαράξιμο παράδειγμα) για να μεγιστοποιήσετε τις πιθανότητές σας να λάβετε χρήσιμη βοήθεια και μερικές γενικές συμβουλές για να είστε πάντα ενημερωμένοι σχετικά με τον κόσμο της R.",
    "crumbs": [
      "Η ολοκληρωμένη εικόνα",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Εισαγωγή δεδομένων</span>"
    ]
  },
  {
    "objectID": "data-import.html#footnotes",
    "href": "data-import.html#footnotes",
    "title": "7  Εισαγωγή δεδομένων",
    "section": "",
    "text": "Το πακέτο janitor δεν αποτελεί μέρος του tidyverse, αλλά προσφέρει εύχρηστες λειτουργίες για τον καθαρισμό δεδομένων και λειτουργεί καλά σε ροές εργασιών σε δεδομένα που χρησιμοποιούν |&gt;.↩︎\nΜπορείτε να παρακάμψετε την προεπιλογή των 1.000 γραμμών με το όρισμα guess_max.↩︎",
    "crumbs": [
      "Η ολοκληρωμένη εικόνα",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Εισαγωγή δεδομένων</span>"
    ]
  },
  {
    "objectID": "workflow-help.html",
    "href": "workflow-help.html",
    "title": "8  Ροή εργασίας: αναζητώντας βοήθεια",
    "section": "",
    "text": "8.1 Η Google είναι φίλος σας\nΑν κολλήσετε, ξεκινήστε με τη μηχανή αναζήτησης της Google. Τυπικά, η προσθήκη του “R” σε ένα ερώτημα είναι αρκετή για να περιοριστεί σε σχετικά αποτελέσματα: εάν η αναζήτηση δεν είναι χρήσιμη, σημαίνει συχνά ότι δεν υπάρχουν διαθέσιμα αποτελέσματα ειδικά για την R. Επιπλέον, η προσθήκη ονομάτων πακέτων όπως “tidyverse” ή “ggplot2” θα σας βοηθήσει να περιορίσετε τα αποτελέσματα σε κώδικα που θα σας φαίνεται πιο οικείος, π.χ. “πώς να κάνετε ένα θηκόγραμμα στην R” έναντι του “πώς να δημιουργήσετε ένα θηκόγραμμα στην R με ggplot2”. Η αναζήτηση της Google είναι επίσης ιδιαίτερα χρήσιμη για μηνύματα λάθους. Αν λάβετε ένα μήνυμα σφάλματος και δεν έχετε ιδέα τι σημαίνει, δοκιμάστε να το γκουγκλάρετε! Υπάρχουν καλές πιθανότητες ότι κάποιος άλλος έχει ασχοληθεί με αυτό στο παρελθόν, οπότε θα υπάρχει βοήθεια κάπου στο διαδίκτυο. (Εάν το μήνυμα σφάλματος δεν είναι στα Αγγλικά, εκτελέστε Sys.setenv(LANGUAGE = \"en\") και εκτελέστε ξανά τον κώδικα. Με αυτό τον τρόπο είναι πιο πιθανό να βρείτε βοήθεια για μηνύματα σφάλματος στα αγγλικά.)\nΕάν η Google δεν σας βοηθήσει, δοκιμάστε το Stack Overflow. Ξεκινήστε αφιερώνοντας λίγο χρόνο αναζητώντας μία υπάρχουσα απάντηση, συμπεριλαμβανομένου του φίλτρου «[R]», για να περιορίσετε την αναζήτησή σας σε ερωτήσεις και απαντήσεις που χρησιμοποιούν την R.",
    "crumbs": [
      "Η ολοκληρωμένη εικόνα",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Ροή εργασίας: αναζητώντας βοήθεια</span>"
    ]
  },
  {
    "objectID": "workflow-help.html#δημιουργώντας-ένα-αναπαράξιμο-παράδειγμα-reprex",
    "href": "workflow-help.html#δημιουργώντας-ένα-αναπαράξιμο-παράδειγμα-reprex",
    "title": "8  Ροή εργασίας: αναζητώντας βοήθεια",
    "section": "\n8.2 Δημιουργώντας ένα αναπαράξιμο παράδειγμα (reprex)",
    "text": "8.2 Δημιουργώντας ένα αναπαράξιμο παράδειγμα (reprex)\nΕάν το γκουγκλάρισμα σας δεν βρίσκει τίποτα χρήσιμο, μία πολύ καλή ιδέα είναι να ετοιμάσετε ένα reprex, ένα ελάχιστο αναπαράξιμο παράδειμα (reproducible example). Ένα καλό reprex διευκολύνει τους άλλους να σας βοηθήσουν και συχνά θα εντοπίσετε μόνοι σας το πρόβλημα κατά τη διάρκεια της δημιουργίας του. Υπάρχουν δύο μέρη για τη δημιουργία ενός reprex:\n\nΠρώτα, πρέπει να κάνετε τον κώδικά σας αναπαράξιμο. Αυτό σημαίνει ότι πρέπει να καταγράψετε τα πάντα, δηλαδή να συμπεριλάβετε τυχόν κλήσεις σε βιβλιοθήκες και να δημιουργήσετε όλα τα απαραίτητα αντικείμενα. Ο ευκολότερος τρόπος για να βεβαιωθείτε ότι το έχετε κάνει είναι να χρησιμοποιήσετε το πακέτο reprex.\nΔεύτερον, πρέπει να το κάνετε σύντομο. Αφαιρέστε όλα όσα δεν σχετίζονται άμεσα με το πρόβλημά σας. Αυτό συνήθως περιλαμβάνει τη δημιουργία ενός πολύ μικρότερου και απλούστερου αντικειμένου R από αυτό που αντιμετωπίζετε στην πραγματική ζωή ή ακόμη και τη χρήση ενσωματωμένων δεδομένων.\n\nΑυτό ακούγεται σαν πολλή δουλειά! Και μπορεί να είναι, αλλά έχει μεγάλη απόδοση:\n\nΣτο 80% των περιπτώσεων, η δημιουργία ενός καλού reprex είναι ικανή να αποκαλύψει την πηγή του προβλήματός σας. Είναι εκπληκτικό πόσο συχνά η διαδικασία σύνταξης ενός αυτοτελούς και ελάχιστου παραδείγματος σας επιτρέπει να απαντήσετε στη δική σας ερώτηση.\nΤο υπόλοιπο 20% των περιπτώσεων, θα έχετε συλλάβει την ουσία του προβλήματός σας με τρόπο που είναι εύκολο για τους άλλους να πειραματιστούν και να παίξουν με αυτό. Αυτό βελτιώνει σημαντικά τις πιθανότητές σας να λάβετε βοήθεια!\n\nΌταν δημιουργείτε ένα reprex με το χέρι, είναι εύκολο να σας ξεφύγει κάτι κατά λάθος, που σημαίνει ότι ο κώδικάς σας δεν μπορεί να εκτελεστεί στον υπολογιστή κάποιου άλλου. Αποφύγετε αυτό το πρόβλημα χρησιμοποιώντας το πακέτο reprex, το οποίο είναι εγκατεστημένο ως μέρος του tidyverse. Ας υποθέσουμε ότι αντιγράψατε αυτόν τον κώδικα στο πρόχειρο σας (ή, στον διακομιστή RStudio ή στο Cloud - επιλέξτε τον):\n\ny &lt;- 1:4\nmean(y)\n\nΣτη συνέχεια καλέστε την reprex(), όπου η προεπιλεγμένη έξοδος είναι διαμορφωμένη σύμφωνα με τα πρότυπα του GitHub:\nreprex::reprex()\nΈνας σωστά διαμορφωμένος HTML κώδικας θα εμφανιστεί στον Viewer του RStudio (αν βρίσκεστε στο RStudio) ή, διαφορετικά, στο προεπιλεγμένο πρόγραμμα περιήγησης σας. Το reprex αντιγράφεται αυτόματα στο πρόχειρο σας (στο RStudio Server ή στο Cloud, θα χρειαστεί να το αντιγράψετε μόνοι σας):\n``` r\ny &lt;- 1:4\nmean(y)\n#&gt; [1] 2.5\n```\nΑυτό το κείμενο έχει μορφοποιηθεί με έναν ειδικό τρόπο, που ονομάζεται Markdown, ο οποίος μπορεί να επικολληθεί σε ιστότοπους όπως το StackOverflow ή το Github, και θα το αποδώσουν αυτόματα ώστε να μοιάζει με κώδικα. Δείτε πώς θα έμοιαζε αυτό το Markdown στο GitHub:\n\ny &lt;- 1:4\nmean(y)\n#&gt; [1] 2.5\n\nΟποιοσδήποτε άλλος μπορεί να το αντιγράψει, να επικολλήσει και να το εκτελέσει αμέσως.\nΥπάρχουν τρία πράγματα που πρέπει να συμπεριλάβετε για να κάνετε το παράδειγμά σας αναπαράξιμο: τα απαιτούμενα πακέτα, τα δεδομένα και τον κώδικα.\n\nΤα πακέτα θα πρέπει να φορτώνονται στο επάνω μέρος του αρχείου κώδικα, ώστε να είναι εύκολο να δείτε ποια χρειάζεται το παράδειγμα. Αυτή είναι μία καλή στιγμή για να ελέγξετε ότι χρησιμοποιείτε την πιο πρόσφατη έκδοση κάθε πακέτου - μπορεί να έχετε ανακαλύψει ένα σφάλμα που έχει διορθωθεί από τότε που εγκαταστήσατε ή ενημερώσατε την τελευταία φορά το πακέτο. Για πακέτα στο tidyverse, ο ευκολότερος τρόπος ελέγχου είναι εκτελώντας το tidyverse_update().\n\nΟ ευκολότερος τρόπος για να συμπεριλάβετε δεδομένα είναι να χρησιμοποιήσετε την dput() για να δημιουργήσετε τον κώδικα R που απαιτείται για την αναδημιουργία του. Για παράδειγμα, για να δημιουργήσετε ξανά το σύνολο δεδομένων mtcars στην R, εκτελέστε τα ακόλουθα βήματα:\n\nΤρέξτε dput(mtcars) στην R.\nΑντιγράψτε το αποτέλεσμα.\nΣτο reprex, πληκτρολογήστε mtcars &lt;-, και στη συνέχεια κάντε επικόλληση το κομμάτι που αντιγράψατε.\n\nΠροσπαθήστε να χρησιμοποιήσετε το μικρότερο δυνατό υποσύνολο των δεδομένων σας που αποκαλύπτει όμως το πρόβλημα.\n\n\nΑφιερώστε λίγο χρόνο για να διασφαλίσετε ότι ο κώδικας σας είναι εύκολος να τον διαβάσουν οι άλλοι:\n\nΒεβαιωθείτε ότι έχετε χρησιμοποιήσει κενά και τα ονόματα των μεταβλητών σας είναι συνοπτικά αλλά ενημερωτικά.\nΧρησιμοποιήστε σχόλια για να υποδείξετε πού βρίσκεται το πρόβλημά σας.\nΚάντε ό,τι μπορείτε για να αφαιρέσετε οτιδήποτε δεν σχετίζεται με το πρόβλημα.\n\nΌσο πιο σύντομος είναι ο κώδικάς σας, τόσο πιο εύκολο είναι να κατανοηθεί και τόσο πιο εύκολο να διορθωθεί.\n\n\nΟλοκληρώστε ελέγχοντας ότι έχετε κάνει πραγματικά ένα αναπαράξιμο παράδειγμα ξεκινώντας μία νέα περίοδο λειτουργίας στην R και αντιγράφοντας και επικολλώντας το αρχείο κώδικα σας.\nΗ δημιουργία reprex δεν είναι απλή και θα χρειαστεί λίγη εξάσκηση για να μάθετε να δημιουργείτε καλά, πραγματικά σύντομα reprexes. Ωστόσο, το να μάθετε να κάνετε ερωτήσεις που περιλαμβάνουν τον κώδικα σας και να επενδύετε χρόνο για να τον κάνετε αναπαράξιμο θα συνεχίσει να αποδίδει καθώς μαθαίνετε και κατακτάτε την R.",
    "crumbs": [
      "Η ολοκληρωμένη εικόνα",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Ροή εργασίας: αναζητώντας βοήθεια</span>"
    ]
  },
  {
    "objectID": "workflow-help.html#επενδύοντας-στον-εαυτό-σας",
    "href": "workflow-help.html#επενδύοντας-στον-εαυτό-σας",
    "title": "8  Ροή εργασίας: αναζητώντας βοήθεια",
    "section": "\n8.3 Επενδύοντας στον εαυτό σας",
    "text": "8.3 Επενδύοντας στον εαυτό σας\nΘα πρέπει επίσης να αφιερώσετε λίγο χρόνο για να προετοιμάσετε τον εαυτό σας για να λύνει προβλήματα πριν αυτά εμφανιστούν. Επενδύοντας λίγο χρόνο στην εκμάθηση της R κάθε μέρα, μακροπρόθεσμα, θα αποδώσει πολύ. Ένας τρόπος είναι να παρακολουθήσετε τι κάνει η ομάδα του tidyverse στον ιστότοπο του tidyverse. Για να συμβαδίσετε με την κοινότητα της R γενικότερα, συνιστούμε να διαβάζετε το R Weekly: είναι μία προσπάθεια της κοινότητας να συγκεντρώνει τις πιο ενδιαφέρουσες ειδήσεις στην κοινότητα της R κάθε εβδομάδα.",
    "crumbs": [
      "Η ολοκληρωμένη εικόνα",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Ροή εργασίας: αναζητώντας βοήθεια</span>"
    ]
  },
  {
    "objectID": "workflow-help.html#σύνοψη",
    "href": "workflow-help.html#σύνοψη",
    "title": "8  Ροή εργασίας: αναζητώντας βοήθεια",
    "section": "\n8.4 Σύνοψη",
    "text": "8.4 Σύνοψη\nΑυτό το κεφάλαιο ολοκληρώνει το μέρος του βιβλίου “Η ολοκληρωμένη εικόνα”. Τώρα έχετε δει τα πιο σημαντικά μέρη της διαδικασίας της επιστήμης δεδομένων: οπτικοποίηση, μετασχηματισμός, τακτοποίηση και εισαγωγή. Έχετε πλέον μία ολιστική άποψη της διαδικασίας και αρχίζουμε να μπαίνουμε στις λεπτομέρειες των μικρών κομματιών.\nΤο επόμενο μέρος του βιβλίου, Οπτικοποίηση, κάνει μία μεγαλύτερη εμβάθυνση στη γραμματική των γραφικών και στη δημιουργία οπτικοποιήσεων δεδομένων με το πακέτο ggplot2, παρουσιάζει πώς να χρησιμοποιείτε τα εργαλεία που έχετε μάθει μέχρι τώρα για τη διεξαγωγή διερευνητικής ανάλυσης δεδομένων και εισάγει καλές πρακτικές για τη δημιουργία διαγραμμάτων για την επικοινωνία της πληροφορίας.",
    "crumbs": [
      "Η ολοκληρωμένη εικόνα",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Ροή εργασίας: αναζητώντας βοήθεια</span>"
    ]
  },
  {
    "objectID": "visualize.html",
    "href": "visualize.html",
    "title": "Οπτικοποίηση",
    "section": "",
    "text": "Αφού διαβάσατε το πρώτο μέρος του βιβλίου, καταλαβαίνετε (τουλάχιστον επιφανειακά) τα πιο σημαντικά εργαλεία για την εφαρμογή της επιστήμης των δεδομένων. Ηρθε η ώρα, πλέον, να αρχίσετε να εμβαθύνετε στις λεπτομέρειες. Σε αυτό το μέρος του βιβλίου, θα μάθετε για την οπτικοποίηση δεδομένων σε μεγαλύτερο βάθος.\n\n\n\n\n\n\n\nΣχήμα 1: Η οπτικοποίηση δεδομένων είναι συχνά το πρώτο βήμα κατα την εξερεύνηση των δεδομένων.\n\n\n\n\nΚάθε κεφάλαιο εξετάζει τουλάχιστον μία περίπτωση οπτικοποίησης δεδομένων.\n\nΣτο 9  Επίπεδα θα μάθετε για την πολυεπίπεδη γραμματική των γραφικών.\nΣτο 10  Διερευνητική ανάλυση δεδομένων, θα συνδυάσετε την οπτικοποίηση με την περιέργεια και τον σκεπτικισμό σας για να θέσετε και να απαντήσετε ενδιαφέρουσες ερωτήσεις περί δεδομένων.\nΤέλος, στο 11  Επικοινωνία θα μάθετε πώς να χρησιμοποιείτε τα διερευνητικά γραφικά σας, να τα αναβαθμίσετε και να τα μετατρέψετε σε επεξηγηματικά γραφικά που βοηθούν άτομα νέα ως προς στην ανάλυσή σας να καταλάβουν τι συμβαίνει όσο το δυνατόν πιο γρήγορα και εύκολα.\n\nΤα τρία αυτά κεφάλαια σας δίνουν μία πρώτη εικόνα για τον κόσμο της οπτικοποίησης, αλλά υπάρχουν πολλά περισσότερα να μάθετε. Το καλύτερο μέρος για να μάθετε περισσότερα είναι το βιβλίο της ggplot2: ggplot2: Elegant graphics for data analysis. Εμβαθύνει σε πολύ μεγαλύτερο εύρος σχετικά με την υποκείμενη θεωρία και έχει πολλά περισσότερα παραδείγματα για το πώς να συνδυάσετε μεμονωμένα κομμάτια για να λύσετε πρακτικά προβλήματα. Μία άλλη εξαιρετική πηγή είναι η γκαλερί επεκτάσεων της ggplot2 https://exts.ggplot2.tidyverse.org/gallery/. Ο ιστότοπος αυτός παραθέτει πολλά από τα πακέτα που επεκτείνουν το πακέτο ggplot2 με νέα γεωμετρικά αντικείμενα (geom) και κλίμακες (scales). Είναι ένα εξαιρετικό μέρος για να ξεκινήσετε εάν προσπαθείτε να κάνετε κάτι που φαίνεται δύσκολο με το πακέτο ggplot2.",
    "crumbs": [
      "Οπτικοποίηση"
    ]
  },
  {
    "objectID": "layers.html",
    "href": "layers.html",
    "title": "9  Επίπεδα",
    "section": "",
    "text": "9.1 Εισαγωγή\nΣτο Κεφάλαιο 1, μάθατε πολλά περισσότερα από το πώς να δημιουργείτε γραφήματα διασποράς, ραβδογράμματα και θηκογράμματα. Μάθατε μία βάση που μπορείτε να χρησιμοποιήσετε για να φτιάξετε οποιονδήποτε τύπο γραφήματος με το πακέτο ggplot2.\nΣε αυτό το κεφάλαιο, θα επεκταθείτε χρησιμοποιώντας αυτή τη βάση καθώς μαθαίνετε για την πολυεπίπεδη γραμματική των γραφικών. Θα ξεκινήσουμε με μία εμβάθυνση στα αισθητικά στοιχεία, τα γεωμετρικά αντικείμενα και τις όψεις (facets). Στη συνέχεια, θα μάθετε για τους στατιστικούς μετασχηματισμούς που κάνει το πακέτο ggplot2 στο παρασκήνιο κατά τη δημιουργία ενός διαγράμματος. Αυτοί οι μετασχηματισμοί χρησιμοποιούνται για τον υπολογισμό νέων τιμών προς οπτικοποίηση, όπως τα ύψη των ράβδων σε ένα ραβδόγραμμα ή οι διάμεσοι σε ένα θηκόγραμμα. Θα μάθετε επίσης για τις προσαρμογές θέσεων, οι οποίες μεταβάλλουν τον τρόπο εμφάνισης των γεωμετρικών αντικειμένων (geoms) στα διαγράμματά σας. Τέλος, θα παρουσιάσουμε εν συντομία τα συστήματα συντεταγμένων.",
    "crumbs": [
      "Οπτικοποίηση",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Επίπεδα</span>"
    ]
  },
  {
    "objectID": "layers.html#εισαγωγή",
    "href": "layers.html#εισαγωγή",
    "title": "9  Επίπεδα",
    "section": "",
    "text": "9.1.1 Προαπαιτούμενα\nΑυτό το κεφάλαιο εστιάζει στο πακέτο ggplot2. Για να αποκτήσετε πρόσβαση στα δεδομένα, τις σελίδες βοήθειας και τις συναρτήσεις που χρησιμοποιούνται σε αυτό το κεφάλαιο, φορτώστε το tidyverse εκτελώντας αυτόν τον κώδικα:\n\nlibrary(tidyverse)",
    "crumbs": [
      "Οπτικοποίηση",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Επίπεδα</span>"
    ]
  },
  {
    "objectID": "layers.html#αισθητικά-στοιχεία",
    "href": "layers.html#αισθητικά-στοιχεία",
    "title": "9  Επίπεδα",
    "section": "\n9.2 Αισθητικά στοιχεία",
    "text": "9.2 Αισθητικά στοιχεία\n\n“Η μεγαλύτερη αξία μιας εικόνας είναι όταν μας αναγκάζει να παρατηρήσουμε αυτό που δεν περιμέναμε ποτέ να δούμε.” — John Tukey\n\nΘυμηθείτε ότι το πλαίσιο δεδομένων mpg που συμπεριλαμβάνεται στο πακέτο ggplot2 περιέχει 234 παρατηρήσεις (γραμμές) για 38 μοντέλα αυτοκινήτων.\n\nmpg\n#&gt; # A tibble: 234 × 11\n#&gt;   manufacturer model displ  year   cyl trans      drv     cty   hwy fl   \n#&gt;   &lt;chr&gt;        &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt;      &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt;\n#&gt; 1 audi         a4      1.8  1999     4 auto(l5)   f        18    29 p    \n#&gt; 2 audi         a4      1.8  1999     4 manual(m5) f        21    29 p    \n#&gt; 3 audi         a4      2    2008     4 manual(m6) f        20    31 p    \n#&gt; 4 audi         a4      2    2008     4 auto(av)   f        21    30 p    \n#&gt; 5 audi         a4      2.8  1999     6 auto(l5)   f        16    26 p    \n#&gt; 6 audi         a4      2.8  1999     6 manual(m5) f        18    26 p    \n#&gt; # ℹ 228 more rows\n#&gt; # ℹ 1 more variable: class &lt;chr&gt;\n\nΜερικές από τις μεταβλητές που περιέχονται στο mpg είναι:\n\ndispl: Μέγεθος κινητήρα αυτοκινήτου, σε λίτρα. Μία αριθμητική μεταβλητή.\nhwy: Η απόδοση καυσίμου ενός αυτοκινήτου στον αυτοκινητόδρομο, σε μίλια ανά γαλόνι (mpg). Ένα αυτοκίνητο με χαμηλή απόδοση καυσίμου καταναλώνει περισσότερο καύσιμο από ένα αυτοκίνητο με υψηλή απόδοση καυσίμου όταν διανύει την ίδια απόσταση. Μία αριθμητική μεταβλητή.\nclass: Τύπος αυτοκινήτου. Μία κατηγορηματική μεταβλητή.\n\nΑς ξεκινήσουμε οπτικοποιώντας τη σχέση μεταξύ displ και hwy για διάφορες κατηγορίες (class) αυτοκινήτων . Μπορούμε να το κάνουμε αυτό με ένα διάγραμμα διασποράς όπου οι αριθμητικές μεταβλητές αντιστοιχίζονται στα αισθητικά στοιχεία x και y και η κατηγορική μεταβλητή αντιστοιχίζεται σε ένα αισθητικό στοιχείο όπως το χρώμα (color) ή σχήμα (shape).\n# Left\nggplot(mpg, aes(x = displ, y = hwy, color = class)) +\n  geom_point()\n\n# Right\nggplot(mpg, aes(x = displ, y = hwy, shape = class)) +\n  geom_point()\n#&gt; Warning: The shape palette can deal with a maximum of 6 discrete values because more\n#&gt; than 6 becomes difficult to discriminate\n#&gt; ℹ you have requested 7 values. Consider specifying shapes manually if you\n#&gt;   need that many have them.\n#&gt; Warning: Removed 62 rows containing missing values or values outside the scale range\n#&gt; (`geom_point()`).\n\n\n\n\n\n\n\n\n\n\nΌταν η μεταβλητή class ορίζεται στο στοιχείο shape, λαμβάνουμε δύο προειδοποιήσεις:\n\n1: The shape palette can deal with a maximum of 6 discrete values because more than 6 becomes difficult to discriminate; you have 7. Consider specifying shapes manually if you must have them.\n2: Removed 62 rows containing missing values (geom_point()).\n\nΔεδομένου ότι το πακέτο ggplot2 χρησιμοποιεί μόνο έξι σχήματα τη φορά, από προεπιλογή, οι πρόσθετες ομάδες δεν θα οπτικοποιηθούν όσο χρησιμοποιείτε το αισθητικό στοιχείο του σχήματος (shape). Η δεύτερη προειδοποίηση είναι σχετική με τη προηγούμενη – υπάρχουν 62 SUV στα δεδομένων και δεν οπτικοποιούνται.\nΟμοίως, μπορούμε να ορίσουμε την μεταβλητή class στα αισθητικά στοιχεία size ή alpha, που ελέγχουν το σχήμα και τη διαφάνεια των σημείων, αντίστοιχα.\n# Left\nggplot(mpg, aes(x = displ, y = hwy, size = class)) +\n  geom_point()\n#&gt; Warning: Using size for a discrete variable is not advised.\n\n# Right\nggplot(mpg, aes(x = displ, y = hwy, alpha = class)) +\n  geom_point()\n#&gt; Warning: Using alpha for a discrete variable is not advised.\n\n\n\n\n\n\n\n\n\n\nΚαι οι δύο παραπάνω επιλογές θα επιστρέψουν προειδοποιήσεις (warnings):\n\nΗ χρήση του alpha για μία διακριτή μεταβλητή δεν συνιστάται.\n\nΗ αντιστοίχιση μιας μη διατεταγμένης διακριτής (κατηγορικής) μεταβλητής (class) σε μία διατεταγμένη αισθητική (size ή alpha) γενικά δεν είναι καλή ιδέα επειδή υπονοεί μία κατάταξη που στην πραγματικότητα δεν υπάρχει.\nΑπο τη στιγμή που αντιστοιχίσετε ένα αισθητικό στοιχείο, το πακέτο ggplot2 αναλαμβάνει τα υπόλοιπα. Επιλέγει μία λογική κλίμακα για χρήση με τα αισθητικά στοιχεία και δημιουργεί έναν υπόμνημα που εξηγεί την αντιστοίχιση μεταξύ επιπέδων και τιμών. Για τα αισθητικά στοιχεία των x και y, το πακέτο ggplot2 δεν δημιουργεί υπόμνημα, αλλά δημιουργεί μία γραμμή άξονα με σημάδια και μία ετικέτα. Η γραμμή άξονα παρέχει τις ίδιες πληροφορίες με ένα υπόμνημα; εξηγεί την αντιστοίχιση μεταξύ τοποθεσιών και τιμών.\nΜπορείτε επίσης να ορίσετε τις οπτικές ιδιότητες του geom σας με μη αυτόματο τρόπο, ως όρισμα της συνάρτησης geom (εκτός του aes()), αντί να βασίζεστε σε μία αντιστοίχιση μεταβλητής για να προσδιορίσετε την εμφάνιση. Για παράδειγμα, μπορούμε να κάνουμε όλα τα σημεία στο διάγραμμα μπλε:\n\nggplot(mpg, aes(x = displ, y = hwy)) + \n  geom_point(color = \"blue\")\n\n\n\n\n\n\n\nΕδώ, το χρώμα δεν προσδίδει πληροφορίες για κάποια μεταβλητή, αλλάζει μόνο την εμφάνιση του διαγράμματος. Θα χρειαστεί να επιλέξετε μία τιμή που έχει νόημα για αυτό το αισθητικό στοιχείο:\n\nΤο όνομα ενός χρώματος ως συμβολοσειρά, π.χ., color = \"blue\"\n\nΤο μέγεθος ενός σημείου σε mm, π.χ. size = 1\n\nΤο σχήμα ενός σημείου ως αριθμός, π.χ. shape = 1, όπως φαίνεται στο Σχήμα 9.1.\n\n\n\n\n\n\n\n\nΣχήμα 9.1: Η R έχει 25 ενσωματωμένα σχήματα που προσδιορίζονται απο αριθμούς. Υπάρχουν μερικά φαινομενικά διπλότυπα: για παράδειγμα, το 0, το 15 και το 22 είναι όλα τετράγωνα. Η διαφορά προέρχεται από την αλληλεπίδραση των αισθητικών στοιχείων color και fill. Τα κενά σχήματα (0–14) έχουν ένα περίγραμμα που καθορίζεται από το color. Τα συμπαγή σχήματα (15–20) είναι γεμισμένα με color. Τα γεμισμένα σχήματα (21–24) έχουν περίγραμμα color και γεμίζονται με fill. Τα σχήματα είναι διατεταγμένα ώστε να διατηρούν παρόμοια σχήματα το ένα δίπλα στο άλλο.\n\n\n\n\nΜέχρι στιγμής έχουμε συζητήσει για τα αισθητικά στοιχεία που μπορούμε να ορίσουμε σε ένα διάγραμμα διασποράς, όταν χρησιμοποιούμε ένα geom σημείων (geom point). Μπορείτε να μάθετε περισσότερα για όλες τις πιθανές επιλογές σχετικές με τα αισθητικά στοιχεία στη διεύθυνση https://ggplot2.tidyverse.org/articles/ggplot2-specs.html.\nΤα αισθητικά στοιχεία που μπορείτε να χρησιμοποιήσετε για ένα διάγραμμα εξαρτώνται από το συγκεκριμένο geom που χρησιμοποιείτε για να αναπαραστήσετε δεδομένα. Αναλύουμε περισσότερο τα geoms στην επόμενη ενότητα.\n\n9.2.1 Ασκήσεις\n\nΔημιουργήστε ένα διάγραμμα διασποράς της μεταβλητής hwy έναντι της displ όπου τα σημεία είναι τρίγωνα γεμισμένα με ροζ χρώμα.\n\nΓιατί ο παρακάτω κώδικας δεν έχει ως αποτέλεσμα ένα διάγραμμα με μπλε σημεία;\n\nggplot(mpg) + \n  geom_point(aes(x = displ, y = hwy, color = \"blue\"))\n\n\nΤι κάνει το αισθητικό στοιχείο stroke; Με τι σχήματα λειτουργεί; (Συμβουλή: χρησιμοποιήστε το ?geom_point)\nΤι συμβαίνει εάν αντιστοιχίσετε ένα αισθητικό στοιχείο σε κάτι διαφορετικό από ένα όνομα μεταβλητής, όπως aes(color = displ &lt; 5); Σημείωση, θα χρειαστεί επίσης να καθορίσετε τιμές για τα x και y.",
    "crumbs": [
      "Οπτικοποίηση",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Επίπεδα</span>"
    ]
  },
  {
    "objectID": "layers.html#γεωμετρικά-αντικείμενα",
    "href": "layers.html#γεωμετρικά-αντικείμενα",
    "title": "9  Επίπεδα",
    "section": "\n9.3 Γεωμετρικά αντικείμενα",
    "text": "9.3 Γεωμετρικά αντικείμενα\nΠόσο όμοια είναι αυτά τα δύο διαγράμματα;\n\n\n\n\n\n\n\n\n\n\n\n\n\nΚαι τα δύο διαγράμματα περιέχουν την ίδια μεταβλητή x, την ίδια μεταβλητή y, και τα δύο περιγράφουν τα ίδια δεδομένα. Αλλά δεν είναι πανομοιότυπα. Κάθε διάγραμμα χρησιμοποιεί ένα διαφορετικό γεωμετρικό αντικείμενο, το geom, για να αναπαραστήσει τα δεδομένα. Το διάγραμμα στα αριστερά χρησιμοποιεί το στοιχείο geom και η γραφική παράσταση στα δεξιά χρησιμοποιεί το smooth geom, μία ομαλοποιημένη γραμμή προσαρμοσμένη στα δεδομένα.\nΓια να αλλάξετε το geom στο διάγραμμα σας, αλλάξτε τη συνάρτηση geom που προσθέτετε στη ggplot(). Για παράδειγμα, για να φτιάξετε τα παραπάνω διαγράμματα, μπορείτε να χρησιμοποιήσετε τον ακόλουθο κώδικα:\n\n# Αριστερά\nggplot(mpg, aes(x = displ, y = hwy)) + \n  geom_point()\n\n# Δεξιά\nggplot(mpg, aes(x = displ, y = hwy)) + \n  geom_smooth()\n#&gt; `geom_smooth()` using method = 'loess' and formula = 'y ~ x'\n\nΚάθε λειτουργία του geom στο πακέτο ggplot2 λαμβάνει ένα όρισμα mapping που είτε ορίζεται τοπικά στο geom είτε καθολικά στο επίπεδο της ggplot(). Ωστόσο, κάθε αισθητικό στοιχείο δεν λειτουργεί με κάθε geom. Θα μπορούσατε να ορίσετε το σχήμα ενός σημείου, αλλά δεν θα μπορούσατε να ορίσετε το “σχήμα” μιας γραμμής (linetype). Εάν το προσπαθήσετε, το πακέτο ggplot2 θα το αγνοήσει χωρίς κάποια προειδοποίηση. Από την άλλη πλευρά, θα μπορούσατε να ορίσετε τον τύπο μιας γραμμής. Η geom_smooth() θα σχεδιάσει μία διαφορετική γραμμή, με διαφορετικό τύπο, για κάθε μοναδική τιμή της μεταβλητής που αντιστοιχίζετε σε αυτό τον τύπο.\n# Αριστερά\nggplot(mpg, aes(x = displ, y = hwy, shape = drv)) + \n  geom_smooth()\n\n# Δεξιά\nggplot(mpg, aes(x = displ, y = hwy, linetype = drv)) + \n  geom_smooth()\n\n\n\n\n\n\n\n\n\n\nΕδώ, η geom_smooth() χωρίζει τα αυτοκίνητα σε τρεις γραμμές με βάση την αντίστοιχη τιμή τους στη μεταβλητή drv, η οποία περιγράφει την κίνηση ενός αυτοκινήτου. Μία γραμμή περιγράφει όλα τα σημεία που έχουν τιμή 4, μία περιγράφει όλα τα σημεία που έχουν τιμή f και μία περιγράφει όλα τα σημεία που έχουν τιμή r. Εδώ, το 4 σημαίνει τετρακίνηση, το f κίνηση στους μπροστινούς τροχούς και το r κίνηση στους πίσω τροχούς.\nΣε περίπτωση που αυτό φαίνεται περίεργο, μπορούμε να το κάνουμε πιο σαφές τοποθετώντας τις γραμμές πάνω από τα ανεπεξέργαστα δεδομένα και μετά χρωματίζοντάς τα σύμφωνα με τη drv.\n\nggplot(mpg, aes(x = displ, y = hwy, color = drv)) + \n  geom_point() +\n  geom_smooth(aes(linetype = drv))\n\n\n\n\n\n\n\nΠαρατηρήστε ότι το διάγραμμα περιέχει δύο στοιχεία geom στο ίδιο γράφημα.\nΠολλά geoms, όπως η geom_smooth(), χρησιμοποιούν ένα μόνο γεωμετρικό αντικείμενο για να προβάλλουν πολλές γραμμές δεδομένων. Για αυτά τα geoms, μπορείτε να ορίσετε το αισθητικό στοιχείο group σε μία κατηγορική μεταβλητή έτσι ώστε να σχεδιάσετε πολλά αντικείμενα. Η ggplot2 θα σχεδιάσει ένα ξεχωριστό αντικείμενο για κάθε μοναδική τιμή της μεταβλητής ομαδοποίησης. Στην πράξη, το πακέτο ggplot2 θα ομαδοποιεί αυτόματα τα δεδομένα για αυτά τα geoms κάθε φορά που χρησιμοποιείτε ένα αισθητικό στοιχείο σε μία διακριτή μεταβλητή (όπως στο παράδειγμα με τη linetype). Είναι βολικό να βασίζεστε σε αυτό το χαρακτηριστικό, καθώς το στοιχείο group από μόνο του δεν προσθέτει κάποιο υπόμνημα ή διακριτά χαρακτηριστικά στα geoms.\n# Αριστερά\nggplot(mpg, aes(x = displ, y = hwy)) +\n  geom_smooth()\n\n# Μέση\nggplot(mpg, aes(x = displ, y = hwy)) +\n  geom_smooth(aes(group = drv))\n\n# Δεξιά\nggplot(mpg, aes(x = displ, y = hwy)) +\n  geom_smooth(aes(color = drv), show.legend = FALSE)\n\n\n\n\n\n\n\n\n\n\n\n\n\nΕάν τοποθετήσετε ορίσματα σε ένα στοιχείο geom, το πακέτο ggplot2 θα τα αντιμετωπίσει ως τοπικά ορίσματα για το συγκεκριμένο επίπεδο. Θα τα χρησιμοποιήσει για να επεκτείνει ή να αντικαταστήσει τα γενικά ορίσματα μόνο για αυτό το επίπεδο. Αυτό καθιστά δυνατή την εμφάνιση διαφορετικών αισθητικών στοιχείων σε διαφορετικά επίπεδα.\n\nggplot(mpg, aes(x = displ, y = hwy)) + \n  geom_point(aes(color = class)) + \n  geom_smooth()\n\n\n\n\n\n\n\nΜπορείτε να χρησιμοποιήσετε την ίδια μεθοδολογία για να ορίσετε διαφορετικά δεδομένα στο όρισμα data για κάθε επίπεδο. Εδώ, χρησιμοποιούμε κόκκινα σημεία καθώς και ανοιχτούς κύκλους για να τονίσουμε τα διθέσια αυτοκίνητα. Ο ορισμός των δεδομένων στη geom_point() αντικαθιστά το γενικό όρισμα δεδομένων στη ggplot() μόνο για αυτό το επίπεδο.\n\nggplot(mpg, aes(x = displ, y = hwy)) + \n  geom_point() + \n  geom_point(\n    data = mpg |&gt; filter(class == \"2seater\"), \n    color = \"red\"\n  ) +\n  geom_point(\n    data = mpg |&gt; filter(class == \"2seater\"), \n    shape = \"circle open\", size = 3, color = \"red\"\n  )\n\n\n\n\n\n\n\nΤα geoms είναι τα δομικά στοιχεία της ggplot2. Μπορείτε να αλλάξετε εντελώς την εμφάνιση του διαγράμματός σας αλλάζοντας τα αντίστοιχα geoms καθώς διαφορετικοί τύποι μπορούν να αποκαλύψουν διαφορετικά χαρακτηριστικά των δεδομένων σας. Για παράδειγμα, το ιστόγραμμα και το διάγραμμα πυκνότητας παρακάτω αποκαλύπτουν ότι η κατανομή των χιλιομέτρων σε αυτοκινητόδρομο εμφανίζει δύο κορυφές και θετική στρέβλωση, ενώ το θηκόγραμμα αποκαλύπτει δύο πιθανές ακραίες τιμές.\n# Αριστερά\nggplot(mpg, aes(x = hwy)) +\n  geom_histogram(binwidth = 2)\n\n# Μέση\nggplot(mpg, aes(x = hwy)) +\n  geom_density()\n\n# Δεξιά\nggplot(mpg, aes(x = hwy)) +\n  geom_boxplot()\n\n\n\n\n\n\n\n\n\n\n\n\n\nΗ ggplot2 παρέχει περισσότερα από 40 στοιχεία geom. Αυτά όμως δεν καλύπτουν κάθε πιθανό διάγραμμα που θα μπορούσε κάποιος να κάνει. Εάν χρειάζεστε διαφορετικά geoms, συνιστούμε να εξετάσετε πρώτα τα πακέτα επεκτάσεων για να δείτε εάν κάποιος άλλος το έχει ήδη εφαρμόσει (βλέπε https://exts.ggplot2.tidyverse.org/gallery/ για ένα δείγμα). Για παράδειγμα, το πακέτο ggridges (https://wilkelab.org/ggridges) είναι χρήσιμο για τη δημιουργία διαγραμμάτων κορυφογραμμής (ridgeline), για την οπτικοποίηση της πυκνότητας μιας αριθμητικής μεταβλητής για διαφορετικά επίπεδα μιας άλλης κατηγορικής μεταβλητής. Στο παρακάτω διάγραμμα όχι μόνο χρησιμοποιήσαμε ένα νέο geom (geom_density_ridges()), αλλά αντιστοιχίσαμε επίσης την ίδια μεταβλητή σε πολλαπλά αισθητικά στοιχεία (drv στη y, fill, και color) και ορίσαμε ένα αισθητικό στοιχείο (alpha = 0.5) για να κάνουμε τις καμπύλες πυκνότητας διαφανείς.\n\nlibrary(ggridges)\n\nggplot(mpg, aes(x = hwy, y = drv, fill = drv, color = drv)) +\n  geom_density_ridges(alpha = 0.5, show.legend = FALSE)\n#&gt; Picking joint bandwidth of 1.28\n\n\n\n\n\n\n\nΤο καλύτερο μέρος για να έχετε μία ολοκληρωμένη εικόνα όλων των geoms που προσφέρει το πακέτο ggplot2, καθώς και όλων των λειτουργιών του πακέτου, είναι η σελίδα: https://ggplot2.tidyverse.org/reference. Για να μάθετε περισσότερα σχετικά με οποιοδήποτε μεμονωμένο geom, χρησιμοποιήστε την εντολή βοήθειας (π.χ. ?geom_smooth).\n\n9.3.1 Ασκήσεις\n\nΠοιο geom θα χρησιμοποιούσατε για να σχεδιάσετε ένα διάγραμμα γραμμών; Ένα θηκόγραμμα; Ένα Ιστόγραμμα; Ένα διάγραμμα περιοχής;\n\nΝωρίτερα σε αυτό το κεφάλαιο χρησιμοποιήσαμε το show.legend χωρίς να το εξηγήσουμε:\n\nggplot(mpg, aes(x = displ, y = hwy)) +\n  geom_smooth(aes(color = drv), show.legend = FALSE)\n\nΤι κάνει εδώ το “show.legend = FALSE”; Τι θα συμβεί αν το αφαιρέσετε; Γιατί πιστεύετε ότι το χρησιμοποιήσαμε νωρίτερα;\n\nΤι κάνει το όρισμα se στη geom_smooth();\n\nΓράψτε ξανά τον κώδικα R που είναι απαραίτητος για τη δημιουργία των παρακάτω γραφημάτων. Σημειώστε ότι οπουδήποτε στο διάγραμμα χρησιμοποιείται μία κατηγορική μεταβλητή, είναι η drv.",
    "crumbs": [
      "Οπτικοποίηση",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Επίπεδα</span>"
    ]
  },
  {
    "objectID": "layers.html#όψεις",
    "href": "layers.html#όψεις",
    "title": "9  Επίπεδα",
    "section": "\n9.4 Όψεις",
    "text": "9.4 Όψεις\nΣτο Κεφάλαιο 1 μάθατε για τις όψεις με τη facet_wrap(), η οποία χωρίζει ένα διάγραμμα σε υπο-διαγράμματα όπου το καθένα εμφανίζει ένα υποσύνολο των δεδομένων με βάση μία κατηγορική μεταβλητή.\n\nggplot(mpg, aes(x = displ, y = hwy)) + \n  geom_point() + \n  facet_wrap(~cyl)\n\n\n\n\n\n\n\nΓια να δημιουργήσετε όψεις στο διάγραμμα σας με τον συνδυασμό δύο μεταβλητών, χρησιμοποιήστε αντί της facet_wrap() τη facet_grid(). Το πρώτο όρισμα της facet_grid() είναι επίσης ένας μαθηματικός τύπος (formula), αλλά τώρα είναι τύπος διπλής όψης: γραμμές ~ στήλες.\n\nggplot(mpg, aes(x = displ, y = hwy)) + \n  geom_point() + \n  facet_grid(drv ~ cyl)\n\n\n\n\n\n\n\nΑπό προεπιλογή, κάθε όψη μοιράζεται την ίδια κλίμακα και εύρος στους άξονες x και y. Αυτό είναι χρήσιμο όταν θέλετε να συγκρίνετε δεδομένα μεταξύ των όψεων, αλλά μπορεί σας περιορίσει όταν θέλετε να οπτικοποιήσετε τη σχέση μεταξύ τους. Η ρύθμιση του ορίσματος scales σε free μέσα σε μία συνάρτηση όψεως θα επιτρέψει την ύπαρξη διαφορετικών κλιμάκων αξόνων στις γραμμές και στις στήλες, το free_x θα επιτρέψει διαφορετικές κλίμακες στις σειρές και το free_y θα επιτρέψει διαφορετικές κλίμακες στις στήλες.\n\nggplot(mpg, aes(x = displ, y = hwy)) + \n  geom_point() + \n  facet_grid(drv ~ cyl, scales = \"free_y\")\n\n\n\n\n\n\n\n\n9.4.1 Ασκήσεις\n\nΤι συμβαίνει αν δημιουργήσετε όψεις με μία συνεχή μεταβλητή;\nΤι σημαίνουν τα άδεια κελιά στο παραπάνω διάγραμμα έχοντας χρησιμοποιήσει facet_grid(drv ~ cyl); Εκτελέστε τον παρακάτω κώδικα. Πώς σχετίζονται με το διάγραμμα που προκύπτει;\n\n```{r}\n#| fig-show: hide\n\nggplot(mpg) + \n  geom_point(aes(x = drv, y = cyl))\n```\n\n\nΤι διαγράμματα παράγει ο παρακάτω κώδικας; Τι κάνει το .;\n\nggplot(mpg) + \n  geom_point(aes(x = displ, y = hwy)) +\n  facet_grid(drv ~ .)\n\nggplot(mpg) + \n  geom_point(aes(x = displ, y = hwy)) +\n  facet_grid(. ~ cyl)\n\n\n\nΠάρτε το πρώτο διάγραμμα με όψεις σε αυτο το κεφάλαιο:\n\nggplot(mpg) + \n  geom_point(aes(x = displ, y = hwy)) + \n  facet_wrap(~ class, nrow = 2)\n\nΠοια είναι τα πλεονεκτήματα από τη χρήση όψεων σε σχέση με τα αισθητικά στοιχεία χρωμάτων; Ποια είναι τα μειονεκτήματα; Πώς μπορεί να αλλάξει η ισορροπία εαν είχατε ένα μεγαλύτερο σύνολο δεδομένων;\n\nΔιαβάστε το βοηθητικό κείμενο της ?facet_wrap. Τι κάνει το nrow; Τι κάνει το ncol; Ποιες άλλες επιλογές ελέγχουν τη διάταξη των επιμέρους πλαισίων; Γιατί το facet_grid() δεν έχει ορίσματα nrow και ncol;\n\nΠοιο από τα παρακάτω διαγράμματα καθιστά πιο εύκολη τη σύγκριση του μεγέθους του κινητήρα (displ) σε αυτοκίνητα με διαφορετικά συστήματα μετάδοσης κίνησης; Τι λέει αυτό για το πότε πρέπει να τοποθετηθεί μία μεταβλητή με όψη σε γραμμές ή στήλες;\n\nggplot(mpg, aes(x = displ)) + \n  geom_histogram() + \n  facet_grid(drv ~ .)\n\nggplot(mpg, aes(x = displ)) + \n  geom_histogram() +\n  facet_grid(. ~ drv)\n\n\n\nΔημιουργήστε ξανά το ακόλουθο διάγραμμα χρησιμοποιώντας facet_wrap() αντί για facet_grid(). Πώς αλλάζουν οι θέσεις των τίτλων των όψεων;\n\nggplot(mpg) + \n  geom_point(aes(x = displ, y = hwy)) +\n  facet_grid(drv ~ .)",
    "crumbs": [
      "Οπτικοποίηση",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Επίπεδα</span>"
    ]
  },
  {
    "objectID": "layers.html#στατιστικοί-μετασχηματισμοί",
    "href": "layers.html#στατιστικοί-μετασχηματισμοί",
    "title": "9  Επίπεδα",
    "section": "\n9.5 Στατιστικοί μετασχηματισμοί",
    "text": "9.5 Στατιστικοί μετασχηματισμοί\nΈστω ένα απλό διάγραμμα ράβδων, σχεδιασμένο με geom_bar() ή geom_col(). Το παρακάτω διάγραμμα δείχνει τον συνολικό αριθμό διαμαντιών στο σύνολο δεδομένων diamonds, ομαδοποιημένα ανά cut. Το σύνολο δεδομένων diamonds βρίσκεται στο πακέτο ggplot2 και περιέχει πληροφορίες για ~54.000 διαμάντια, συμπεριλαμβανομένων των price (τιμή), carat (καράτια), color (χρώμα), clarity (ευκρίνεια), και cut (κοπή) κάθε διαμαντιού. Το διάγραμμα δείχνει ότι περισσότερα διαμάντια είναι διαθέσιμα με κοπές υψηλής ποιότητας παρά με κοπές χαμηλής ποιότητας.\n\nggplot(diamonds, aes(x = cut)) + \n  geom_bar()\n\n\n\n\n\n\n\nΣτον άξονα x, το διάγραμμα εμφανίζει την cut, μία μεταβλητή από το diamonds. Στον άξονα y, εμφανίζει το πλήθος, αλλά το πλήθος δεν είναι διαθέσημη μεταβλητή στο σετ δεδομένων diamonds! Από πού προέρχεται αυτή η καταμέτρηση του πλήθους; Πολλά γραφήματα, όπως τα διαγράμματα διασποράς, παρουσιάζουν τις ανεπεξέργαστες τιμές του συνόλου δεδομένων σας. Άλλα γραφήματα, όπως τα γραφήματα ράβδων, υπολογίζουν νέες τιμές για σχεδίαση:\n\nΤα γραφήματα ράβδων, τα ιστογράμματα και τα πολύγωνα συχνότητας χωρίζουν σε εύρη τα δεδομένα σας και, στη συνέχεια, παρουσιάζουν τις καταμετρήσεις των παρατηρήσεων που βρίσκονται μέσα σε αυτά τα εύρη.\nΟι εξομαλυντές ή ομαλοποιητές (smoothers) προσαρμόζουν ένα μοντέλο στα δεδομένα σας και στη συνέχεια παρουσιάζουν τις αντίστοιχες προβλέψεις του.\nΤα θηκογράμματα υπολογίζουν τα πέντε βασικά περιγραφικά στατιστικά της κατανομής των δεδομένων και στη συνέχεια τα παρουσιάζουν ως ένα ειδικά διαμορφωμένο πλαίσιο.\n\nΟ αλγόριθμος που χρησιμοποιείται για τον υπολογισμό νέων τιμών για ένα γράφημα ονομάζεται stat, συντομογραφία του στατιστικού μετασχηματισμού (statistical transformation). Το Σχήμα 9.2 δείχνει πώς λειτουργεί αυτή η διαδικασία με το geom_bar().\n\n\n\n\n\n\n\nΣχήμα 9.2: Όταν δημιουργούμε ένα ραβδόγραμμα, αρχίζουμε με τα ανεπεξέργαστα δεδομένα, μετά τα συγκεντρώνουμε για να μετρήσουμε τον αριθμό των παρατηρήσεων σε κάθε ράβδο και, τέλος, αντοστοιχίζουμε αυτές τις μεταβλητές για την παρουσίαση των αισθητικών στοιχείων.\n\n\n\n\nΜπορείτε να μάθετε ποια στατιστική (stat) χρησιμοποιεί ένα geom επιθεωρώντας την προεπιλεγμένη τιμή για το όρισμα stat. Για παράδειγμα, το ?geom_bar δείχνει ότι η προεπιλεγμένη τιμή για το stat είναι η count, που σημαίνει ότι το geom_bar() χρησιμοποιεί το stat_count(). Το stat_count() τεκμηριώνεται στην ίδια σελίδα με το geom_bar(). Λίγο παρα κάτω, η ενότητα “Υπολογιζόμενες μεταβλητές” εξηγεί ότι υπολογίζει δύο νέες μεταβλητές: την count και τη prop.\nΚάθε geom έχει μία προεπιλεγμένη στατιστική (stat) και κάθε στατιστική έχει ένα προεπιλεγμένο geom. Αυτό σημαίνει ότι μπορείτε συνήθως να χρησιμοποιήσετε ένα geom χωρίς να ανησυχείτε για τον υποκείμενο στατιστικό μετασχηματισμό. Ωστόσο, υπάρχουν τρεις λόγοι για τους οποίους μπορεί να χρειαστεί να χρησιμοποιήσετε μία διαφορετική στατιστική:\n\nΊσως θέλετε να παρακάμψετε το προεπιλεγμένο στατιστικό. Στον παρακάτω κώδικα, αλλάζουμε το stat του geom_bar() από count (η προεπιλογή) σε identity. Αυτό μας επιτρέπει να αντιστοιχίσουμε το ύψος των ράβδων με τις ανεπεξέργαστες τιμές μιας μεταβλητής y.\n\n\ndiamonds |&gt;\n  count(cut) |&gt;\n  ggplot(aes(x = cut, y = n)) +\n  geom_bar(stat = \"identity\")\n\n\n\n\n\n\n\n\n\nΊσως θέλετε να παρακάμψετε την προεπιλεγμένη αντιστοίχιση από μετασχηματισμένες μεταβλητές σε αισθητικά στοιχεία. Για παράδειγμα, μπορεί να θέλετε να παρουσιάσετε ένα γράφημα ράβδων με αναλογίες, αντί για καταμετρήσεις:\n\nggplot(diamonds, aes(x = cut, y = after_stat(prop), group = 1)) + \n  geom_bar()\n\n\n\n\n\n\n\nΓια να βρείτε τις πιθανές μεταβλητές που μπορούν να υπολογιστούν από το στατιστικό (stat), αναζητήστε την ενότητα με τίτλο “Υπολογιζόμενες Μεταβλητές” στο παράθυρο βοήθειας της geom_bar().\n\n\nΊσως θέλετε να δώσετε μεγαλύτερη προσοχή στον στατιστικό μετασχηματισμό στον κώδικά σας. Για παράδειγμα, μπορείτε να χρησιμοποιήσετε τη stat_summary(), η οποία συνοψίζει τις τιμές y για κάθε μοναδική τιμή x, για να δώσετε την έμφαση στη σύνοψη που υπολογίζετε:\n\nggplot(diamonds) + \n  stat_summary(\n    aes(x = cut, y = depth),\n    fun.min = min,\n    fun.max = max,\n    fun = median\n  )\n\n\n\n\n\n\n\n\n\nΗ ggplot2 παρέχει περισσότερα από 20 στατιστικά για χρήση. Κάθε στατιστικό είναι μία συνάρτηση, επομένως μπορείτε να λάβετε βοήθεια με τον συνηθισμένο τρόπο, π.χ. ?stat_bin.\n\n9.5.1 Ασκήσεις\n\nΠοιο είναι το προεπιλεγμένο geom που σχετίζεται με το stat_summary(); Πώς θα μπορούσατε να ξαναγράψετε το προηγούμενο διάγραμμα για να χρησιμοποιήσετε τη συνάρτηση geom αντί για τη συνάρτηση stat;\nΤι κάνει η geom_col(); Πώς διαφέρει από τη geom_bar();\nΤα περισσότερα geoms και στατιστικά έρχονται σε ζεύγη που χρησιμοποιούνται σχεδόν πάντα μαζί. Κάντε μία λίστα με όλα τα ζευγάρια. Τι έχουν κοινό? (Συμβουλή: Διαβάστε την τεκμηρίωση.)\nΠοιες μεταβλητές υπολογίζει η stat_smooth(); Ποια ορίσματα ελέγχουν τη συμπεριφορά του;\n\nΣτο διάγραμμα ράβδων αναλογιών, πρέπει να ορίσουμε group = 1. Γιατί; Με άλλα λόγια, ποιο είναι το πρόβλημα με αυτά τα δύο διαγράμματα;\n\nggplot(diamonds, aes(x = cut, y = after_stat(prop))) + \n  geom_bar()\nggplot(diamonds, aes(x = cut, fill = color, y = after_stat(prop))) + \n  geom_bar()",
    "crumbs": [
      "Οπτικοποίηση",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Επίπεδα</span>"
    ]
  },
  {
    "objectID": "layers.html#ρυθμίσεις-θέσης",
    "href": "layers.html#ρυθμίσεις-θέσης",
    "title": "9  Επίπεδα",
    "section": "\n9.6 Ρυθμίσεις θέσης",
    "text": "9.6 Ρυθμίσεις θέσης\nΥπάρχει ένα ακόμη μαγικό στοιχείο που σχετίζεται με το ραβδόγραμμα. Μπορείτε να χρωματίσετε ένα γράφημα ράβδων χρησιμοποιώντας είτε το αισθητικό στοιχείο color ή, πιο χρήσιμα, το στοιχείο fill:\n# Αριστερά\nggplot(mpg, aes(x = drv, color = drv)) + \n  geom_bar()\n\n# Δεξιά\nggplot(mpg, aes(x = drv, fill = drv)) + \n  geom_bar()\n\n\n\n\n\n\n\n\n\n\nΠαρατηρήστε τι συμβαίνει εάν αντιστοιχίσετε το αισθητικό στοιχείο fill σε μία άλλη μεταβλητή, όπως η class: οι γραμμές στοιβάζονται αυτόματα. Κάθε έγχρωμο ορθογώνιο αντιπροσωπεύει έναν συνδυασμό των μεταβλητών drv και class.\n\nggplot(mpg, aes(x = drv, fill = class)) + \n  geom_bar()\n\n\n\n\n\n\n\nΗ στοίβαξη εκτελείται αυτόματα χρησιμοποιώντας την προσαρμογή θέσης που καθορίζεται από το όρισμα position. Εάν δεν θέλετε ένα γράφημα με στοιβαγμένες μπάρες, μπορείτε να χρησιμοποιήσετε μία από τις τρεις άλλες επιλογές: identity, dodge ή fill.\n\nΤο position = \"identity\" θα τοποθετήσει κάθε αντικείμενο ακριβώς εκεί που εμπίπτει στο πλαίσιο του γραφήματος. Αυτό δεν είναι πολύ χρήσιμο για τις μπάρες, γιατί τις επικαλύπτει. Για να δούμε αυτήν την επικάλυψη, πρέπει είτε να κάνουμε τις ράβδους ελαφρώς διαφανείς ορίζοντας το alpha σε μία μικρή τιμή ή εντελώς διαφανείς ορίζοντας fill = NA.\n\n# Αριστερά\nggplot(mpg, aes(x = drv, fill = class)) + \n  geom_bar(alpha = 1/5, position = \"identity\")\n\n# Δεξιά\nggplot(mpg, aes(x = drv, color = class)) + \n  geom_bar(fill = NA, position = \"identity\")\n\n\n\n\n\n\n\n\n\n\nΗ προσαρμογή θέσης με τη χρήση του identity είναι πιο χρήσιμη για geoms 2 διαστάσεων, όπως σημεία, όπου είναι και η προεπιλογή.\n\nΤο position = \"fill\" λειτουργεί όπως η στοίβαξη, αλλά κάνει κάθε σετ στοιβαγμένων ράβδων το ίδιο ύψος. Αυτό διευκολύνει τη σύγκριση των αναλογιών μεταξύ των ομάδων.\nΤο position = \"dodge\" τοποθετεί επικαλυπτόμενα αντικείμενα απευθείας δίπλα το ένα στο άλλο. Αυτό διευκολύνει τη σύγκριση μεμονωμένων τιμών.\n\n# Αριστερά\nggplot(mpg, aes(x = drv, fill = class)) + \n  geom_bar(position = \"fill\")\n\n# Δεξιά\nggplot(mpg, aes(x = drv, fill = class)) + \n  geom_bar(position = \"dodge\")\n\n\n\n\n\n\n\n\n\n\nΥπάρχει ένας άλλος τύπος προσαρμογής που δεν είναι χρήσιμος για διαγράμματα ράβδων, αλλά μπορεί να είναι πολύ χρήσιμος για διαγράμματα διασποράς. Θυμηθείτε το πρώτο μας διάγραμμα διασποράς. Παρατηρήσατε ότι το διάγραμμα εμφανίζει μόνο 126 σημεία, παρόλο που υπάρχουν 234 παρατηρήσεις στο σύνολο δεδομένων;\n\n\n\n\n\n\n\n\nΟι υποκείμενες τιμές των hwy και displ στρογγυλοποιούνται, ώστε τα σημεία να εμφανίζονται σε ένα πλέγμα και έτσι πολλά σημεία επικαλύπτονται μεταξύ τους. Αυτό το πρόβλημα είναι γνωστό ως overplotting. Αυτή η διάταξη καθιστά την προβολή της κατανομής των δεδομένων δύσκολη. Τα σημεία δεδομένων κατανέμονται ομοιόμορφα σε όλο το διάγραμμα ή μπορεί να υπάρχει ένας συνδυασμός των μεταβλητών hwy και displ που περιέχει 109 τιμές;\nΜπορείτε να αποφύγετε αυτό το πρόβλημα αλλάζοντας τη ρύθμιση θέσης σε “jitter”. Το position = \"jitter\" προσθέτει μία μικρή ποσότητα τυχαίου θορύβου σε κάθε σημείο. Αυτό διαχέει τα σημεία, επειδή δύο σημεία δεν είναι πιθανό να λάβουν την ίδια ποσότητα τυχαίου θορύβου.\n\nggplot(mpg, aes(x = displ, y = hwy)) + \n  geom_point(position = \"jitter\")\n\n\n\n\n\n\n\nΗ προσθήκη τυχαιότητας φαίνεται σαν ένας περίεργος τρόπος για να βελτιώσετε το διάγραμμα σας, αλλά ενώ κάνει το γράφημά σας λιγότερο ακριβές σε μικρές κλίμακες, κάνει το γράφημά σας περισσότερο αποκαλυπτικό σε μεγάλες κλίμακες. Επειδή αυτή είναι μία πολύ χρήσιμη λειτουργία, το πακέτο ggplot2 περιέχει μία συντομογραφία για το geom_point(position = \"jitter\"): geom_jitter().\nΓια να μάθετε περισσότερα σχετικά με μία προσαρμογή θέσης, ανατρέξτε στη σελίδα βοήθειας που σχετίζεται με κάθε προσαρμογή: ?position_dodge, ?position_fill, ?position_identity, ?position_jitter και ?position_stack.\n\n9.6.1 Ασκήσεις\n\n\nΠοιο είναι το πρόβλημα με το παρακάτω διάγραμμα; Πώς θα μπορούσατε να το βελτιώσετε;\n\nggplot(mpg, aes(x = cty, y = hwy)) + \n  geom_point()\n\n\n\nΠοια είναι, εάν υπάρχει, η διαφορά μεταξύ των δύο διαγραμμάτων; Γιατί;\n\nggplot(mpg, aes(x = displ, y = hwy)) +\n  geom_point()\nggplot(mpg, aes(x = displ, y = hwy)) +\n  geom_point(position = \"identity\")\n\n\nΠοιες παράμετροι για το geom_jitter() ελέγχουν την ποσότητα του jittering;\nΣυγκρίνετε και αντιπαραβάλλετε το geom_jitter() με το geom_count().\nΠοια είναι η προεπιλεγμένη προσαρμογή θέσης για το geom_boxplot(); Δημιουργήστε μία οπτικοποίηση του συνόλου δεδομένων mpg η οποία το παρουσιάζει.",
    "crumbs": [
      "Οπτικοποίηση",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Επίπεδα</span>"
    ]
  },
  {
    "objectID": "layers.html#συστήματα-συντεταγμένων",
    "href": "layers.html#συστήματα-συντεταγμένων",
    "title": "9  Επίπεδα",
    "section": "\n9.7 Συστήματα συντεταγμένων",
    "text": "9.7 Συστήματα συντεταγμένων\nΤα συστήματα συντεταγμένων είναι ίσως το πιο περίπλοκο μέρος της ggplot2. Το προεπιλεγμένο σύστημα συντεταγμένων είναι το καρτεσιανό σύστημα συντεταγμένων όπου οι θέσεις x και y ενεργούν ανεξάρτητα για να καθορίσουν τη θέση κάθε σημείου. Υπάρχουν δύο άλλα συστήματα συντεταγμένων που, ανά περίπτωση, είναι χρήσιμα.\n\n\nΤο coord_quickmap() ορίζει σωστά την αναλογία διαστάσεων για γεωγραφικούς χάρτες. Αυτό είναι πολύ σημαντικό εάν σχεδιάζετε χωρικά δεδομένα με το πακέτο ggplot2. Δεν έχουμε χώρο για να συζητήσουμε για χάρτες σε αυτό το βιβλίο, αλλά μπορείτε να μάθετε περισσότερα στο κεφάλαιο Maps του ggplot2: Κομψά γραφικά για ανάλυση δεδομένων.\nnz &lt;- map_data(\"nz\")\n\nggplot(nz, aes(x = long, y = lat, group = group)) +\n  geom_polygon(fill = \"white\", color = \"black\")\n\nggplot(nz, aes(x = long, y = lat, group = group)) +\n  geom_polygon(fill = \"white\", color = \"black\") +\n  coord_quickmap()\n\n\n\n\n\n\n\n\n\n\n\n\nΤο coord_polar() χρησιμοποιεί πολικό σύστημα συντεταγμένων. Οι πολικές συντεταγμένες φανερώνουν μία ενδιαφέρουσα σύνδεση μεταξύ ενός διαγράμματος ράβδων και ενός διαγράμματος Coxcomb.\nbar &lt;- ggplot(data = diamonds) + \n  geom_bar(\nmapping = aes(x = clarity, fill = clarity), \nshow.legend = FALSE,\nwidth = 1\n  ) + \n  theme(aspect.ratio = 1)\n\nbar + coord_flip()\nbar + coord_polar()\n\n\n\n\n\n\n\n\n\n\n\n\n\n9.7.1 Ασκήσεις\n\nΜετατρέψτε ένα διάγραμμα στοιβαγμένων ράβδων σε γράφημα πίτας χρησιμοποιώντας το coord_polar().\nΠοια είναι η διαφορά μεταξύ της coord_quickmap() και του coord_map();\n\nΤι σας λέει το παρακάτω διάγραμμα για τη σχέση μεταξύ ταχύτητας (mpg) μέσα στη πόλη και αυτοκινητόδρομου; Γιατί είναι σημαντικό το coord_fixed(); Τι κάνει το geom_abline();\n\nggplot(data = mpg, mapping = aes(x = cty, y = hwy)) +\n  geom_point() + \n  geom_abline() +\n  coord_fixed()",
    "crumbs": [
      "Οπτικοποίηση",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Επίπεδα</span>"
    ]
  },
  {
    "objectID": "layers.html#η-πολυεπίπεδη-γραμματική-των-γραφικών",
    "href": "layers.html#η-πολυεπίπεδη-γραμματική-των-γραφικών",
    "title": "9  Επίπεδα",
    "section": "\n9.8 Η πολυεπίπεδη γραμματική των γραφικών",
    "text": "9.8 Η πολυεπίπεδη γραμματική των γραφικών\nΜπορούμε να επεκτείνουμε το πρότυπο γραφημάτων που μάθατε στην Ενότητα 1.3 προσθέτοντας προσαρμογές θέσης, στατιστικά στοιχεία, συστήματα συντεταγμένων και επιφάνειες:\nggplot(data = &lt;DATA&gt;) + \n  &lt;GEOM_FUNCTION&gt;(\n     mapping = aes(&lt;MAPPINGS&gt;),\n     stat = &lt;STAT&gt;, \n     position = &lt;POSITION&gt;\n  ) +\n  &lt;COORDINATE_FUNCTION&gt; +\n  &lt;FACET_FUNCTION&gt;\nΤο νέο μας πρότυπο παίρνει επτά παραμέτρους, τις λέξεις με αγκύλες που εμφανίζονται στο πρότυπο. Πρακτικά, σπάνια χρειάζεται να παρέχετε και τις επτά παραμέτρους για να δημιουργήσετε ένα διάγραμμα επειδή το πακέτο ggplot2 θα παρέχει χρήσιμες προεπιλογές για τα πάντα εκτός από τα δεδομένα, τις αντιστοιχίσεις και τη συνάρτηση geom.\nΟι επτά παράμετροι στο πρότυπο συνθέτουν τη γραμματική των γραφικών, ένα επίσημο σύστημα για διαγράμματα. Η γραμματική των γραφικών βασίζεται στο ότι μπορείτε να περιγράψετε μοναδικά οποιαδήποτε διάγραμμα ως συνδυασμό ενός συνόλου δεδομένων, ενός γεωγραφικού στοιχείου, ενός συνόλου αντιστοιχίσεων, ενός στατιστικού στοιχείου, μιας προσαρμογής θέσης, ενός συστήματος συντεταγμένων, ενός σχήματος όψεων και ενός θέματος.\nΓια να δείτε πώς λειτουργεί αυτό, σκεφτείτε πώς θα μπορούσατε να δημιουργήσετε ένα απλό διάγραμμα από την αρχή: θα μπορούσατε να ξεκινήσετε με ένα σύνολο δεδομένων και στη συνέχεια να το μετατρέψετε στις πληροφορίες που θέλετε να εμφανίσετε (με ένα στατιστικό). Στη συνέχεια, θα μπορούσατε να επιλέξετε ένα γεωμετρικό αντικείμενο για να αναπαραστήσετε κάθε παρατήρηση στα μετασχηματισμένα δεδομένα. Στη συνέχεια, θα μπορούσατε να χρησιμοποιήσετε τις αισθητικές ιδιότητες των geoms για να αναπαραστήσετε μεταβλητές στα δεδομένα. Θα αντιστοιχίζατε τις τιμές κάθε μεταβλητής στα επίπεδα ενός αισθητικού στοιχείου. Αυτά τα βήματα απεικονίζονται στο Σχήμα 9.3. Στη συνέχεια, θα επιλέγατε ένα σύστημα συντεταγμένων στο οποίο θα τοποθετήσετε τα geoms, χρησιμοποιώντας τη θέση των αντικειμένων (η οποία είναι από μόνη της μία αισθητική ιδιότητα) για να εμφανίσετε τις τιμές των μεταβλητών x και y.\n\n\n\n\n\n\n\nΣχήμα 9.3: Βήματα για τη μετάβαση από τα ανεπεξέργαστα δεδομένα σε έναν πίνακα συχνοτήτων σε ένα διάγραμμα ράβδων όπου τα ύψη της ράβδου αντιπροσωπεύουν τις συχνότητες.\n\n\n\n\nΣε αυτό το σημείο, θα πρέπει να έχετε ένα πλήρες διάγραμμα, αλλά θα μπορούσατε να προσαρμόσετε περαιτέρω τις θέσεις των γεωγραφικών στοιχείων (geoms) μέσα στο σύστημα συντεταγμένων (μια προσαρμογή θέσης) ή να χωρίσετε το γράφημα σε υπο-διαγράμματα (με όψεις). Θα μπορούσατε επίσης να επεκτείνετε το διάγραμμα προσθέτοντας ένα ή περισσότερα επιπλέον επίπεδα, όπου κάθε επιπλέον επίπεδο χρησιμοποιεί ένα σύνολο δεδομένων, ένα γεωγραφικό στοιχείο, ένα σύνολο αντιστοιχίσεων, ένα στατιστικό στοιχείο και μία προσαρμογή θέσης.\nΘα μπορούσατε να χρησιμοποιήσετε αυτήν τη μέθοδο για να δημιουργήσετε οποιοδήποτε διάγραμμα φαντάζεστε. Με άλλα λόγια, μπορείτε να χρησιμοποιήσετε τον κώδικα που έχετε μάθει σε αυτό το κεφάλαιο για να δημιουργήσετε εκατοντάδες χιλιάδες μοναδικά διαγράμματα\nΕάν θέλετε να μάθετε περισσότερα σχετικά με τις θεωρητικές βάσεις της ggplot2, μπορείτε να διαβάσετε το “The Layered Grammar of Graphics”, την επιστημονική εργασία που περιγράφει αναλυτικά τη θεωρία της ggplot2.",
    "crumbs": [
      "Οπτικοποίηση",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Επίπεδα</span>"
    ]
  },
  {
    "objectID": "layers.html#σύνοψη",
    "href": "layers.html#σύνοψη",
    "title": "9  Επίπεδα",
    "section": "\n9.9 Σύνοψη",
    "text": "9.9 Σύνοψη\nΣε αυτό το κεφάλαιο μάθατε για την πολυεπίπεδη γραμματική των γραφικών ξεκινώντας με την αισθητική και τη γεωμετρία για να δημιουργήσετε ένα απλό διάγραμμα, όψεις για τον διαχωρισμό του διαγράμματος σε υποσύνολα, στατιστικά στοιχεία για την κατανόηση του τρόπου υπολογισμού των γεωμετρικών στοιχείων, προσαρμογές θέσης για τον έλεγχο των λεπτομερειών της θέσης όταν τα γεωμετρικά στοιχεία επικαλύπτονται μεταξύ τους και να μεταχειρίζεστε συστήματα που σας επιτρέπουν να αλλάξετε ριζικά τη σημασία των αξόνων x και y. Ένα επίπεδο που δεν έχουμε αγγίξει ακόμα είναι το θέμα, το οποίο θα εισαγάγουμε στην Ενότητα 11.5.\nΔύο πολύ χρήσιμοι πόροι για να έχετε μία επισκόπηση της πλήρους λειτουργικότητας της ggplot2 είναι το αντίστοιχο σκονάκι της (το οποίο μπορείτε να βρείτε στη διεύθυνση https://posit.co/resources/cheatsheets) και ο ιστότοπος του πακέτου ggplot2 (https://ggplot2. tidyverse.org).\nΈνα σημαντικό μάθημα που πρέπει να πάρετε από αυτό το κεφάλαιο είναι ότι όταν χρειάζεστε ένα geom που δεν παρέχεται από το πακέτο ggplot2, είναι πάντα καλή ιδέα να εξετάσετε εάν κάποιος άλλος έχει ήδη λύσει το πρόβλημά σας δημιουργώντας το ως πακέτο επέκτασης της ggplot2.",
    "crumbs": [
      "Οπτικοποίηση",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Επίπεδα</span>"
    ]
  },
  {
    "objectID": "EDA.html",
    "href": "EDA.html",
    "title": "10  Διερευνητική ανάλυση δεδομένων",
    "section": "",
    "text": "10.1 Εισαγωγή\nΑυτό το κεφάλαιο θα σας δείξει πώς να χρησιμοποιήσετε οπτικοποιήσεις και μετασχηματισμούς για να εξερευνήσετε τα δεδομένα σας με έναν συστηματικό τρόπο, μία μεθοδολογία που οι στατιστικολόγοι αποκαλούν διερευνητική ανάλυση δεδομένων (exploratory data analysis, EDA) ή ΔΑΔ εν συντομία. Η ΔΑΔ είναι μία επαναληπτική κυκλική διαδικασία. Εσείς:\nΗ ΔΑΔ δεν είναι μία επίσημη διαδικασία που αποτελείται από ένα αυστηρό σύνολο σχετικών κανόνων. Περισσότερο από οτιδήποτε άλλο, η ΔΑΔ είναι μία ιδεολογία. Κατά τις αρχικές φάσεις της ΔΑΔ θα πρέπει να αισθάνεστε ελεύθεροι να διερευνήσετε κάθε ιδέα σας. Μερικές από αυτές τις ιδέες θα αποδώσουν, και κάποιες θα οδηγήσουν σε αδιέξοδα. Καθώς η εξερεύνησή σας συνεχίζεται, θα κατευθυνθείτε μερικές ιδιαίτερα παραγωγικές πληροφορίες που τελικά θα καταγράψετε και θα επικοινωνήσετε σε άλλους.\nΗ ΔΑΔ είναι ένα σημαντικό μέρος οποιασδήποτε ανάλυσης δεδομένων, ακόμη και αν τα ερωτήματα της κύριας έρευνας σας παραδίδονται στο πιάτο, επειδή πρέπει πάντα να διερευνάτε την ποιότητα των δεδομένων σας. Ο καθαρισμός δεδομένων είναι μόνο μία εφαρμογή της ΔΑΔ: κάνετε ερωτήσεις σχετικά με το εάν τα δεδομένα σας ανταποκρίνονται στις προσδοκίες σας ή όχι. Για να κάνετε καθαρισμό δεδομένων, θα χρειαστεί να χρησιμοποιήσετε όλα τα εργαλεία της ΔΑΔ: οπτικοποίηση, μετασχηματισμό και μοντελοποίηση.",
    "crumbs": [
      "Οπτικοποίηση",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Διερευνητική ανάλυση δεδομένων</span>"
    ]
  },
  {
    "objectID": "EDA.html#εισαγωγή",
    "href": "EDA.html#εισαγωγή",
    "title": "10  Διερευνητική ανάλυση δεδομένων",
    "section": "",
    "text": "Δημιουργείτε ερωτήσεις σχετικά με τα δεδομένα σας.\nΑναζητείτε απαντήσεις οπτικοποιώντας, μεταμορφώνοντας και μοντελοποιώντας τα δεδομένα σας.\nΧρησιμοποιείτε όσα μαθαίνετε για να βελτιώσετε τις ερωτήσεις σας ή/και να δημιουργήσετε νέες ερωτήσεις.\n\n\n\n\n10.1.1 Προαπετούμενα\nΣε αυτό το κεφάλαιο θα συνδυάσουμε ό,τι μάθατε για το πακέτο dplyr και το πακέτο ggplot2 για να κάνετε ερωτήσεις διαδραστικά, να τις απαντήσετε με δεδομένα και στη συνέχεια να κάνετε νέες ερωτήσεις.\n\nlibrary(tidyverse)",
    "crumbs": [
      "Οπτικοποίηση",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Διερευνητική ανάλυση δεδομένων</span>"
    ]
  },
  {
    "objectID": "EDA.html#ερωτήματα",
    "href": "EDA.html#ερωτήματα",
    "title": "10  Διερευνητική ανάλυση δεδομένων",
    "section": "\n10.2 Ερωτήματα",
    "text": "10.2 Ερωτήματα\n\n“Δεν υπάρχουν απλές στατιστικές ερωτήσεις, μόνο αμφισβητήσιμες στατιστικές διαδικασίες.” — Σερ Ντέιβιντ Κοξ\n\n\n“Πολύ καλύτερη μία κατά προσέγγιση απάντηση στη σωστή ερώτηση, η οποία είναι συχνά ασαφής, παρά μία ακριβής απάντηση στη λάθος ερώτηση, η οποία μπορεί πάντα να είναι ακριβής.” — Τζον Τούκι\n\nΟ στόχος σας κατά τη διάρκεια της ΔΑΔ είναι να κατανοήσετε τα δεδομένα σας. Ο ευκολότερος τρόπος για να το κάνετε αυτό είναι να χρησιμοποιήσετε ερωτήσεις ως εργαλεία για να καθοδηγήσετε την έρευνά σας. Όταν κάνετε μία ερώτηση, η ερώτηση εστιάζει την προσοχή σας σε ένα συγκεκριμένο μέρος του συνόλου δεδομένων και σας βοηθά να αποφασίσετε ποια γραφήματα, μοντέλα ή μετασχηματισμούς να κάνετε.\nΗ ΔΑΔ είναι κατά κύριο λόγο μία δημιουργική διαδικασία. Και όπως οι περισσότερες δημιουργικές διαδικασίες, το κλειδί για να κάνετε ερωτήσεις ποιότητας είναι να δημιουργήσετε μία μεγάλη ποσότητα ερωτήσεων. Είναι δύσκολο να κάνετε αποκαλυπτικές ερωτήσεις στην αρχή της ανάλυσής σας, επειδή δεν γνωρίζετε ποιες πληροφορίες μπορούν να εξαχθούν από το σύνολο δεδομένων σας. Από την άλλη πλευρά, κάθε νέα ερώτηση που κάνετε θα σας εκθέσει σε μία νέα πτυχή των δεδομένων σας και θα αυξήσει τις πιθανότητές σας να κάνετε μία ανακάλυψη. Μπορείτε να εμβαθύνετε γρήγορα στα πιο ενδιαφέροντα μέρη των δεδομένων σας — και να αναπτύξετε ένα σύνολο ερωτήσεων που προκαλούν σκέψη — εάν ακολουθείτε κάθε ερώτηση με μία νέα ερώτηση με βάση αυτό που βρίσκετε.\nΔεν υπάρχει κανόνας σχετικά με τις ερωτήσεις που πρέπει να κάνετε για να καθοδηγήσετε την έρευνά σας. Ωστόσο, δύο τύποι ερωτήσεων θα είναι πάντα χρήσιμοι για την πραγματοποίηση ανακαλύψεων στα δεδομένα σας. Μπορείτε να διατυπώσετε χαλαρά αυτές τις ερωτήσεις ως:\n\nΤι είδους παραλλαγή εμφανίζεται στις μεταβλητές μου;\nΤι είδους συνδιακύμανση συμβαίνει μεταξύ των μεταβλητών μου;\n\nΤο υπόλοιπο αυτού του κεφαλαίου θα εξετάσει αυτές τις δύο ερωτήσεις. Θα εξηγήσουμε τι είναι η παραλλαγή και η συνδιακύμανση και θα σας δείξουμε αρκετούς τρόπους για να απαντήσετε σε κάθε ερώτηση.",
    "crumbs": [
      "Οπτικοποίηση",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Διερευνητική ανάλυση δεδομένων</span>"
    ]
  },
  {
    "objectID": "EDA.html#διακύμανση",
    "href": "EDA.html#διακύμανση",
    "title": "10  Διερευνητική ανάλυση δεδομένων",
    "section": "\n10.3 Διακύμανση",
    "text": "10.3 Διακύμανση\nΔιακύμανση είναι η τάση προς αλλαγή των τιμών μιας μεταβλητής από μέτρηση σε μέτρηση. Μπορείτε να παρατηρήσετε την έννοια της διακύμανσης εύκολα στην πραγματική ζωή. Εάν μετρήσετε οποιαδήποτε συνεχής μεταβλητή δύο φορές, θα έχετε δύο διαφορετικά αποτελέσματα. Αυτό ισχύει ακόμη και αν μετράτε ποσότητες που είναι σταθερές, όπως η ταχύτητα του φωτός. Κάθε μία από τις μετρήσεις σας θα περιλαμβάνει μία μικρή ποσότητα σφάλματος που θα ποικίλλει από μέτρηση σε μέτρηση. Οι μεταβλητές μπορεί επίσης να διαφέρουν εάν μετράτε διαφορετικά υποκείμενα (π.χ. τα χρώματα των ματιών διαφορετικών ανθρώπων) ή διαφορετικές χρονικές στιγμές (π.χ. τα επίπεδα ενέργειας ενός ηλεκτρονίου σε διαφορετικές στιγμές). Κάθε μεταβλητή έχει το δικό της μοτίβο διακύμανσης, το οποίο μπορεί να αποκαλύψει ενδιαφέρουσες πληροφορίες σχετικά με το πώς ποικίλλει μεταξύ των μετρήσεων της ίδιας παρατήρησης καθώς και μεταξύ των παρατηρήσεων. Ο καλύτερος τρόπος για να κατανοήσετε αυτό το μοτίβο είναι να οπτικοποιήσετε την κατανομή των τιμών της μεταβλητής, για την οποία έχετε μάθει στο Κεφάλαιο 1.\nΘα ξεκινήσουμε την εξερεύνηση μας με την απεικόνιση της κατανομής των βαρών (carat) των ~54.000 διαμαντιών από το σύνολο δεδομένων diamonds. Δεδομένου ότι η carat είναι μία αριθμητική μεταβλητή, μπορούμε να χρησιμοποιήσουμε ένα ιστόγραμμα:\n\nggplot(diamonds, aes(x = carat)) +\ngeom_histogram(binwidth = 0.5)\n\n\n\n\n\n\n\nΤώρα που μπορείτε να απεικονίσετε τις διακυμάνσεις, τι πρέπει να αναζητήσετε στα διαγράμματά σας; Και τι είδους συμπληρωματικών ερωτήσεων πρέπει να κάνετε; Συγκεντρώσαμε παρακάτω μία λίστα με τους πιο χρήσιμους τύπους πληροφοριών που θα βρείτε στα γραφήματα σας, μαζί με μερικές συμπληρωματικές ερωτήσεις για κάθε τύπο πληροφορίας. Το κλειδί για να κάνετε καλές συμπληρωματικές ερωτήσεις θα είναι να βασιστείτε στην περιέργειά σας (Για τι θέλετε να μάθετε περισσότερα;) καθώς και στον σκεπτικισμό σας (Πώς θα μπορούσε αυτό να είναι παραπλανητικό;).\n\n10.3.1 Τυπικές τιμές\nΚαι στα δύο διαγράμματα ράβδων και τα ιστογράμματα, οι ψηλές ράβδοι δείχνουν τις κοινές τιμές μιας μεταβλητής και οι μικρότερες ράβδοι δείχνουν λιγότερο κοινές τιμές. Τα μέρη που δεν έχουν ράβδους αποκαλύπτουν τιμές που δεν παρατηρήθηκαν στα δεδομένα σας. Για να μετατρέψετε αυτές τις πληροφορίες σε χρήσιμες ερωτήσεις, αναζητήστε για οτιδήποτε απροσδόκητο:\n\nΠοιες τιμές είναι οι πιο κοινές; Γιατί;\nΠοιες τιμές είναι σπάνιες; Γιατί; Επαληθεύεται απο τις προσδοκίες σας;\nΜπορείτε να δείτε κάποια ασυνήθιστα μοτίβα; Τι μπορεί να τα εξηγήσει;\n\nΑς ρίξουμε μία ματιά στη κατανομή της carat για μικρότερα διαμάντια.\n\nsmaller &lt;- diamonds |&gt; \n  filter(carat &lt; 3)\n\nggplot(smaller, aes(x = carat)) +\n  geom_histogram(binwidth = 0.01)\n\n\n\n\n\n\n\nΑυτό το ιστόγραμμα αναδεικνύει αρκετές ενδιαφέρουσες ερωτήσεις:\n\nΓιατί υπάρχουν περισσότερα διαμάντια σε ολόκληρα καράτια και κοινά μέρη καρατιών;\nΓιατί υπάρχουν περισσότερα διαμάντια ελαφρώς στα δεξιά κάθε κορυφής από ότι ελαφρώς στα αριστερά κάθε κορυφής;\n\nΟι απεικονίσεις μπορούν επίσης να αποκαλύψουν συστάδες, γεγονός που υποδηλώνει ότι υπάρχουν υπο-ομάδες στα δεδομένα σας. Για να κατανοήσετε τις υπο-ομάδες, ρωτήστε:\n\nΠώς είναι οι παρατηρήσεις σε κάθε υποομάδα παρόμοια μεταξύ τους;\nΠώς διαφέρουν οι παρατηρήσεις σε ξεχωριστές συστάδες μεταξύ τους;\nΠώς μπορείτε να εξηγήσετε ή να περιγράψετε τις συστάδες;\nΓιατί μπορεί η εμφάνιση των συστάδων να είναι παραπλανητική;\n\nΟρισμένες από αυτές τις ερωτήσεις μπορούν να απαντηθούν με τα δεδομένα, ενώ ορισμένες απαιτούν εξειδίκευση στον τομέα σχετική με τα δεδομένα. Πολλά από αυτά θα σας προτρέψουν να εξερευνήσετε μία σχέση μεταξύ μεταβλητών, για παράδειγμα, για να δείτε εάν οι τιμές μιας μεταβλητής μπορούν να εξηγήσουν τη συμπεριφορά μιας άλλης μεταβλητής. Θα φτάσουμε σε αυτό σύντομα.\n\n10.3.2 Ασυνήθιστες τιμές\nΟι ακραίες τιμές είναι παρατηρήσεις που είναι ασυνήθιστες. Είναι δηλαδή σημεία δεδομένων που δεν φαίνεται να ταιριάζουν στο μοτίβο. Μερικές φορές οι ακραίες τιμές είναι σφάλματα της εισαγωγής δεδομένων, μερικές φορές είναι απλώς μεγάλες τιμές που έτυχε να παρατηρηθούν σε αυτήν τη συλλογή δεδομένων και άλλες φορές προτείνουν σημαντικές νέες ανακαλύψεις. Όταν έχετε πολλά δεδομένα, οι ακραίες τιμές είναι μερικές φορές δύσκολο να φανούν σε ένα ιστόγραμμα. Για παράδειγμα, πάρτε την κατανομή της μεταβλητής y από το σύνολο δεδομένων diamonds. Η μόνη απόδειξη των ακραίων τιμών είναι τα ασυνήθιστα μεγάλα όρια στον άξονα x.\n\nggplot(diamonds, aes(x = y)) + \n  geom_histogram(binwidth = 0.5)\n\n\n\n\n\n\n\nΥπάρχουν πολλές παρατηρήσεις στις κοινές κατηγορίες που οι σπάνιες κατηγορίες είναι πολύ μικρές, με αποτέλεσμα να είναι πολύ δύσκολο να τις δεις (αν και ίσως κοιτάξεις επίμονα το 0 θα εντοπίσεις κάτι). Για να είναι εύκολο να δούμε τις ασυνήθιστες τιμές, πρέπει να μεγεθύνουμε στις μικρές τιμές του άξονα y με το coord_cartesian():\n\nggplot(diamonds, aes(x = y)) + \ngeom_histogram(binwidth = 0.5) +\ncoord_cartesian(ylim = c(0, 50))\n\n\n\n\n\n\n\nΤο coord_cartesian() έχει επίσης ένα όρισμα xlim() για την περίπτωση που πρέπει να μεγεθύνετε στον άξονα x. Η ggplot2 έχει και αυτή συναρτήσεις xlim() και ylim() που λειτουργούν λίγο διαφορετικά: πετούν τα δεδομένα έξω από τα όρια.\nΑυτό μας επιτρέπει να δούμε ότι υπάρχουν τρεις ασυνήθιστες τιμές: 0, ~30 και ~60. Τα βγάζουμε εκτός με το πακέτο dplyr:\n\nunusual &lt;- diamonds |&gt; \n  filter(y &lt; 3 | y &gt; 20) |&gt; \n  select(price, x, y, z) |&gt;\n  arrange(y)\nunusual\n#&gt; # A tibble: 9 × 4\n#&gt;   price     x     y     z\n#&gt;   &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n#&gt; 1  5139  0      0    0   \n#&gt; 2  6381  0      0    0   \n#&gt; 3 12800  0      0    0   \n#&gt; 4 15686  0      0    0   \n#&gt; 5 18034  0      0    0   \n#&gt; 6  2130  0      0    0   \n#&gt; 7  2130  0      0    0   \n#&gt; 8  2075  5.15  31.8  5.12\n#&gt; 9 12210  8.09  58.9  8.06\n\nΗ μεταβλητή y μετρά μία από τις τρεις διαστάσεις αυτών των διαμαντιών, σε mm. Γνωρίζουμε ότι τα διαμάντια δεν μπορούν να έχουν πλάτος 0mm, επομένως αυτές οι τιμές πρέπει να είναι λανθασμένες. Εφαρμόζοντας ΑΔΑ, ανακαλύψαμε δεδομένα που λείπουν και κωδικοποιήθηκαν ως 0, τα οποία δεν θα βρίσκαμε ποτέ κάνοντας απλή αναζήτηση για τιμές NA. Στο εξής, ενδέχεται να επιλέξουμε να κωδικοποιήσουμε εκ νέου αυτές τις τιμές ως NA για να αποτρέψουμε παραπλανητικούς υπολογισμούς. Μπορεί επίσης να υποψιαζόμαστε ότι οι μετρήσεις των 32mm και 59mm είναι απίθανες: τα διαμάντια αυτά έχουν μήκος πάνω από μία ίντσα, αλλά δεν κοστίζουν εκατοντάδες χιλιάδες δολάρια!\nΕίναι καλή πρακτική να επαναλαμβάνετε την ανάλυσή σας με και χωρίς τις ακραίες τιμές. Σε περίπτωση που έχουν ελάχιστη επίδραση στα αποτελέσματα και δεν μπορείτε να καταλάβετε γιατί είναι εκεί, είναι λογικό να τις παραλείψετε και να προχωρήσετε. Ωστόσο, εάν έχουν ουσιαστική επίδραση στα αποτελέσματά σας, δεν πρέπει να τις απορρίψετε χωρίς αιτιολόγηση. Θα πρέπει να καταλάβετε τι τις προκάλεσε (π.χ. ένα σφάλμα εισαγωγής δεδομένων) και να ενημερώσετε ότι τις καταργήσατε.\n\n10.3.3 Ασκήσεις\n\nΕξερευνήστε την κατανομή καθεμιάς από τις μεταβλητές x, y και z στο diamonds. Τι μαθαίνετε? Φέρτε στη φαντασία σας ένα διαμάντι και πώς μπορείτε να αποφασίσετε ποια διάσταση είναι το μήκος, το πλάτος και το βάθος.\nΕξερευνήστε την κατανομή της price. Ανακαλύπτετε κάτι ασυνήθιστο ή αναπάντεχο; (Συμβουλή: Δώστε προσοχή τον ορισμό της μεταβλητής binwidth και βεβαιωθείτε ότι έχετε δοκιμάσει ένα ευρύ φάσμα τιμών.)\nΠόσα διαμάντια είναι 0,99 καρατίων; Πόσα είναι 1 καράτι; Ποια πιστεύετε ότι είναι η αιτία της διαφοράς;\nΣυγκρίνετε και αντιπαραβάλλετε τη coord_cartesian() με τη xlim() ή τη ylim() όταν μεγεθύνετε σε ένα ιστόγραμμα. Τι θα συμβεί δεν χρησιμοποιήσετε τη binwidth; Τι θα συμβεί εάν προσπαθήσετε να κάνετε μεγέθυνση ώστε να εμφανίζεται μόνο μισή μπάρα;",
    "crumbs": [
      "Οπτικοποίηση",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Διερευνητική ανάλυση δεδομένων</span>"
    ]
  },
  {
    "objectID": "EDA.html#sec-unusual-values-eda",
    "href": "EDA.html#sec-unusual-values-eda",
    "title": "10  Διερευνητική ανάλυση δεδομένων",
    "section": "\n10.4 Ασυνήθιστες τιμές",
    "text": "10.4 Ασυνήθιστες τιμές\nΕάν έχετε συναντήσει ασυνήθιστες τιμές στο σύνολο δεδομένων σας και θέλετε απλώς να προχωρήσετε στην υπόλοιπη ανάλυσή σας, έχετε δύο επιλογές.\n\nΑφαιρέστε ολόκληρη τη σειρά που περιέχει ασυνήθιστες τιμές:\n\n\ndiamonds2 &lt;- diamonds |&gt; \nfilter(between(y, 3, 20))\n\nΔεν συνιστούμε αυτήν την επιλογή επειδή μία μη έγκυρη τιμή δεν σημαίνει ότι όλες οι άλλες τιμές για αυτήν την παρατήρηση δεν είναι επίσης έγκυρες. Επιπλέον, εάν η ποιότητα των δεδομένων σας δεν είναι καλή, από τη στιγμή που θα έχετε εφαρμόσει αυτήν την προσέγγιση σε κάθε μεταβλητή, ενδέχεται να διαπιστώσετε ότι δεν σας έχουν απομείνει δεδομένα!\n\nΑντίθετα, συνιστούμε να αντικαταστήσετε τις ασυνήθιστες τιμές με κενές τιμές. Ο ευκολότερος τρόπος για να γίνει αυτό είναι να χρησιμοποιήσετε τη mutate() για να αντικαταστήσετε τη μεταβλητή με ένα τροποποιημένο αντίγραφο. Μπορείτε να χρησιμοποιήσετε τη συνάρτηση if_else() για να αντικαταστήσετε ασυνήθιστες τιμές με NA:\n\n\ndiamonds2 &lt;- diamonds |&gt; \nmutate(y = if_else(y &lt; 3 | y &gt; 20, NA, y))\n\nΤο που θα απεικονισθούν οι κενές τιμές δεν είναι προφανές, επομένως το πακέτο ggplot2 δεν τις περιλαμβάνει στο διάγραμμα, αλλά προειδοποιεί ότι έχουν αφαιρεθεί:\n\nggplot(diamonds2, aes(x = x, y = y)) + \ngeom_point()\n#&gt; Warning: Removed 9 rows containing missing values or values outside the scale range\n#&gt; (`geom_point()`).\n\n\n\n\n\n\n\nΓια να μην τυπωθεί η προειδοποίηση, ορίστε na.rm = TRUE:\n\nggplot(diamonds2, aes(x = x, y = y)) + \ngeom_point(na.rm = TRUE)\n\nΆλλες φορές, θέλετε να καταλάβετε τι κάνει τις παρατηρήσεις με τιμές που λείπουν διαφορετικές από τις παρατηρήσεις με καταγεγραμμένες τιμές. Για παράδειγμα, στο nycflights13::flights1, οι κενές τιμές της μεταβλητής dep_time υποδηλώνουν ότι η πτήση ακυρώθηκε. Επομένως, ίσως θέλετε να συγκρίνετε τις προγραμματισμένες ώρες αναχώρησης για ακυρωμένες και μη ακυρωμένες ώρες. Αυτό μπορείτε να το κάνετε δημιουργώντας μία νέα μεταβλητή, χρησιμοποιώντας την is.na() για να ελέγξετε αν η dep_time λείπει.\n\nnycflights13::flights |&gt; \n  mutate(\n    cancelled = is.na(dep_time),\n    sched_hour = sched_dep_time %/% 100,\n    sched_min = sched_dep_time %% 100,\n    sched_dep_time = sched_hour + (sched_min / 60)\n  ) |&gt; \n  ggplot(aes(x = sched_dep_time)) + \n  geom_freqpoly(aes(color = cancelled), binwidth = 1/4)\n\n\n\n\n\n\n\nΩστόσο, αυτή το διάγραμμα δεν είναι καλό, επειδή υπάρχουν πολύ περισσότερες μη ακυρωμένες πτήσεις από ακυρωμένες πτήσεις. Στην επόμενη ενότητα θα διερευνήσουμε ορισμένες τεχνικές για τη βελτίωση αυτής της σύγκρισης.\n\n10.4.1 Ασκήσεις\n\nΤι συμβαίνει με τις κενές τιμές σε ένα ιστόγραμμα; Τι συμβαίνει με τις κενές τιμές σε ένα ραβδόγραμμα; Γιατί υπάρχει διαφορά στον τρόπο χειρισμού των ελλιπών τιμών στα ιστογράμματα και στα ραβδογράμματα;\nΤι κάνει το na.rm = TRUE στη mean() και sum();\nΔημιουργήστε ξανά το διάγραμμα συχνότητας του scheduled_dep_time χρωματισμένο ανάλογα με το αν η πτήση ακυρώθηκε ή όχι. Επίσης, δημιουργήστε όψεις χρησιμοποιώντας τη μεταβλητή cancelled. Πειραματιστείτε με διαφορετικές τιμές της μεταβλητής scales στη συνάρτηση όψεων για να μετριαστεί η επίδραση περισσότερων μη ακυρωμένων πτήσεων από ακυρωμένες πτήσεις.",
    "crumbs": [
      "Οπτικοποίηση",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Διερευνητική ανάλυση δεδομένων</span>"
    ]
  },
  {
    "objectID": "EDA.html#συνδιακύμανση",
    "href": "EDA.html#συνδιακύμανση",
    "title": "10  Διερευνητική ανάλυση δεδομένων",
    "section": "\n10.5 Συνδιακύμανση",
    "text": "10.5 Συνδιακύμανση\nΕάν η διακύμανση περιγράφει τη συμπεριφορά εντός μιας μεταβλητής, η συνδιακύμανση περιγράφει τη συμπεριφορά μεταξύ μεταβλητών. Συνδιακύμανση είναι η τάση οι τιμές δύο ή περισσότερων μεταβλητών να ποικίλλουν μαζί με σχετικό τρόπο. Ο καλύτερος τρόπος για να εντοπίσετε τη συνδιακύμανση είναι να απεικονίσετε τη σχέση μεταξύ δύο ή περισσότερων μεταβλητών.\n\n10.5.1 Μία κατηγορική και μία αριθμητική μεταβλητή\nΓια παράδειγμα, ας εξερευνήσουμε πώς η τιμή ενός διαμαντιού ποικίλλει ανάλογα με την ποιότητά του (μετρούμενη από την cut) χρησιμοποιώντας τη geom_freqpoly():\n\nggplot(diamonds, aes(x = price)) + \ngeom_freqpoly(aes(color = cut), binwidth = 500, linewidth = 0.75)\n\n\n\n\n\n\n\nΣημειώστε ότι το πακέτο ggplot2 χρησιμοποιεί μία διατεταγμένη χρωματική κλίμακα για τη cut επειδή ορίζεται ως μία διατεταγμένη παραγοντική μεταβλητή (ordered factor variable) στα δεδομένα. Θα μάθετε περισσότερα για αυτά στην Ενότητα 16.6.\nΗ προεπιλεγμένη ρύθμιση της geom_freqpoly() δεν είναι τόσο χρήσιμη εδώ επειδή το ύψος, που καθορίζεται από το συνολικό πλήθος, διαφέρει πολύ μεταξύ των τιμών της cut, καθιστώντας δύσκολο να δούμε τις διαφορές στα σχήματα των κατανομών τους.\nΓια να κάνουμε τη σύγκριση πιο εύκολη, πρέπει να μεταφέρουμε αυτό που εμφανίζεται στον άξονα y. Αντί να εμφανίσουμε το πλήθος, θα εμφανίσουμε την πυκνότητα, η οποία είναι το τυποποιήμενο πλήθος έτσι ώστε η περιοχή κάτω από κάθε πολύγωνο συχνότητας να είναι ένα.\n\nggplot(diamonds, aes(x = price, y = after_stat(density))) + \n  geom_freqpoly(aes(color = cut), binwidth = 500, linewidth = 0.75)\n\n\n\n\n\n\n\nΣημειώστε ότι αντιστοιχίζουμε την πυκνότητα με την y, αλλά επειδή η πυκνότητα δεν είναι μεταβλητή στο σύνολο δεδομένων diamonds, πρέπει πρώτα να την υπολογίσουμε. Για να το κάνουμε αυτό χρησιμοποιούμε τη λειτουργία after_stat().\nΥπάρχει κάτι μάλλον εκπληκτικό σε αυτό το διάγραμμα - φαίνεται ότι τα διαμάντια με ικανοποιητικό κόψιμο (η χαμηλότερη ποιότητα) έχουν την υψηλότερη μέση τιμή! Αλλά ίσως αυτό συμβαίνει επειδή τα πολύγωνα συχνότητας είναι λίγο δύσκολο να ερμηνευτούν - υπάρχουν πολλά που συμβαίνουν σε αυτό το διάγραμμα.\nΈνα οπτικά απλούστερο διάγραμμα για την εξερεύνηση αυτής της σχέσης είναι η χρήση θηκογραμμάτων το ένα δίπλα στο άλλο.\n\nggplot(diamonds, aes(x = cut, y = price)) +\n  geom_boxplot()\n\n\n\n\n\n\n\nΒλέπουμε πολύ λιγότερες πληροφορίες σχετικά με τη κατανομή, αλλά τα θηκογράμματα είναι πολύ πιο συμπαγή, ώστε να μπορούμε να τα συγκρίνουμε πιο εύκολα (και να χωρέσουν περισσότερα σε ένα διάγραμμα). Υποστηρίζει το μη αναμενόμενο εύρημα ότι τα διαμάντια καλύτερης ποιότητας είναι συνήθως φθηνότερα! Στις ασκήσεις, θα κληθείτε να καταλάβετε το γιατί.\nΗ μεταβλητή cut είναι μία διατεταγμένη παραγοντική μεταβλητή: το ικανοποιητικό κόψιμο είναι χειρότερο από το καλό, το οποίο είναι χειρότερο από το πολύ καλό και ούτω καθεξής. Αρκετές κατηγορικές μεταβλητές δεν έχουν τέτοια εγγενή διάταξη, επομένως ίσως θελήσετε να τις αναδιατάξετε για να δημιουργήσετε μία πιο κατατοπιστική οπτική. Ένας τρόπος για να γίνει αυτό είναι με τη fct_reorder(). Θα μάθετε περισσότερα για αυτήν τη συνάρτηση στην Ενότητα 16.4, αλλά θέλουμε να σας δώσουμε μία γρήγορη προεπισκόπηση εδώ καθώς είναι αρκετά χρήσιμη. Για παράδειγμα, πάρτε τη μεταβλητή class από το σύνολο δεδομένων mpg. Μπορεί να σας ενδιαφέρει να μάθετε πώς διαφέρει η χιλιομετρική απόσταση σε αυτοκινητόδρομο μεταξύ κατηγοριών αυτοκινήτων:\n\nggplot(mpg, aes(x = class, y = hwy)) +\ngeom_boxplot()\n\n\n\n\n\n\n\nΓια να γίνει πιο ευδιάκριτη η τάση, μπορούμε να αναδιατάξουμε τη μεταβλητή class με βάση τη διάμεση τιμή της hwy:\n\nggplot(mpg, aes(x = fct_reorder(class, hwy, median), y = hwy)) +\ngeom_boxplot()\n\n\n\n\n\n\n\nΕάν έχετε ονόματα μεταβλητών με μεγάλο αριθμό χαρακτήρων, η geom_boxplot() θα λειτουργήσει καλύτερα αν τα στρέψετε κατά 90°. Μπορείτε να το εφαρμόσετε αλλάζοντας τις αισθητικές αντιστοιχίσεις x και y.\n\nggplot(mpg, aes(x = hwy, y = fct_reorder(class, hwy, median))) +\n  geom_boxplot()\n\n\n\n\n\n\n\n\n10.5.1.1 Ασκήσεις\n\nΧρησιμοποιήστε όσα έχετε μάθει για να βελτιώσετε την οπτικοποίηση των ωρών αναχώρησης ακυρωμένων έναντι μη ακυρωμένων πτήσεων.\nΜε βάση την ΑΔΑ, ποια μεταβλητή στο σύνολο δεδομένων diamonds φαίνεται να είναι πιο σημαντική για την πρόβλεψη της τιμής ενός διαμαντιού; Πώς συσχετίζεται αυτή η μεταβλητή με τη cut; Γιατί ο συνδυασμός αυτών των δύο σχέσεων οδηγεί στο συμπέρασμα ότι είναι πιο ακριβά τα διαμάντια χαμηλότερης ποιότητας;\nΑντί να αλλάξετε τις μεταβλητές x και y μεταξύ τους, προσθέστε τη coord_flip() ως νέο επίπεδο στο κατακόρυφο θηκόγραμμα για να δημιουργήσετε ένα οριζόντιο. Πώς συγκρίνεται αυτό με την ανταλλαγή των μεταβλητών;\nΈνα πρόβλημα με τα θηκογράμματα είναι ότι αναπτύχθηκαν σε μία εποχή πολύ μικρότερων συνόλων δεδομένων και τείνουν να εμφανίζουν έναν απαγορευτικά μεγάλο αριθμό “ακραίων τιμών”. Μία προσέγγιση για την επίλυση αυτού του προβλήματος είναι η γραφική παράσταση τιμής γράμματος. Εγκαταστήστε το πακέτο lvplot και δοκιμάστε να χρησιμοποιήσετε τη geom_lv() για να εμφανίσετε την κατανομή της μεταβλητής price έναντι της cut. Τι μαθαίνετε? Πώς ερμηνεύετε τα διαγράμματα;\nΔημιουργήστε μία απεικόνιση των τιμών των διαμαντιών έναντι μιας κατηγορηματικής μεταβλητής από το σύνολο δεδομένων diamonds χρησιμοποιώντας τη geom_violin(), στη συνέχεια ένα ιστόγραμμα με όψεις χρησιμοποιώντας τη geom_histogram(), έπειτα ένα πολύγωνο συχνότητας με χρωματισμό χρησιμοποιώντας τη geom_freqpoly(), και στη συνέχεια μία απεικόνιση πυκνότητας με χρωματισμό χρησιμοποιώντας τη geom_densy(). Συγκρίνετε και αντιπαραβάλλετε τα τέσσερα διαγράμματα. Ποια είναι τα πλεονεκτήματα και τα μειονεκτήματα κάθε μεθόδου οπτικοποίησης της κατανομής μιας αριθμητικής μεταβλητής με βάση τα επίπεδα μιας κατηγορικής μεταβλητής;\nΕάν έχετε ένα μικρό σύνολο δεδομένων, είναι μερικές φορές χρήσιμο να χρησιμοποιήσετε τη geom_jitter() για να αποφύγετε την οπτικοποίηση πολλαπλών στοιχείων έτσι ώστε η σχέση μεταξύ μιας συνεχούς και κατηγορικής μεταβλητής να είναι πιο εύκολα αντιληπτή. Το πακέτο ggbeeswarm παρέχει έναν αριθμό μεθόδων παρόμοιων με τη geom_jitter(). Καταγράψτε τα και περιγράψτε εν συντομία τι κάνει το καθένα.\n\n10.5.2 Δύο κατηγορικές μεταβλητές\nΓια να απεικονίσετε τη συνδιακύμανση μεταξύ κατηγορικών μεταβλητών, θα χρειαστεί να μετρήσετε τον αριθμό των παρατηρήσεων για κάθε συνδυασμό επιπέδων αυτών των κατηγορικών μεταβλητών. Ένας τρόπος για να το κάνετε αυτό είναι να βασιστείτε στην ενσωματωμένη συνάρτηση geom_count():\n\nggplot(diamonds, aes(x = cut, y = color)) +\ngeom_count()\n\n\n\n\n\n\n\nΤο μέγεθος κάθε κύκλου στο διάγραμμα δείχνει πόσες παρατηρήσεις υπάρχουν για κάθε συνδυασμό τιμών. Η συνδιακύμανση θα εμφανιστεί ως ισχυρή συσχέτιση μεταξύ συγκεκριμένων τιμών x και συγκεκριμένων τιμών y.\nΈνας άλλος τρόπος για τη διερεύνηση της σχέσης μεταξύ αυτών των μεταβλητών είναι ο υπολογισμός των μετρήσεων με το πακέτο dplyr:\n\ndiamonds |&gt; \ncount(color, cut)\n#&gt; # A tibble: 35 × 3\n#&gt;   color cut           n\n#&gt;   &lt;ord&gt; &lt;ord&gt;     &lt;int&gt;\n#&gt; 1 D     Fair        163\n#&gt; 2 D     Good        662\n#&gt; 3 D     Very Good  1513\n#&gt; 4 D     Premium    1603\n#&gt; 5 D     Ideal      2834\n#&gt; 6 E     Fair        224\n#&gt; # ℹ 29 more rows\n\nΣτη συνέχεια, οπτικοποιήστε με τη geom_tile() και το αισθητικό στοιχείο fill:\n\ndiamonds |&gt; \ncount(color, cut) |&gt;  \nggplot(aes(x = color, y = cut)) +\ngeom_tile(aes(fill = n))\n\n\n\n\n\n\n\nΕάν οι κατηγορικές μεταβλητές δεν είναι ταξινομημένες, μπορείτε να χρησιμοποιήσετε το πακέτο seriation για να αναδιατάξετε τις γραμμές και τις στήλες, προκειμένου να αποκαλύψετε ακόμα πιο ξεκάθαρα ενδιαφέροντα μοτίβα. Για μεγαλύτερα διαγράμματα, μπορείτε να δοκιμάσετε το πακέτο heatmaply, για διαδραστικά διαγράμματα.\n\n10.5.2.1 Ασκήσεις\n\nΠώς θα μπορούσατε να αναδιαμορφώσετε το σύνολο δεδομένων πλήθους παραπάνω για να δείξετε με μεγαλύτερη σαφήνεια την κατανομή της κοπής ανά χρώμα ή του χρώματος ανά κοπή;\nΠοιες διαφορετικές πληροφορίες λαμβάνετε για τα δεδομένα με ένα τμηματοποιημένο ραβδόγραμμα εάν το χρώμα αντιστοιχιστεί στο αισθητικό στοιχείο x και η cut αντιστοιχιστεί στο αισθητικό στοιχείο fill; Υπολογίστε τις μετρήσεις που εμπίπτουν σε καθένα από τα τμήματα.\nΧρησιμοποιήστε τη geom_tile() μαζί με το πακέτο dplyr για να εξερευνήσετε πώς διαφέρουν οι μέσες καθυστερήσεις αναχώρησης πτήσεων ανά προορισμό και μήνα του έτους. Τι δυσκολεύει την ανάγνωση του διαγράμματος; Πώς θα μπορούσατε να το βελτιώσετε;\n\n10.5.3 Δύο αριθμητικές μεταβλητές\nΈχετε ήδη δει έναν εξαιρετικό τρόπο οπτικοποίησης της συνδιακύμανσης μεταξύ δύο αριθμητικών μεταβλητών: σχεδιάστε ένα διάγραμμα διασποράς με τη geom_point(). Μπορείτε να ερμηνεύσετε τη συνδιακύμανση ως το μοτίβο στα σημεία. Για παράδειγμα, μπορείτε να δείτε μία θετική σχέση μεταξύ του μεγέθους των καρατίων και της τιμής ενός διαμαντιού: τα διαμάντια με περισσότερα καράτια έχουν υψηλότερη τιμή. Η σχέση αυτή είναι εκθετική.\n\nggplot(smaller, aes(x = carat, y = price)) +\n  geom_point()\n\n\n\n\n\n\n\n(Σε αυτήν την ενότητα θα χρησιμοποιήσουμε το σύνολο δεδομένων smaller για να παραμείνουμε εστιασμένοι στο μέρος των διαμαντιών που είναι μικρότερα από 3 καράτια)\nΤα διαγράμματα διασποράς γίνονται λιγότερο χρήσιμα καθώς αυξάνεται το μέγεθος του συνόλου δεδομένων σας, επειδή τα σημεία αρχίζουν να συσσωρεύονται και να δημιουργούν περιοχές με μαύρο χρώμα. Έτσι, καθίσταται δύσκολη η ικανότητά μας στην αντίληψη των διαφορών στην πυκνότητα των δεδομένων στις 2 διαστάσεις καθώς ακόμα και ο εντοπισμός τάσεων. Έχετε ήδη δει έναν τρόπο για να διορθώσετε το πρόβλημα: να χρησιμοποιήσετε το αισθητικό στοιχείο alpha έτσι ώστε να προσθέσετε διαφάνεια.\n\nggplot(smaller, aes(x = carat, y = price)) + \n  geom_point(alpha = 1 / 100)\n\n\n\n\n\n\n\nΗ χρήση της διαφάνειας, όμως, μπορεί να είναι δύσκολη για πολύ μεγάλα σύνολα δεδομένων. Μία άλλη λύση είναι η χρήση πλαισίων με σκοπό την κατηγοριοποίηση (ή ομαδοποίηση). Προηγουμένως χρησιμοποιούσατε τις geom_histogram() και geom_freqpoly() για να κατηγοριοποιήσετε σε μία διάσταση. Τώρα θα μάθετε πώς να χρησιμοποιείτε τη geom_bin2d() και τη geom_hex() για να κατηγοριοποιήσετε σε δύο διαστάσεις.\nΟι geom_bin2d() και geom_hex() διαιρούν το επίπεδο συντεταγμένων σε πλαίσια δύο διαστάσεων και στη συνέχεια χρησιμοποιούν αντίστοιχα χρώματα για να εμφανίσουν πόσα σημεία ανήκουν σε κάθε πλαίσιο. Η geom_bin2d() δημιουργεί ορθογώνια πλαίσια. Η geom_hex() δημιουργεί εξάγωνα πλαίσια. Θα χρειαστεί να εγκαταστήσετε το πακέτο hexbin για να χρησιμοποιήσετε τη geom_hex().\nggplot(smaller, aes(x = carat, y = price)) +\n  geom_bin2d()\n\n# install.packages(\"hexbin\")\nggplot(smaller, aes(x = carat, y = price)) +\n  geom_hex()\n\n\n\n\n\n\n\n\n\n\nΜία άλλη επιλογή είναι βάλετε κατηγορίες μία συνεχή μεταβλητή έτσι ώστε να λειτουργεί σαν μία κατηγορική μεταβλητή. Στη συνέχεια, μπορείτε να χρησιμοποιήσετε μία από τις τεχνικές οπτικοποίησης του συνδυασμού μεταξύ μιας κατηγορικής και μιας συνεχούς μεταβλητής για την οποία μάθατε. Για παράδειγμα, θα μπορούσατε να κατηγοριοποιήσετε τη μεταβλητή carat και, στη συνέχεια, για κάθε ομάδα, να παρουσιάσετε ένα θηκόγραμμα:\n\nggplot(smaller, aes(x = carat, y = price)) + \ngeom_boxplot(aes(group = cut_width(carat, 0.1)))\n\n\n\n\n\n\n\nΗ cut_width(x, width), όπως χρησιμοποιείται παραπάνω, διαιρεί το όρισμα x σε πλαίσια πλάτους width. Από προεπιλογή, τα θηκογράμματα φαίνονται περίπου τα ίδια (εκτός από τον αριθμό των ακραίων τιμών) ανεξάρτητα από το πόσες παρατηρήσεις υπάρχουν, επομένως είναι δύσκολο να πούμε ότι κάθε γραφική δίνει μία σύνοψη από διαφορετικό αριθμό σημείων. Για να μπορέσετε να το δείξετε αυτό, ένας τρόπος περιλαμβάνει να κάνετε το πλάτος του θηκογράμματος ανάλογο με τον αριθμό των σημείων θέτοντας varwidth = TRUE.\n\n10.5.3.1 Ασκήσεις\n\nΑντί να συνοψίζετε την υπό όρους κατανομή με ένα θηκόγραμμα, θα μπορούσατε να χρησιμοποιήσετε ένα πολύγωνο συχνότητας. Τι πρέπει να λάβετε υπόψιν όταν χρησιμοποιείτε τη cut_width() έναντι της cut_number(); Με ποιο τρόπο επηρεάζει αυτό μία οπτικοποίηση της δισδιάστατης κατανομής των μεταβλητών carats και price;\nΟπτικοποιήστε την κατανομή της carat, ανά price.\nΠώς συγκρίνεται η κατανομή των τιμών των πολύ μεγάλων διαμαντιών με τα μικρά διαμάντια; Είναι όπως το περιμένατε ή σας εκπλήσσει;\nΣυνδυάστε δύο από τις τεχνικές που έχετε μάθει για να απεικονίσετε τη συνδυασμένη κατανομή των μεταβλητών cut, carat, και price.\nΟι δισδιάστατες γραφικές παραστάσεις αποκαλύπτουν ακραίες τιμές που δεν είναι ορατές σε μονοδιάστατες γραφικές παραστάσεις. Για παράδειγμα, ορισμένα σημεία στην ακόλουθη γραφική παράσταση έχουν έναν ασυνήθιστο συνδυασμό τιμών x και y, που καθιστά τα σημεία ακραία, παρόλο που οι τιμές x και y φαίνονται κανονικές όταν εξετάζονται χωριστά. Γιατί ένα διάγραμμα διασποράς είναι καλύτερη απεικόνιση από ένα διάγραμμα με πλαίσια για αυτήν την περίπτωση;\n\n\ndiamonds |&gt; \n  filter(x &gt;= 4) |&gt; \n  ggplot(aes(x = x, y = y)) +\n  geom_point() +\n  coord_cartesian(xlim = c(4, 11), ylim = c(4, 11))\n\n\nΑντί να δημιουργήσουμε κατηγορίες ίσου πλάτους με τη cut_width(), θα μπορούσαμε να δημιουργήσουμε πλαίσια που περιέχουν περίπου ίσο αριθμό σημείων με τη cut_number(). Ποια είναι τα πλεονεκτήματα και τα μειονεκτήματα αυτής της προσέγγισης;\n\n\nggplot(smaller, aes(x = carat, y = price)) + \n  geom_boxplot(aes(group = cut_number(carat, 20)))",
    "crumbs": [
      "Οπτικοποίηση",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Διερευνητική ανάλυση δεδομένων</span>"
    ]
  },
  {
    "objectID": "EDA.html#μοτίβα-και-μοντέλα",
    "href": "EDA.html#μοτίβα-και-μοντέλα",
    "title": "10  Διερευνητική ανάλυση δεδομένων",
    "section": "\n10.6 Μοτίβα και μοντέλα",
    "text": "10.6 Μοτίβα και μοντέλα\nΕάν υπάρχει συστηματική σχέση μεταξύ δύο μεταβλητών στα δεδομένα, αυτή θα εμφανίζεται με τη μορφή μοτίβου. Εάν εντοπίσετε ένα μοτίβο, αναρωτηθείτε:\n\nΘα μπορούσε αυτό το μοτίβο να οφείλεται σε σύμπτωση (δηλαδή τυχαία πιθανότητα);\nΠώς μπορείτε να περιγράψετε τη σχέση που εμφανίζεται από το μοτίβο;\nΠόσο ισχυρή είναι η σχέση που εμφανίζεται από το μοτίβο;\nΠοιες άλλες μεταβλητές μπορεί να επηρεάσουν τη σχέση;\nΑλλάζει η σχέση αν κοιτάξετε μεμονωμένες υπο-ομάδες των δεδομένων;\n\nΤα μοτίβα στα δεδομένα σας παρέχουν ενδείξεις για τις σχέσεις, δηλαδή αποκαλύπτουν συνδιακύμανση. Εάν σκέφτεστε τη διακύμανση ως ένα φαινόμενο που δημιουργεί αβεβαιότητα, από την άλλη, η συνδιακύμανση είναι ένα φαινόμενο που τη μειώνει. Εάν δύο μεταβλητές μεταβάλλονται με τον ίδιο τρόπο, μπορείτε να χρησιμοποιήσετε τις τιμές μιας μεταβλητής για να κάνετε καλύτερες προβλέψεις σχετικά με τις τιμές της δεύτερης. Εάν η συνδιακύμανση οφείλεται σε μία αιτιώδη σχέση (αυτή είναι μία ειδική περίπτωση), τότε μπορείτε να χρησιμοποιήσετε την τιμή μιας μεταβλητής για τον έλεγχο της τιμής της δεύτερης.\nΤα μοντέλα είναι ένα εργαλείο για την εξαγωγή μοτίβων από δεδομένα. Για παράδειγμα, θεωρείστε τα δεδομένα των διαμαντιών. Είναι δύσκολο να κατανοήσουμε τη σχέση μεταξύ κοπής και τιμής, επειδή η κοπή και το καράτι, και το καράτι και η τιμή συνδέονται στενά. Είναι δυνατό να χρησιμοποιήσουμε ένα μοντέλο για να αφαιρέσουμε την ισχυρή σχέση μεταξύ τιμής και καρατιού, ώστε να μπορέσουμε να εξερευνήσουμε τις λεπτομέρειες που παραμένουν. Ο παρακάτω κώδικας προσαρμόζει ένα μοντέλο που προβλέπει την μεταβλητή price από τη carat και στη συνέχεια υπολογίζει τα κατάλοιπα της πρόβλεψης (residuals) (η διαφορά μεταξύ της προβλεπόμενης τιμής και της πραγματικής τιμής). Τα κατάλοιπα μας δίνουν μία άποψη της τιμής του διαμαντιού, αφού αφαιρεθεί η επίδραση του καρατιού. Σημειώστε ότι αντί να χρησιμοποιούμε τις αρχικές τιμές των μεταβλητών price και carat, υπολογίζουμε τον λογάριθμο αυτών πρώτα και προσαρμόζουμε ένα μοντέλο στις λογαριθμισμένες τιμές. Στη συνέχεια, υπολογίζουμε την εκθετική συνάρτηση με βάση το e των καταλοίπων για να τα επαναφέρουμε στην κλίμακα των αρχικών τιμών.\n\nlibrary(tidymodels)\n\ndiamonds &lt;- diamonds |&gt;\n  mutate(\n    log_price = log(price),\n    log_carat = log(carat)\n  )\n\ndiamonds_fit &lt;- linear_reg() |&gt;\n  fit(log_price ~ log_carat, data = diamonds)\n\ndiamonds_aug &lt;- augment(diamonds_fit, new_data = diamonds) |&gt;\n  mutate(.resid = exp(.resid))\n\nggplot(diamonds_aug, aes(x = carat, y = .resid)) + \n  geom_point()\n\n\n\n\n\n\n\nΜόλις αφαιρέσετε την ισχυρή σχέση μεταξύ καρατιών και τιμής, μπορείτε να δείτε αυτό που περιμένετε στη σχέση μεταξύ κοπής και τιμής: σε σχέση με το μέγεθός τους, τα διαμάντια καλύτερης ποιότητας είναι πιο ακριβά.\n\nggplot(diamonds_aug, aes(x = cut, y = .resid)) + \n  geom_boxplot()\n\n\n\n\n\n\n\nΣε αυτό το βιβλίο δεν συζητάμε για τη μοντελοποίηση επειδή είναι πιο εύκολο να κατανοήσετε τι είναι τα μοντέλα και πώς λειτουργούν όταν έχετε στη διάθεσή σας εργαλεία μετασχηματισμού δεδομένων και προγραμματισμού.",
    "crumbs": [
      "Οπτικοποίηση",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Διερευνητική ανάλυση δεδομένων</span>"
    ]
  },
  {
    "objectID": "EDA.html#σύνοψη",
    "href": "EDA.html#σύνοψη",
    "title": "10  Διερευνητική ανάλυση δεδομένων",
    "section": "\n10.7 Σύνοψη",
    "text": "10.7 Σύνοψη\nΣε αυτό το κεφάλαιο έχετε μάθει μία ευρεία γκάμα εργαλείων που θα σας βοηθήσουν να κατανοήσετε τη διακύμανση στα δεδομένα σας. Έχετε δει τεχνικές που λειτουργούν με μία μόνο μεταβλητή κάθε φορά όσο και με ζεύγη μεταβλητών. Μπορεί να σας φάνηκε οδυνηρά περιοριστικό εάν έχετε δεκάδες ή εκατοντάδες μεταβλητές στο σύνολο των δεδομένων σας, αλλά αποτελούν τη βάση πάνω στην οποία χτίζονται όλες οι άλλες τεχνικές.\nΣτο επόμενο κεφάλαιο, θα επικεντρωθούμε στα εργαλεία που μπορούμε να χρησιμοποιήσουμε για να επικοινωνήσουμε τα αποτελέσματά μας.",
    "crumbs": [
      "Οπτικοποίηση",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Διερευνητική ανάλυση δεδομένων</span>"
    ]
  },
  {
    "objectID": "EDA.html#footnotes",
    "href": "EDA.html#footnotes",
    "title": "10  Διερευνητική ανάλυση δεδομένων",
    "section": "",
    "text": "Να θυμάστε ότι όταν πρέπει να είμαστε ξεκάθαροι σχετικά με την προέλευση μίας συνάρτησης (ή συνόλου δεδομένων), θα χρησιμοποιήσουμε τον ειδικό ορισμό package::function() ή package::dataset.↩︎",
    "crumbs": [
      "Οπτικοποίηση",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Διερευνητική ανάλυση δεδομένων</span>"
    ]
  },
  {
    "objectID": "communication.html",
    "href": "communication.html",
    "title": "11  Επικοινωνία",
    "section": "",
    "text": "11.1 Εισαγωγή\nΣτο Κεφάλαιο 10, μάθατε πώς να χρησιμοποιείτε διαγράμματα ως εργαλεία για την εξερεύνηση των δεδομένων σας. Όταν κάνετε διερευνητικά διαγράμματα, γνωρίζετε —ακόμα χωρίς να κοιτάξετε — ποιες μεταβλητές θα παρουσιάζονται στο διάγραμμα. Δημιουργήσατε κάθε διάγραμμα με συγκεκριμένο σκοπό και μπορείτε να του ρίξετε μία γρήγορη ματιά και να προχωρήσετε στο επόμενο. Κατά τη διάρκεια των περισσότερων αναλύσεων, θα δημιουργήσετε δεκάδες ή εκατοντάδες διαγράμματα, τα περισσότερα από τα οποία καταλήγουν να απορριφθούν αμέσως.\nΤώρα που καταλαβαίνετε τα δεδομένα σας, πρέπει να επικοινωνήσετε αυτή την κατανόησή σας σε άλλους. Το κοινό σας πιθανότατα δεν θα έχει τις γνώσεις με εσάς και δεν θα δείξει το ίδιο βαθύ ενδιαφέρον στα δεδομένα μας. Για να βοηθήσετε τους άλλους να δημιουργήσουν γρήγορα ένα καλό νοητικό μοντέλο των δεδομένων, θα χρειαστεί να καταβάλετε σημαντική προσπάθεια για να κάνετε τα διαγράμματα σας όσο το δυνατόν πιο αυτονόητα. Σε αυτό το κεφάλαιο, θα μάθετε μερικά από τα εργαλεία που παρέχει το πακέτο ggplot2 για να το πετύχετε αυτό.\nΑυτό το κεφάλαιο εστιάζει στα εργαλεία που χρειάζεστε για να δημιουργήσετε καλά γραφικά. Υποθέτουμε ότι ξέρετε τι θέλετε και απλά πρέπει να μάθετε πώς να το κάνετε. Για αυτόν τον λόγο, συνιστούμε ανεπιφύλακτα να συνδυάσετε αυτό το κεφάλαιο με ένα καλό βιβλίο γενικής απεικόνισης. Μας αρέσει ιδιαίτερα το The Truthful Art, του Albert Cairo. Δεν διδάσκει τους μηχανισμούς της δημιουργίας οπτικοποιήσεων, αλλά εστιάζει σε αυτό που πρέπει να σκεφτείτε για να δημιουργήσετε αποτελεσματικά γραφικά.",
    "crumbs": [
      "Οπτικοποίηση",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Επικοινωνία</span>"
    ]
  },
  {
    "objectID": "communication.html#εισαγωγή",
    "href": "communication.html#εισαγωγή",
    "title": "11  Επικοινωνία",
    "section": "",
    "text": "11.1.1 Προαπαιτούμενα\nΣε αυτό το κεφάλαιο, θα επικεντρωθούμε για άλλη μία φορά στο πακέτο ggplot2. Θα χρησιμοποιήσουμε επίσης λίγο και το πακέτο dplyr για το χειρισμό των δεδομένων, το πακέτο scales για να παρακάμψουμε τα προεπιλεγμένα διαστήματα, τις ετικέτες, τους μετασχηματισμούς και τις παλέτες, καθώς και μερικά πακέτα επέκτασης των δυνατοτήτων της ggplot2, συμπεριλαμβανομένου των ggrepel (https://ggrepel. slowkow.com) από τον Kamil Slowikowski και patchwork (https://patchwork.data-imaginist.com) του Thomas Lin Pedersen. Μην ξεχνάτε ότι θα χρειαστεί να εγκαταστήσετε αυτά τα πακέτα με την εντολή ‘install.packages()’ αν δεν τα έχετε ήδη.\n\nlibrary(tidyverse)\nlibrary(scales)\nlibrary(ggrepel)\nlibrary(patchwork)",
    "crumbs": [
      "Οπτικοποίηση",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Επικοινωνία</span>"
    ]
  },
  {
    "objectID": "communication.html#ετικέτες-labels",
    "href": "communication.html#ετικέτες-labels",
    "title": "11  Επικοινωνία",
    "section": "\n11.2 Ετικέτες (labels)",
    "text": "11.2 Ετικέτες (labels)\nΤο πιο εύκολο μέρος για να ξεκινήσετε όταν μετατρέπετε ένα διερευνητικό διάγραμμα σε ένα επεξηγητικό γραφικό είναι με τις καλές ετικέτες. Μπορείτε να να προσθέσετε ετικέτες σε ένα διάγραμμα με τη συνάρτηση labs().\n\nggplot(mpg, aes(x = displ, y = hwy)) +\n  geom_point(aes(color = class)) +\n  geom_smooth(se = FALSE) +\n  labs(\n    x = \"Engine displacement (L)\",\n    y = \"Highway fuel economy (mpg)\",\n    color = \"Car type\",\n    title = \"Fuel efficiency generally decreases with engine size\",\n    subtitle = \"Two seaters (sports cars) are an exception because of their light weight\",\n    caption = \"Data from fueleconomy.gov\"\n  )\n\n\n\n\n\n\n\nΟ σκοπός ενός τίτλου σε ένα διάγραμμα είναι να συνοψίσει το κύριο εύρημα. Αποφύγετε τίτλους που απλώς περιγράφουν τι είναι το διάγραμμα, π.χ., “Ένα διάγραμμα διασποράς του κυβισμού κινητήρα έναντι της οικονομίας καυσίμου”.\nΕάν χρειάζεται να προσθέσετε περισσότερο κείμενο, υπάρχουν δύο άλλες χρήσιμες ετικέτες: ο υπότιτλος (subtitle) προσθέτει επιπλέον λεπτομέρειες με μικρότερη γραμματοσειρά κάτω από τον τίτλο και η λεζάντα (caption) που προσθέτει κείμενο στην κάτω δεξιά γωνία του διαγράμματος, και χρησιμοποιείται συχνά για να περιγράψει την πηγή των δεδομένων. Μπορείτε επίσης να χρησιμοποιήσετε το labs() για να αντικαταστήσετε τους τίτλους των αξόνων και των υπομνημάτων. Συνήθως είναι καλή ιδέα να αντικαταστήσετε σύντομα ονόματα μεταβλητών με πιο λεπτομερείς περιγραφές και να συμπεριλάβετε τις μονάδες.\nΕίναι δυνατό να χρησιμοποιηθούν μαθηματικές εξισώσεις αντί για συμβολοσειρές κειμένου. Απλώς απενεργοποιήστε το \"\" στην quote() και διαβάστε για τις διαθέσιμες επιλογές στο ?plotmath:\n\ndf &lt;- tibble(\n  x = 1:10,\n  y = cumsum(x^2)\n)\n\nggplot(df, aes(x, y)) +\n  geom_point() +\n  labs(\n    x = quote(x[i]),\n    y = quote(sum(x[i] ^ 2, i == 1, n))\n  )\n\n\n\n\n\n\n\n\n11.2.1 Ασκήσεις\n\nΔημιουργήστε ένα διάγραμμα με τα δεδομένα οικονομίας καυσίμου με προσαρμοσμένες τις ετικέτες title, subtitle, caption, x, y, και color.\n\nΔημιουργήστε ξανά το παρακάτω διάγραμμα χρησιμοποιώντας τα δεδομένα οικονομίας καυσίμου. Σημειώστε ότι τόσο τα χρώματα όσο και τα σχήματα των σημείων διαφέρουν ανάλογα με τον τύπο του συστήματος μετάδοσης κίνησης.\n\n\n\n\n\n\n\n\n\nΞεκινήστε με ένα διερευνητικό διάγραμμα που δημιουργήσατε τον τελευταίο μήνα και προσθέστε ενημερωτικούς τίτλους για να το καταλάβουν πιο εύκολα οι άλλοι.",
    "crumbs": [
      "Οπτικοποίηση",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Επικοινωνία</span>"
    ]
  },
  {
    "objectID": "communication.html#επισημάνσεις",
    "href": "communication.html#επισημάνσεις",
    "title": "11  Επικοινωνία",
    "section": "\n11.3 Επισημάνσεις",
    "text": "11.3 Επισημάνσεις\nΕκτός από την επισήμανση βασικών στοιχείων του διαγράμματος σας, είναι συχνά χρήσιμο να επισημαίνετε μεμονωμένες παρατηρήσεις ή ομάδες παρατηρήσεων. Το πρώτο εργαλείο που έχετε στη διάθεσή σας είναι η geom_text(). Η geom_text() είναι παρόμοια με τη geom_point(), αλλά έχει ένα επιπλέον αισθητικό στοιχείο: το label. Αυτό καθιστά δυνατή την προσθήκη ετικετών κειμένου στα διαγράμματα σας.\nΥπάρχουν δύο πιθανές πηγές ετικετών. Πρώτον, μπορεί να έχετε ένα tibble που παρέχει ετικέτες. Στο παρακάτω διάγραμμα επιλέγουμε τα αυτοκίνητα με το μεγαλύτερο μέγεθος κινητήρα σε κάθε τύπο κίνησης και αποθηκεύουμε τις πληροφορίες τους σε ένα νέο πλαίσιο δεδομένων που ονομάζεται label_info.\n\nlabel_info &lt;- mpg |&gt;\n  group_by(drv) |&gt;\n  arrange(desc(displ)) |&gt;\n  slice_head(n = 1) |&gt;\n  mutate(\n    drive_type = case_when(\n      drv == \"f\" ~ \"front-wheel drive\",\n      drv == \"r\" ~ \"rear-wheel drive\",\n      drv == \"4\" ~ \"4-wheel drive\"\n    )\n  ) |&gt;\n  select(displ, hwy, drv, drive_type)\n\nlabel_info\n#&gt; # A tibble: 3 × 4\n#&gt; # Groups:   drv [3]\n#&gt;   displ   hwy drv   drive_type       \n#&gt;   &lt;dbl&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt;            \n#&gt; 1   6.5    17 4     4-wheel drive    \n#&gt; 2   5.3    25 f     front-wheel drive\n#&gt; 3   7      24 r     rear-wheel drive\n\nΣτη συνέχεια, χρησιμοποιούμε αυτό το νέο πλαίσιο δεδομένων για να επισημάνουμε απευθείας τις τρεις ομάδες, αντικαθιστώντας το υπόμνημα με ετικέτες που τοποθετούνται απευθείας στο διάγραμμα Χρησιμοποιώντας τα ορίσματα fontface και size μπορούμε να προσαρμόσουμε την εμφάνιση των ετικετών κειμένου. Αυτές είναι μεγαλύτερες από το υπόλοιπο κείμενο στο διάγραμμα και με έντονη γραφή. Το (theme(legend.position = \"none\") απενεργοποιεί όλα τα υπομνήματα — θα μιλήσουμε για αυτό σύντομα.)\n\nggplot(mpg, aes(x = displ, y = hwy, color = drv)) +\n  geom_point(alpha = 0.3) +\n  geom_smooth(se = FALSE) +\n  geom_text(\n    data = label_info, \n    aes(x = displ, y = hwy, label = drive_type),\n    fontface = \"bold\", size = 5, hjust = \"right\", vjust = \"bottom\"\n  ) +\n  theme(legend.position = \"none\")\n#&gt; `geom_smooth()` using method = 'loess' and formula = 'y ~ x'\n\n\n\n\n\n\n\nΣημειώστε τη χρήση των hjust (οριζόντια στοίχιση, horizontal justification) και vjust (κάθετη στοίχιση, vertical justification) για τον έλεγχο της ευθυγράμμισης της ετικέτας.\nΩστόσο, το επισημασμένο διάγραμμα που δημιουργήσαμε παραπάνω είναι δύσκολο να διαβαστεί καθώς οι ετικέτες επικαλύπτονται μεταξύ τους και με τα σημεία. Μπορούμε να χρησιμοποιήσουμε τη συνάρτηση geom_label_repel() από το πακέτο ggrepel για να αντιμετωπίσουμε και τα δύο αυτά ζητήματα. Αυτό το χρήσιμο πακέτο θα προσαρμόσει αυτόματα τις ετικέτες έτσι ώστε να μην αλληλεπικαλύπτονται:\n\nggplot(mpg, aes(x = displ, y = hwy, color = drv)) +\n  geom_point(alpha = 0.3) +\n  geom_smooth(se = FALSE) +\n  geom_label_repel(\n    data = label_info, \n    aes(x = displ, y = hwy, label = drive_type),\n    fontface = \"bold\", size = 5, nudge_y = 2\n  ) +\n  theme(legend.position = \"none\")\n#&gt; `geom_smooth()` using method = 'loess' and formula = 'y ~ x'\n\n\n\n\n\n\n\nΜπορείτε επίσης να ακολουθήσετε την ίδια ιδέα για να επισημάνετε ορισμένα σημεία σε μία γραφική παράσταση με τη geom_text_repel() από το πακέτο ggrepel. Σημειώστε μία άλλη εύχρηστη τεχνική που χρησιμοποιείται εδώ: προσθέσαμε ένα δεύτερο στρώμα μεγάλων, κοίλων σημείων για να τονίσουμε περαιτέρω τα σημεία που φέρουν ετικέτα.\n\npotential_outliers &lt;- mpg |&gt;\n  filter(hwy &gt; 40 | (hwy &gt; 20 & displ &gt; 5))\n  \nggplot(mpg, aes(x = displ, y = hwy)) +\n  geom_point() +\n  geom_text_repel(data = potential_outliers, aes(label = model)) +\n  geom_point(data = potential_outliers, color = \"red\") +\n  geom_point(\n    data = potential_outliers,\n    color = \"red\", size = 3, shape = \"circle open\"\n  )\n\n\n\n\n\n\n\nΘυμηθείτε, εκτός από τη geom_text() και τη geom_label(), έχετε πολλά άλλα γεωμετρικά στοιχεία διαθέσιμα στο πακέτο ggplot2 για να βοηθήσετε στην επισήμανση του διαγράμματος σας. Μερικές ιδέες:\n\nΧρησιμοποιήστε τις geom_hline() και geom_vline() για να προσθέσετε γραμμές αναφοράς. Συχνά χρησιμοποιούμε πιο παχιές γραμμές (linewidth = 2) και λευκές (color = white) και τις σχεδιάζουμε κάτω από το κύριο επίπεδο δεδομένων. Αυτό τις καθιστά εύκολα ορατές, χωρίς να αποσπά την προσοχή από τα δεδομένα.\nΧρησιμοποιήστε τη geom_rect() για να σχεδιάσετε ένα ορθογώνιο γύρω από σημεία που σας ενδιαφέρουν. Τα όρια του ορθογωνίου ορίζονται από τα αισθητικά στοιχεία xmin, xmax, ymin, ymax. Εναλλακτικά, ανατρέξτε στο πακέτο ggforce, και συγκεκριμένα στο geom_mark_hull(), το οποίο σας επιτρέπει να σχολιάζετε υποσύνολα σημείων με τη βοήθεια περιγραμμάτων.\nΧρησιμοποιήστε την geom_segment() με το όρισμα arrow για να επιστήσετε την προσοχή σε ένα σημείο, υποδεικνύοντας το με ένα βέλος. Χρησιμοποιήστε τα αισθητικά στοιχεία x και y για να ορίσετε την αρχική θέση και τα xend και yend για να ορίσετε την τελική θέση.\n\nΜία άλλη εύχρηστη συνάρτηση για την προσθήκη σχολιασμών σε διαγράμματα είναι η annotate(). Ως εμπειρικό κανόνα, τα γεωμετρικά στοιχεία είναι γενικά χρήσιμα για την επισήμανση ενός υποσυνόλου δεδομένων ενώ η annotate() είναι χρήσιμη για την προσθήκη ενός ή μικρού αριθμού στοιχείων σχολιασμού σε ένα γράφημα.\nΓια να δείξουμε τη χρήση της annotate(), ας δημιουργήσουμε ένα κείμενο για να προσθέσουμε στο διάγραμμα μας. Το κείμενο είναι λίγο μεγάλο, επομένως θα χρησιμοποιήσουμε την stringr::str_wrap() για να προσθέσουμε αυτόματα αλλαγές γραμμής, δεδομένου του αριθμού των χαρακτήρων που θέλετε ανά γραμμή:\n\ntrend_text &lt;- \"Larger engine sizes tend to have lower fuel economy.\" |&gt;\n  str_wrap(width = 30)\ntrend_text\n#&gt; [1] \"Larger engine sizes tend to\\nhave lower fuel economy.\"\n\nΣτη συνέχεια, προσθέτουμε δύο επίπεδα επισήμανσης: το ένα με γεωμετρικό στοιχείο ετικέτας και το άλλο με γεωμετρικό ευθύγραμμου τμήματος (segment). Τα αισθητικά στοιχεία x και y και στα δύο αυτά γεωμετρικά στοιχεία ορίζουν από πού πρέπει να ξεκινά η επισήμανση και τα αισθητικά xend και yend στην περίπτωση του γεωμετρικού στοιχείου ευθύγραμμου τμήματος ορίζουν την τελική θέση του τμήματος. Σημειώστε επίσης ότι το ευθύγραμμο τμήμα έχει τη μορφή βέλους.\n\nggplot(mpg, aes(x = displ, y = hwy)) +\n  geom_point() +\n  annotate(\n    geom = \"label\", x = 3.5, y = 38,\n    label = trend_text,\n    hjust = \"left\", color = \"red\"\n  ) +\n  annotate(\n    geom = \"segment\",\n    x = 3, y = 35, xend = 5, yend = 25, color = \"red\",\n    arrow = arrow(type = \"closed\")\n  )\n\n\n\n\n\n\n\nΗ επισήμανση είναι ένα ισχυρό εργαλείο για την επικοινωνία των κύριων σημείων και των χαρακτηριστικών ενδιαφέροντος των οπτικοποιήσεων σας. Ο μόνος περιορισμός είναι η φαντασία σας (και η υπομονή σας με την τοποθέτηση επισημάνσεων ώστε να είναι αισθητικά ευχάριστες)!\n\n11.3.1 Ασκήσεις\n\nΧρησιμοποιήστε την geom_text() με άπειρες θέσεις για να τοποθετήσετε κείμενο στις τέσσερις γωνίες της γραφικής παράστασης.\nΧρησιμοποιήστε την annotate() για να προσθέσετε ένα γεωμετρικό στοιχείο στη μέση του τελευταίου διαγράμματος, χωρίς να χρειάζεται να δημιουργήσετε ένα tibble. Προσαρμόστε το σχήμα, το μέγεθος ή το χρώμα του σημείου.\nΠώς αλληλεπιδρούν οι ετικέτες με τη geom_text() με τη δημιουργία όψεων (faceting); Πώς μπορείτε να προσθέσετε μία ετικέτα σε μία μεμονωμένη όψη; Πώς μπορείτε να βάλετε διαφορετική ετικέτα σε κάθε όψη; (Συμβουλή: Σκεφτείτε το σύνολο δεδομένων που μεταβιβάζεται στη geom_text().)\nΠοια ορίσματα της geom_label() ελέγχουν την εμφάνιση του πλαισίου φόντου;\nΠοια είναι τα τέσσερα ορίσματα της arrow(); Πώς λειτουργούν; Δημιουργήστε μία σειρά από διαγράμματα που δείχνουν τις πιο σημαντικές επιλογές.",
    "crumbs": [
      "Οπτικοποίηση",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Επικοινωνία</span>"
    ]
  },
  {
    "objectID": "communication.html#κλίμακες",
    "href": "communication.html#κλίμακες",
    "title": "11  Επικοινωνία",
    "section": "\n11.4 Κλίμακες",
    "text": "11.4 Κλίμακες\nΟ τρίτος τρόπος με τον οποίο μπορείτε να κάνετε το διάγραμμα σας καλύτερο για επικοινωνία είναι να προσαρμόσετε τις κλίμακες. Οι κλίμακες ελέγχουν πώς εμφανίζονται οπτικά οι αισθητικές αντιστοιχίσεις.\n\n11.4.1 Προεπιλεγμένες κλίμακες\nΦυσιολογικά, το πακέτο ggplot2 προσθέτει αυτόματα κλίμακες για εσάς. Για παράδειγμα, όταν πληκτρολογείτε:\n\nggplot(mpg, aes(x = displ, y = hwy)) +\n  geom_point(aes(color = class))\n\nΗ ggplot2 προσθέτει αυτόματα προεπιλεγμένες κλίμακες στο παρασκήνιο:\n\nggplot(mpg, aes(x = displ, y = hwy)) +\n  geom_point(aes(color = class)) +\n  scale_x_continuous() +\n  scale_y_continuous() +\n  scale_color_discrete()\n\nΠαρατηρήστε το σύστημα ονομασίας για τις κλίμακες: scale_ ακολουθούμενο από το όνομα του αισθητικού στοιχείου, μετά _, και μετά το όνομα της κλίμακας. Οι προεπιλεγμένες κλίμακες ονομάζονται ανάλογα με τον τύπο της μεταβλητής με την οποία αντιστοιχίζονται: συνεχής, διακριτή, ημερομηνία και ώρας ή ημερομηνία. Η scale_x_continuous() βάζει τις αριθμητικές τιμές από το displ σε μία συνεχή αριθμητική γραμμή στον άξονα x, η scale_color_discrete() επιλέγει χρώματα για κάθε μία από τις κατηγορίες (class) του car κ.λπ. Υπάρχουν πολλές μη προεπιλεγμένες κλίμακες για τις οποίες θα μάθετε παρακάτω.\nΟι προεπιλεγμένες κλίμακες έχουν επιλεγεί προσεκτικά για να κάνουν καλή δουλειά για ένα ευρύ φάσμα εισόδων. Ωστόσο, μπορεί να θέλετε να παρακάμψετε τις προεπιλογές για δύο λόγους:\n\nΊσως θέλετε να τροποποιήσετε ορισμένες από τις παραμέτρους της προεπιλεγμένης κλίμακας. Αυτό σας επιτρέπει να κάνετε πράγματα όπως να αλλάξετε τα διαστήματα στους άξονες ή τις ετικέτες στο υπόμνημα.\nΊσως θέλετε να αντικαταστήσετε εντελώς την κλίμακα και να χρησιμοποιήσετε έναν εντελώς διαφορετικό αλγόριθμο. Συχνά μπορείτε να πετύχετε καλύτερο αποτέλεσμα από την προεπιλογή, επειδή γνωρίζετε περισσότερα για τα δεδομένα.\n\n11.4.2 Διαχωριστικά σημεία αξόνων και ετικέτες υπομνημάτων\nΣυνολικά, οι άξονες και τα υπομνήματα είναι γνωστά ως οδηγοί (guides). Οι άξονες χρησιμοποιούνται για τα αισθητικά στοιχεία x και y, ενώ τα υπομνήματα χρησιμοποιούνται για οτιδήποτε άλλο.\nΥπάρχουν δύο κύρια ορίσματα που επηρεάζουν την εμφάνιση των διαχωριστικών σημείων στους άξονες και τις ετικέτες στο υπόμνημα: breaks και labels αντίστοιχα. Το breaks ελέγχει τη θέση των διαχωριστικών ή τις τιμές που σχετίζονται με τις ετικέτες/κλειδιά. Το labels ελέγχει την ετικέτα κειμένου που σχετίζεται με κάθε διαχωριστικό/κλειδί. Η πιο κοινή χρήση του breaks είναι η παράκαμψη της προκαθορισμένης επιλογής:\n\nggplot(mpg, aes(x = displ, y = hwy, color = drv)) +\n  geom_point() +\n  scale_y_continuous(breaks = seq(15, 40, by = 5)) \n\n\n\n\n\n\n\nΜπορείτε να χρησιμοποιήσετε το labels με τον ίδιο τρόπο (ένα διάνυσμα χαρακτήρων ίδιου μήκους με το breaks), αλλά μπορείτε επίσης να το ορίσετε ως NULL για να καταργήσετε τις ετικέτες εντελώς. Αυτό μπορεί να είναι χρήσιμο για χάρτες ή για δημοσίευση διαγραμμάτων όπου δεν μπορείτε να μοιραστείτε τους απόλυτους αριθμούς. Μπορείτε επίσης να χρησιμοποιήσετε τα breaks και labels για να ελέγξετε την εμφάνιση των υπομνημάτων. Για διακριτές κλίμακες κατηγορικών μεταβλητών, το labels μπορεί να είναι μία λίστα της οποίας τα στοιχεία έχουν ονόματα και η οποία περιέχει τα υπάρχοντα ονόματα κλάσεων και τις επιθυμητές ετικέτες για αυτά.\n\nggplot(mpg, aes(x = displ, y = hwy, color = drv)) +\n  geom_point() +\n  scale_x_continuous(labels = NULL) +\n  scale_y_continuous(labels = NULL) +\n  scale_color_discrete(labels = c(\"4\" = \"4-wheel\", \"f\" = \"front\", \"r\" = \"rear\"))\n\n\n\n\n\n\n\nΤο όρισμα labels σε συνδυασμό με συναρτήσεις επισήμανσης από το πακέτο scales είναι επίσης χρήσιμο για τη μορφοποίηση αριθμών ως συνάλλαγμα, ποσοστό κ.λπ. Το διάγραμμα στα αριστερά δείχνει την προεπιλεγμένη επισήμανση με την label_dollar(), η οποία προσθέτει το σύμβολο του δολαρίου καθώς και ένα διαχωριστικό κόμμα για να υποδηλώσει τις χιλιάδες. Η γραφική παράσταση στα δεξιά προσθέτει ένα επιπλέον επίπεδο παραμετροποίησης διαιρώντας τις τιμές σε δολάρια με 1.000 και προσθέτοντας ένα επίθημα “K” (για “χιλιάδες”) καθώς και προσθέτοντας προσαρμοσμένα διαχωριστικά σημεία. Σημειώστε ότι τα breaks ακολουθούν την αρχική κλίμακα των δεδομένων.\n# Αριστερά\nggplot(diamonds, aes(x = price, y = cut)) +\n  geom_boxplot(alpha = 0.05) +\n  scale_x_continuous(labels = label_dollar())\n\n# Δεξιά\nggplot(diamonds, aes(x = price, y = cut)) +\n  geom_boxplot(alpha = 0.05) +\n  scale_x_continuous(\n    labels = label_dollar(scale = 1/1000, suffix = \"K\"), \n    breaks = seq(1000, 19000, by = 6000)\n  )\n\n\n\n\n\n\n\n\n\n\nΑκόμη μία χρήσιμη συνάρτηση είναι η label_percent():\n\nggplot(diamonds, aes(x = cut, fill = clarity)) +\n  geom_bar(position = \"fill\") +\n  scale_y_continuous(name = \"Percentage\", labels = label_percent())\n\n\n\n\n\n\n\nΜία άλλη χρήση του breaks είναι όταν έχετε σχετικά λίγα σημεία δεδομένων και θέλετε να επισημάνετε ακριβώς πού εντοπίζονται οι παρατηρήσεις. Για παράδειγμα, πάρτε αυτό το διάγραμμα που δείχνει πότε κάθε πρόεδρος των ΗΠΑ ξεκίνησε και ολοκλήρωσε τη θητεία του.\n\npresidential |&gt;\n  mutate(id = 33 + row_number()) |&gt;\n  ggplot(aes(x = start, y = id)) +\n  geom_point() +\n  geom_segment(aes(xend = end, yend = id)) +\n  scale_x_date(name = NULL, breaks = presidential$start, date_labels = \"'%y\")\n\n\n\n\n\n\n\nΣημειώστε ότι για το όρισμα breaks έχουμε εξάγει τη μεταβλητή start ως διάνυσμα, επιλέγοντας την ως presidential$start, επειδή δεν μπορούμε να κάνουμε αισθητική αντιστοίχιση για αυτό το όρισμα. Σημειώστε επίσης ότι η επιλογή των διαχωριστικών και των ετικετών για τις κλίμακες ημερομηνίας και ώρας είναι λίγο διαφορετική:\n\nΤο date_labels δέχεται μία συγκεκριμένη δομή μορφοποίησης, ίδια με τη συνάρτηση parse_datetime().\nΤο date_breaks (δεν εμφανίζεται εδώ), παίρνει μία συμβολοσειρά όπως για παράδειγμα “2 days” ή “1 month”.\n\n11.4.3 Διάταξη υπομνήματος\nΣυνήθως θα χρησιμοποιείτε τα breaks και labels για να τροποποιήσετε τους άξονες. Ενώ και οι δύο λειτουργούν και για υπομνήματα, υπάρχουν μερικές άλλες τεχνικές που είναι πιο πιθανό να χρησιμοποιήσετε.\nΓια να ελέγξετε τη συνολική θέση του υπομνήματος, πρέπει να το ορίσετε μέσω του theme(). Θα επανέλθουμε στα θέματα στο τέλος του κεφαλαίου, αλλά εν συντομία, αυτά ελέγχουν τα μέρη του διαγράμματος που δεν έχουν να κάνουν με τα δεδομένα. Η επιλογή legend.position ελέγχει πού θα σχεδιαστεί το υπόμνημα:\nbase &lt;- ggplot(mpg, aes(x = displ, y = hwy)) +\n  geom_point(aes(color = class))\n\nbase + theme(legend.position = \"right\") # the default\nbase + theme(legend.position = \"left\")\nbase + \n  theme(legend.position = \"top\") +\n  guides(color = guide_legend(nrow = 3))\nbase + \n  theme(legend.position = \"bottom\") +\n  guides(color = guide_legend(nrow = 3))\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nΕάν το διάγραμμα σας είναι κοντό και πλατύ, τοποθετήστε το υπόμνημα στην κορυφή ή στο κάτω μέρος και αν είναι ψηλό και στενό, τοποθετήστε το υπόμνημα αριστερά ή δεξιά. Μπορείτε επίσης να χρησιμοποιήσετε την επιλογή legend.position = \"none\" για να καταστείλετε εντελώς την εμφάνιση του υπομνήματος.\nΓια να ελέγξετε την εμφάνιση μεμονωμένων υπομνημάτων, χρησιμοποιήστε την guides() μαζί με τη guide_legend() ή τη guide_colorbar(). Το ακόλουθο παράδειγμα δείχνει δύο σημαντικές ρυθμίσεις: τον έλεγχο του αριθμού των γραμμών που χρησιμοποιεί το υπόμνημα με το όρισμα “nrow” και την παράκαμψη ενός από τα αισθητικά στοιχεία για να μεγαλώσουν τα σημεία. Αυτό είναι ιδιαίτερα χρήσιμο εάν έχετε χρησιμοποιήσει χαμηλή τιμή alpha για να παρουσιάσετε πολλά σημεία σε μία γραφική παράσταση.\n\nggplot(mpg, aes(x = displ, y = hwy)) +\n  geom_point(aes(color = class)) +\n  geom_smooth(se = FALSE) +\n  theme(legend.position = \"bottom\") +\n  guides(color = guide_legend(nrow = 2, override.aes = list(size = 4)))\n#&gt; `geom_smooth()` using method = 'loess' and formula = 'y ~ x'\n\n\n\n\n\n\n\nΠαρατηρήστε ότι το όνομα του ορίσματος στη guides() ταιριάζει με το όνομα του αισθητικού στοιχείου, ακριβώς όπως και στη labs().\n\n11.4.4 Αντικαθιστώντας μία κλίμακα\nΑντί για να τροποποιήσετε λίγο τις λεπτομέρειες, μπορείτε να αντικαταστήσετε εντελώς την κλίμακα. Υπάρχουν δύο τύποι κλιμάκων που είναι πιο πιθανό να θέλετε να αλλάξετε: κλίμακες συνεχούς θέσης και κλίμακες χρώματος. Ευτυχώς, οι ίδιες αρχές ισχύουν για όλες τις υπόλοιπες αισθητικές, επομένως, αφού κατανοήσετε τη θέση και το χρώμα, θα μπορείτε να κατανοήσετε γρήγορα και άλλες αντικαταστάσεις κλιμάκων.\nΕίναι πολύ χρήσιμο να απεικονίζετε μετασχηματισμούς της μεταβλητής σας. Για παράδειγμα, είναι ευκολότερο να δούμε την ακριβή σχέση μεταξύ των μεταβλητών carat και price αν τις μετασχηματίσουμε λογαριθμώντας τες:\n# Αριστερά\nggplot(diamonds, aes(x = carat, y = price)) +\n  geom_bin2d()\n\n# Δεξιά\nggplot(diamonds, aes(x = log10(carat), y = log10(price))) +\n  geom_bin2d()\n\n\n\n\n\n\n\n\n\n\nΩστόσο, το μειονέκτημα αυτού του μετασχηματισμού είναι ότι οι άξονες επισημαίνονται τώρα με τις μετασχηματισμένες τιμές, καθιστώντας δύσκολη την ερμηνεία του διαγράμματος. Αντί να κάνουμε τον μετασχηματισμό στην αισθητική χαρτογράφηση, μπορούμε να το κάνουμε με την κλίμακα. Αυτό είναι οπτικά πανομοιότυπο, εκτός από το ότι οι άξονες επισημαίνονται στην αρχική κλίμακα δεδομένων.\n\nggplot(diamonds, aes(x = carat, y = price)) +\n  geom_bin2d() + \n  scale_x_log10() + \n  scale_y_log10()\n\n\n\n\n\n\n\nΜία άλλη κλίμακα την οποία προσαρμόζουμε συχνά είναι το χρώμα. Η προεπιλεγμένη κατηγορική κλίμακα επιλέγει χρώματα που είναι ομοιόμορφα τοποθετημένα γύρω από τον τροχό χρωμάτων. Χρήσιμες εναλλακτικές είναι οι κλίμακες ColorBrewer που έχουν επιλεγεί για να λειτουργούν καλύτερα για άτομα με συνήθεις τύπους αχρωματοψίας. Τα δύο παρακάτω διαγράμματα μοιάζουν, αλλά υπάρχει μεγάλη διαφορά στις αποχρώσεις του κόκκινου και του πράσινου, έτσι ώστε οι κουκκίδες στα δεξιά να διακρίνονται ακόμα και από άτομα με αχρωματοψία στο κόκκινο και το πράσινο1.\nggplot(mpg, aes(x = displ, y = hwy)) +\n  geom_point(aes(color = drv))\n\nggplot(mpg, aes(x = displ, y = hwy)) +\n  geom_point(aes(color = drv)) +\n  scale_color_brewer(palette = \"Set1\")\n\n\n\n\n\n\n\n\n\n\nΜην ξεχνάτε απλούστερες τεχνικές για τη βελτίωση του πόσο προσβάσιμα είναι τα διαγράμματα σας. Εάν υπάρχουν μόνο λίγα χρώματα, μπορείτε να προσθέσετε μία πλεονάζουσα αντιστοίχιση σχήματος. Αυτό θα βοηθήσει επίσης να διασφαλίσετε ότι το διάγραμμα σας είναι ερμηνεύσιμο σε μαύρο και άσπρο.\n\nggplot(mpg, aes(x = displ, y = hwy)) +\n  geom_point(aes(color = drv, shape = drv)) +\n  scale_color_brewer(palette = \"Set1\")\n\n\n\n\n\n\n\nΟι κλίμακες ColorBrewer καταγράφονται αναλυτικά στη διαδικτυακή διεύθυνση https://colorbrewer2.org/ και διατίθενται στην R μέσω του πακέτου RColorBrewer, από τον Erich Neuwirth. Το Σχήμα 11.1 εμφανίζει την πλήρη λίστα όλων των παλετών. Η διαδοχική (επάνω) και η αποκλίνουσα (κάτω) παλέτα είναι ιδιαίτερα χρήσιμες αν οι κατηγορίες σας είναι ταξινομημένες ή έχουν μία “μεσαία” τιμή. Αυτό προκύπτει συχνά εάν έχετε χρησιμοποιήσει την cut() για να μετατρέψετε μία συνεχή μεταβλητή σε κατηγορική.\n\n\n\n\n\n\n\nΣχήμα 11.1: Όλες οι χρωματικές διαβαθμίσεις του colorBrewer.\n\n\n\n\nΌταν έχετε μία προκαθορισμένη αντιστοίχιση μεταξύ τιμών και χρωμάτων, χρησιμοποιήστε την scale_color_manual(). Για παράδειγμα, εάν αντιστοιχίσουμε τα πολιτικά κόμματα που διεκδικούν την προεδρία των ΗΠΑ με ένα χρώμα, θα θέλουμε να χρησιμοποιήσουμε την τυπική χαρτογράφηση του κόκκινου για τους Ρεπουμπλικάνους και του μπλε για τους Δημοκρατικούς. Μία προσέγγιση για την εκχώρηση αυτών των χρωμάτων είναι η χρήση δεκαεξαδικών (hex, hexadecimal) κωδικών χρωμάτων:\n\npresidential |&gt;\n  mutate(id = 33 + row_number()) |&gt;\n  ggplot(aes(x = start, y = id, color = party)) +\n  geom_point() +\n  geom_segment(aes(xend = end, yend = id)) +\n  scale_color_manual(values = c(Republican = \"#E81B23\", Democratic = \"#00AEF3\"))\n\n\n\n\n\n\n\nΓια συνεχές χρώμα, μπορείτε να χρησιμοποιήσετε τις ενσωματωμένες συναρτήσεις scale_color_gradient() ή scale_fill_gradient(). Εάν έχετε αποκλίνουσα κλίμακα, μπορείτε να χρησιμοποιήσετε τη scale_color_gradient2(). Αυτό σας επιτρέπει να δώσετε, για παράδειγμα, διαφορετικά χρώματα σε θετικές και αρνητικές τιμές. Αυτό μερικές φορές είναι επίσης χρήσιμο εάν θέλετε να διακρίνετε σημεία πάνω ή κάτω από τη μέση τιμή.\nΜία άλλη επιλογή είναι να χρησιμοποιήσετε τις χρωματικές κλίμακες viridis. Οι σχεδιαστές, ο Nathaniel Smith και ο Stéfan van der Walt, προσάρμοσαν προσεκτικά συνεχείς χρωματικούς συνδυασμούς που είναι αντιληπτοί σε άτομα με διάφορες μορφές αχρωματοψίας ενώ γίνονται αντιληπτοί με ομοιόμορφο τρόπο, τόσο ως έγχρωμοι όσο και ασπρόμαυροι. Αυτές οι κλίμακες είναι διαθέσιμες ως συνεχείς (c), διακριτές (d) και binned (b) παλέτες στο πακέτο ggplot2.\ndf &lt;- tibble(\n  x = rnorm(10000),\n  y = rnorm(10000)\n)\n\nggplot(df, aes(x, y)) +\n  geom_hex() +\n  coord_fixed() +\n  labs(title = \"Default, continuous\", x = NULL, y = NULL)\n\nggplot(df, aes(x, y)) +\n  geom_hex() +\n  coord_fixed() +\n  scale_fill_viridis_c() +\n  labs(title = \"Viridis, continuous\", x = NULL, y = NULL)\n\nggplot(df, aes(x, y)) +\n  geom_hex() +\n  coord_fixed() +\n  scale_fill_viridis_b() +\n  labs(title = \"Viridis, binned\", x = NULL, y = NULL)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nΠαρατηρήστε ότι όλες οι χρωματικές κλίμακες διατίθενται σε δύο ποικιλίες: scale_color_*() και scale_fill_*() για τα αισθητικά στοιχεία color και fill αντίστοιχα (οι κλίμακες χρώματος είναι διαθέσιμες ακολουθώντας τον τρόπο γραφής τόσο του Ηνωμένου Βασιλείου όσο και των ΗΠΑ).\n\n11.4.5 Εστιάζοντας\nΥπάρχουν τρεις τρόποι για να ελέγξετε τα όρια του διαγράμματος:\n\nΠροσαρμογή των δεδομένων που σχεδιάζονται.\nΡύθμιση των ορίων σε κάθε κλίμακα.\nΡύθμιση των xlim και ylim στη συνάρτηση coord_cartesian().\n\nΘα δείξουμε αυτές τις επιλογές σε μία σειρά διαγραμμάτων. Το διάγραμμα στα αριστερά δείχνει τη σχέση μεταξύ του μεγέθους του κινητήρα και της απόδοσης καυσίμου, χρωματισμένη ανά τύπο συστήματος μετάδοσης κίνησης. Το διάγραμμα στα δεξιά δείχνει τις ίδιες μεταβλητές, αλλά αναπαριστώντας υποσύνολα των δεδομένα. Η υποομάδα των δεδομένων έχει επηρεάσει τις κλίμακες x και y καθώς και την ομαλή καμπύλη.\n# Αριστερά\nggplot(mpg, aes(x = displ, y = hwy)) +\n  geom_point(aes(color = drv)) +\n  geom_smooth()\n\n# Δεξιά\nmpg |&gt;\n  filter(displ &gt;= 5 & displ &lt;= 6 & hwy &gt;= 10 & hwy &lt;= 25) |&gt;\n  ggplot(aes(x = displ, y = hwy)) +\n  geom_point(aes(color = drv)) +\n  geom_smooth()\n\n\n\n\n\n\n\n\n\n\nΑς τα συγκρίνουμε με τα δύο παρακάτω διαγράμματα όπου το διάγραμμα στα αριστερά θέτει τα limits σε μεμονωμένες κλίμακες και το διάγραμμα στα δεξιά τα ορίζει μέσω της coord_cartesian(). Μπορούμε να δούμε ότι η μείωση των ορίων ισοδυναμεί με δημιουργία υποσυνόλων των δεδομένων. Επομένως, για να εστιάσετε σε μία περιοχή της γραφικής παράστασης, είναι γενικά καλύτερο να χρησιμοποιήσετε το coord_cartesian().\n# Αριστερά\nggplot(mpg, aes(x = displ, y = hwy)) +\n  geom_point(aes(color = drv)) +\n  geom_smooth() +\n  scale_x_continuous(limits = c(5, 6)) +\n  scale_y_continuous(limits = c(10, 25))\n\n# Δεξιά\nggplot(mpg, aes(x = displ, y = hwy)) +\n  geom_point(aes(color = drv)) +\n  geom_smooth() +\n  coord_cartesian(xlim = c(5, 6), ylim = c(10, 25))\n\n\n\n\n\n\n\n\n\n\nΑπό την άλλη, ο ορισμός των limits σε μεμονωμένες κλίμακες είναι γενικά πιο χρήσιμος εάν θέλετε να επεκτείνετε τα όρια, π.χ. ώστε να ταιριάξετε τις κλίμακες που χρησιμοποιούνται σε διαφορετικά διαγράμματα. Για παράδειγμα, αν εξαγάγουμε δύο κατηγορίες αυτοκινήτων και τις αναπαραστήσουμε χωριστά, είναι δύσκολο να συγκρίνουμε τα διαγράμματα επειδή και οι τρεις κλίμακες (ο άξονας x, ο άξονας y και το χρωματικό αισθητικό στοιχείο) έχουν διαφορετικά εύρη.\nsuv &lt;- mpg |&gt; filter(class == \"suv\")\ncompact &lt;- mpg |&gt; filter(class == \"compact\")\n\n# Αριστερά\nggplot(suv, aes(x = displ, y = hwy, color = drv)) +\n  geom_point()\n\n# Δεξιά\nggplot(compact, aes(x = displ, y = hwy, color = drv)) +\n  geom_point()\n\n\n\n\n\n\n\n\n\n\nΈνας τρόπος για να ξεπεραστεί αυτό το πρόβλημα είναι να μοιράζεστε κλίμακες σε πολλαπλά διαγράμματα, εκπαιδεύοντας τις κλίμακες με τις τιμές των limits που αντιστοιχούν στα πλήρη δεδομένα.\nx_scale &lt;- scale_x_continuous(limits = range(mpg$displ))\ny_scale &lt;- scale_y_continuous(limits = range(mpg$hwy))\ncol_scale &lt;- scale_color_discrete(limits = unique(mpg$drv))\n\n# Αριστερά\nggplot(suv, aes(x = displ, y = hwy, color = drv)) +\n  geom_point() +\n  x_scale +\n  y_scale +\n  col_scale\n\n# Δεξιά\nggplot(compact, aes(x = displ, y = hwy, color = drv)) +\n  geom_point() +\n  x_scale +\n  y_scale +\n  col_scale\n\n\n\n\n\n\n\n\n\n\nΣε αυτή τη συγκεκριμένη περίπτωση, θα μπορούσατε απλώς να έχετε χρησιμοποιήσει όψεις (faceting), αλλά αυτή η τεχνική είναι χρήσιμη γενικότερα, εάν, για παράδειγμα, θέλετε να κατανείμετε γραφικά σε πολλές σελίδες μιας αναφοράς.\n\n11.4.6 Ασκήσεις\n\n\nΓιατί ο παρακάτω κώδικας δεν αντικαθιστά την προεπιλεγμένη κλίμακα;\n\ndf &lt;- tibble(\n  x = rnorm(10000),\n  y = rnorm(10000)\n)\n\nggplot(df, aes(x, y)) +\n  geom_hex() +\n  scale_color_gradient(low = \"white\", high = \"red\") +\n  coord_fixed()\n\n\nΠοιο είναι το πρώτο όρισμα σε κάθε κλίμακα; Πώς συγκρίνεται με τη συνάρτηση labs();\n\nΑλλάξτε την εμφάνιση των προεδρικών θητειών:\n\nΣυνδυάζοντας τις δύο παραλλαγές που προσαρμόζουν τα χρώματα και τα διαχωριστικά του άξονα x.\nΒελτιώνοντας την εμφάνισης του άξονα y.\nΕπισημαίνοντας κάθε θητεία με το όνομα του προέδρου.\nΠροσθέτοντας ενημερωτικές ετικέτες.\nΤοποθετώντας τα διαχωριστικά κάθε 4 χρόνια (αυτό είναι πιο δύσκολο από όσο φαίνεται!).\n\n\n\nΑρχικά, δημιουργήστε το ακόλουθο διάγραμμα. Στη συνέχεια, τροποποιήστε τον κώδικα χρησιμοποιώντας το όρισμα override.aes για να κάνετε το υπόμνημα πιο ευδιάκριτο.\n\nggplot(diamonds, aes(x = carat, y = price)) +\n  geom_point(aes(color = cut), alpha = 1/20)",
    "crumbs": [
      "Οπτικοποίηση",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Επικοινωνία</span>"
    ]
  },
  {
    "objectID": "communication.html#sec-themes",
    "href": "communication.html#sec-themes",
    "title": "11  Επικοινωνία",
    "section": "\n11.5 Θέματα",
    "text": "11.5 Θέματα\nΤέλος, μπορείτε να εξατομικεύσετε τα στοιχεία του διαγράμματος που δεν σχετίζονται με τα δεδομένα χρησιμοποιώντας ένα θέμα:\n\nggplot(mpg, aes(x = displ, y = hwy)) +\n  geom_point(aes(color = class)) +\n  geom_smooth(se = FALSE) +\n  theme_bw()\n\n\n\n\n\n\n\nΗ ggplot2 περιλαμβάνει τα οκτώ θέματα που εμφανίζονται στο Σχήμα 11.2, με το theme_gray() ως προεπιλογή.2 Πολλά άλλα περιλαμβάνονται σε πακέτα πρόσθετων όπως το ggthemes (https://jrnold.github.io/ggthemes), του Jeffrey Arnold. Μπορείτε επίσης να δημιουργήσετε τα δικά σας θέματα, εάν προσπαθείτε να ακολουθήσετε ένα συγκεκριμένο εταιρικό στυλ ή στυλ που συναντάται σε κάποιο επιστημονικό περιοδικό.\n\n\n\n\n\n\n\nΣχήμα 11.2: Οι οκτώ προεγκατεστημένες θεματικές επιλογές του πακέτου ggplot2.\n\n\n\n\nΕίναι επίσης δυνατός ο έλεγχος μεμονωμένων στοιχείων κάθε θέματος, όπως το μέγεθος και το χρώμα της γραμματοσειράς που χρησιμοποιείται για τον άξονα y. Έχουμε ήδη δει ότι το legend.position ελέγχει πού τοποθετείται το υπόμνημα. Υπάρχουν πολλές άλλες πτυχές του υπομνήματος που μπορούν να προσαρμοστούν με τη συνάρτηση theme(). Για παράδειγμα, στο παρακάτω διάγραμμα αλλάζουμε την κατεύθυνση του υπομνήματος, ενώ τοποθετούμε και ένα μαύρο περίγραμμα γύρω του. Σημειώστε ότι η προσαρμογή του πλαισίου υπομνήματος και των στοιχείων τίτλου πλοκής του θέματος γίνεται με τις συναρτήσεις element_*(). Αυτές οι συναρτήσεις καθορίζουν το στυλ των στοιχείων που είναι ανεξάρτητα των δεδομένων, για παράδειγμα το κείμενο του τίτλου είναι με έντονη γραφή στο όρισμα face της element_text() και το χρώμα του περιγράμματος του υπομνήματος ορίζεται στο όρισμα color της element_rect(). Τα στοιχεία του θέματος που ελέγχουν τη θέση του τίτλου και της λεζάντας είναι τα plot.title.position και plot.caption.position, αντίστοιχα. Στο ακόλουθο διάγραμμα, αυτά ορίζονται σε \"plot\" για να υποδείξουν ότι αυτά τα στοιχεία είναι ευθυγραμμισμένα σε ολόκληρη την περιοχή της γραφικής παράστασης, αντί με το πλαίσιο γραφικής παράστασης (η προεπιλογή). Μερικά άλλα χρήσιμα στοιχεία της theme() χρησιμοποιούνται για την αλλαγή της τοποθέτησης για τη μορφή του κειμένου του τίτλου και της λεζάντας.\n\nggplot(mpg, aes(x = displ, y = hwy, color = drv)) +\n  geom_point() +\n  labs(\n    title = \"Larger engine sizes tend to have lower fuel economy\",\n    caption = \"Source: https://fueleconomy.gov.\"\n  ) +\n  theme(\n    legend.position = c(0.6, 0.7),\n    legend.direction = \"horizontal\",\n    legend.box.background = element_rect(color = \"black\"),\n    plot.title = element_text(face = \"bold\"),\n    plot.title.position = \"plot\",\n    plot.caption.position = \"plot\",\n    plot.caption = element_text(hjust = 0)\n  )\n#&gt; Warning: A numeric `legend.position` argument in `theme()` was deprecated in ggplot2\n#&gt; 3.5.0.\n#&gt; ℹ Please use the `legend.position.inside` argument of `theme()` instead.\n\n\n\n\n\n\n\nΓια μία επισκόπηση όλων των στοιχείων της theme(), ανατρέξτε στη βοήθεια με το ?theme. Το σχετικό βιβλίο της ggplot2 είναι επίσης ένα εξαιρετικό μέρος που μπορείτε να επισκεφθείτε για τις πλήρεις λεπτομέρειες σχετικά με το θέμα.\n\n11.5.1 Ασκήσεις\n\nΕπιλέξτε ένα θέμα που προσφέρεται από το πακέτο ggthemes και εφαρμόστε το στο τελευταίο διάγραμμα που δημιουργήσατε.\nΚάντε τις ετικέτες των αξόνων του διαγράμματος σας μπλε και έντονες.",
    "crumbs": [
      "Οπτικοποίηση",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Επικοινωνία</span>"
    ]
  },
  {
    "objectID": "communication.html#διάταξη",
    "href": "communication.html#διάταξη",
    "title": "11  Επικοινωνία",
    "section": "\n11.6 Διάταξη",
    "text": "11.6 Διάταξη\nΜέχρι στιγμής μιλήσαμε για το πώς να δημιουργήσουμε και να τροποποιήσουμε ένα ενιαίο διάγραμμα Τι γίνεται αν έχετε πολλά διαγράμματα που θέλετε να διατάξετε με συγκεκριμένο τρόπο; Το πακέτο patchwork σας επιτρέπει να συνδυάσετε ξεχωριστά διαγράμματα στο ίδιο γραφικό. Φορτώσαμε αυτό το πακέτο νωρίτερα στο κεφάλαιο.\nΓια να τοποθετήσετε δύο διαγράμματα το ένα δίπλα στο άλλο, μπορείτε απλά να τα προσθέσετε το ένα στο άλλο. Σημειώστε ότι πρέπει πρώτα να δημιουργήσετε τις γραφικές παραστάσεις και να τις αποθηκεύσετε ως αντικείμενα (στο παρακάτω παράδειγμα ονομάζονται p1 και p2). Στη συνέχεια, τα τοποθετείτε το ένα δίπλα στο άλλο με το +.\n\np1 &lt;- ggplot(mpg, aes(x = displ, y = hwy)) + \n  geom_point() + \n  labs(title = \"Plot 1\")\np2 &lt;- ggplot(mpg, aes(x = drv, y = hwy)) + \n  geom_boxplot() + \n  labs(title = \"Plot 2\")\np1 + p2\n\n\n\n\n\n\n\nΕίναι σημαντικό να σημειωθεί ότι στο παραπάνω κομμάτι κώδικα δεν χρησιμοποιήσαμε κάποια νέα συνάρτηση από το πακέτο patchwork Αντίθετα, το πακέτο πρόσθεσε μία νέα λειτουργικότητα στον τελεστή +.\nΜπορείτε επίσης να δημιουργήσετε σύνθετες διατάξεις διαγραμμάτων με το patchwork. Παρακάτω, το | τοποθετεί το p1 και το p3 το ένα δίπλα στο άλλο και το / μετακινεί το p2 στην επόμενη γραμμή.\n\np3 &lt;- ggplot(mpg, aes(x = cty, y = hwy)) + \n  geom_point() + \n  labs(title = \"Plot 3\")\n(p1 | p3) / p2\n\n\n\n\n\n\n\nΕπιπλέον, το patchwork σας επιτρέπει να συλλέγετε υπομνήματα από πολλά διαγράμματα σε ένα κοινό υπόμνημα, να προσαρμόζετε την τοποθέτηση του υπομνήματος καθώς και τις διαστάσεις των διαγραμμάτων και να προσθέτετε έναν κοινό τίτλο, υπότιτλο, λεζάντα κ.λπ. στα διαγράμματα σας. Παρακάτω δημιουργούμε 5 διαγράμματα Απενεργοποιήσαμε τα υπομνήματα στα θηκογράμματα και στο διάγραμμα διασποράς και συλλέξαμε τα υπομνήματα για τα διαγράμματα πυκνότητας στην κορυφή του διαγράμματος με το & theme(legend.position = «κορυφή»). Παρατηρήστε ότι εδώ χρησιμοποιούμε τον τελεστή & αντί του συνηθισμένου +. Αυτό συμβαίνει επειδή τροποποιούμε το θέμα για το patchwork διάγραμμα σε αντίθεση με τα μεμονωμένα ggplots. Το υπόμνημα τοποθετείται στην κορυφή, μέσα στη guide_area(). Τέλος, έχουμε επίσης προσαρμόσει τα ύψη των διαφόρων εξαρτημάτων του patchwork μας – ο οδηγός έχει ύψος 1, τα θηκογράμματα ύψος 3, τα γραφήματα πυκνότητας 2 και το πολύπλευρο διάγραμμα διασποράς 4. Το patchwork διαιρεί την περιοχή που έχετε παραχωρήσει για το διάγραμμα σας χρησιμοποιώντας αυτήν την κλίμακα και τοποθετεί κάθε εξάρτημα ανάλογα.\n\np1 &lt;- ggplot(mpg, aes(x = drv, y = cty, color = drv)) + \n  geom_boxplot(show.legend = FALSE) + \n  labs(title = \"Plot 1\")\n\np2 &lt;- ggplot(mpg, aes(x = drv, y = hwy, color = drv)) + \n  geom_boxplot(show.legend = FALSE) + \n  labs(title = \"Plot 2\")\n\np3 &lt;- ggplot(mpg, aes(x = cty, color = drv, fill = drv)) + \n  geom_density(alpha = 0.5) + \n  labs(title = \"Plot 3\")\n\np4 &lt;- ggplot(mpg, aes(x = hwy, color = drv, fill = drv)) + \n  geom_density(alpha = 0.5) + \n  labs(title = \"Plot 4\")\n\np5 &lt;- ggplot(mpg, aes(x = cty, y = hwy, color = drv)) + \n  geom_point(show.legend = FALSE) + \n  facet_wrap(~drv) +\n  labs(title = \"Plot 5\")\n\n(guide_area() / (p1 + p2) / (p3 + p4) / p5) +\n  plot_annotation(\n    title = \"City and highway mileage for cars with different drive trains\",\n    caption = \"Source: https://fueleconomy.gov.\"\n  ) +\n  plot_layout(\n    guides = \"collect\",\n    heights = c(1, 3, 2, 4)\n    ) &\n  theme(legend.position = \"top\")\n\n\n\n\n\n\n\nΕάν θέλετε να μάθετε περισσότερα σχετικά με το συνδυασμό και τη διάταξη πολλαπλών γραφικών με το patchwork, συνιστούμε να ανατρέξετε στους οδηγούς στον ιστότοπο του πακέτου: https://patchwork.data-imaginist.com.\n\n11.6.1 Ασκήσεις\n\n\nΤι θα συμβεί αν παραλείψετε τις παρενθέσεις στην παρακάτω διάταξη διαγράμματος. Μπορείτε να εξηγήσετε γιατί συμβαίνει αυτό;\n\np1 &lt;- ggplot(mpg, aes(x = displ, y = hwy)) + \n  geom_point() + \n  labs(title = \"Plot 1\")\np2 &lt;- ggplot(mpg, aes(x = drv, y = hwy)) + \n  geom_boxplot() + \n  labs(title = \"Plot 2\")\np3 &lt;- ggplot(mpg, aes(x = cty, y = hwy)) + \n  geom_point() + \n  labs(title = \"Plot 3\")\n\n(p1 | p2) / p3\n\n\n\nΧρησιμοποιώντας τα τρία διαγράμματα από την προηγούμενη άσκηση, δημιουργήστε ξανά το παρακάτω συνονθύλευμα (patchwork).",
    "crumbs": [
      "Οπτικοποίηση",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Επικοινωνία</span>"
    ]
  },
  {
    "objectID": "communication.html#σύνοψη",
    "href": "communication.html#σύνοψη",
    "title": "11  Επικοινωνία",
    "section": "\n11.7 Σύνοψη",
    "text": "11.7 Σύνοψη\nΣε αυτό το κεφάλαιο μάθατε για την προσθήκη ετικετών στα διαγράμματα, όπως για παράδειγμα τίτλο, υπότιτλο, λεζάντα, καθώς και την τροποποίηση προεπιλεγμένων ετικετών αξόνων, τη χρήση σχολιασμού για την προσθήκη ενημερωτικού κειμένου στο διάγραμμα σας ή την επισήμανση συγκεκριμένων σημείων δεδομένων, την προσαρμογή των κλιμάκων του άξονα και την αλλαγή του θέματος της πλοκής σας. Έχετε μάθει επίσης πώς να συνδυάζετε πολλαπλά διαγράμματα σε ένα μόνο γράφημα χρησιμοποιώντας απλές και σύνθετες διατάξεις γραφικών παραστάσεων.\nΕνώ μέχρι στιγμής έχετε μάθει πώς να δημιουργείτε πολλούς διαφορετικούς τύπους διαγραμμάτων και πώς να τα προσαρμόζετε χρησιμοποιώντας μία ποικιλία τεχνικών, μόλις έχουμε γρατσουνίσει την επιφάνεια του τι μπορείτε να δημιουργήσετε με το πακέτο ggplot2. Εάν θέλετε να κατανοήσετε πλήρως το ggplot2, συνιστούμε να διαβάσετε το βιβλίο, ggplot2: Elegant Graphics for Data Analysis. Άλλες χρήσιμες πηγές είναι το R Graphics Cookbook του Winston Chang και το Fundamentals of Data Visualization του Claus Wilke .",
    "crumbs": [
      "Οπτικοποίηση",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Επικοινωνία</span>"
    ]
  },
  {
    "objectID": "communication.html#footnotes",
    "href": "communication.html#footnotes",
    "title": "11  Επικοινωνία",
    "section": "",
    "text": "Μπορείτε να χρησιμοποιήσετε ένα εργαλείο όπως το SimDaltonism για να προσομοιώσετε την αχρωματοψία και να το δοκιμάσετε σε αυτές τις εικόνες.↩︎\nΠολλοί αναρωτιούνται γιατί το προεπιλεγμένο θέμα έχει γκρι φόντο. Αυτή ήταν μία σκόπιμη επιλογή γιατί προβάλλει τα δεδομένα ενώ παράλληλα κάνει ορατές τις γραμμές πλέγματος. Οι λευκές γραμμές πλέγματος είναι ορατές (κάτι που είναι σημαντικό γιατί βοηθούν σημαντικά να διακρίνουμε τη θέση), αλλά έχουν μικρό οπτικό αντίκτυπο και μπορούμε εύκολα να τις εξαφανίσουμε. Το γκρι φόντο δίνει στην πλοκή παρόμοιο τυπογραφικό χρώμα με το κείμενο, διασφαλίζοντας ότι τα γραφικά ταιριάζουν με τη ροή ενός εγγράφου χωρίς να ξεχωρίζουν έντονα με φωτεινό λευκό φόντο. Τέλος, το γκρι φόντο δημιουργεί ένα συνεχές χρωματικό πεδίο που διασφαλίζει ότι το διάγραμμα γίνεται αντιληπτό ως μία ενιαία οπτική οντότητα.↩︎",
    "crumbs": [
      "Οπτικοποίηση",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Επικοινωνία</span>"
    ]
  },
  {
    "objectID": "transform.html",
    "href": "transform.html",
    "title": "Μετασχηματισμοί",
    "section": "",
    "text": "Το δεύτερο μέρος του βιβλίου ήταν μία εις βάθος διερεύνηση της οπτικοποίησης δεδομένων. Σε αυτό το μέρος του βιβλίου, θα μάθετε για τους πιο σημαντικούς τύπους μεταβλητών που θα συναντήσετε μέσα σε ένα πλαίσιο δεδομένων και θα μάθετε τα εργαλεία που μπορείτε να χρησιμοποιήσετε για να εργαστείτε μαζί τους.\n\n\n\n\n\n\n\nΣχήμα 1: Οι επιλογές για τον μετασχηματισμό δεδομένων εξαρτώνται σε μεγάλο βαθμό από τον τύπο των αντίστοιχων δεδομένων, που είναι και το θέμα αυτού του μέρους του βιβλίου.\n\n\n\n\nΜπορείτε να διαβάσετε αυτά τα κεφάλαια με όποια σειρά επιθυμείτε. Έχουν σχεδιαστεί για να είναι, σε μεγάλο βαθμό, αυτόνομα, ώστε να μπορούν να διαβαστούν μεμονωμένα.\n\nΤο 12  Λογικά διανύσματα σας διδάσκει για τα λογικά διανύσματα. Είναι οι απλούστεροι τύποι διανυσμάτων, είναι όμως εξαιρετικά ισχυροί. Θα μάθετε πώς να τα δημιουργείτε με αριθμητικές συγκρίσεις, πώς να τα συνδυάζετε με άλγεβρα Boole, πώς να τα χρησιμοποιείτε σε συνόψεις και πώς να τα χρησιμοποιείτε για μετασχηματισμούς συνθηκών.\nΤο 13  Αριθμητικά διανύσματα εμβαθύνει σε εργαλεία για διανύσματα αριθμών, το επίκεντρο της επιστήμης δεδομένων. Θα μάθετε περισσότερα για τη καταμέτρηση και για έναν αριθμό σημαντικών συναρτήσεων μετασχηματισμού και σύνοψης.\nΤο 14  Συμβολοσειρές θα σας δώσει τα εργαλεία για να δουλέψετε με συμβολοσειρές: θα τις διαμελίσετε με κάθε πιθανό τρόπο και θα τις ενώσετε ξανά. Αυτό το κεφάλαιο εστιάζει ως επί το πλείστον στο πακέτο stringr, αλλά θα μάθετε επίσης μερικές συναρτήσεις του πακέτου tidyr, προσανατολισμένες στην εξαγωγή δεδομένων από συμβολοσειρές χαρακτήρων.\nΤο 15  Λογικές εκφράσεις θα σας συστήσει στις κανονικές εκφράσεις, ένα ισχυρό εργαλείο για το χειρισμό συμβολοσειρών. Αυτό το κεφάλαιο θα σας μεταφέρει από τη ιδέα ότι μία γάτα πέρασε πάνω από το πληκτρολόγιό σας στο να μπορείτε να διαβάσετε και να γράψετε περίπλοκα μοτίβα συμβολοσειρών.\nΤο 16  Παράγοντες παρουσιάζει τους παράγοντες: τον τύπο δεδομένων που χρησιμοποιεί η R για την αποθήκευση κατηγορικών δεδομένων. Χρησιμοποιείτε έναν παράγοντα όταν η μεταβλητή έχει ένα σταθερό σύνολο πιθανών τιμών ή όταν θέλετε να χρησιμοποιήσετε μία μη αλφαβητική διάταξη μιας συμβολοσειράς.\nΤο 17  Ημερομηνίες και ώρες θα σας δώσει τα βασικά εργαλεία για την δουλεύετε με ημερομηνίες. Δυστυχώς, όσο περισσότερα μαθαίνετε για τις ημερομηνίες, τόσο πιο περίπλοκες φαίνονται να γίνονται, αλλά με τη βοήθεια του πακέτου lubridate, θα μάθετε πώς να ξεπερνάτε τις πιο συνηθισμένες προκλήσεις.\nΤο 18  Κενές τιμές συζητά σε βάθος τις κενές τιμές. Τις έχουμε συζητήσει μερικές φορές μεμονωμένα, αλλά τώρα ήρθε η ώρα να τις συζητήσουμε καθολικά, βοηθώντας σας να καταλάβετε τη διαφορά μεταξύ έμμεσων και ξεκάθαρων κενών τιμών όσο ακόμα και το πώς και το γιατί μπορείτε να κάνετε μετατροπές μεταξύ των δύο.\nΤο 19  Ενώσεις ολοκληρώνει αυτό το μέρος του βιβλίου παρέχοντάς σας εργαλεία για να ενώσετε δύο (ή περισσότερα) πλαίσια δεδομένων μαζί. Η εκμάθηση σχετικά με τις ενώσεις θα σας αναγκάσει να αντιμετωπίσετε την ιδέα των κλειδιών και να σκεφτείτε πώς προσδιορίζετε κάθε γραμμή σε ένα σύνολο δεδομένων.",
    "crumbs": [
      "Μετασχηματισμοί"
    ]
  },
  {
    "objectID": "logicals.html",
    "href": "logicals.html",
    "title": "12  Λογικά διανύσματα",
    "section": "",
    "text": "12.1 Εισαγωγή\nΣε αυτό το κεφάλαιο, θα μάθετε για εργαλεία που θα σας βοηθήσουν να δουλεύετε με λογικά διανύσματα. Τα λογικά διανύσματα είναι ο πιο απλός τύπος διανύσματος, επειδή κάθε στοιχείο μπορεί να είναι μόνο μία από τις τρεις πιθανές τιμές: TRUE, FALSE και NA. Είναι σχετικά σπάνιο να βρείτε λογικά διανύσματα στα ανεπεξέργαστα δεδομένα σας, αλλά θα τα δημιουργείτε και θα τα χειρίζεστε κατά τη διάρκεια σχεδόν κάθε ανάλυσης.\nΘα ξεκινήσουμε συζητώντας τον πιο συνηθισμένο τρόπο δημιουργίας λογικών διανυσμάτων: τις αριθμητικές συγκρίσεις. Στη συνέχεια, θα μάθετε πώς μπορείτε να χρησιμοποιήσετε την άλγεβρα Boole για να συνδυάσετε διαφορετικά λογικά διανύσματα, καθώς και μερικές χρήσιμες συνόψεις. Θα ολοκληρώσουμε με τις if_else() και case_when(), δύο χρήσιμες συναρτήσεις για την υπο όρους πραγματοποίηση αλλαγών μέσα από λογικά διανύσματα.",
    "crumbs": [
      "Μετασχηματισμοί",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Λογικά διανύσματα</span>"
    ]
  },
  {
    "objectID": "logicals.html#εισαγωγή",
    "href": "logicals.html#εισαγωγή",
    "title": "12  Λογικά διανύσματα",
    "section": "",
    "text": "12.1.1 Προαπαιτούμενα\nΟι περισσότερες από τις λειτουργίες για τις οποίες θα μάθετε σε αυτό το κεφάλαιο παρέχονται από το βασικό πακέτο λειτουργιών της R, επομένως το tidyverse δεν χρειάζεται, αλλά θα το φορτώσουμε για να μπορούμε να χρησιμοποιήσουμε την mutate(), την filter(), και άλλες παρόμοιες συναρτήσεις σε πλαίσια δεδομένων. Θα συνεχίσουμε επίσης να αντλούμε παραδείγματα από το σύνολο δεδομένων nycflights13::flights.\n\nlibrary(tidyverse)\nlibrary(nycflights13)\n\nΩστόσο, καθώς αρχίζουμε να καλύπτουμε περισσότερα εργαλεία, δεν θα υπάρχει πάντα κάποιο αντίστοιχο τέλειο πραγματικό παράδειγμα. Θα αρχίσουμε λοιπόν φτιάχνοντας μερικά συνθετικά δεδομένα με την c():\n\nx &lt;- c(1, 2, 3, 5, 7, 11, 13)\nx * 2\n#&gt; [1]  2  4  6 10 14 22 26\n\nΑυτό διευκολύνει την εξήγηση μεμονωμένων συναρτήσεων με το μειονέκτημα ότι είναι πιο δύσκολο να δούμε πώς αυτή μπορεί να εφαρμοστεί για τα προβλήματα των δεδομένων σας. Να θυμάστε ότι κάθε χειρισμό που εφαρμόζουμε σε ένα διάνυσμα, μπορείτε να τον εφαρμόσετε και σε μία μεταβλητή μέσα σε ένα πλαίσιο δεδομένων με την mutate() και άλλες παρόμοιες συναρτήσεις.\n\ndf &lt;- tibble(x)\ndf |&gt; \n  mutate(y = x * 2)\n#&gt; # A tibble: 7 × 2\n#&gt;       x     y\n#&gt;   &lt;dbl&gt; &lt;dbl&gt;\n#&gt; 1     1     2\n#&gt; 2     2     4\n#&gt; 3     3     6\n#&gt; 4     5    10\n#&gt; 5     7    14\n#&gt; 6    11    22\n#&gt; # ℹ 1 more row",
    "crumbs": [
      "Μετασχηματισμοί",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Λογικά διανύσματα</span>"
    ]
  },
  {
    "objectID": "logicals.html#συγκρίσεις",
    "href": "logicals.html#συγκρίσεις",
    "title": "12  Λογικά διανύσματα",
    "section": "\n12.2 Συγκρίσεις",
    "text": "12.2 Συγκρίσεις\nΈνας αρκετά συνηθισμένος τρόπος για να δημιουργήσετε ένα λογικό διάνυσμα είναι μέσω μιας αριθμητικής σύγκρισης με τους τελεστές &lt;, &lt;=, &gt;, &gt;=, != και ==. Μέχρι στιγμής, έχουμε δημιουργήσει ως επί το πλείστον λογικές μεταβλητές μέσα στην filter() — υπολογίζονται, χρησιμοποιούνται και στη συνέχεια αγνοούνται. Για παράδειγμα, η ακόλουθη filter βρίσκει όλες τις ημερήσιες αναχωρήσεις που φτάνουν περίπου στην ώρα τους:\n\nflights |&gt; \n  filter(dep_time &gt; 600 & dep_time &lt; 2000 & abs(arr_delay) &lt; 20)\n#&gt; # A tibble: 172,286 × 19\n#&gt;    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n#&gt;   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;\n#&gt; 1  2013     1     1      601            600         1      844            850\n#&gt; 2  2013     1     1      602            610        -8      812            820\n#&gt; 3  2013     1     1      602            605        -3      821            805\n#&gt; 4  2013     1     1      606            610        -4      858            910\n#&gt; 5  2013     1     1      606            610        -4      837            845\n#&gt; 6  2013     1     1      607            607         0      858            915\n#&gt; # ℹ 172,280 more rows\n#&gt; # ℹ 11 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;, …\n\nΕίναι χρήσιμο να γνωρίζετε ότι αυτό είναι μία συντόμευση και ότι μπορείτε να δημιουργήσετε ξεχωριστά τις υποκείμενες λογικές μεταβλητές με την mutate():\n\nflights |&gt; \n  mutate(\n    daytime = dep_time &gt; 600 & dep_time &lt; 2000,\n    approx_ontime = abs(arr_delay) &lt; 20,\n    .keep = \"used\"\n  )\n#&gt; # A tibble: 336,776 × 4\n#&gt;   dep_time arr_delay daytime approx_ontime\n#&gt;      &lt;int&gt;     &lt;dbl&gt; &lt;lgl&gt;   &lt;lgl&gt;        \n#&gt; 1      517        11 FALSE   TRUE         \n#&gt; 2      533        20 FALSE   FALSE        \n#&gt; 3      542        33 FALSE   FALSE        \n#&gt; 4      544       -18 FALSE   TRUE         \n#&gt; 5      554       -25 FALSE   FALSE        \n#&gt; 6      554        12 FALSE   TRUE         \n#&gt; # ℹ 336,770 more rows\n\nΑυτό είναι ιδιαίτερα χρήσιμο στην περίπτωση μιας πιο περίπλοκης λογικής, καθώς δίνοντας ονόματα στα ενδιάμεσα βήματα διευκολύνεται τόσο η ανάγνωση του κώδικά σας όσο και ο έλεγχος ότι κάθε βήμα έχει υπολογιστεί σωστά.\nΕν τέλει, η αρχική filter είναι ισοδύναμη με:\n\nflights |&gt; \n  mutate(\n    daytime = dep_time &gt; 600 & dep_time &lt; 2000,\n    approx_ontime = abs(arr_delay) &lt; 20,\n  ) |&gt; \n  filter(daytime & approx_ontime)\n\n\n12.2.1 Σύγκριση κινητής υποδιαστολής\nΔώστε προσοχή στη χρήση του == με αριθμούς. Για παράδειγμα, φαίνεται ότι αυτό το διάνυσμα περιέχει τους αριθμούς 1 και 2:\n\nx &lt;- c(1 / 49 * 49, sqrt(2) ^ 2)\nx\n#&gt; [1] 1 2\n\nΕάν όμως τα ελέγξετε για την ισότητά τους, θα πάρετε FALSE\n\nx == c(1, 2)\n#&gt; [1] FALSE FALSE\n\nΤι συμβαίνει;\nΟι υπολογιστές αποθηκεύουν αριθμούς με σταθερό αριθμό δεκαδικών ψηφίων, επομένως δεν υπάρχει τρόπος να αντιπροσωπεύσετε ακριβώς το 1/49 ή το sqrt(2) και οι επόμενοι υπολογισμοί θα είναι ελαφρώς ανόμοιοι. Μπορούμε να δούμε τις ακριβείς τιμές καλώντας την print() με το όρισμα digits1:\n\nprint(x, digits = 16)\n#&gt; [1] 0.9999999999999999 2.0000000000000004\n\nΜπορείτε να δείτε γιατί η R στρογγυλοποιεί από προεπιλογή αυτούς τους αριθμούς. Είναι πραγματικά πολύ κοντά σε αυτό που περιμένετε.\nΤώρα που καταλάβατε γιατί το == αποτυγχάνει, τι μπορείτε να κάνετε για αυτό;\nΜία επιλογή είναι να χρησιμοποιήσετε την dplyr::near() που αγνοεί μικρές διαφορές:\n\nnear(x, c(1, 2))\n#&gt; [1] TRUE TRUE\n\n\n12.2.2 Κενές τιμές\nΟι κενές τιμές αντιπροσωπεύουν το άγνωστο, επομένως είναι “μεταδοτικές”: σχεδόν οποιαδήποτε λειτουργία που περιλαμβάνει μία άγνωστη τιμή θα είναι επίσης άγνωστη:\n\nNA &gt; 5\n#&gt; [1] NA\n10 == NA\n#&gt; [1] NA\n\nΤο αποτέλεσμα που προκαλεί περισσότερη σύγχυση είναι αυτό:\n\nNA == NA\n#&gt; [1] NA\n\nΕίναι πιο εύκολο να καταλάβουμε γιατί ισχύει αυτό, εάν δώσουμε λίγες περισσότερες πληροφορίες:\n\n# Δεν ξέρουμε την ηλικία της Mary\nage_mary &lt;- NA\n\n# Δεν ξέρουμε την ηλικία του John\nage_john &lt;- NA\n\n# Έχουν την ίδια ηλικία η Mary και ο John;\nage_mary == age_john\n#&gt; [1] NA\n# Δεν ξέρουμε!\n\nΕπομένως, εάν θέλετε να βρείτε όλες τις πτήσεις όπου η dep_time έχει κενές τιμές, ο ακόλουθος κώδικας δεν λειτουργεί επειδή το dep_time == NA θα δώσει NA για κάθε γραμμή και μετά η filter() θα αφαιρέσει αυτόματα τις κενές τιμές:\n\nflights |&gt; \n  filter(dep_time == NA)\n#&gt; # A tibble: 0 × 19\n#&gt; # ℹ 19 variables: year &lt;int&gt;, month &lt;int&gt;, day &lt;int&gt;, dep_time &lt;int&gt;,\n#&gt; #   sched_dep_time &lt;int&gt;, dep_delay &lt;dbl&gt;, arr_time &lt;int&gt;, …\n\nAντ’ αυτού, θα χρειαστούμε ένα νέο εργαλείο: την is.na().\n\n12.2.3 is.na()\n\nH is.na(x) λειτουργεί με οποιονδήποτε τύπο διανύσματος και επιστρέφει TRUE για τιμές που λείπουν και FALSE για οτιδήποτε άλλο:\n\nis.na(c(TRUE, NA, FALSE))\n#&gt; [1] FALSE  TRUE FALSE\nis.na(c(1, NA, 3))\n#&gt; [1] FALSE  TRUE FALSE\nis.na(c(\"a\", NA, \"b\"))\n#&gt; [1] FALSE  TRUE FALSE\n\nΜπορούμε να χρησιμοποιήσουμε την is.na() για να βρούμε όλες τις γραμμές με κενές τιμές στη dep_time:\n\nflights |&gt; \n  filter(is.na(dep_time))\n#&gt; # A tibble: 8,255 × 19\n#&gt;    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n#&gt;   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;\n#&gt; 1  2013     1     1       NA           1630        NA       NA           1815\n#&gt; 2  2013     1     1       NA           1935        NA       NA           2240\n#&gt; 3  2013     1     1       NA           1500        NA       NA           1825\n#&gt; 4  2013     1     1       NA            600        NA       NA            901\n#&gt; 5  2013     1     2       NA           1540        NA       NA           1747\n#&gt; 6  2013     1     2       NA           1620        NA       NA           1746\n#&gt; # ℹ 8,249 more rows\n#&gt; # ℹ 11 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;, …\n\nΗ is.na() μπορεί επίσης να είναι χρήσιμη στην arrange(). Η arrange() συνήθως βάζει όλες τις κενές τιμές στο τέλος, μπορείτε όμως να παρακάμψετε αυτήν την προεπιλογή ταξινομώντας πρώτα κατά is.na():\n\nflights |&gt; \n  filter(month == 1, day == 1) |&gt; \n  arrange(dep_time)\n#&gt; # A tibble: 842 × 19\n#&gt;    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n#&gt;   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;\n#&gt; 1  2013     1     1      517            515         2      830            819\n#&gt; 2  2013     1     1      533            529         4      850            830\n#&gt; 3  2013     1     1      542            540         2      923            850\n#&gt; 4  2013     1     1      544            545        -1     1004           1022\n#&gt; 5  2013     1     1      554            600        -6      812            837\n#&gt; 6  2013     1     1      554            558        -4      740            728\n#&gt; # ℹ 836 more rows\n#&gt; # ℹ 11 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;, …\n\nflights |&gt; \n  filter(month == 1, day == 1) |&gt; \n  arrange(desc(is.na(dep_time)), dep_time)\n#&gt; # A tibble: 842 × 19\n#&gt;    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n#&gt;   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;\n#&gt; 1  2013     1     1       NA           1630        NA       NA           1815\n#&gt; 2  2013     1     1       NA           1935        NA       NA           2240\n#&gt; 3  2013     1     1       NA           1500        NA       NA           1825\n#&gt; 4  2013     1     1       NA            600        NA       NA            901\n#&gt; 5  2013     1     1      517            515         2      830            819\n#&gt; 6  2013     1     1      533            529         4      850            830\n#&gt; # ℹ 836 more rows\n#&gt; # ℹ 11 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;, …\n\nΘα επανέλθουμε για να καλύψουμε τις κενές τιμές σε μεγαλύτερο βάθος στο Κεφάλαιο 18.\n\n12.2.4 Ασκήσεις\n\nΠώς λειτουργεί η dplyr::near(); Πληκτρολογήστε near για να δείτε τον πηγαίο κώδικα. Είναι το αποτέλεσμα της sqrt(2)^2 κοντά στο 2;\nΧρησιμοποιήστε τις mutate(), is.na() και count() μαζί για να περιγράψετε πώς συνδέονται οι κενές τιμές στις dep_time, sched_dep_time και dep_delay.",
    "crumbs": [
      "Μετασχηματισμοί",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Λογικά διανύσματα</span>"
    ]
  },
  {
    "objectID": "logicals.html#άλγεβρα-boole",
    "href": "logicals.html#άλγεβρα-boole",
    "title": "12  Λογικά διανύσματα",
    "section": "\n12.3 Άλγεβρα Boole",
    "text": "12.3 Άλγεβρα Boole\nΑφού έχετε πολλαπλά λογικά διανύσματα, μπορείτε να τα συνδυάσετε χρησιμοποιώντας άλγεβρα Boole. Στην R, το & είναι “και”, το | είναι “είτε”, το “!” είναι “όχι” και το xor() είναι αποκλειστική διάζευξη2. Για παράδειγμα, το df |&gt; filter(!is.na(x)) βρίσκει όλες τις γραμμές όπου το x δεν είναι κενό και το df |&gt; filter(x &lt; -10 | x &gt; 0) βρίσκει όλες τις γραμμές όπου το x είναι μικρότερο από -10 ή μεγαλύτερο από 0. Το Σχήμα 12.1 δείχνει το πλήρες σύνολο των λογικών πράξεων και τον τρόπο λειτουργίας τους.\n\n\n\n\n\n\n\nΣχήμα 12.1: Το πλήρες σύνολο των πράξεων Boole. Σε κάθε περίπτωση, το x είναι ο κύκλος στα αριστερά, το y είναι ο κύλος στα δεξιά, και η χρωματισμένη περιοχή δίχνει τα σημεία που επιλέγοντε απο κάθε τελεστή.\n\n\n\n\nΕκτός από τα & και |, η R έχει επίσης τα && και ||. Μην τα χρησιμοποιείτε σε συναρτήσεις της dplyr! Ονομάζονται υπο συνθήκη τελεστές και επιστρέφουν μόνο ένα TRUE ή FALSE. Είναι σημαντικά για τον προγραμματισμό, όχι για την επιστήμη των δεδομένων.\n\n12.3.1 Κενές τιμές\nΟι κανόνες για τις κενές τιμές στην άλγεβρα Boole είναι λίγο δύσκολο να εξηγηθούν επειδή φαίνονται αντιφατικοί με μία πρώτη ματιά:\n\ndf &lt;- tibble(x = c(TRUE, FALSE, NA))\n\ndf |&gt; \n  mutate(\n    and = x & NA,\n    or = x | NA\n  )\n#&gt; # A tibble: 3 × 3\n#&gt;   x     and   or   \n#&gt;   &lt;lgl&gt; &lt;lgl&gt; &lt;lgl&gt;\n#&gt; 1 TRUE  NA    TRUE \n#&gt; 2 FALSE FALSE NA   \n#&gt; 3 NA    NA    NA\n\nΓια να καταλάβετε τι συμβαίνει, σκεφτείτε το NA | TRUE (NA είτε TRUE). Μία κενή τιμή σε ένα λογικό διάνυσμα σημαίνει ότι η τιμή μπορεί να είναι TRUE ή FALSE. Τα TRUE | TRUE και FALSE | TRUE είναι και τα δύο TRUE, επειδή τουλάχιστον ένα από αυτά είναι TRUE. Το NA | TRUE πρέπει επίσης να είναι TRUE επειδή το NA μπορεί να είναι είτε TRUE είτε FALSE. Ωστόσο, το NA | FALSE είναι NA, επειδή δεν γνωρίζουμε αν το NA είναι TRUE ή FALSE. Παρόμοια λογική ισχύει και για το NA & FALSE.\n\n12.3.2 Σειρά πράξεων\nΣημειώστε ότι η σειρά των πράξεων δεν λειτουργεί όπως στα ελληνικά. Δείτε τον παρακάτω κώδικα που βρίσκει όλες τις πτήσεις που αναχώρησαν τον Νοέμβριο ή τον Δεκέμβριο:\n\nflights |&gt; \n   filter(month == 11 | month == 12)\n\nΜπορεί να μπείτε στον πειρασμό να το γράψετε όπως θα λέγατε στα Ελληνικά: “Βρές όλες τις πτήσεις που αναχώρησαν τον Νοέμβριο ή τον Δεκέμβριο.”:\n\nflights |&gt; \n   filter(month == 11 | 12)\n#&gt; # A tibble: 336,776 × 19\n#&gt;    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n#&gt;   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;\n#&gt; 1  2013     1     1      517            515         2      830            819\n#&gt; 2  2013     1     1      533            529         4      850            830\n#&gt; 3  2013     1     1      542            540         2      923            850\n#&gt; 4  2013     1     1      544            545        -1     1004           1022\n#&gt; 5  2013     1     1      554            600        -6      812            837\n#&gt; 6  2013     1     1      554            558        -4      740            728\n#&gt; # ℹ 336,770 more rows\n#&gt; # ℹ 11 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;, …\n\nΑυτός ο κώδικας δεν βγάζει κάποιο σφάλμα, αλλά επίσης δεν φαίνεται και να έχει δουλέψει. Τι συμβαίνει;\nΕδώ, η R αξιολογεί πρώτα το month == 11 δημιουργώντας ένα λογικό διάνυσμα, το οποίο ονομάζουμε nov. Υπολογίζει, άρα, το nov | 12. Όταν χρησιμοποιείτε έναν αριθμό με έναν λογικό τελεστή, τα πάντα εκτός από το 0 μετατρέπονται σε TRUE, οπότε αυτό ισοδυναμεί με nov | TRUE που θα είναι πάντα TRUE, επομένως θα επιλεγούν όλες οι γραμμές:\n\nflights |&gt; \n  mutate(\n    nov = month == 11,\n    final = nov | 12,\n    .keep = \"used\"\n  )\n#&gt; # A tibble: 336,776 × 3\n#&gt;   month nov   final\n#&gt;   &lt;int&gt; &lt;lgl&gt; &lt;lgl&gt;\n#&gt; 1     1 FALSE TRUE \n#&gt; 2     1 FALSE TRUE \n#&gt; 3     1 FALSE TRUE \n#&gt; 4     1 FALSE TRUE \n#&gt; 5     1 FALSE TRUE \n#&gt; 6     1 FALSE TRUE \n#&gt; # ℹ 336,770 more rows\n\n\n12.3.3 %in%\n\nΈνας εύκολος τρόπος για να αποφύγετε το πρόβλημα του να βάλετε στη σωστή σειρά τα == και | είναι να χρησιμοποιήσετε το %in%. Το x %in% y επιστρέφει ένα λογικό διάνυσμα ίδιου μήκους με το x που είναι TRUE κάθε φορά που μία τιμή στο x βρίσκεται οπουδήποτε στο y.\n\n1:12 %in% c(1, 5, 11)\n#&gt;  [1]  TRUE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE FALSE FALSE  TRUE FALSE\nletters[1:10] %in% c(\"a\", \"e\", \"i\", \"o\", \"u\")\n#&gt;  [1]  TRUE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE  TRUE FALSE\n\nΓια να βρούμε λοιπόν όλες τις πτήσεις τον Νοέμβριο και τον Δεκέμβριο θα μπορούσαμε να γράψουμε:\n\nflights |&gt; \n  filter(month %in% c(11, 12))\n\nΣημειώστε ότι το %in% υπακούει σε διαφορετικούς κανόνες απο αυτούς του == για τα NA, καθώς το NA %in% NA είναι TRUE.\n\nc(1, 2, NA) == NA\n#&gt; [1] NA NA NA\nc(1, 2, NA) %in% NA\n#&gt; [1] FALSE FALSE  TRUE\n\nΤο παραπάνω δημιουργεί μία χρήσιμη συντόμευση:\n\nflights |&gt; \n  filter(dep_time %in% c(NA, 0800))\n#&gt; # A tibble: 8,803 × 19\n#&gt;    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n#&gt;   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;\n#&gt; 1  2013     1     1      800            800         0     1022           1014\n#&gt; 2  2013     1     1      800            810       -10      949            955\n#&gt; 3  2013     1     1       NA           1630        NA       NA           1815\n#&gt; 4  2013     1     1       NA           1935        NA       NA           2240\n#&gt; 5  2013     1     1       NA           1500        NA       NA           1825\n#&gt; 6  2013     1     1       NA            600        NA       NA            901\n#&gt; # ℹ 8,797 more rows\n#&gt; # ℹ 11 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;, …\n\n\n12.3.4 Ασκήσεις\n\nΒρείτε όλες τις πτήσεις στις οποίες υπάρχουν κενές τιμές στην στήλη arr_delay αλλά όχι στην dep_delay. Βρείτε όλες τις πτήσεις στις οποίες δεν λείπουν τιμές ούτε στην arr_time, ούτε στην sched_arr_time, αλλά λείπουν στην arr_delay.\nΠόσες πτήσεις έχουν κενές τιμές στη στήλη dep_time; Ποιες άλλες μεταβλητές έχουν κενές τιμές σε αυτές τις γραμμές; Τι μπορεί να αντιπροσωπεύουν αυτές οι γραμμές;\nΑν υποθέσουμε ότι μία κενή τιμή στην στήλη dep_time σημαίνει ότι μία πτήση έχει ακυρωθεί, δείτε τον αριθμό των ακυρωμένων πτήσεων ανά ημέρα. Υπάρχει κάποιο μοτίβο; Υπάρχει σχέση μεταξύ του ποσοστού των ακυρωμένων πτήσεων και της μέσης καθυστέρησης των μη ακυρωμένων πτήσεων;",
    "crumbs": [
      "Μετασχηματισμοί",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Λογικά διανύσματα</span>"
    ]
  },
  {
    "objectID": "logicals.html#sec-logical-summaries",
    "href": "logicals.html#sec-logical-summaries",
    "title": "12  Λογικά διανύσματα",
    "section": "\n12.4 Συνόψεις",
    "text": "12.4 Συνόψεις\nΟι ακόλουθες ενότητες περιγράφουν μερικές χρήσιμες τεχνικές για τη σύνοψη λογικών διανυσμάτων. Εκτός από συναρτήσεις που λειτουργούν ειδικά μόνο με λογικά διανύσματα, μπορείτε επίσης να χρησιμοποιήσετε συναρτήσεις που λειτουργούν με αριθμητικά διανύσματα.\n\n12.4.1 Λογικές συνόψεις\nΥπάρχουν δύο κύριες συναρτήσεις λογικών συνόψεων: η any() και η all(). Η any(x) είναι το ισοδύναμη του | και θα επιστρέψει TRUE εάν υπάρχουν τιμές TRUE στο x. Η all(x) ισοδυναμεί με το & και θα επιστρέψει TRUE μόνο εάν όλες οι τιμές του x είναι TRUE. Όπως και όλες οι συναρτήσεις σύνοψης, έτσι και αυτές θα επιστρέψουν NA εάν υπάρχουν κενές τιμές και, ως συνήθως, μπορείτε να τις αγνοήσετε με το na.rm = TRUE.\nΓια παράδειγμα, θα μπορούσαμε να χρησιμοποιήσουμε την all() και την any() για να μάθουμε εάν κάθε πτήση καθυστέρησε κατά την αναχώρηση κατά μία ώρα το πολύ, ή εάν κάποια πτήση είχε καθυστέρηση κατά την άφιξη κατά πέντε ώρες ή περισσότερο. Η χρήση της group_by() μας επιτρέπει να το κάνουμε αυτό και ανά ημέρα:\n\nflights |&gt; \n  group_by(year, month, day) |&gt; \n  summarize(\n    all_delayed = all(dep_delay &lt;= 60, na.rm = TRUE),\n    any_long_delay = any(arr_delay &gt;= 300, na.rm = TRUE),\n    .groups = \"drop\"\n  )\n#&gt; # A tibble: 365 × 5\n#&gt;    year month   day all_delayed any_long_delay\n#&gt;   &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;lgl&gt;       &lt;lgl&gt;         \n#&gt; 1  2013     1     1 FALSE       TRUE          \n#&gt; 2  2013     1     2 FALSE       TRUE          \n#&gt; 3  2013     1     3 FALSE       FALSE         \n#&gt; 4  2013     1     4 FALSE       FALSE         \n#&gt; 5  2013     1     5 FALSE       TRUE          \n#&gt; 6  2013     1     6 FALSE       FALSE         \n#&gt; # ℹ 359 more rows\n\nΣτις περισσότερες περιπτώσεις, ωστόσο, η έξοδος της any() και της all() είναι λίγο απλή και θα ήταν καλό να μπορούσαμε να μάθουμε λίγες περισσότερες λεπτομέρειες σχετικά με το πόσες τιμές είναι TRUE ή FALSE. Αυτό μας οδηγεί στις αριθμητικές συνόψεις.\n\n12.4.2 Αριθμητικές συνόψεις λογικών διανυσμάτων\nΌταν χρησιμοποιείτε ένα λογικό διάνυσμα σε ένα αριθμητικό γενικό πλαίσιο, το TRUE γίνεται 1 και το FALSE γίνεται 0. Αυτό κάνει τις sum() και mean() πολύ χρήσιμες με λογικά διανύσματα, επειδή η sum(x) δίνει τον αριθμό των TRUE και η mean(x) δίνει την αναλογία των TRUE (γιατί η mean() διαιρείται απλώς με την sum()) με την length().\nΑυτό, για παράδειγμα, μας επιτρέπει να δούμε το ποσοστό των πτήσεων που καθυστέρησαν κατά την αναχώρηση κατά μία ώρα το πολύ, αλλά και τον αριθμό των πτήσεων που καθυστέρησαν κατά την άφιξη κατά πέντε ώρες ή περισσότερο:\n\nflights |&gt; \n  group_by(year, month, day) |&gt; \n  summarize(\n    proportion_delayed = mean(dep_delay &lt;= 60, na.rm = TRUE),\n    count_long_delay = sum(arr_delay &gt;= 300, na.rm = TRUE),\n    .groups = \"drop\"\n  )\n#&gt; # A tibble: 365 × 5\n#&gt;    year month   day proportion_delayed count_long_delay\n#&gt;   &lt;int&gt; &lt;int&gt; &lt;int&gt;              &lt;dbl&gt;            &lt;int&gt;\n#&gt; 1  2013     1     1              0.939                3\n#&gt; 2  2013     1     2              0.914                3\n#&gt; 3  2013     1     3              0.941                0\n#&gt; 4  2013     1     4              0.953                0\n#&gt; 5  2013     1     5              0.964                1\n#&gt; 6  2013     1     6              0.959                0\n#&gt; # ℹ 359 more rows\n\n\n12.4.3 Λογική δημιουργία υποσυνόλων\nΥπάρχει μία τελευταία χρήση για τα λογικά διανύσματα στις συνόψεις: μπορείτε να χρησιμοποιήσετε ένα λογικό διάνυσμα για να φιλτράρετε μία μεταβλητή σε ένα υποσύνολο. Αυτό χρησιμοποιεί τον βασικό τελεστή [ (ονομάζεται τελεστής υποσυνόλου), για τον οποίο θα μάθετε περισσότερα στην Ενότητα 27.2.\nΦανταστείτε ότι θέλαμε να δούμε τη μέση καθυστέρηση μόνο για πτήσεις που είχαν όντως καθυστέρηση. Ένας τρόπος για να το κάνετε αυτό θα ήταν να φιλτράρετε πρώτα τις πτήσεις και στη συνέχεια να υπολογίσετε τη μέση καθυστέρηση:\n\nflights |&gt; \n  filter(arr_delay &gt; 0) |&gt; \n  group_by(year, month, day) |&gt; \n  summarize(\n    behind = mean(arr_delay),\n    n = n(),\n    .groups = \"drop\"\n  )\n#&gt; # A tibble: 365 × 5\n#&gt;    year month   day behind     n\n#&gt;   &lt;int&gt; &lt;int&gt; &lt;int&gt;  &lt;dbl&gt; &lt;int&gt;\n#&gt; 1  2013     1     1   32.5   461\n#&gt; 2  2013     1     2   32.0   535\n#&gt; 3  2013     1     3   27.7   460\n#&gt; 4  2013     1     4   28.3   297\n#&gt; 5  2013     1     5   22.6   238\n#&gt; 6  2013     1     6   24.4   381\n#&gt; # ℹ 359 more rows\n\nΑυτό λειτουργεί, αλλά τι θα γινόταν αν θέλαμε να υπολογίσουμε και τη μέση καθυστέρηση για πτήσεις που έφτασαν νωρίς;\nΘα πρέπει να εκτελέσουμε ένα ξεχωριστό βήμα φιλτραρίσματος και, στη συνέχεια, να καταλάβουμε πώς να συνδυάσουμε τα δύο πλαίσια δεδομένων μαζί3. Αντ’ αυτού, θα μπορούσατε να χρησιμοποιήσετε το [ για να εφαρμόσετε το φίλτρο: το arr_delay[arr_delay &gt; 0] θα επιστρέψει μόνο τις θετικές καθυστερήσεις άφιξης.\nΑυτό οδηγεί στο:\n\nflights |&gt; \n  group_by(year, month, day) |&gt; \n  summarize(\n    behind = mean(arr_delay[arr_delay &gt; 0], na.rm = TRUE),\n    ahead = mean(arr_delay[arr_delay &lt; 0], na.rm = TRUE),\n    n = n(),\n    .groups = \"drop\"\n  )\n#&gt; # A tibble: 365 × 6\n#&gt;    year month   day behind ahead     n\n#&gt;   &lt;int&gt; &lt;int&gt; &lt;int&gt;  &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt;\n#&gt; 1  2013     1     1   32.5 -12.5   842\n#&gt; 2  2013     1     2   32.0 -14.3   943\n#&gt; 3  2013     1     3   27.7 -18.2   914\n#&gt; 4  2013     1     4   28.3 -17.0   915\n#&gt; 5  2013     1     5   22.6 -14.0   720\n#&gt; 6  2013     1     6   24.4 -13.6   832\n#&gt; # ℹ 359 more rows\n\nΣημειώστε επίσης τη διαφορά στο μέγεθος των ομάδων: στο πρώτο κομμάτι κώδικα, η n() δίνει τον αριθμό των καθυστερημένων πτήσεων ανά ημέρα. Στο δεύτερο, η n() δίνει τον συνολικό αριθμό πτήσεων.\n\n12.4.4 Ασκήσεις\n\nΤι θα κάνει η sum(is.na(x));\nΤι η mean(is.na(x));\nΤι επιστρέφει η prod() όταν εφαρμόζεται σε ένα λογικό διάνυσμα;\nΜε ποια συνάρτηση λογικής σύνοψης είναι ισοδύναμη;\nΤι επιστρέφει η min() όταν εφαρμόζεται σε ένα λογικό διάνυσμα;\nΜε ποια συνάρτηση λογικής σύνοψης είναι ισοδύναμη;\nΔιαβάστε τις οδηγίες και εκτελέστε μερικά πειράματα.",
    "crumbs": [
      "Μετασχηματισμοί",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Λογικά διανύσματα</span>"
    ]
  },
  {
    "objectID": "logicals.html#μετασχηματισμοί-υπό-όρους",
    "href": "logicals.html#μετασχηματισμοί-υπό-όρους",
    "title": "12  Λογικά διανύσματα",
    "section": "\n12.5 Μετασχηματισμοί υπό όρους",
    "text": "12.5 Μετασχηματισμοί υπό όρους\nΈνα από τα πιο ισχυρά χαρακτηριστικά των λογικών διανυσμάτων είναι η χρήση τους για μετασχηματισμούς υπό όρους, δηλαδή να κάνουν ένα πράγμα για τη συνθήκη x και κάτι διαφορετικό για τη συνθήκη y. Υπάρχουν δύο σημαντικά εργαλεία για αυτό: η if_else() και η case_when().\n\n12.5.1 if_else()\n\nΕάν θέλετε να χρησιμοποιήσετε μία τιμή όταν μία συνθήκη είναι TRUE και μία άλλη τιμή όταν είναι FALSE, μπορείτε να αξιοποιήσετε την dplyr::if_else()4. Τα τρία πρώτα όρισμα της if_else() χρησιμοποιούνται πάντα. Το πρώτο όρισμα, condition, είναι ένα λογικό διάνυσμα, το δεύτερο, true, δίνει την αντίστοιχη τιμή εξόδου όταν η συνθήκη είναι αληθής, και το τρίτο, false, δίνει την την αντίστοιχη τιμή εξόδου εάν η συνθήκη είναι ψευδής.\nΑς ξεκινήσουμε με ένα απλό παράδειγμα χαρακτηρισμού ενός αριθμητικού διανύσματος είτε ως “+ve” (θετικό) ή “-ve” (αρνητικό):\n\nx &lt;- c(-3:3, NA)\nif_else(x &gt; 0, \"+ve\", \"-ve\")\n#&gt; [1] \"-ve\" \"-ve\" \"-ve\" \"-ve\" \"+ve\" \"+ve\" \"+ve\" NA\n\nΥπάρχει ένα προαιρετικό τέταρτο όρισμα, το missing, το οποίο θα χρησιμοποιηθεί εάν η είσοδος είναι NA:\n\nif_else(x &gt; 0, \"+ve\", \"-ve\", \"???\")\n#&gt; [1] \"-ve\" \"-ve\" \"-ve\" \"-ve\" \"+ve\" \"+ve\" \"+ve\" \"???\"\n\nΜπορείτε επίσης να χρησιμοποιήσετε διανύσματα για τα ορίσματα true και false. Για παράδειγμα, το παρακάτω μας επιτρέπει να δημιουργήσουμε μία συνοπτική υλοποίηση της abs():\n\nif_else(x &lt; 0, -x, x)\n#&gt; [1]  3  2  1  0  1  2  3 NA\n\nΜέχρι στιγμής όλα τα ορίσματα έχουν χρησιμοποιήσει τα ίδια διανύσματα. Μπορείτε όμως φυσικά να χρησιμοποιήσετε ο,τι επιθυμείτε. Για παράδειγμα, θα μπορούσατε να εφαρμόσετε μία απλή έκδοση της coalesce() ως εξής:\n\nx1 &lt;- c(NA, 1, 2, NA)\ny1 &lt;- c(3, NA, 4, 6)\nif_else(is.na(x1), y1, x1)\n#&gt; [1] 3 1 2 6\n\nΊσως έχετε παρατηρήσει μία μικρή ασάφεια στο παραπάνω παράδειγμα χαρακτηρισμού: το μηδέν δεν είναι ούτε θετικό ούτε αρνητικό. Θα μπορούσαμε να το επιλύσουμε προσθέτοντας μία επιπλέον if_else():\n\nif_else(x == 0, \"0\", if_else(x &lt; 0, \"-ve\", \"+ve\"), \"???\")\n#&gt; [1] \"-ve\" \"-ve\" \"-ve\" \"0\"   \"+ve\" \"+ve\" \"+ve\" \"???\"\n\nΑυτό είναι ήδη λίγο δύσκολο να διαβαστεί και μπορείτε να φανταστείτε ότι θα γίνει μόνο χειρότερο εάν έχετε περισσότερες συνθήκες. Αντ’ αυτού, μπορείτε να χρησιμοποιήσετε την dplyr::case_when().\n\n12.5.2 case_when()\n\nΗ case_when() της dplyr είναι εμπνευσμένη από τη δήλωση CASE της SQL και παρέχει έναν ευέλικτο τρόπο εκτέλεσης διαφορετικών υπολογισμών για διαφορετικές συνθήκες. Έχει μία ειδική σύνταξη που δυστυχώς δεν μοιάζει με τίποτα άλλο που θα δείτε στο tidyverse. Χρειάζονται ζεύγη που μοιάζουν ως συνθήκη ~ έξοδος. Η συνθήκη πρέπει να είναι ένα λογικό διάνυσμα. Όταν είναι TRUE, η έξοδος θα χρησιμοποιηθεί.\nΑυτό σημαίνει ότι θα μπορούσαμε να αναδημιουργήσουμε την προηγούμενη εμφωλευμένη if_else() ως εξής:\n\nx &lt;- c(-3:3, NA)\ncase_when(\n  x == 0   ~ \"0\",\n  x &lt; 0    ~ \"-ve\", \n  x &gt; 0    ~ \"+ve\",\n  is.na(x) ~ \"???\"\n)\n#&gt; [1] \"-ve\" \"-ve\" \"-ve\" \"0\"   \"+ve\" \"+ve\" \"+ve\" \"???\"\n\nΕίναι περισσότερος κώδικας, αλλά είναι επίσης πιο ξεκάθαρος.\nΓια να εξηγήσουμε πώς λειτουργεί η case_when(), ας εξερευνήσουμε μερικές πιο απλές περιπτώσεις. Εάν καμία από τις περιπτώσεις δεν ταιριάζει, η έξοδος παίρνει NA:\n\ncase_when(\n  x &lt; 0 ~ \"-ve\",\n  x &gt; 0 ~ \"+ve\"\n)\n#&gt; [1] \"-ve\" \"-ve\" \"-ve\" NA    \"+ve\" \"+ve\" \"+ve\" NA\n\nΧρησιμοποιήστε το .default εάν θέλετε να δημιουργήσετε μία τιμή για οποιαδήποτε άλλη περίπτωση (σαν προεπιλογή):\n\ncase_when(\n  x &lt; 0 ~ \"-ve\",\n  x &gt; 0 ~ \"+ve\",\n  .default = \"???\"\n)\n#&gt; [1] \"-ve\" \"-ve\" \"-ve\" \"???\" \"+ve\" \"+ve\" \"+ve\" \"???\"\n\nΚαι σημειώστε ότι εάν πολλαπλές συνθήκες ταιριάζουν, θα χρησιμοποιηθεί μόνο η πρώτη:\n\ncase_when(\n  x &gt; 0 ~ \"+ve\",\n  x &gt; 2 ~ \"big\"\n)\n#&gt; [1] NA    NA    NA    NA    \"+ve\" \"+ve\" \"+ve\" NA\n\nΑκριβώς όπως και με την if_else() μπορείτε να χρησιμοποιήσετε μεταβλητές και στις δύο πλευρές του ~ και μπορείτε να συνδυάσετε και να ταιριάξετε μεταβλητές όπως χρειάζεστε για το πρόβλημά σας. Για παράδειγμα, θα μπορούσαμε να χρησιμοποιήσουμε την case_when() για να παρέχουμε ορισμένους κατανοητούς χαρακτηρισμούς για την καθυστέρηση άφιξης:\n\nflights |&gt; \n  mutate(\n    status = case_when(\n      is.na(arr_delay)      ~ \"cancelled\",\n      arr_delay &lt; -30       ~ \"very early\",\n      arr_delay &lt; -15       ~ \"early\",\n      abs(arr_delay) &lt;= 15  ~ \"on time\",\n      arr_delay &lt; 60        ~ \"late\",\n      arr_delay &lt; Inf       ~ \"very late\",\n    ),\n    .keep = \"used\"\n  )\n#&gt; # A tibble: 336,776 × 2\n#&gt;   arr_delay status \n#&gt;       &lt;dbl&gt; &lt;chr&gt;  \n#&gt; 1        11 on time\n#&gt; 2        20 late   \n#&gt; 3        33 late   \n#&gt; 4       -18 early  \n#&gt; 5       -25 early  \n#&gt; 6        12 on time\n#&gt; # ℹ 336,770 more rows\n\nΝα είστε προσεκτικοί όταν γράφετε αυτού του είδους σύνθετες δηλώσεις case_when(). Οι δύο πρώτες μου απόπειρες χρησιμοποίησαν έναν συνδυασμό &lt; και &gt; και συνέχισα να δημιουργώ κατά λάθος αλληλεπικαλυπτόμενες συνθήκες.\n\n12.5.3 Συμβατοί τύποι\nΣημειώστε ότι τόσο η if_else() όσο και η case_when() απαιτούν συμβατούς τύπους τιμών στην έξοδο. Εάν δεν είναι συμβατοί, θα δείτε σφάλματα όπως αυτό:\n\nif_else(TRUE, \"a\", 1)\n#&gt; Error in `if_else()`:\n#&gt; ! Can't combine `true` &lt;character&gt; and `false` &lt;double&gt;.\n\ncase_when(\n  x &lt; -1 ~ TRUE,  \n  x &gt; 0  ~ now()\n)\n#&gt; Error in `case_when()`:\n#&gt; ! Can't combine `..1 (right)` &lt;logical&gt; and `..2 (right)` &lt;datetime&lt;local&gt;&gt;.\n\nΓενικά, σχετικά λίγοι τύποι είναι συμβατοί, επειδή η αυτόματη μετατροπή ενός τύπου διανύσματος σε άλλο είναι μία κοινή πηγή σφαλμάτων. Παρακάτω καταγράφονται οι πιο σημαντικές περιπτώσεις όπου οι τύποι είναι συμβατοί:\n\nΤα αριθμητικά και λογικά διανύσματα είναι συμβατά, όπως συζητήσαμε στην Ενότητα 12.4.2.\nΟι συμβολοσειρές και οι παράγοντες (Κεφάλαιο 16) είναι συμβατοί, επειδή μπορείτε να σκεφτείτε έναν παράγοντα ως μία συμβολοσειρά με ένα περιορισμένο σύνολο τιμών.\nΟι ημερομηνίες και οι ημερομηνίες με ώρα, τις οποίες θα συζητήσουμε στο Κεφάλαιο 17, είναι συμβατές επειδή μπορείτε να σκεφτείτε μία ημερομηνία ως μία ειδική περίπτωση ημερομηνίας-ώρας.\nΤο NA, το οποίο είναι τεχνικά ένα λογικό διάνυσμα, είναι συμβατό με τα πάντα επειδή κάθε διάνυσμα έχει κάποιο τρόπο να αναπαριστά μία κενή τιμή.\n\nΔεν περιμένουμε από εσάς να απομνημονεύσετε αυτούς τους κανόνες, αλλά θα πρέπει με την πάροδο του χρόνου να τους συνηθίσετε, επειδή εφαρμόζονται με τον ίδιο τρόπο σε όλο το tidyverse.\n\n12.5.4 Ασκήσεις\n\nΈνας αριθμός είναι άρτιος εαν διαιρείται με το δύο, κάτι που στην R μπορείτε να το βρείτε με το x %% 2 == 0. Χρησιμοποιήστε αυτό το γεγονός και την if_else() για να προσδιορίσετε εάν κάθε αριθμός μεταξύ 0 και 20 είναι άρτιος ή περιττός.\nΔεδομένου ενός διανύσματος ημερών όπως το x &lt;- c(\"Monday\", \"Saturday\", \"Wednesday\"), χρησιμοποιήστε μία δήλωση if_else() για να τις χαρακτηρίσετε ως Σαββατοκύριακα ή καθημερινές.\nΧρησιμοποιήστε την if_else() για να υπολογίσετε την απόλυτη τιμή ενός αριθμητικού διανύσματος με όνομα x.\nΓράψτε μία δήλωση case_when() που χρησιμοποιεί τις στήλες month και day από το σύνολο δεδομένων flights για τον χαρακτηρισμό μιας επιλογής σημαντικών εορτών στις ΗΠΑ (π.χ. Πρωτοχρονιά, 4η Ιουλίου, Ημέρα των Ευχαριστιών και Χριστούγεννα). Δημιουργήστε πρώτα μία λογική στήλη που είναι είτε TRUE είτε FALSE και, στη συνέχεια, δημιουργήστε μία στήλη χαρακτήρων που είτε δίνει το όνομα της αργίας είτε είναι NA.",
    "crumbs": [
      "Μετασχηματισμοί",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Λογικά διανύσματα</span>"
    ]
  },
  {
    "objectID": "logicals.html#σύνοψη",
    "href": "logicals.html#σύνοψη",
    "title": "12  Λογικά διανύσματα",
    "section": "\n12.6 Σύνοψη",
    "text": "12.6 Σύνοψη\nΟ ορισμός ενός λογικού διανύσματος είναι απλός γιατί κάθε τιμή πρέπει να είναι TRUE, FALSE ή NA. Παρ’ όλα αυτά, τα λογικά διανύσματα είναι αρκετά ισχυρά. Σε αυτό το κεφάλαιο, μάθατε πώς να δημιουργείτε λογικά διανύσματα με &gt;, &lt;, &lt;=, &gt;=, ==, !=, και is.na(), πώς για να τα συνδυάσετε με τα !, & και | και πώς να τα συνοψίσετε με τις any(), all(), sum() και mean(). Μάθατε επίσης τις ισχυρές συναρτήσεις if_else() και case_when() που σας επιτρέπουν να επιστρέφετε τιμές ανάλογα με την τιμή ενός λογικού διανύσματος.\nΘα βλέπουμε λογικά διανύσματα αρκετές φορές στα επόμενα κεφάλαια. Για παράδειγμα, στο Κεφάλαιο 14 θα μάθετε για την str_detect(x, μοτίβο) η οποία επιστρέφει ένα λογικό διάνυσμα που είναι TRUE για τα στοιχεία του x που ταιριάζουν με το μοτίβο και στο Κεφάλαιο 17 θα δημιουργήσετε λογικά διανύσματα από τη σύγκριση ημερομηνιών και ωρών. Προς το παρόν όμως, θα προχωρήσουμε στον επόμενο πιο σημαντικό τύπο διανύσματος: τα αριθμητικά διανύσματα.",
    "crumbs": [
      "Μετασχηματισμοί",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Λογικά διανύσματα</span>"
    ]
  },
  {
    "objectID": "logicals.html#footnotes",
    "href": "logicals.html#footnotes",
    "title": "12  Λογικά διανύσματα",
    "section": "",
    "text": "Η R συνήθως καλεί την print για εσάς (το x, δηλαδή, είναι μία συντόμευση για την print(x)), αλλά η κλήση της εκ νέου είναι χρήσιμη σε περιπτώσεις που θέλετε να παρέχετε άλλα ορίσματα.↩︎\nΔηλαδή, το xor(x, y) είναι αληθές αν το x είναι αληθές ή το y είναι αληθές, αλλά όχι και τα δύο. Συνληθως, έτσι χρησιμοποιούμε το “είτε” στα Ελληνικά. Το «και τα δύο» δεν είναι συνήθως αποδεκτή απάντηση στην ερώτηση «θα ήθελες παγωτό ή κέικ;».↩︎\nΘα το καλύψουμε στο Κεφάλαιο 19.↩︎\nΗ if_else() της dplyr είναι πολύ παρόμοιο με της ifelse() του βασικού πακέτου λειτουργιών R. Υπάρχουν δύο βασικά πλεονεκτήματα της if_else() έναντι της ifelse(): μπορείτε να επιλέξετε τι θα συμβεί με τις κενές τιμές και η if_else() είναι πολύ πιο πιθανό να σας δώσει ένα σημαντικό σφάλμα εάν οι μεταβλητές σας έχουν μη συμβατούς τύπους.↩︎",
    "crumbs": [
      "Μετασχηματισμοί",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Λογικά διανύσματα</span>"
    ]
  },
  {
    "objectID": "numbers.html",
    "href": "numbers.html",
    "title": "13  Αριθμητικά διανύσματα",
    "section": "",
    "text": "13.1 Εισαγωγή\nΤα αριθμητικά διανύσματα είναι η ραχοκοκαλιά της επιστήμης των δεδομένων και τα έχετε ήδη χρησιμοποιήσει αρκετές φορές σε προηγούμενα κεφάλαια αυτού του βιβλίου. Είναι ώρα πλέον να εξερευνήσετε τι μπορείτε να κάνετε με αυτά στην R, διασφαλίζοντας ότι είστε κατάλληλα εξοπλισμένοι για να αντιμετωπίσετε οποιοδήποτε μελλοντικό πρόβλημα σχετικό με αριθμητικά διανύσματα.\nΘα ξεκινήσουμε δίνοντάς σας μερικά εργαλεία για να δημιουργήσετε αριθμούς από συμβολοσειρές και θα προχωρήσουμε σε λίγες περισσότερες λεπτομέρειες για την count(). Στη συνέχεια, θα εμβαθύνουμε σε διάφορους αριθμητικούς μετασχηματισμούς που συνδυάζονται καλά με την mutate(), συμπεριλαμβανομένων και πιο γενικών μετασχηματισμών που μπορούν να εφαρμοστούν σε άλλους τύπους διανυσμάτων, αλλά χρησιμοποιούνται συχνά με αριθμητικά διανύσματα. Θα ολοκληρώσουμε καλύπτοντας τις συναρτήσεις σύνοψης που συνδυάζονται ωραία με την summarize() και θα σας δείξουμε πώς μπορούν ακόμα να χρησιμοποιηθούν με την mutate().",
    "crumbs": [
      "Μετασχηματισμοί",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Αριθμητικά διανύσματα</span>"
    ]
  },
  {
    "objectID": "numbers.html#εισαγωγή",
    "href": "numbers.html#εισαγωγή",
    "title": "13  Αριθμητικά διανύσματα",
    "section": "",
    "text": "13.1.1 Προαπαιτούμενα\nΑυτό το κεφάλαιο χρησιμοποιεί συναρτήσεις κυρίως από το βασικό πακέτο λειτουργιών της R, οι οποίες είναι διαθέσιμες χωρίς φόρτωση κάποιου πακέτου. Ωστόσο, χρειαζόμαστε ακόμα το tidyverse, γιατί θα χρησιμοποιήσουμε αυτές τις βασικές συναρτήσεις της R μέσα σε συναρτήσεις του tidyverse, όπως στην mutate() και την filter(). Όπως και στο προηγούμενο κεφάλαιο, έτσι και εδώ θα χρησιμοποιήσουμε πραγματικά παραδείγματα από το σύνολο δεδομένων nycflights13, καθώς και τυχαία παραδείγματα που δημιουργήθηκαν με την c() και την tribble().\n\nlibrary(tidyverse)\nlibrary(nycflights13)",
    "crumbs": [
      "Μετασχηματισμοί",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Αριθμητικά διανύσματα</span>"
    ]
  },
  {
    "objectID": "numbers.html#δημιουργώντας-αριθμούς",
    "href": "numbers.html#δημιουργώντας-αριθμούς",
    "title": "13  Αριθμητικά διανύσματα",
    "section": "\n13.2 Δημιουργώντας αριθμούς",
    "text": "13.2 Δημιουργώντας αριθμούς\nΣτις περισσότερες περιπτώσεις, θα έχετε αριθμούς που υπάρχουν ήδη ως ένας απο τους αριθμητικούς τύπους δεδομένων της R: ακέραιους (integer) ή κινητής υποδιαστολής (γνωστοί και ως διπλής ακρίβειας, double). Σε ορισμένες περιπτώσεις, ωστόσο, θα τους συναντήσετε ως συμβολοσειρές, πιθανώς επειδή τις έχετε δημιουργήσει μέσω ενός συγκεντρωτικού πίνακα ή επειδή κάτι πήγε στραβά κατά την εισαγωγή των δεδομένων σας.\nΗ readr παρέχει δύο χρήσιμες συναρτήσεις για την ανάλυση συμβολοσειρών σε αριθμούς: την parse_double() και την parse_number(). Χρησιμοποιήστε την parse_double() όταν έχετε αριθμούς που έχουν γραφτεί ως συμβολοσειρές:\n\nx &lt;- c(\"1.2\", \"5.6\", \"1e3\")\nparse_double(x)\n#&gt; [1]    1.2    5.6 1000.0\n\nΧρησιμοποιήστε την parse_number() όταν η συμβολοσειρά περιέχει μη αριθμητικό κείμενο που θέλετε να αγνοήσετε. Είναι ιδιαίτερα χρήσιμη για δεδομένα συναλλάγματος και ποσοστά:\n\nx &lt;- c(\"$1,234\", \"USD 3,513\", \"59%\")\nparse_number(x)\n#&gt; [1] 1234 3513   59",
    "crumbs": [
      "Μετασχηματισμοί",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Αριθμητικά διανύσματα</span>"
    ]
  },
  {
    "objectID": "numbers.html#sec-counts",
    "href": "numbers.html#sec-counts",
    "title": "13  Αριθμητικά διανύσματα",
    "section": "\n13.3 Καταμετρήσεις",
    "text": "13.3 Καταμετρήσεις\nΕίναι εκπληκτικό το πόση επιστήμη δεδομένων μπορείτε να εφαρμόσετε χρησιμοποιώντας μόνο μετρήσεις και λίγη βασική αριθμητική. Για αυτό, το πακέτο dplyr προσπαθεί να κάνει τη μέτρηση όσο το δυνατόν πιο εύκολη με την count(). Η συνάρτηση αυτή είναι εξαιρετική για γρήγορη εξερεύνηση και ελέγχους κατά την ανάλυση των δεδομένων:\n\nflights |&gt; count(dest)\n#&gt; # A tibble: 105 × 2\n#&gt;   dest      n\n#&gt;   &lt;chr&gt; &lt;int&gt;\n#&gt; 1 ABQ     254\n#&gt; 2 ACK     265\n#&gt; 3 ALB     439\n#&gt; 4 ANC       8\n#&gt; 5 ATL   17215\n#&gt; 6 AUS    2439\n#&gt; # ℹ 99 more rows\n\n(Παρά τις συμβουλές της ενότητας Κεφάλαιο 4, συνήθως βάζουμε την count() σε μία ξεχωριστή γραμμή καθώς συχνά χρησιμοποιείται στην κονσόλα για να ελέγξουμε γρήγορα ότι ένας υπολογισμός λειτουργεί όπως αναμένεται.)\nΕάν θέλετε να δείτε τις πιο συνηθισμένες τιμές, προσθέστε το όρισμα sort = TRUE:\n\nflights |&gt; count(dest, sort = TRUE)\n#&gt; # A tibble: 105 × 2\n#&gt;   dest      n\n#&gt;   &lt;chr&gt; &lt;int&gt;\n#&gt; 1 ORD   17283\n#&gt; 2 ATL   17215\n#&gt; 3 LAX   16174\n#&gt; 4 BOS   15508\n#&gt; 5 MCO   14082\n#&gt; 6 CLT   14064\n#&gt; # ℹ 99 more rows\n\nΚαι να θυμάστε ότι εάν θέλετε να δείτε όλες τις τιμές, μπορείτε να χρησιμοποιήσετε το |&gt; View() ή το |&gt; print(n = Inf).\nΜπορείτε να εκτελέσετε τον ίδιο υπολογισμό “με το χέρι” με τις group_by(), summarize() και n(). Αυτό είναι χρήσιμο επειδή σας επιτρέπει να υπολογίζετε και άλλες περιλήψεις ταυτόχρονα:\n\nflights |&gt; \n  group_by(dest) |&gt; \n  summarize(\n    n = n(),\n    delay = mean(arr_delay, na.rm = TRUE)\n  )\n#&gt; # A tibble: 105 × 3\n#&gt;   dest      n delay\n#&gt;   &lt;chr&gt; &lt;int&gt; &lt;dbl&gt;\n#&gt; 1 ABQ     254  4.38\n#&gt; 2 ACK     265  4.85\n#&gt; 3 ALB     439 14.4 \n#&gt; 4 ANC       8 -2.5 \n#&gt; 5 ATL   17215 11.3 \n#&gt; 6 AUS    2439  6.02\n#&gt; # ℹ 99 more rows\n\nΗ n() είναι μία ειδική συνάρτηση σύνοψης που δεν δέχεται ορίσματα και αντ’ αυτού έχει πρόσβαση σε πληροφορίες σχετικά με την “τρέχουσα” ομάδα. Αυτό σημαίνει ότι λειτουργεί μόνο μέσα σε συναρτήσεις της dplyr:\n\nn()\n#&gt; Error in `n()`:\n#&gt; ! Must only be used inside data-masking verbs like `mutate()`,\n#&gt;   `filter()`, and `group_by()`.\n\nΥπάρχουν μερικές παραλλαγές της n() και της count() που μπορεί να σας φανούν χρήσιμες:\n\n\nΗ n_distinct(x) μετρά τον αριθμό των διακριτών (μοναδικών) τιμών μιας ή περισσότερων μεταβλητών. Για παράδειγμα, θα μπορούσαμε να καταλάβουμε ποιοι προορισμοί εξυπηρετούνται από τις περισσότερες εταιρείες:\n\nflights |&gt; \n  group_by(dest) |&gt; \n  summarize(carriers = n_distinct(carrier)) |&gt; \n  arrange(desc(carriers))\n#&gt; # A tibble: 105 × 2\n#&gt;   dest  carriers\n#&gt;   &lt;chr&gt;    &lt;int&gt;\n#&gt; 1 ATL          7\n#&gt; 2 BOS          7\n#&gt; 3 CLT          7\n#&gt; 4 ORD          7\n#&gt; 5 TPA          7\n#&gt; 6 AUS          6\n#&gt; # ℹ 99 more rows\n\n\n\nΜία σταθμισμένη καταμέτρηση είναι ένα άθροισμα. Για παράδειγμα, θα μπορούσατε να “μετρήσετε” τον αριθμό των μιλίων που πέταξε κάθε αεροπλάνο:\n\nflights |&gt; \n  group_by(tailnum) |&gt; \n  summarize(miles = sum(distance))\n#&gt; # A tibble: 4,044 × 2\n#&gt;   tailnum  miles\n#&gt;   &lt;chr&gt;    &lt;dbl&gt;\n#&gt; 1 D942DN    3418\n#&gt; 2 N0EGMQ  250866\n#&gt; 3 N10156  115966\n#&gt; 4 N102UW   25722\n#&gt; 5 N103US   24619\n#&gt; 6 N104UW   25157\n#&gt; # ℹ 4,038 more rows\n\nΟι σταθμισμένες καταμετρήσεις είναι ένα κοινό πρόβλημα, επομένως η count() έχει το όρισμα wt που λαμβάνει υπόψη ακριβώς αυτό:\n\nflights |&gt; count(tailnum, wt = distance)\n\n\n\nΜπορείτε να μετρήσετε τις τιμές που λείπουν συνδυάζοντας την sum() και την is.na(). Στο σύνολο δεδομένων flights αυτό αντιπροσωπεύει πτήσεις που ακυρώνονται:\n\nflights |&gt; \n  group_by(dest) |&gt; \n  summarize(n_cancelled = sum(is.na(dep_time))) \n#&gt; # A tibble: 105 × 2\n#&gt;   dest  n_cancelled\n#&gt;   &lt;chr&gt;       &lt;int&gt;\n#&gt; 1 ABQ             0\n#&gt; 2 ACK             0\n#&gt; 3 ALB            20\n#&gt; 4 ANC             0\n#&gt; 5 ATL           317\n#&gt; 6 AUS            21\n#&gt; # ℹ 99 more rows\n\n\n\n\n13.3.1 Ασκήσεις\n\nΠώς μπορείτε να χρησιμοποιήσετε την count() για να καταμετρήσετε τις αριθμητικές γραμμές με μία κενή τιμή για μία μεταβλητή;\nΑντικαταστήστε την count() στις παρακάτω κλήσεις της, χρησιμοποιώντας τις group_by(), summarize() και arrange():\n\nflights |&gt; count(dest, sort = TRUE)\nflights |&gt; count(tailnum, wt = distance)",
    "crumbs": [
      "Μετασχηματισμοί",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Αριθμητικά διανύσματα</span>"
    ]
  },
  {
    "objectID": "numbers.html#αριθμητικοί-μετασχηματισμοί",
    "href": "numbers.html#αριθμητικοί-μετασχηματισμοί",
    "title": "13  Αριθμητικά διανύσματα",
    "section": "\n13.4 Αριθμητικοί μετασχηματισμοί",
    "text": "13.4 Αριθμητικοί μετασχηματισμοί\nΟι συναρτήσεις μετασχηματισμού λειτουργούν καλά με την mutate() επειδή η έξοδος τους είναι το ίδιο μήκος με την είσοδο. Η συντριπτική πλειοψηφία των συναρτήσεων μετασχηματισμού είναι ήδη ενσωματωμένες στο βασικό πακέτο λειτουργιών της R. Μιας και δεν θα ήταν πρακτικό να αναφερθούμε σε όλα, αυτή η ενότητα θα δείξει τα πιο χρήσιμα. Για παράδειγμα, ενώ η R παρέχει όλες τις τριγωνομετρικές συναρτήσεις που μπορεί να φανταστείτε, δεν τις αναφέρουμε εδώ επειδή σπάνια θα χρειαστούν στην επιστήμη των δεδομένων.\n\n13.4.1 Κανόνες αριθμητικής και ανακύκλωσης\nΕίπαμε για τα βασικά της αριθμητικής (+, -, *, /, ^) στο Κεφάλαιο 2 και τα έχουμε χρησιμοποιήσει αρκετά από τότε. Οι συναρτήσεις αυτές δεν χρειάζονται εκτενείς εξηγήσεις, καθώς κάνουν ακριβώς ό,τι μάθατε στο δημοτικό. Πρέπει όμως να μιλήσουμε εν συντομία για τους κανόνες ανακύκλωσης που καθορίζουν τι συμβαίνει όταν η αριστερή και η δεξιά πλευρά έχουν διαφορετικά μήκη. Αυτό είναι σημαντικό για λειτουργίες όπως flights |&gt; mutate(air_time = air_time / 60), επειδή υπάρχουν 336.776 αριθμοί στα αριστερά του / αλλά μόνο ένας στα δεξιά.\nΗ R χειρίζεται άνισα μήκη ανακυκλώνοντας ή επαναλαμβάνοντας το μικρότερο διάνυσμα. Μπορούμε να το δούμε σε λειτουργία πιο εύκολα εάν δημιουργήσουμε μερικά διανύσματα εκτός κάποιου πλαισίου δεδομένων:\n\nx &lt;- c(1, 2, 10, 20)\nx / 5\n#&gt; [1] 0.2 0.4 2.0 4.0\n# είναι συντομογραφία για το\nx / c(5, 5, 5, 5)\n#&gt; [1] 0.2 0.4 2.0 4.0\n\nΓενικά, θέλετε να ανακυκλώσετε μόνο μεμονωμένους αριθμούς (δηλαδή διανύσματα μήκους 1), αλλά η R θα ανακυκλώσει οποιοδήποτε διάνυσμα μικρότερου μήκους. Συνήθως (αλλά όχι πάντα) σας δίνει μία προειδοποίηση εάν το μεγαλύτερο διάνυσμα δεν είναι πολλαπλάσιο του μικρότερου:\n\nx * c(1, 2)\n#&gt; [1]  1  4 10 40\nx * c(1, 2, 3)\n#&gt; Warning in x * c(1, 2, 3): longer object length is not a multiple of shorter\n#&gt; object length\n#&gt; [1]  1  4 30 20\n\nΑυτοί οι κανόνες ανακύκλωσης εφαρμόζονται επίσης σε λογικές συγκρίσεις (==, &lt;, &lt;=, &gt;, &gt;=, !=) και μπορούν να οδηγήσουν σε ένα απροσδόκητο αποτέλεσμα εάν χρησιμοποιήσετε κατά λάθος το == αντί για το %in% και το πλαίσιο δεδομένων έχει έναν μη αναμενόμενο αριθμό γραμμών. Για παράδειγμα, πάρτε τον παρακάτω κώδικα ο οποίος προσπαθεί να βρει όλες τις πτήσεις τον Ιανουάριο και τον Φεβρουάριο:\n\nflights |&gt; \n  filter(month == c(1, 2))\n#&gt; # A tibble: 25,977 × 19\n#&gt;    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n#&gt;   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;\n#&gt; 1  2013     1     1      517            515         2      830            819\n#&gt; 2  2013     1     1      542            540         2      923            850\n#&gt; 3  2013     1     1      554            600        -6      812            837\n#&gt; 4  2013     1     1      555            600        -5      913            854\n#&gt; 5  2013     1     1      557            600        -3      838            846\n#&gt; 6  2013     1     1      558            600        -2      849            851\n#&gt; # ℹ 25,971 more rows\n#&gt; # ℹ 11 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;, …\n\nΟ κώδικας εκτελείται χωρίς σφάλμα, αλλά δεν επιστρέφει αυτό που θέλετε. Λόγω των κανόνων ανακύκλωσης, βρίσκει πτήσεις σε μονές γραμμές που αναχώρησαν τον Ιανουάριο και πτήσεις σε ζυγές γραμμές που αναχώρησαν τον Φεβρουάριο. Και δυστυχώς δεν υπάρχει καμία προειδοποίηση επειδή το σύνολο δεδομένων flights έχει ζυγό αριθμό γραμμών.\nΓια να σας προστατεύσουν από αυτόν τον τύπο αθόρυβης αποτυχίας, οι περισσότερες συναρτήσεις του tidyverse χρησιμοποιούν μία πιο αυστηρή μορφή ανακύκλωσης, η οποία ανακυκλώνει μόνο μεμονωμένες τιμές. Δυστυχώς, εδώ, ή ακόμα και σε πολλές άλλες περιπτώσεις, αυτό δεν βοηθά, γιατί ο κύριος υπολογισμός εκτελείται από τον βασικό τελεστή του βασικού πακέτου λειτουργιών της R, ==, και όχι από την filter().\n\n13.4.2 Ελάχιστο και μέγιστο\nΟι αριθμητικές συναρτήσεις λειτουργούν με ζεύγη μεταβλητών. Δύο στενά συνδεδεμένες συναρτήσεις είναι οι pmin() και pmax(), οι οποίες όταν τους δίνονται δύο ή περισσότερες μεταβλητές θα επιστρέψουν τη μικρότερη ή μεγαλύτερη τιμή σε κάθε γραμμή:\n\ndf &lt;- tribble(\n  ~x, ~y,\n  1,  3,\n  5,  2,\n  7, NA,\n)\n\ndf |&gt; \n  mutate(\n    min = pmin(x, y, na.rm = TRUE),\n    max = pmax(x, y, na.rm = TRUE)\n  )\n#&gt; # A tibble: 3 × 4\n#&gt;       x     y   min   max\n#&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n#&gt; 1     1     3     1     3\n#&gt; 2     5     2     2     5\n#&gt; 3     7    NA     7     7\n\nΣημειώστε ότι αυτές διαφέρουν από τις συναρτήσεις σύνοψης min() και max() οι οποίες παίρνουν πολλαπλές παρατηρήσεις και επιστρέφουν μόνο μία τιμή. Μπορείτε να πείτε ότι έχετε χρησιμοποιήσει την λάθος συνάρτηση όταν όλα τα ελάχιστα και όλα τα μέγιστα έχουν την ίδια τιμή:\n\ndf |&gt; \n  mutate(\n    min = min(x, y, na.rm = TRUE),\n    max = max(x, y, na.rm = TRUE)\n  )\n#&gt; # A tibble: 3 × 4\n#&gt;       x     y   min   max\n#&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n#&gt; 1     1     3     1     7\n#&gt; 2     5     2     1     7\n#&gt; 3     7    NA     1     7\n\n\n13.4.3 Αριθμητική υπολοίπων\nΗ αριθμητική υπολοίπων είναι η τεχνική ονομασία για τον τύπο μαθηματικών που κάνατε πριν μάθετε για τα δεκαδικά ψηφία, δηλαδή τη διαίρεση που δίνει έναν ακέραιο αριθμό και ένα υπόλοιπο. Στην R, το %/% κάνει διαίρεση ακεραίων και το %% υπολογίζει το υπόλοιπο:\n\n1:10 %/% 3\n#&gt;  [1] 0 0 1 1 1 2 2 2 3 3\n1:10 %% 3\n#&gt;  [1] 1 2 0 1 2 0 1 2 0 1\n\nΗ αριθμητική υπολοίπων είναι χρήσιμη για το σύνολο δεδομένων flights, καθώς μπορούμε να τη χρησιμοποιήσουμε για να αποσυνθέσουμε τη μεταβλητή sched_dep_time σε hour (ώρα) και minute (λεπτό):\n\nflights |&gt; \n  mutate(\n    hour = sched_dep_time %/% 100,\n    minute = sched_dep_time %% 100,\n    .keep = \"used\"\n  )\n#&gt; # A tibble: 336,776 × 3\n#&gt;   sched_dep_time  hour minute\n#&gt;            &lt;int&gt; &lt;dbl&gt;  &lt;dbl&gt;\n#&gt; 1            515     5     15\n#&gt; 2            529     5     29\n#&gt; 3            540     5     40\n#&gt; 4            545     5     45\n#&gt; 5            600     6      0\n#&gt; 6            558     5     58\n#&gt; # ℹ 336,770 more rows\n\nΜπορούμε να τη συνδυάσουμε με το κόλπο που βασίζεται στην mean(is.na(x)) από την Ενότητα 12.4, για να δούμε πώς το ποσοστό των ακυρωμένων πτήσεων διαφέρει κατά τη διάρκεια της ημέρας. Τα αποτελέσματα εμφανίζονται στο Σχήμα 13.1.\n\nflights |&gt; \n  group_by(hour = sched_dep_time %/% 100) |&gt; \n  summarize(prop_cancelled = mean(is.na(dep_time)), n = n()) |&gt; \n  filter(hour &gt; 1) |&gt; \n  ggplot(aes(x = hour, y = prop_cancelled)) +\n  geom_line(color = \"grey50\") + \n  geom_point(aes(size = n))\n\n\n\n\n\n\nΣχήμα 13.1: Ένα διάγραμμα γραμμής με την προγραμματισμένη ώρα αναχώρησης στον άξονα x και την αναλογία ακυρωμένων πτήσεων στον άξονα y. Οι ακυρώσεις φαίνεται να συσσωρεύονται κατά τη διάρκεια της ημέρας μέχρι τις 8μμ, ενώ οι πολύ καθυστερημένες πτήσεις είναι πολύ λιγότερο πιθανό να ακυρωθούν.\n\n\n\n\n\n13.4.4 Λογάριθμοι\nΟι λογάριθμοι είναι ένας απίστευτα χρήσιμος μετασχηματισμός για την αντιμετώπιση δεδομένων που κυμαίνονται σε πολλαπλές τάξεις μεγέθους και τη μετατροπή της εκθετικής αύξησης σε γραμμική αύξηση. Στην R, έχετε να επιλέξετε μεταξύ τριών συναρτήσεων λογαρίθμων: log() (τον φυσικό λογάριθμο, με βάση την σταθερά e), log2() (με βάση το 2) και log10() (με βάση το 10). Συνιστούμε τη χρήση της log2() ή log10(). Η log2() ερμηνεύετε εύκολα καθώς μία διαφορά μονάδας στην λογαριθμική κλίμακα αντιστοιχεί σε διπλασιασμό στην αρχική κλίμακα και μία διαφορά -1 αντιστοιχεί στο μισό της αρχικής. Η log10() είναι εύκολο να μετασχηματιστεί ξανά επειδή (π.χ.) το 3 είναι 10^3 = 1000. Το αντίστροφο της log() είναι η exp(). Για να υπολογίσετε το αντίστροφο της log2() ή της log10() θα χρειαστεί να χρησιμοποιήσετε το 2^ ή το 10^.\n\n13.4.5 Στρογγυλοποίηση\nΧρησιμοποιήστε την round(x) για να στρογγυλοποιήσετε έναν αριθμό στον πλησιέστερο ακέραιο:\n\nround(123.456)\n#&gt; [1] 123\n\nΜπορείτε να ελέγξετε την ακρίβεια της στρογγυλοποίησης με το δεύτερο όρισμα, το digits. Η round(x, digits) στρογγυλοποιείται στο πλησιέστερο 10^-n οπότε το digits = 2 θα στρογγυλοποιηθεί στο πλησιέστερο 0,01. Αυτός ο ορισμός είναι χρήσιμος επειδή υπονοεί ότι το round(x, -3) θα στρογγυλοποιηθεί στην πλησιέστερη χιλιάδα, κάτι που όντως συμβαίνει:\n\nround(123.456, 2)  # δύο ψηφία\n#&gt; [1] 123.46\nround(123.456, 1)  # ένα ψηφίο\n#&gt; [1] 123.5\nround(123.456, -1) # στρογγυλοποίηση στη πλησιέστερη δεκάδα\n#&gt; [1] 120\nround(123.456, -2) # στρογγυλοποίηση στη πλησιέστερη χιλιάδα\n#&gt; [1] 100\n\nΕκ πρώτης όψεως, φαίνεται να υπάρχει κάτι παράξενο με την round():\n\nround(c(1.5, 2.5))\n#&gt; [1] 2 2\n\nΗ round() χρησιμοποιεί κάτι που είναι γνωστό ως “στρογγυλοποίηση μισού στον πλησιέστερο ζυγού” ή τραπεζική στρογγυλοποίηση: εάν ένας αριθμός βρίσκεται στη μέση μεταξύ δύο ακεραίων, θα στρογγυλοποιηθεί στον ζυγό ακέραιο. Αυτή είναι μία καλή στρατηγική γιατί διατηρεί τη στρογγυλοποίηση αμερόληπτη: τα μισά από όλα τα 0,5 στρογγυλοποιούνται ένα προς τα πάνω και τα μισά στρογγυλοποιούνται ένα προς τα κάτω.\nΗ round() συνδυάζεται με την floor() που στρογγυλοποιεί πάντα προς τα κάτω και την ceiling() που στρογγυλοποιεί πάντα προς τα πάνω:\n\nx &lt;- 123.456\n\nfloor(x)\n#&gt; [1] 123\nceiling(x)\n#&gt; [1] 124\n\nΟι συναρτήσεις αυτές δεν έχουν όρισμα digits, για να μπορείτε να στρογγυλοποιήσετε προς τα κάτω και προς τα πάνω:\n\n# Στρογγυλοποίηση προς τα κάτω στα πλησιέστερα δύο ψηφία\nfloor(x / 0.01) * 0.01\n#&gt; [1] 123.45\n# Στρογγυλοποίηση προς τα πάνω στα πλησιέστερα δύο ψηφία\nceiling(x / 0.01) * 0.01\n#&gt; [1] 123.46\n\nΜπορείτε να χρησιμοποιήσετε την ίδια τεχνική εάν θέλετε να χρησιμοποιήσετε την round() σε ένα πολλαπλάσιο κάποιου άλλου αριθμού:\n\n# Στρογγυλοποίηση στο πλησιέστερο πολλαπλάσιο του 4\nround(x / 4) * 4\n#&gt; [1] 124\n\n# Στρογγυλοποίηση στο πλησιέστερο τεταρτημόριο (0.25)\nround(x / 0.25) * 0.25\n#&gt; [1] 123.5\n\n\n13.4.6 Τοποθετώντας αριθμούς σε εύρη\nΧρησιμοποιήστε την cut()1 για να χωρίσετε ένα αριθμητικό διάνυσμα σε διακριτές κατηγορίες (διαδικασία γνωστή και ως binning):\n\nx &lt;- c(1, 2, 5, 10, 15, 20)\ncut(x, breaks = c(0, 5, 10, 15, 20))\n#&gt; [1] (0,5]   (0,5]   (0,5]   (5,10]  (10,15] (15,20]\n#&gt; Levels: (0,5] (5,10] (10,15] (15,20]\n\nΤα διαχωριστικά (breaks) δεν χρειάζεται να είναι ομοιόμορφα:\n\ncut(x, breaks = c(0, 5, 10, 100))\n#&gt; [1] (0,5]    (0,5]    (0,5]    (5,10]   (10,100] (10,100]\n#&gt; Levels: (0,5] (5,10] (10,100]\n\nΜπορείτε προαιρετικά να δώσετε τις δικές σας ετικέτες (labels). Σημειώστε ότι θα πρέπει να υπάρχει μία ετικέτα λιγότερη από τα διαχωριστικά (breaks).\n\ncut(x, \n  breaks = c(0, 5, 10, 15, 20), \n  labels = c(\"sm\", \"md\", \"lg\", \"xl\")\n)\n#&gt; [1] sm sm sm md lg xl\n#&gt; Levels: sm md lg xl\n\nΟποιεσδήποτε τιμές εκτός του εύρους των διαχωριστικών θα γίνουν NA:\n\ny &lt;- c(NA, -10, 5, 10, 30)\ncut(y, breaks = c(0, 5, 10, 15, 20))\n#&gt; [1] &lt;NA&gt;   &lt;NA&gt;   (0,5]  (5,10] &lt;NA&gt;  \n#&gt; Levels: (0,5] (5,10] (10,15] (15,20]\n\nΔείτε τις οδηγίες και για άλλα χρήσιμα ορίσματα, όπως το right και το include.lowest, τα οποία ελέγχουν εάν τα διαστήματα είναι [a, b) ή (a, b] και εάν το χαμηλότερο διάστημα πρέπει να είναι [a, b].\n\n13.4.7 Συσσωρευτικά και κυλιόμενα σύνολα\nΤο βασικό πακέτο λειτουργιών της R παρέχει τις συναρτήσεις cumsum(), cumprod(), cummin(), cummax() για κυλιόμενα ή συσσωρευτικά αθροίσματα, γινόμενα, ελάχιστα και μέγιστα. Η dplyr παρέχει την cummean() για συσσωρευτικούς μέσους. Στην πράξη, τα συσσωρευτικά αθροίσματα τείνουν να προκύπτουν περισσότερο:\n\nx &lt;- 1:10\ncumsum(x)\n#&gt;  [1]  1  3  6 10 15 21 28 36 45 55\n\nΕάν χρειάζεστε πιο σύνθετα κυλιόμενα σύνολα, δοκιμάστε το πακέτο slider.\n\n13.4.8 Ασκήσεις\n\nΕξηγήστε με λόγια τι κάνει κάθε γραμμή του κώδικα που χρησιμοποιήθηκε για τη δημιουργία του Σχήμα 13.1.\nΠοιες τριγωνομετρικές συναρτήσεις παρέχει η R;\nΜαντέψτε μερικά ονόματα και αναζητήστε την τεκμηρίωση. Χρησιμοποιούν μοίρες ή ακτίνια;\n\nΠρος το παρόν, οι στήλες dep_time και sched_dep_time είναι χρήσιμες για να τις εξετάσει κανείς, αλλά είναι δύσκολο να χρησιμοποιηθούν σε υπολογισμούς, επειδή δεν είναι πραγματικά συνεχείς αριθμοί. Μπορείτε να παρατηρήσετε αυτό το βασικό πρόβλημα εκτελώντας τον παρακάτω κώδικα: υπάρχει ένα κενό μεταξύ κάθε ώρας.\n\nflights |&gt; \n  filter(month == 1, day == 1) |&gt; \n  ggplot(aes(x = sched_dep_time, y = dep_delay)) +\n  geom_point()\n\nΜετατρέψτε τες σε μία πιο πραγματική αναπαράσταση του χρόνου (είτε κλασματικές ώρες είτε λεπτά μετά τα μεσάνυχτα).\n\nΣτρογγυλοποιήστε τις dep_time και arr_time στα πιο κοντινά πέντε λεπτά.",
    "crumbs": [
      "Μετασχηματισμοί",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Αριθμητικά διανύσματα</span>"
    ]
  },
  {
    "objectID": "numbers.html#γενικοί-μετασχηματισμοί",
    "href": "numbers.html#γενικοί-μετασχηματισμοί",
    "title": "13  Αριθμητικά διανύσματα",
    "section": "\n13.5 Γενικοί μετασχηματισμοί",
    "text": "13.5 Γενικοί μετασχηματισμοί\nΟι ακόλουθες ενότητες περιγράφουν ορισμένους γενικούς μετασχηματισμούς που χρησιμοποιούνται συχνά με αριθμητικά διανύσματα, αλλά μπορούν να εφαρμοστούν σε όλους τους άλλους τύπους στηλών.\n\n13.5.1 Κατατάξεις\nΗ dplyr παρέχει μία σειρά από συναρτήσεις κατάταξης εμπνευσμένες από την SQL, αλλά θα πρέπει πάντα να ξεκινάτε με την dplyr::min_rank(). Αυτή χρησιμοποιεί την συνηθισμένη μέθοδο για τον χειρισμό της ισοπαλίας, π.χ., 1ος, 2ος, 2ος, 4ος.\n\nx &lt;- c(1, 2, 2, 3, 4, NA)\nmin_rank(x)\n#&gt; [1]  1  2  2  4  5 NA\n\nΣημειώστε ότι οι μικρότερες τιμές λαμβάνουν τις χαμηλότερες κατατάξεις. Χρησιμοποιήστε την desc(x) για να δώσετε στις μεγαλύτερες τιμές τις μικρότερες κατατάξεις:\n\nmin_rank(desc(x))\n#&gt; [1]  5  3  3  2  1 NA\n\nΕάν η min_rank() δεν κάνει αυτό που χρειάζεστε, εξερευνήστε τις παραλλαγές dplyr::row_number(), dplyr::dense_rank(), dplyr::percent_rank() και dplyr:: cume_dist(). Δείτε τις οδηγίες για λεπτομέρειες.\n\ndf &lt;- tibble(x = x)\ndf |&gt; \n  mutate(\n    row_number = row_number(x),\n    dense_rank = dense_rank(x),\n    percent_rank = percent_rank(x),\n    cume_dist = cume_dist(x)\n  )\n#&gt; # A tibble: 6 × 5\n#&gt;       x row_number dense_rank percent_rank cume_dist\n#&gt;   &lt;dbl&gt;      &lt;int&gt;      &lt;int&gt;        &lt;dbl&gt;     &lt;dbl&gt;\n#&gt; 1     1          1          1         0          0.2\n#&gt; 2     2          2          2         0.25       0.6\n#&gt; 3     2          3          2         0.25       0.6\n#&gt; 4     3          4          3         0.75       0.8\n#&gt; 5     4          5          4         1          1  \n#&gt; 6    NA         NA         NA        NA         NA\n\nΜπορείτε να πετύχετε ίδια αποτελέσματα με πολλές από τις παραπάνω συναρτήσεις επιλέγοντας την κατάλληλη τιμή στο όρισμα ties.method στην rank() του βασικού πακέτου λειτουργιών της R. Πιθανότατα θα θέλετε επίσης να ορίσετε το na.last = \"keep\" για να διατηρήσετε τα NA ως NA.\nΗ row_number() μπορεί επίσης να χρησιμοποιηθεί χωρίς ορίσματα όταν βρίσκεται μέσα σε μία συνάρτηση της dplyr. Σε αυτήν την περίπτωση, θα δώσει τον αριθμό της “τρέχουσας” γραμμής. Επιπλέον, όταν συνδυαστεί με το %% ή το %/%, μπορεί να γίνει ένα χρήσιμο εργαλείο για τη διαίρεση δεδομένων σε ομάδες παρόμοιου μεγέθους:\n\ndf &lt;- tibble(id = 1:10)\n\ndf |&gt; \n  mutate(\n    row0 = row_number() - 1,\n    three_groups = row0 %% 3,\n    three_in_each_group = row0 %/% 3\n  )\n#&gt; # A tibble: 10 × 4\n#&gt;      id  row0 three_groups three_in_each_group\n#&gt;   &lt;int&gt; &lt;dbl&gt;        &lt;dbl&gt;               &lt;dbl&gt;\n#&gt; 1     1     0            0                   0\n#&gt; 2     2     1            1                   0\n#&gt; 3     3     2            2                   0\n#&gt; 4     4     3            0                   1\n#&gt; 5     5     4            1                   1\n#&gt; 6     6     5            2                   1\n#&gt; # ℹ 4 more rows\n\n\n13.5.2 Ορίσματα μετατόπισης\nΟι dplyr::lead() και dplyr::lag() σας επιτρέπουν να αναφερθείτε στις τιμές ακριβώς πριν ή αμέσως μετά την “τρέχουσα” τιμή. Επιστρέφουν ένα διάνυσμα του ίδιου μήκους με την είσοδο, με πρόσθετες τιμές NA στην αρχή ή στο τέλος:\n\nx &lt;- c(2, 5, 11, 11, 19, 35)\nlag(x)\n#&gt; [1] NA  2  5 11 11 19\nlead(x)\n#&gt; [1]  5 11 11 19 35 NA\n\n\n\nΤο x - lag(x) σας δίνει τη διαφορά μεταξύ της τρέχουσας και της προηγούμενης τιμής.\n\nx - lag(x)\n#&gt; [1] NA  3  6  0  8 16\n\n\n\nΤο x == lag(x) σας λέει πότε αλλάζει η τρέχουσα τιμή.\n\nx == lag(x)\n#&gt; [1]    NA FALSE FALSE  TRUE FALSE FALSE\n\n\n\nΜπορείτε να πάρετε τιμές πριν και μετά, κατά περισσότερες από μία θέσεις, χρησιμοποιώντας το δεύτερο όρισμα, n.\n\n13.5.3 Διαδοχικά αναγνωριστικά\nΜερικές φορές θέλετε να ξεκινήσετε μία νέα ομάδα κάθε φορά που κάποιο συμβάν λαμβάνει χώρα. Για παράδειγμα, όταν έχετε να κάνετε με δεδομένα ιστοτόπου, είναι σύνηθες να θέλετε να χωρίσετε τα συμβάντα σε περιόδους σύνδεσης, ξεκινώντας μία νέα περίοδο μετά από ένα κενό άνω των x λεπτών από την τελευταία δραστηριότητα. Για παράδειγμα, φανταστείτε ότι έχετε τις στιγμές που κάποιος επισκέφτηκε έναν ιστότοπο:\n\nevents &lt;- tibble(\n  time = c(0, 1, 2, 3, 5, 10, 12, 15, 17, 19, 20, 27, 28, 30)\n)\n\nΈχετε υπολογίσει το χρόνο μεταξύ κάθε γεγονότος και έχετε βρει εάν υπάρχει κάποιο κενό αρκετά μεγάλο για να πληροί τις προϋποθέσεις:\n\nevents &lt;- events |&gt; \n  mutate(\n    diff = time - lag(time, default = first(time)),\n    has_gap = diff &gt;= 5\n  )\nevents\n#&gt; # A tibble: 14 × 3\n#&gt;    time  diff has_gap\n#&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;lgl&gt;  \n#&gt; 1     0     0 FALSE  \n#&gt; 2     1     1 FALSE  \n#&gt; 3     2     1 FALSE  \n#&gt; 4     3     1 FALSE  \n#&gt; 5     5     2 FALSE  \n#&gt; 6    10     5 TRUE   \n#&gt; # ℹ 8 more rows\n\nΑλλά πώς πηγαίνουμε από αυτό το λογικό διάνυσμα σε κάτι που μπορούμε να εφαρμόσουμε την group_by();\nH cumsum(), από την Ενότητα 13.4.7, σώζει την κατάσταση, καθώς όταν η has_gap είναι TRUE, θα αυξήσει την group κατά ένα (Ενότητα 12.4.2):\n\nevents |&gt; mutate(\n  group = cumsum(has_gap)\n)\n#&gt; # A tibble: 14 × 4\n#&gt;    time  diff has_gap group\n#&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;lgl&gt;   &lt;int&gt;\n#&gt; 1     0     0 FALSE       0\n#&gt; 2     1     1 FALSE       0\n#&gt; 3     2     1 FALSE       0\n#&gt; 4     3     1 FALSE       0\n#&gt; 5     5     2 FALSE       0\n#&gt; 6    10     5 TRUE        1\n#&gt; # ℹ 8 more rows\n\nΜία άλλη προσέγγιση για τη δημιουργία μεταβλητών ομαδοποίησης είναι η consecutive_id(), η οποία ξεκινά μία νέα ομάδα κάθε φορά που αλλάζει ένα από τα ορίσματά της. Για παράδειγμα, εμπνευσμένο από αυτή την ερώτηση στο stackoverflow, φανταστείτε ότι έχετε ένα πλαίσιο δεδομένων με επαναλαμβανόμενες τιμές:\n\ndf &lt;- tibble(\n  x = c(\"a\", \"a\", \"a\", \"b\", \"c\", \"c\", \"d\", \"e\", \"a\", \"a\", \"b\", \"b\"),\n  y = c(1, 2, 3, 2, 4, 1, 3, 9, 4, 8, 10, 199)\n)\n\nΕάν θέλετε να διατηρήσετε την πρώτη γραμμή από κάθε επαναλαμβανόμενο x, μπορείτε να χρησιμοποιήσετε τις group_by(), consecutive_id() και slice_head():\n\ndf |&gt; \n  group_by(id = consecutive_id(x)) |&gt; \n  slice_head(n = 1)\n#&gt; # A tibble: 7 × 3\n#&gt; # Groups:   id [7]\n#&gt;   x         y    id\n#&gt;   &lt;chr&gt; &lt;dbl&gt; &lt;int&gt;\n#&gt; 1 a         1     1\n#&gt; 2 b         2     2\n#&gt; 3 c         4     3\n#&gt; 4 d         3     4\n#&gt; 5 e         9     5\n#&gt; 6 a         4     6\n#&gt; # ℹ 1 more row\n\n\n13.5.4 Ασκήσεις\n\nΒρείτε τις 10 πτήσεις με τις περισσότερες καθυστερήσεις χρησιμοποιώντας μία συνάρτηση κατάταξης. Πώς θέλετε να χειριστείτε τις ισοπαλίες;\nΔιαβάστε προσεκτικά τις οδηγίες για την min_rank().\nΠοιο αεροπλάνο (tailnum) έχει το χειρότερο ρεκόρ για το εάν είναι στην ώρα του;\nΠοια ώρα της ημέρας πρέπει να πετάξετε αν θέλετε να αποφύγετε όσο το δυνατόν περισσότερες καθυστερήσεις;\nΤι κάνει το flights |&gt; group_by(dest) |&gt; filter(row_number() &lt; 4);\nΤι κάνει το flights |&gt; group_by(dest) |&gt; filter(row_number(dep_delay) &lt; 4);\nΓια κάθε προορισμό, υπολογίστε τα συνολικά λεπτά καθυστέρησης. Για κάθε πτήση, υπολογίστε το ποσοστό της συνολικής καθυστέρησης για τον προορισμό της.\n\nΟι καθυστερήσεις συνήθως συσχετίζονται χρονικά: ακόμη και όταν επιλυθεί το πρόβλημα που προκάλεσε την αρχική καθυστέρηση, οι μεταγενέστερες πτήσεις καθυστερούν για να επιτραπεί η αναχώρηση των προηγούμενων πτήσεων. Χρησιμοποιώντας την lag(), εξερευνήστε πώς η μέση καθυστέρηση πτήσης για μία ώρα σχετίζεται με τη μέση καθυστέρηση για την προηγούμενη ώρα.\n\nflights |&gt; \n  mutate(hour = dep_time %/% 100) |&gt; \n  group_by(year, month, day, hour) |&gt; \n  summarize(\n    dep_delay = mean(dep_delay, na.rm = TRUE),\n    n = n(),\n    .groups = \"drop\"\n  ) |&gt; \n  filter(n &gt; 5)\n\n\nΠαρατηρήστε κάθε προορισμό. Μπορείτε να βρείτε πτήσεις που είναι ύποπτα γρήγορες (δηλαδή πτήσεις που παρουσιάζουν ένα πιθανό σφάλμα εισαγωγής δεδομένων);\nΥπολογίστε τον χρόνο που βρίσκεται στον αέρα μία πτήση, σε σχέση με τη συντομότερη πτήση προς αυτόν τον προορισμό. Ποιες πτήσεις καθυστέρησαν περισσότερο στον αέρα;\nΒρείτε όλους τους προορισμούς που πραγματοποιούν πτήσεις από τουλάχιστον δύο εταιρίες. Χρησιμοποιήστε αυτούς τους προορισμούς για να καταλήξετε σε μία σχετική κατάταξη των αερομεταφορέων με βάση την απόδοσή τους για τον ίδιο προορισμό.",
    "crumbs": [
      "Μετασχηματισμοί",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Αριθμητικά διανύσματα</span>"
    ]
  },
  {
    "objectID": "numbers.html#αριθμητικές-συνόψεις",
    "href": "numbers.html#αριθμητικές-συνόψεις",
    "title": "13  Αριθμητικά διανύσματα",
    "section": "\n13.6 Αριθμητικές συνόψεις",
    "text": "13.6 Αριθμητικές συνόψεις\nΗ χρήση των καταμετρήσεων, των μέσων και των αθροισμάτων που έχουμε ήδη παρουσιάσει μπορεί να σας βοηθήσει αρκετά, αλλά η R παρέχει πολλές άλλες χρήσιμες συναρτήσεις σύνοψης. Παρακάτω υπάρχουν επιλογές που μπορεί να σας φανούν χρήσιμες.\n\n13.6.1 Κεντρική θέση\nΜέχρι στιγμής, χρησιμοποιούσαμε κυρίως την mean() για να συνοψίσουμε το κέντρο ενός διανύσματος τιμών. Όπως είδαμε στην Ενότητα 3.6, επειδή ο μέσος όρος είναι το άθροισμα διαιρούμενο με το πλήθος, είναι ευαίσθητο ακόμη και σε λίγες ασυνήθιστα υψηλές ή χαμηλές τιμές. Μία εναλλακτική λύση είναι να χρησιμοποιήσετε την median(), η οποία βρίσκει μία τιμή που βρίσκεται στη “μέση” του διανύσματος, δηλαδή το 50% των τιμών είναι πάνω από αυτό και το άλλο 50% είναι κάτω από αυτό. Ανάλογα με το σχήμα της κατανομής της μεταβλητής που σας ενδιαφέρει, ο καλύτερος υπολογισμός του κέντρου μπορεί να γίνει είτε μέσα από τον μέσο όρο είτε μέσα από την διάμεσο. Για παράδειγμα, για συμμετρικές κατανομές αναφέρουμε γενικά τη μέση τιμή ενώ για λοξές (ασύμμετρες) κατανομές συνήθως αναφέρουμε τη διάμεσο.\nΤο Σχήμα 13.2 συγκρίνει τη μέση με τη διάμεση καθυστέρηση αναχώρησης (σε λεπτά) για κάθε προορισμό. Η διάμεση καθυστέρηση είναι πάντα μικρότερη από τη μέση καθυστέρηση, επειδή οι πτήσεις μερικές φορές αναχωρούν με καθυστέρηση πολλών ωρών, αλλά ποτέ δεν αναχωρούν πολλές ώρες νωρίτερα.\n\nflights |&gt;\n  group_by(year, month, day) |&gt;\n  summarize(\n    mean = mean(dep_delay, na.rm = TRUE),\n    median = median(dep_delay, na.rm = TRUE),\n    n = n(),\n    .groups = \"drop\"\n  ) |&gt; \n  ggplot(aes(x = mean, y = median)) + \n  geom_abline(slope = 1, intercept = 0, color = \"white\", linewidth = 2) +\n  geom_point()\n\n\n\n\n\n\nΣχήμα 13.2: Ένα διάγραμμα διασποράς που δείχνει τις διαφορές της σύνοψης της ημερήσιας καθυστέρησης αναχώρησης με την διάμεσο αντί για τον μέσο όρο.\n\n\n\n\nΜπορεί επίσης να αναρωτιέστε για την επικρατούσα τιμή ή την πιο συχνή τιμή. Αυτή είναι μία σύνοψη που λειτουργεί καλά μόνο για πολύ απλές περιπτώσεις (γι’ αυτό μπορεί να την έχετε μάθει στο λύκειο), αλλά δεν λειτουργεί καλά για πολλά πραγματικά σύνολα δεδομένων. Εάν τα δεδομένα είναι διακριτά, μπορεί να υπάρχουν πολλαπλές κοινές τιμές και εάν τα δεδομένα είναι συνεχή, μπορεί να μην υπάρχει πιο κοινή τιμή επειδή κάθε τιμή είναι πάντα ελαφρώς διαφορετική. Για αυτούς τους λόγους, η επικρατούσα τιμή τείνει να μην χρησιμοποιείται από στατιστικολόγους και δεν περιλαμβάνεται σε κάποια συνάρτηση του βασικού πακέτου λειτουργιών της R2.\n\n13.6.2 Ελάχιστα, μέγιστα και ποσοστηµόρια\nΤι γίνεται αν ενδιαφέρεστε για άλλες θέσεις εκτός από το κέντρο;\nΟι min() και max() θα σας δώσουν τις μεγαλύτερες και τις μικρότερες τιμές αντίστοιχα. Ένα άλλο ισχυρό εργαλείο είναι η συνάρτηση quantile() που είναι μία γενίκευση της διάμεσης τιμής: η quantile(x, 0.25) θα βρει την τιμή του x που είναι μεγαλύτερη από το 25% των τιμών, η quantile(x, 0.5) ισοδυναμεί με τη διάμεσο και η quantile(x, 0.95) θα βρει την τιμή που είναι μεγαλύτερη από το 95% των τιμών.\nΓια το σύνολο δεδομένων flights, ίσως θελήσετε να εξετάσετε το 95% των καθυστερήσεων και όχι τον μέγιστο αριθμό, καθώς θα αγνοήσει το 5% των περισσότερων καθυστερημένων πτήσεων, οι οποίες μπορεί να είναι αρκετά ακραίες.\n\nflights |&gt;\n  group_by(year, month, day) |&gt;\n  summarize(\n    max = max(dep_delay, na.rm = TRUE),\n    q95 = quantile(dep_delay, 0.95, na.rm = TRUE),\n    .groups = \"drop\"\n  )\n#&gt; # A tibble: 365 × 5\n#&gt;    year month   day   max   q95\n#&gt;   &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt;\n#&gt; 1  2013     1     1   853  70.1\n#&gt; 2  2013     1     2   379  85  \n#&gt; 3  2013     1     3   291  68  \n#&gt; 4  2013     1     4   288  60  \n#&gt; 5  2013     1     5   327  41  \n#&gt; 6  2013     1     6   202  51  \n#&gt; # ℹ 359 more rows\n\n\n13.6.3 Έκταση\nΜερικές φορές δεν ενδιαφέρεστε τόσο για το πού βρίσκεται το μεγαλύτερο μέρος των δεδομένων, αλλά για το πώς εκτείνονται τα δεδομένα. Δύο συνόψεις που χρησιμοποιούνται συνήθως είναι η τυπική απόκλιση, sd(x), και το ενδοτεταρτημοριακό εύρος, IQR(). Δεν θα εξηγήσουμε την sd() εδώ, καθώς πιθανώς το γνωρίζετε ήδη, η IQR() όμως μπορεί να είναι νέα για εσάς — στην ουσία είναι το αποτέλεσμα του quantile(x, 0.75) - quantile(x, 0.25) και σας δίνει το εύρος που περιέχει το μεσαίο 50% των δεδομένων.\nΜπορούμε να το χρησιμοποιήσουμε για να αποκαλύψουμε μία μικρή ιδιορρυθμία στα δεδομένα του flights. Μπορεί να περιμένετε ότι η έκταση της απόστασης μεταξύ προέλευσης και προορισμού θα είναι μηδενική, καθώς τα αεροδρόμια βρίσκονται πάντα στο ίδιο σημείο. Ο παρακάτω κώδικας όμως αποκαλύπτει κάτι περίεργο για το αεροδρόμιο EGE:\n\nflights |&gt; \n  group_by(origin, dest) |&gt; \n  summarize(\n    distance_iqr = IQR(distance), \n    n = n(),\n    .groups = \"drop\"\n  ) |&gt; \n  filter(distance_iqr &gt; 0)\n#&gt; # A tibble: 2 × 4\n#&gt;   origin dest  distance_iqr     n\n#&gt;   &lt;chr&gt;  &lt;chr&gt;        &lt;dbl&gt; &lt;int&gt;\n#&gt; 1 EWR    EGE              1   110\n#&gt; 2 JFK    EGE              1   103\n\n\n13.6.4 Κατανομές\nΑξίζει να θυμάστε ότι όλα τα στατιστικά στοιχεία σύνοψης που περιγράφονται παραπάνω είναι ένας τρόπος συμπύκνωσης της κατανομής σε έναν μόνο αριθμό. Αυτό σημαίνει ότι είναι θεμελιωδώς αναγωγικά και αν επιλέξετε λάθος σύνοψη, μπορείτε εύκολα να χάσετε σημαντικές διαφορές μεταξύ ομάδων. Γι’ αυτό, είναι πάντα καλή ιδέα να οπτικοποιείτε τη κατανομή προτού αποφασίσετε για τα στατιστικά σύνοψης σας.\nΤο Σχήμα 13.3 δείχνει τη συνολική κατανομή των καθυστερήσεων αναχώρησης. Η κατανομή είναι τόσο λοξή που πρέπει να εστιάσουμε κατάλληλα για να δούμε το μεγαλύτερο μέρος των δεδομένων. Αυτό υποδηλώνει ότι ο μέσος όρος είναι απίθανο να δώσει μία καλή σύνοψη και ίσως προτιμήσουμε τη διάμεσο.\n\n\n\n\n\n\n\nΣχήμα 13.3: (Αριστερά) Το ιστόγραμμα όλων των δεδομένων είναι εξαιρετικά λοξό, καθιστώντας την λήψη πληροφοριών δύσκολη. (Δεξιά) Η εστίαση στις καθυστερήσεις μικρότερες των δύο ωρών καθιστά δυνατή την εξερεύνηση του μεγαλύτερο μέρος των παρατηρήσεων.\n\n\n\n\nΕίναι επίσης καλή ιδέα να ελέγξετε ότι οι κατανομές των υποομάδων μοιάζουν με το σύνολο. Στο ακόλουθο διάγραμμα βλέπουμε να επικαλύπτονται 365 πολύγωνα συχνότητας της μεταβλητής dep_delay, ένα για κάθε ημέρα. Οι κατανομές φαίνεται να ακολουθούν ένα κοινό μοτίβο, υποδηλώνοντας ότι είναι καλό να χρησιμοποιείτε την ίδια σύνοψη για κάθε μέρα.\n\nflights |&gt;\n  filter(dep_delay &lt; 120) |&gt; \n  ggplot(aes(x = dep_delay, group = interaction(day, month))) + \n  geom_freqpoly(binwidth = 5, alpha = 1/5)\n\n\n\n\n\n\n\nΜην φοβάστε να εξερευνήσετε τις δικές σας συνόψεις που είναι ειδικά προσαρμοσμένες για τα δεδομένα με τα οποία εργάζεστε. Σε αυτήν την περίπτωση, αυτό μπορεί να σημαίνει την δημιουργία ξεχωριστής σύνοψης για τις πτήσεις που αναχώρησαν νωρίς έναντι των πτήσεων που αναχώρησαν αργά ή, δεδομένου ότι οι τιμές είναι τόσο πολύ λοξές, μπορείτε να δοκιμάσετε έναν λογαριθμικό μετασχηματισμό. Τέλος, μην ξεχνάτε τι μάθατε στην Ενότητα 3.6: κάθε φορά που δημιουργείτε αριθμητικές συνόψεις, είναι καλή ιδέα να συμπεριλαμβάνετε και τον αριθμό των παρατηρήσεων σε κάθε ομάδα.\n\n13.6.5 Θέσεις\nΥπάρχει ένας τελικός τύπος σύνοψης που είναι χρήσιμος για αριθμητικά διανύσματα, αλλά λειτουργεί επίσης και με κάθε άλλο τύπο τιμής: η εξαγωγή μιας τιμής που βρίσκεται σε μία συγκεκριμένη θέση: first(x), last(x) και nth(x, n).\nΓια παράδειγμα, μπορούμε να βρούμε την πρώτη, την πέμπτη και την τελευταία αναχώρηση για κάθε ημέρα:\n\nflights |&gt; \n  group_by(year, month, day) |&gt; \n  summarize(\n    first_dep = first(dep_time, na_rm = TRUE), \n    fifth_dep = nth(dep_time, 5, na_rm = TRUE),\n    last_dep = last(dep_time, na_rm = TRUE)\n  )\n#&gt; `summarise()` has grouped output by 'year', 'month'. You can override using\n#&gt; the `.groups` argument.\n#&gt; # A tibble: 365 × 6\n#&gt; # Groups:   year, month [12]\n#&gt;    year month   day first_dep fifth_dep last_dep\n#&gt;   &lt;int&gt; &lt;int&gt; &lt;int&gt;     &lt;int&gt;     &lt;int&gt;    &lt;int&gt;\n#&gt; 1  2013     1     1       517       554     2356\n#&gt; 2  2013     1     2        42       535     2354\n#&gt; 3  2013     1     3        32       520     2349\n#&gt; 4  2013     1     4        25       531     2358\n#&gt; 5  2013     1     5        14       534     2357\n#&gt; 6  2013     1     6        16       555     2355\n#&gt; # ℹ 359 more rows\n\n(Σημείωση: Επειδή οι συναρτήσεις της dplyr χρησιμοποιούν το _ για να διαχωρίσουν τα στοιχεία των ονομάτων και των ορισμάτων τους, οι συναρτήσεις αυτές χρησιμοποιούν το na_rm αντί για το na.rm.)\nΕάν είστε εξοικειωμένοι με το [, στο οποίο θα επανέλθουμε στην Ενότητα 27.2, ίσως αναρωτηθείτε εάν οι συναρτήσεις αυτές θα σας χρειαστούν. Υπάρχουν τρεις λόγοι: το όρισμα default σας επιτρέπει να παρέχετε μία προεπιλογή εάν δεν υπάρχει η καθορισμένη θέση, το όρισμα order_by σας επιτρέπει να παρακάμψετε τοπικά τη σειρά των γραμμών και το όρισμα na_rm σας επιτρέπει να απορρίψετε τις κενές τιμές.\nΗ εξαγωγή τιμών βάσει θέσης είναι συμπληρωματική στο φιλτράρισμα στις κατατάξεις. Το φιλτράρισμα σας δίνει όλες τις μεταβλητές, με κάθε παρατήρηση να βρίσκετε σε ξεχωριστή γραμμή:\n\nflights |&gt; \n  group_by(year, month, day) |&gt; \n  mutate(r = min_rank(sched_dep_time)) |&gt; \n  filter(r %in% c(1, max(r)))\n#&gt; # A tibble: 1,195 × 20\n#&gt; # Groups:   year, month, day [365]\n#&gt;    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n#&gt;   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;\n#&gt; 1  2013     1     1      517            515         2      830            819\n#&gt; 2  2013     1     1     2353           2359        -6      425            445\n#&gt; 3  2013     1     1     2353           2359        -6      418            442\n#&gt; 4  2013     1     1     2356           2359        -3      425            437\n#&gt; 5  2013     1     2       42           2359        43      518            442\n#&gt; 6  2013     1     2      458            500        -2      703            650\n#&gt; # ℹ 1,189 more rows\n#&gt; # ℹ 12 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;, …\n\n\n13.6.6 Με την mutate()\n\nΌπως υποδηλώνει και το όνομα, οι συναρτήσεις σύνοψης συνήθως πάνε μαζί με την summarize(). Ωστόσο, λόγω των κανόνων ανακύκλωσης που συζητήσαμε στην Ενότητα 13.4.1, μπορούν επίσης να συνδυαστούν αποτελεσματικά και με την mutate(), ειδικά όταν θέλετε να κάνετε κάποιο είδος ομαδικής τυποποίησης. Για παράδειγμα:\n\nΤο x / sum(x) υπολογίζει την αναλογία ενός συνόλου.\nΤο (x - mean(x)) / sd(x) υπολογίζει ένα Z-score (τυποποιημένο με μέσο όρο 0 και τυπική απόκλιση 1).\nΤο (x - min(x)) / (max(x) - min(x)) τυποποιεί στο εύρος [0, 1].\nΤο x / first(x) υπολογίζει έναν δείκτη με βάση την πρώτη παρατήρηση.\n\n13.6.7 Ασκήσεις\n\nΣκεφθείτε τουλάχιστον 5 διαφορετικούς τρόπους για να αξιολογήσετε τα τυπικά χαρακτηριστικά καθυστέρησης μιας ομάδας πτήσεων. Πότε είναι χρήσιμη η mean();\nΠότε είναι χρήσιμη η median();\nΠότε μπορεί να θέλετε να χρησιμοποιήσετε κάτι άλλο;\nΘα πρέπει να χρησιμοποιήσετε την καθυστέρηση άφιξης ή την καθυστέρηση αναχώρησης;\nΓιατί μπορεί να θέλετε να χρησιμοποιήσετε δεδομένα από την μεταβλητή planes;\nΠοιοι προορισμοί παρουσιάζουν τη μεγαλύτερη διακύμανση στην ταχύτητα του αέρα;\nΔημιουργήστε ένα διάγραμμα για να εξερευνήσετε περαιτέρω τις περιπέτειες του αεροδρομίου EGE. Μπορείτε να βρείτε αποδείξεις ότι το αεροδρόμιο άλλαξε τοποθεσίες;\nΜπορείτε να βρείτε κάποια άλλη μεταβλητή που θα μπορούσε να εξηγήσει τη διαφορά;",
    "crumbs": [
      "Μετασχηματισμοί",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Αριθμητικά διανύσματα</span>"
    ]
  },
  {
    "objectID": "numbers.html#σύνοψη",
    "href": "numbers.html#σύνοψη",
    "title": "13  Αριθμητικά διανύσματα",
    "section": "\n13.7 Σύνοψη",
    "text": "13.7 Σύνοψη\nΕίστε ήδη εξοικειωμένοι με πολλά εργαλεία για την εργασία με αριθμούς και, αφού διαβάσατε αυτό το κεφάλαιο, ξέρετε πλέον πώς να τα χρησιμοποιήσετε στην R. Έχετε μάθει επίσης λίγους χρήσιμους γενικούς μετασχηματισμούς που εφαρμόζονται συνήθως, αλλά όχι αποκλειστικά, σε αριθμητικά διανύσματα, όπως κατατάξεις και ορίσματα μετατόπισης. Τέλος, επεξεργαστήκατε μία σειρά από αριθμητικές συνόψεις και συζητήσατε μερικές από τις στατιστικές προκλήσεις που θα πρέπει να λάβετε υπόψη.\nΣτα επόμενα δύο κεφάλαια, θα ασχοληθούμε με την εργασία με συμβολοσειρές με το πακέτο stringr. Οι συμβολοσειρές αποτελούν μία μεγάλη θεματική ενότητα κι επομένως έχουν δύο κεφάλαια, ένα για τις βασικές αρχές των συμβολοσειρών, και ένα για τις κανονικές εκφράσεις.",
    "crumbs": [
      "Μετασχηματισμοί",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Αριθμητικά διανύσματα</span>"
    ]
  },
  {
    "objectID": "numbers.html#footnotes",
    "href": "numbers.html#footnotes",
    "title": "13  Αριθμητικά διανύσματα",
    "section": "",
    "text": "Η ggplot2 παρέχει μερικούς βοηθούς για συνήθεις περιπτώσεις με τις cut_interval(), cut_number() και cut_width(). Η ggplot2 είναι ένα ομολογουμένως περίεργο μέρος για να υπάρχουν αυτές οι συναρτήσεις, αλλά είναι χρήσιμες ως μέρος του υπολογισμού ενός ιστογράμματος και γράφτηκαν πριν από την ύπαρξη οποιουδήποτε άλλου τμήματος του tidyverse.↩︎\nΗ συνάρτηση mode() κάνει κάτι εντελώς διαφορετικό!↩︎",
    "crumbs": [
      "Μετασχηματισμοί",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Αριθμητικά διανύσματα</span>"
    ]
  },
  {
    "objectID": "strings.html",
    "href": "strings.html",
    "title": "14  Συμβολοσειρές",
    "section": "",
    "text": "14.1 Εισαγωγή\nΜέχρι στιγμής, έχετε χρησιμοποιήσει αρκετές συμβολοσειρές χωρίς αρκετό υπόβαθρο. Τώρα ήρθε η ώρα να εμβαθύνετε σε λεπτομέρειες και να μάθετε μερικά από τα ισχυρά εργαλεία χειρισμού συμβολοσειρών που έχετε διαθέσιμα.\nΘα ξεκινήσουμε με τις λεπτομέρειες της δημιουργίας συμβολοσειρών και διανυσμάτων χαρακτήρων. Στη συνέχεια, θα εμβαθύνετε στη δημιουργία συμβολοσειρών από δεδομένα και μετά στο αντίθετο: στην εξαγωγή συμβολοσειρών από δεδομένα. Στη συνέχεια θα συζητήσουμε για εργαλεία που λειτουργούν με μεμονωμένα γράμματα. Το κεφάλαιο ολοκληρώνεται με συναρτήσεις που λειτουργούν με μεμονωμένα γράμματα και μία σύντομη συζήτηση για το πως οι προσδοκίες σας από την αγγλική γλώσσα μπορούν να σας οδηγήσουν λανθασμένα όταν εργάζεστε με άλλες γλώσσες.\nΣτο επόμενο κεφάλαιο, θα συνεχίσουμε να εργαζόμαστε με συμβολοσειρές, όπου και θα μάθετε περισσότερα για τη δύναμη των κανονικών εκφράσεων.",
    "crumbs": [
      "Μετασχηματισμοί",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Συμβολοσειρές</span>"
    ]
  },
  {
    "objectID": "strings.html#εισαγωγή",
    "href": "strings.html#εισαγωγή",
    "title": "14  Συμβολοσειρές",
    "section": "",
    "text": "14.1.1 Προαπαιτούμενα\nΣε αυτό το κεφάλαιο, θα χρησιμοποιήσουμε συναρτήσεις από το πακέτο stringr, το οποίο αποτελεί μέρος του tidyverse. Θα χρησιμοποιήσουμε επίσης τα δεδομένα απο το σύνολο δεδομένων babynames, καθώς περιέχει μερικές διασκεδαστικές συμβολοσειρές για να χειριστούμε.\n\nlibrary(tidyverse)\nlibrary(babynames)\n\nΜπορείτε να καταλάβετε γρήγορα πότε χρησιμοποιείται μία συνάρτηση του πακέτου stringr επειδή όλες οι συναρτήσεις της ξεκινούν με str_. Αυτό είναι ιδιαίτερα χρήσιμο εάν χρησιμοποιείτε το RStudio, επειδή πληκτρολογώντας str_ θα ενεργοποιηθεί η αυτόματη συμπλήρωση, δίνοντάς σας την ευκαιρία να θυμηθείτε τις διαθέσιμες συναρτήσεις.",
    "crumbs": [
      "Μετασχηματισμοί",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Συμβολοσειρές</span>"
    ]
  },
  {
    "objectID": "strings.html#δημιουργώντας-μία-συμβολοσειρά",
    "href": "strings.html#δημιουργώντας-μία-συμβολοσειρά",
    "title": "14  Συμβολοσειρές",
    "section": "\n14.2 Δημιουργώντας μία συμβολοσειρά",
    "text": "14.2 Δημιουργώντας μία συμβολοσειρά\nΈχουμε δημιουργήσει συμβολοσειρές νωρίτερα στο βιβλίο, αλλά δεν συζητήσαμε για λεπτομέρειες. Αρχικά, μπορείτε να δημιουργήσετε μία συμβολοσειρά χρησιμοποιώντας είτε μονά εισαγωγικά (') είτε διπλά (\"). Δεν υπάρχει διαφορά στη συμπεριφορά μεταξύ των δύο, επομένως, για λόγους συνέπειας, ο οδηγός τρόπου γραφής του tidyverse συνιστά τη χρήση του \", εκτός εάν η συμβολοσειρά περιέχει πολλαπλά \".\n\nstring1 &lt;- \"This is a string\"\nstring2 &lt;- 'If I want to include a \"quote\" inside a string, I use single quotes'\n\nΕάν ξεχάσετε να κλείσετε κάποιο εισαγωγικό, θα δείτε το +, την εντολή επέκτασης:\n&gt; \"Αυτή είναι μία συμβολοσειρά χωρίς δεύτερο εισαγωγικό στο τέλος της\n+ \n+ \n+ ΛΙΓΗ ΒΟΗΘΕΙΑ ΠΑΡΑΚΑΛΩ ΕΧΩ ΚΟΛΛΗΣΕΙ ΣΕ ΜΙΑ ΣΥΜΒΟΛΟΔΕΙΡΑ\nΕάν σας συμβεί αυτό και δεν μπορείτε να καταλάβετε ποιο εισαγωγικό να κλείσετε, πατήστε το πλήκτρο Escape για ακύρωση της εκτέλεσης και δοκιμάστε ξανά.\n\n14.2.1 Χαρακτήρες διαφυγής\nΓια να συμπεριλάβετε ένα κυριολεκτικό μονό ή διπλό εισαγωγικό σε μία συμβολοσειρά, μπορείτε να χρησιμοποιήσετε το \\ για να το “φυγαδεύσετε”:\n\ndouble_quote &lt;- \"\\\"\" # or '\"'\nsingle_quote &lt;- '\\'' # or \"'\"\n\nΕπομένως, αν θέλετε να συμπεριλάβετε μία κυριολεκτική ανάποδη κάθετο στη συμβολοσειρά σας, θα πρέπει να την αποφύγετε: \"\\\\\":\n\nbackslash &lt;- \"\\\\\"\n\nΠροσέξτε ότι η εκτυπωμένη αναπαράσταση μιας συμβολοσειράς δεν είναι ίδια με την ίδια τη συμβολοσειρά, επειδή η εκτυπωμένη αναπαράσταση δείχνει τις διαφυγές (με άλλα λόγια, όταν εκτυπώνετε μία συμβολοσειρά, μπορείτε να αντιγράψετε και να επικολλήσετε την έξοδο για να δημιουργήσετε εκ νέου αυτήν τη συμβολοσειρά). Για να δείτε τα ακατέργαστα περιεχόμενα της συμβολοσειράς, χρησιμοποιήστε την str_view()1:\n\nx &lt;- c(single_quote, double_quote, backslash)\nx\n#&gt; [1] \"'\"  \"\\\"\" \"\\\\\"\n\nstr_view(x)\n#&gt; [1] │ '\n#&gt; [2] │ \"\n#&gt; [3] │ \\\n\n\n14.2.2 Ακατέργαστες συμβολοσειρές\nΗ δημιουργία μιας συμβολοσειράς με πολλαπλά εισαγωγικά ή ανάποδες καθέτους γίνεται γρήγορα πολύπλοκη. Για να δείξουμε το πρόβλημα, ας δημιουργήσουμε μία συμβολοσειρά που περιέχει τα περιεχόμενα του κώδικα όπου ορίζουμε τις μεταβλητές double_quote και single_quote:\n\ntricky &lt;- \"double_quote &lt;- \\\"\\\\\\\"\\\" # or '\\\"'\nsingle_quote &lt;- '\\\\'' # or \\\"'\\\"\"\nstr_view(tricky)\n#&gt; [1] │ double_quote &lt;- \"\\\"\" # or '\"'\n#&gt;     │ single_quote &lt;- '\\'' # or \"'\"\n\nΈχουμε πολλές ανάποδες καθέτους! (Μερικές φορές αυτό ονομάζεται σύνδρομο κεκλιμένης οδοντογλυφίδας (leaning toothpick syndrome).) Για να αποφύγετε τη διαφυγή, μπορείτε να χρησιμοποιήσετε μία ακατέργαστη συμβολοσειρά2:\n\ntricky &lt;- r\"(double_quote &lt;- \"\\\"\" # or '\"'\nsingle_quote &lt;- '\\'' # or \"'\")\"\nstr_view(tricky)\n#&gt; [1] │ double_quote &lt;- \"\\\"\" # or '\"'\n#&gt;     │ single_quote &lt;- '\\'' # or \"'\"\n\nΜία ακατέργαστη συμβολοσειρά αρχίζει συνήθως με r\"( και τελειώνει με )\". Αλλά αν η συμβολοσειρά σας περιέχει )\" μπορείτε αντ ’αυτού να χρησιμοποιήσετε το r\"[]\" ή το r\"{}\", και αν ακόμα κι αυτό δεν είναι αρκετό, μπορείτε να εισάγετε οποιονδήποτε αριθμό από παύλες για να κάνετε τα ζεύγη ανοίγματος και κλεισίματος μοναδικά, π.χ. r\"--()--\", r\"---()---\", κ.λπ. Οι ακατέργαστες συμβολοσειρές είναι αρκετά ευέλικτες ώστε να χειρίζονται οποιοδήποτε κείμενο.\n\n14.2.3 Λοιποί ειδικοί χαρακτήρες\nΕκτός από τους \\\", \\' και \\\\, υπάρχουν πολλοί άλλοι ειδικοί χαρακτήρες που μπορεί να σας φανούν χρήσιμοι. Οι πιο συνηθισμένοι είναι ο \\n, για τον ορισμό μιας νέας γραμμής και o \\t, για στηλοθέτες. Επίσης, μερικές φορές θα δείτε συμβολοσειρές που περιέχουν διαφυγές Unicode που ξεκινούν με \\u ή \\U. Αυτός είναι ένας τρόπος γραφής μη αγγλικών χαρακτήρων οι οποίοι λειτουργούν σε όλα τα συστήματα. Μπορείτε να δείτε την πλήρη λίστα των ειδικοί χαρακτήρες εκτελώντας το ?Quotes.\n\nx &lt;- c(\"one\\ntwo\", \"one\\ttwo\", \"\\u00b5\", \"\\U0001f604\")\nx\n#&gt; [1] \"one\\ntwo\" \"one\\ttwo\" \"µ\"        \"😄\"\nstr_view(x)\n#&gt; [1] │ one\n#&gt;     │ two\n#&gt; [2] │ one{\\t}two\n#&gt; [3] │ µ\n#&gt; [4] │ 😄\n\nΣημειώστε ότι η str_view() χρησιμοποιεί άγκιστρα για στηλοθέτες για να διευκολύνει τον εντοπισμό τους3. Μία από τις προκλήσεις που έχει η εργασία με κείμενο είναι ότι υπάρχουν διάφοροι τρόποι με τους οποίους ένας κενός χαρακτήρας μπορεί να βρεθεί στο κείμενο, επομένως αυτή η εισαγωγή σας βοηθά να αναγνωρίσετε ότι κάτι πάει στραβά.\n\n14.2.4 Ασκήσεις\n\n\nΔημιουργήστε συμβολοσειρές που περιέχουν τις ακόλουθες τιμές:\n\nHe said \"That's amazing!\"\n\\a\\b\\c\\d\n\\\\\\\\\\\\\n\n\n\nΔημιουργήστε την ακόλουθη συμβολοσειρά στην R και εκτυπώστε την. Τι συμβαίνει με το ειδικό “\\u00a0”;/ Πώς τον εμφανίζει η str_view();\nΜπορείτε να κάνετε λίγο γκουγκλάρισμα για να καταλάβετε ποιος είναι αυτός ο ιδιαίτερος χαρακτήρας;\n\nx &lt;- \"This\\u00a0is\\u00a0tricky\"",
    "crumbs": [
      "Μετασχηματισμοί",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Συμβολοσειρές</span>"
    ]
  },
  {
    "objectID": "strings.html#δημιουργία-πολλαπλών-συμβολοσειρών-από-δεδομένα",
    "href": "strings.html#δημιουργία-πολλαπλών-συμβολοσειρών-από-δεδομένα",
    "title": "14  Συμβολοσειρές",
    "section": "\n14.3 Δημιουργία πολλαπλών συμβολοσειρών από δεδομένα",
    "text": "14.3 Δημιουργία πολλαπλών συμβολοσειρών από δεδομένα\nΤώρα που έχετε μάθει τα βασικά για τη δημιουργία μιας συμβολοσειράς “με το χέρι”, θα μεταφερθούμε στις λεπτομέρειες της δημιουργίας συμβολοσειρών από άλλες συμβολοσειρές. Αυτό θα σας βοηθήσει να λύσετε το συχνό πρόβλημα στο οποίο έχετε κάποιο κείμενο που γράψατε και θέλετε να το συνδυάσετε με συμβολοσειρές που βρίσκονται σε ένα πλαίσιο δεδομένων. Για παράδειγμα, μπορείτε να συνδυάσετε το “Hello” με μία μεταβλητή που προσδιορίζει ένα όνομα name, για να δημιουργήσετε έναν χαιρετισμό. Θα σας δείξουμε πώς να το κάνετε με τις str_c() και str_glue(), και πώς μπορείτε να τις χρησιμοποιήσετε με την mutate(). Αυτό εγείρει φυσικά το ερώτημα ποιες συναρτήσεις του πακέτου stringr μπορείτε να χρησιμοποιήσετε με την summarize(), οπότε θα ολοκληρώσουμε αυτήν την ενότητα με μία συζήτηση για την str_flatten(), μία συνάρτηση σύνοψης για συμβολοσειρές.\n\n14.3.1 str_c()\n\nΗ str_c() παίρνει οποιονδήποτε αριθμό διανυσμάτων ως όρισμα και επιστρέφει ένα διάνυσμα χαρακτήρων:\n\nstr_c(\"x\", \"y\")\n#&gt; [1] \"xy\"\nstr_c(\"x\", \"y\", \"z\")\n#&gt; [1] \"xyz\"\nstr_c(\"Hello \", c(\"John\", \"Susan\"))\n#&gt; [1] \"Hello John\"  \"Hello Susan\"\n\nΗ str_c() είναι παρόμοια με την βασική συνάρτηση paste0(), αλλά έχει σχεδιαστεί για να χρησιμοποιείται μαζί με την mutate(), υπακούοντας στους συνήθεις κανόνες τακτοποίησης για την ανακύκλωση και τη διαχείριση κενών τιμών:\n\ndf &lt;- tibble(name = c(\"Flora\", \"David\", \"Terra\", NA))\ndf |&gt; mutate(greeting = str_c(\"Hi \", name, \"!\"))\n#&gt; # A tibble: 4 × 2\n#&gt;   name  greeting \n#&gt;   &lt;chr&gt; &lt;chr&gt;    \n#&gt; 1 Flora Hi Flora!\n#&gt; 2 David Hi David!\n#&gt; 3 Terra Hi Terra!\n#&gt; 4 &lt;NA&gt;  &lt;NA&gt;\n\nΕάν θέλετε οι κενές τιμές να εμφανίζονται με άλλο τρόπο, χρησιμοποιήστε την coalesce() για να τις αντικαταστήσετε. Ανάλογα με το τι θέλετε κάθε φορά, μπορείτε να την χρησιμοποιήσετε είτε εντός, είτε εκτός της str_c():\n\ndf |&gt; \n  mutate(\n    greeting1 = str_c(\"Hi \", coalesce(name, \"you\"), \"!\"),\n    greeting2 = coalesce(str_c(\"Hi \", name, \"!\"), \"Hi!\")\n  )\n#&gt; # A tibble: 4 × 3\n#&gt;   name  greeting1 greeting2\n#&gt;   &lt;chr&gt; &lt;chr&gt;     &lt;chr&gt;    \n#&gt; 1 Flora Hi Flora! Hi Flora!\n#&gt; 2 David Hi David! Hi David!\n#&gt; 3 Terra Hi Terra! Hi Terra!\n#&gt; 4 &lt;NA&gt;  Hi you!   Hi!\n\n\n14.3.2 str_glue()\n\nΕάν βάζετε μαζί πολλές σταθερές και μεταβλητές συμβολοσειρές με την str_c(), θα παρατηρήσετε ότι πληκτρολογείτε πολλά \", κάνοντας εύκολο τον αποπροσανατολισμό σας από τον τελικό στόχο του κώδικα. Μία εναλλακτική προσέγγιση παρέχεται από το πακέτο glue μέσω της str_glue()4. Εσείς δίνετε μόνο μία συμβολοσειρά με ένα ειδικό χαρακτηριστικό: οτιδήποτε βρίσκεται μέσα στα {} θα αξιολογηθεί σαν να είναι έξω από τα εισαγωγικά:\n\ndf |&gt; mutate(greeting = str_glue(\"Hi {name}!\"))\n#&gt; # A tibble: 4 × 2\n#&gt;   name  greeting \n#&gt;   &lt;chr&gt; &lt;glue&gt;   \n#&gt; 1 Flora Hi Flora!\n#&gt; 2 David Hi David!\n#&gt; 3 Terra Hi Terra!\n#&gt; 4 &lt;NA&gt;  Hi NA!\n\nΌπως μπορείτε να δείτε, η str_glue() μετατρέπει αυτήν τη στιγμή τις τιμές που λείπουν στη συμβολοσειρά \"NA\", καθιστώντας το, δυστυχώς, ασυνεπές με το str_c().\nΜπορεί επίσης να αναρωτιέστε τι συμβαίνει εάν χρειαστεί να συμπεριλάβετε ένα κανονικό { ή } στη συμβολοσειρά σας. Είστε σε καλό δρόμο αν μαντέψετε ότι θα χρειαστεί με κάποιο τρόπο να το διαφύγετε. Το κόλπο είναι ότι το πακέτο glue χρησιμοποιεί μία ελαφρώς διαφορετική τεχνική διαφυγής: αντί να προσθέτει κάποιο πρόθεμα ειδικού χαρακτήρα όπως το \\, διπλασιάζει τους ειδικούς χαρακτήρες:\n\ndf |&gt; mutate(greeting = str_glue(\"{{Hi {name}!}}\"))\n#&gt; # A tibble: 4 × 2\n#&gt;   name  greeting   \n#&gt;   &lt;chr&gt; &lt;glue&gt;     \n#&gt; 1 Flora {Hi Flora!}\n#&gt; 2 David {Hi David!}\n#&gt; 3 Terra {Hi Terra!}\n#&gt; 4 &lt;NA&gt;  {Hi NA!}\n\n\n14.3.3 str_flatten()\n\nΗ str_c() και η str_glue() λειτουργούν καλά με την mutate() επειδή η έξοδος τους έχει το ίδιο μήκος με τις εισόδους τους. Τι γίνεται αν θέλετε μία συνάρτηση που λειτουργεί καλά με την summarize(), δηλαδή κάτι που επιστρέφει πάντα μία συμβολοσειρά;\nΑυτή είναι η δουλειά της str_flatten()5: παίρνει ένα διάνυσμα χαρακτήρων και συνδυάζει κάθε στοιχείο του διανύσματος σε μία συμβολοσειρά:\n\nstr_flatten(c(\"x\", \"y\", \"z\"))\n#&gt; [1] \"xyz\"\nstr_flatten(c(\"x\", \"y\", \"z\"), \", \")\n#&gt; [1] \"x, y, z\"\nstr_flatten(c(\"x\", \"y\", \"z\"), \", \", last = \", and \")\n#&gt; [1] \"x, y, and z\"\n\nΑυτό την κάνει να λειτουργεί καλά με την summarize():\n\ndf &lt;- tribble(\n  ~ name, ~ fruit,\n  \"Carmen\", \"banana\",\n  \"Carmen\", \"apple\",\n  \"Marvin\", \"nectarine\",\n  \"Terence\", \"cantaloupe\",\n  \"Terence\", \"papaya\",\n  \"Terence\", \"mandarin\"\n)\ndf |&gt;\n  group_by(name) |&gt; \n  summarize(fruits = str_flatten(fruit, \", \"))\n#&gt; # A tibble: 3 × 2\n#&gt;   name    fruits                      \n#&gt;   &lt;chr&gt;   &lt;chr&gt;                       \n#&gt; 1 Carmen  banana, apple               \n#&gt; 2 Marvin  nectarine                   \n#&gt; 3 Terence cantaloupe, papaya, mandarin\n\n\n14.3.4 Ασκήσεις\n\n\nΣυγκρίνετε και αντιπαραβάλλετε τα αποτελέσματα της paste0() με αυτά της str_c() για τις ακόλουθες εισόδους:\n\nstr_c(\"hi \", NA)\nstr_c(letters[1:2], letters[1:3])\n\n\nΠοια είναι η διαφορά μεταξύ της paste() και της paste0();\nΠώς μπορείτε να δημιουργήσετε ξανά το ισοδύναμο της paste() με την str_c();\n\nΜετατρέψτε τις παρακάτω εκφράσεις από str_c() σε str_glue() ή αντίστροφα:\n\nstr_c(\"The price of \", food, \" is \", price)\nstr_glue(\"I'm {age} years old and live in {country}\")\nstr_c(\"\\\\section{\", title, \"}\")",
    "crumbs": [
      "Μετασχηματισμοί",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Συμβολοσειρές</span>"
    ]
  },
  {
    "objectID": "strings.html#εξάγοντας-δεδομένα-απο-σειμβολοδειρές",
    "href": "strings.html#εξάγοντας-δεδομένα-απο-σειμβολοδειρές",
    "title": "14  Συμβολοσειρές",
    "section": "\n14.4 Εξάγοντας δεδομένα απο σειμβολοδειρές",
    "text": "14.4 Εξάγοντας δεδομένα απο σειμβολοδειρές\nΕίναι πολύ σύνηθες για πολλαπλές μεταβλητές να συγχωνεύονται σε μία ενιαία συμβολοσειρά. Σε αυτήν την ενότητα, θα μάθετε πώς να χρησιμοποιείτε τέσσερις συναρτήσεις του πακέτου tidyr για να τις εξάγετε:\n\ndf |&gt; separate_longer_delim(col, delim)\ndf |&gt; separate_longer_position(col, width)\ndf |&gt; separate_wider_delim(col, delim, names)\ndf |&gt; separate_wider_position(col, widths)\n\nΑν κοιτάξετε προσεκτικά, μπορείτε να δείτε ότι υπάρχει ένα κοινό μοτίβο: separate_, ακολουθούμενο από longer ή wider, ακολουθούμενο από _, ακολουθούμενο από delim ή position. Αυτό συμβαίνει επειδή αυτές οι τέσσερις συναρτήσεις αποτελούνται από δύο πιο απλές:\n\nΑκριβώς όπως με τις pivot_longer() και pivot_wider(), οι συναρτήσεις _longer κάνουν το πλαίσιο δεδομένων εισόδου μακρύτερο δημιουργώντας νέες γραμμές ενώ οι συναρτήσεις _wider κάνουν το πλαίσιο δεδομένων εισόδου πλατύτερο με την δημιουργία νέων στηλών.\nΤο delim διαχωρίζει μία συμβολοσειρά με έναν οριοθέτη, όπως \", \" ή \" \". Το position τη διαχωρίζει σε καθορισμένα πλάτη, όπως c(3, 5, 2).\n\nΘα επιστρέψουμε στο τελευταίο μέλος αυτής της οικογένειας, την separate_wider_regex(), στο Κεφάλαιο 15. Είναι η πιο ευέλικτη από τις wider συναρτήσεις, αλλά για να μπορέσετε να τη χρησιμοποιήσετε θα πρέπει να γνωρίζετε λίγα πράγματα για τις κανονικές εκφράσεις.\nΟι ακόλουθες δύο ενότητες θα σας δώσουν τη βασική ιδέα για τις συναρτήσεις, πρώτα χωρίζοντας σε γραμμές (που είναι λίγο πιο απλό) και στη συνέχεια χωρίζοντας σε στήλες. Θα ολοκληρώσουμε συζητώντας τα εργαλεία που σας παρέχουν οι wider συναρτήσεις για τη διάγνωση προβλημάτων.\n\n14.4.1 Διαχωρίζοντας σε γραμμές\nΟ διαχωρισμός μιας συμβολοσειράς σε γραμμές τείνει να είναι πιο χρήσιμη όταν ο αριθμός των στοιχείων ποικίλλει από γραμμή σε γραμμή. Η πιο συνηθισμένη περίπτωση είναι η λειτουργία διαχωρισμού της separate_longer_delim() με βάση έναν οριοθέτη:\n\ndf1 &lt;- tibble(x = c(\"a,b,c\", \"d,e\", \"f\"))\ndf1 |&gt; \n  separate_longer_delim(x, delim = \",\")\n#&gt; # A tibble: 6 × 1\n#&gt;   x    \n#&gt;   &lt;chr&gt;\n#&gt; 1 a    \n#&gt; 2 b    \n#&gt; 3 c    \n#&gt; 4 d    \n#&gt; 5 e    \n#&gt; 6 f\n\nΕίναι πιο σπάνιο να δείτε την separate_longer_position() εκεί έξω, αλλά ορισμένα παλαιότερα σύνολα δεδομένων χρησιμοποιούν μία αρκετά συμπαγή μορφή, όπου κάθε χαρακτήρας χρησιμοποιείται για την καταγραφή μιας τιμής:\n\ndf2 &lt;- tibble(x = c(\"1211\", \"131\", \"21\"))\ndf2 |&gt; \n  separate_longer_position(x, width = 1)\n#&gt; # A tibble: 9 × 1\n#&gt;   x    \n#&gt;   &lt;chr&gt;\n#&gt; 1 1    \n#&gt; 2 2    \n#&gt; 3 1    \n#&gt; 4 1    \n#&gt; 5 1    \n#&gt; 6 3    \n#&gt; # ℹ 3 more rows\n\n\n14.4.2 Διαχωρίζωντας σε στήλες\nΟ διαχωρισμός μιας συμβολοσειράς σε στήλες τείνει να είναι πιο χρήσιμος όταν υπάρχει ένας σταθερός αριθμός στοιχείων σε κάθε συμβολοσειρά και θέλετε να τα κατανείμετε σε στήλες. Είναι ελαφρώς πιο περίπλοκα από τα longer ισοδύναμά τους, επειδή πρέπει να ονομάσετε τις στήλες. Για παράδειγμα, στο ακόλουθο σύνολο δεδομένων, το x αποτελείται από έναν κωδικό, έναν αριθμό έκδοσης και ένα έτος, χωρισμένα με \".\". Για να χρησιμοποιήσουμε την separate_wider_delim(), παρέχουμε τον οριοθέτη και τα ονόματα σε δύο ορίσματα:\n\ndf3 &lt;- tibble(x = c(\"a10.1.2022\", \"b10.2.2011\", \"e15.1.2015\"))\ndf3 |&gt; \n  separate_wider_delim(\n    x,\n    delim = \".\",\n    names = c(\"code\", \"edition\", \"year\")\n  )\n#&gt; # A tibble: 3 × 3\n#&gt;   code  edition year \n#&gt;   &lt;chr&gt; &lt;chr&gt;   &lt;chr&gt;\n#&gt; 1 a10   1       2022 \n#&gt; 2 b10   2       2011 \n#&gt; 3 e15   1       2015\n\nΕάν ένα συγκεκριμένο κομμάτι δεν είναι χρήσιμο, μπορείτε να χρησιμοποιήσετε ένα όνομα NA για να το παραλείψετε από τα αποτελέσματα:\n\ndf3 |&gt; \n  separate_wider_delim(\n    x,\n    delim = \".\",\n    names = c(\"code\", NA, \"year\")\n  )\n#&gt; # A tibble: 3 × 2\n#&gt;   code  year \n#&gt;   &lt;chr&gt; &lt;chr&gt;\n#&gt; 1 a10   2022 \n#&gt; 2 b10   2011 \n#&gt; 3 e15   2015\n\nH separate_wider_position() λειτουργεί λίγο διαφορετικά, επειδή συνήθως θέλετε να καθορίσετε το πλάτος κάθε στήλης. Έτσι, του δίνετε ένα αριθμητικό διάνυσμα με όνομα, όπου το όνομα δίνει το όνομα της νέας στήλης και η τιμή είναι ο αριθμός των χαρακτήρων που καταλαμβάνει. Μπορείτε να παραλείψετε τιμές από την έξοδο, χωρίς να τις ονομάσετε:\n\ndf4 &lt;- tibble(x = c(\"202215TX\", \"202122LA\", \"202325CA\")) \ndf4 |&gt; \n  separate_wider_position(\n    x,\n    widths = c(year = 4, age = 2, state = 2)\n  )\n#&gt; # A tibble: 3 × 3\n#&gt;   year  age   state\n#&gt;   &lt;chr&gt; &lt;chr&gt; &lt;chr&gt;\n#&gt; 1 2022  15    TX   \n#&gt; 2 2021  22    LA   \n#&gt; 3 2023  25    CA\n\n\n14.4.3 Διάγνωση προβλημάτων διεύρυνσης\nΗ separate_wider_delim()6 απαιτεί ένα σταθερό και γνωστό σύνολο στηλών. Τι συμβαίνει εάν ορισμένες από τις γραμμές δεν έχουν τον αναμενόμενο αριθμό τμημάτων;\nΥπάρχουν δύο πιθανά προβλήματα, πολύ λίγα ή πάρα πολλά τμήματα, επομένως η separate_wider_delim() παρέχει δύο ορίσματα για να βοηθήσει: το too_few και το too_many. Ας δούμε πρώτα την περίπτωση του too_few με το ακόλουθο δείγμα δεδομένων:\n\ndf &lt;- tibble(x = c(\"1-1-1\", \"1-1-2\", \"1-3\", \"1-3-2\", \"1\"))\n\ndf |&gt; \n  separate_wider_delim(\n    x,\n    delim = \"-\",\n    names = c(\"x\", \"y\", \"z\")\n  )\n#&gt; Error in `separate_wider_delim()`:\n#&gt; ! Expected 3 pieces in each element of `x`.\n#&gt; ! 2 values were too short.\n#&gt; ℹ Use `too_few = \"debug\"` to diagnose the problem.\n#&gt; ℹ Use `too_few = \"align_start\"/\"align_end\"` to silence this message.\n\nΘα παρατηρήσετε ότι λαμβάνουμε ένα σφάλμα, το οποίο όμως δίνει μερικές προτάσεις για το πώς μπορείτε να προχωρήσετε. Ας ξεκινήσουμε με την αντιμετώπιση των σφαλμάτων του προβλήματος:\n\ndebug &lt;- df |&gt; \n  separate_wider_delim(\n    x,\n    delim = \"-\",\n    names = c(\"x\", \"y\", \"z\"),\n    too_few = \"debug\"\n  )\n#&gt; Warning: Debug mode activated: adding variables `x_ok`, `x_pieces`, and\n#&gt; `x_remainder`.\ndebug\n#&gt; # A tibble: 5 × 6\n#&gt;   x     y     z     x_ok  x_pieces x_remainder\n#&gt;   &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;lgl&gt;    &lt;int&gt; &lt;chr&gt;      \n#&gt; 1 1-1-1 1     1     TRUE         3 \"\"         \n#&gt; 2 1-1-2 1     2     TRUE         3 \"\"         \n#&gt; 3 1-3   3     &lt;NA&gt;  FALSE        2 \"\"         \n#&gt; 4 1-3-2 3     2     TRUE         3 \"\"         \n#&gt; 5 1     &lt;NA&gt;  &lt;NA&gt;  FALSE        1 \"\"\n\nΌταν χρησιμοποιείτε τη λειτουργία εντοπισμού σφαλμάτων, λαμβάνετε τρεις επιπλέον στήλες που προστίθενται στην έξοδο: x_ok, x_pieces και x_remainder (αν διαχωρίσετε μία μεταβλητή με διαφορετικό όνομα, θα λάβετε διαφορετικό πρόθεμα). Εδώ, το x_ok σας επιτρέπει να βρείτε γρήγορα τις εισόδους που απέτυχαν:\n\ndebug |&gt; filter(!x_ok)\n#&gt; # A tibble: 2 × 6\n#&gt;   x     y     z     x_ok  x_pieces x_remainder\n#&gt;   &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;lgl&gt;    &lt;int&gt; &lt;chr&gt;      \n#&gt; 1 1-3   3     &lt;NA&gt;  FALSE        2 \"\"         \n#&gt; 2 1     &lt;NA&gt;  &lt;NA&gt;  FALSE        1 \"\"\n\nΤο x_pieces μας λέει πόσα τμήματα βρέθηκαν, σε σύγκριση με τα αναμενόμενα 3 (το μήκος του names). Το x_remainder δεν είναι χρήσιμο όταν υπάρχουν πολύ λίγα τμήματα, αλλά θα το δούμε ξανά σύντομα.\nΜερικές φορές η εξέταση αυτών των πληροφοριών για τον εντοπισμό σφαλμάτων θα αποκαλύψει ένα πρόβλημα με τη στρατηγική οριοθέτησης, ή θα υποδείξει ότι πρέπει να κάνετε περισσότερη προεπεξεργασία πριν τον διαχωρισμό. Σε αυτήν την περίπτωση, διορθώστε το πρόβλημα στην αρχή και φροντίστε να αφαιρέσετε το too_few = \"debug\", για να διασφαλίσετε ότι τα νέα προβλήματα θα μετατραπούν σε σφάλματα.\nΣε άλλες περιπτώσεις, μπορεί να θέλετε να συμπληρώσετε τα κομμάτια που λείπουν με NA και να προχωρήσετε. Αυτή είναι η δουλειά των too_few = \"align_start\" και too_few = \"align_end\", που σας επιτρέπουν να ελέγχετε πού πρέπει να πηγαίνουν τα NA:\n\ndf |&gt; \n  separate_wider_delim(\n    x,\n    delim = \"-\",\n    names = c(\"x\", \"y\", \"z\"),\n    too_few = \"align_start\"\n  )\n#&gt; # A tibble: 5 × 3\n#&gt;   x     y     z    \n#&gt;   &lt;chr&gt; &lt;chr&gt; &lt;chr&gt;\n#&gt; 1 1     1     1    \n#&gt; 2 1     1     2    \n#&gt; 3 1     3     &lt;NA&gt; \n#&gt; 4 1     3     2    \n#&gt; 5 1     &lt;NA&gt;  &lt;NA&gt;\n\nΟι ίδιες αρχές ισχύουν και στην περίπτωση που έχετε πάρα πολλά τμήματα:\n\ndf &lt;- tibble(x = c(\"1-1-1\", \"1-1-2\", \"1-3-5-6\", \"1-3-2\", \"1-3-5-7-9\"))\n\ndf |&gt; \n  separate_wider_delim(\n    x,\n    delim = \"-\",\n    names = c(\"x\", \"y\", \"z\")\n  )\n#&gt; Error in `separate_wider_delim()`:\n#&gt; ! Expected 3 pieces in each element of `x`.\n#&gt; ! 2 values were too long.\n#&gt; ℹ Use `too_many = \"debug\"` to diagnose the problem.\n#&gt; ℹ Use `too_many = \"drop\"/\"merge\"` to silence this message.\n\nΤώρα όμως, όταν αντιμετωπίζουμε σφάλματα στο αποτέλεσμα, μπορείτε να καταλάβετε τον σκοπό του x_remainder:\n\ndebug &lt;- df |&gt; \n  separate_wider_delim(\n    x,\n    delim = \"-\",\n    names = c(\"x\", \"y\", \"z\"),\n    too_many = \"debug\"\n  )\n#&gt; Warning: Debug mode activated: adding variables `x_ok`, `x_pieces`, and\n#&gt; `x_remainder`.\ndebug |&gt; filter(!x_ok)\n#&gt; # A tibble: 2 × 6\n#&gt;   x         y     z     x_ok  x_pieces x_remainder\n#&gt;   &lt;chr&gt;     &lt;chr&gt; &lt;chr&gt; &lt;lgl&gt;    &lt;int&gt; &lt;chr&gt;      \n#&gt; 1 1-3-5-6   3     5     FALSE        4 -6         \n#&gt; 2 1-3-5-7-9 3     5     FALSE        5 -7-9\n\nΈχετε ένα ελαφρώς διαφορετικό σύνολο επιλογών για το χειρισμό πάρα πολλών τμημάτων: μπορείτε είτε να “διώξετε” σιωπηλά τυχόν πρόσθετα τμήματα ή να τα “συγχωνεύσετε” όλα στην τελευταία στήλη:\n\ndf |&gt; \n  separate_wider_delim(\n    x,\n    delim = \"-\",\n    names = c(\"x\", \"y\", \"z\"),\n    too_many = \"drop\"\n  )\n#&gt; # A tibble: 5 × 3\n#&gt;   x     y     z    \n#&gt;   &lt;chr&gt; &lt;chr&gt; &lt;chr&gt;\n#&gt; 1 1     1     1    \n#&gt; 2 1     1     2    \n#&gt; 3 1     3     5    \n#&gt; 4 1     3     2    \n#&gt; 5 1     3     5\n\n\ndf |&gt; \n  separate_wider_delim(\n    x,\n    delim = \"-\",\n    names = c(\"x\", \"y\", \"z\"),\n    too_many = \"merge\"\n  )\n#&gt; # A tibble: 5 × 3\n#&gt;   x     y     z    \n#&gt;   &lt;chr&gt; &lt;chr&gt; &lt;chr&gt;\n#&gt; 1 1     1     1    \n#&gt; 2 1     1     2    \n#&gt; 3 1     3     5-6  \n#&gt; 4 1     3     2    \n#&gt; 5 1     3     5-7-9",
    "crumbs": [
      "Μετασχηματισμοί",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Συμβολοσειρές</span>"
    ]
  },
  {
    "objectID": "strings.html#γράμματα",
    "href": "strings.html#γράμματα",
    "title": "14  Συμβολοσειρές",
    "section": "\n14.5 Γράμματα",
    "text": "14.5 Γράμματα\nΣε αυτήν την ενότητα, θα σας παρουσιάσουμε συναρτήσεις που σας επιτρέπουν να εργάζεστε με μεμονωμένα γράμματα μέσα σε μία συμβολοσειρά. Θα μάθετε πώς να βρίσκετε το μήκος μιας συμβολοσειράς, να εξάγετε υποσυμβολοσειρές και να χειρίζεστε μεγάλες συμβολοσειρές σε διαγράμματα και πίνακες.\n\n14.5.1 Μήκος\nΗ str_length() σας λέει τον αριθμό των γραμμάτων σε μία συμβολοσειρά:\n\nstr_length(c(\"a\", \"R for data science\", NA))\n#&gt; [1]  1 18 NA\n\nΘα μπορούσατε να τη χρησιμοποιήσετε με την count(), για να βρείτε την κατανομή των μεγεθών των ονομάτων που δίνονται σε μωρά στις ΗΠΑ, και στη συνέχεια με την filter(), για να δείτε τα μεγαλύτερα ονόματα, τα οποία τυχαίνει να έχουν 15 γράμματα7:\n\nbabynames |&gt;\n  count(length = str_length(name), wt = n)\n#&gt; # A tibble: 14 × 2\n#&gt;   length        n\n#&gt;    &lt;int&gt;    &lt;int&gt;\n#&gt; 1      2   338150\n#&gt; 2      3  8589596\n#&gt; 3      4 48506739\n#&gt; 4      5 87011607\n#&gt; 5      6 90749404\n#&gt; 6      7 72120767\n#&gt; # ℹ 8 more rows\n\nbabynames |&gt; \n  filter(str_length(name) == 15) |&gt; \n  count(name, wt = n, sort = TRUE)\n#&gt; # A tibble: 34 × 2\n#&gt;   name                n\n#&gt;   &lt;chr&gt;           &lt;int&gt;\n#&gt; 1 Franciscojavier   123\n#&gt; 2 Christopherjohn   118\n#&gt; 3 Johnchristopher   118\n#&gt; 4 Christopherjame   108\n#&gt; 5 Christophermich    52\n#&gt; 6 Ryanchristopher    45\n#&gt; # ℹ 28 more rows\n\n\n14.5.2 Δημιουργία υποσυνόλων\nΜπορείτε να εξάγετε μέρη μιας συμβολοσειράς χρησιμοποιώντας την str_sub(string, start, end), όπου start και end είναι οι θέσεις στις οποίες πρέπει να ξεκινά και να τελειώνει η υποσυμβολοσειρά. Τα ορίσματα start και end περιλαμβάνονται στο αποτέλεσμα, επομένως το μήκος της συμβολοσειράς που επιστρέφεται θα είναι end - start + 1:\n\nx &lt;- c(\"Apple\", \"Banana\", \"Pear\")\nstr_sub(x, 1, 3)\n#&gt; [1] \"App\" \"Ban\" \"Pea\"\n\nΜπορείτε να χρησιμοποιήσετε αρνητικές τιμές για να μετρήσετε αντίστροφα από το τέλος της συμβολοσειράς: -1 είναι ο τελευταίος χαρακτήρας, -2 είναι ο ο δεύτερος απο το τέλος κ.λπ.\n\nstr_sub(x, -3, -1)\n#&gt; [1] \"ple\" \"ana\" \"ear\"\n\nΣημειώστε ότι η str_sub() δεν θα αποτύχει εάν η συμβολοσειρά είναι πολύ μικρή: απλώς θα επιστρέψει όσο το δυνατόν περισσότερα:\n\nstr_sub(\"a\", 1, 5)\n#&gt; [1] \"a\"\n\nΘα μπορούσαμε να χρησιμοποιήσουμε την str_sub() με την mutate() για να βρούμε το πρώτο και το τελευταίο γράμμα κάθε ονόματος:\n\nbabynames |&gt; \n  mutate(\n    first = str_sub(name, 1, 1),\n    last = str_sub(name, -1, -1)\n  )\n#&gt; # A tibble: 1,924,665 × 7\n#&gt;    year sex   name          n   prop first last \n#&gt;   &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;     &lt;int&gt;  &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;\n#&gt; 1  1880 F     Mary       7065 0.0724 M     y    \n#&gt; 2  1880 F     Anna       2604 0.0267 A     a    \n#&gt; 3  1880 F     Emma       2003 0.0205 E     a    \n#&gt; 4  1880 F     Elizabeth  1939 0.0199 E     h    \n#&gt; 5  1880 F     Minnie     1746 0.0179 M     e    \n#&gt; 6  1880 F     Margaret   1578 0.0162 M     t    \n#&gt; # ℹ 1,924,659 more rows\n\n\n14.5.3 Ασκήσεις\n\nΓιατί χρησιμοποιήσαμε το wt = n, κατά τον υπολογισμό της κατανομής του μήκους των ονομάτων μωρών;\nΧρησιμοποιήστε τις str_length() και str_sub() για να εξάγετε το μεσαίο γράμμα από κάθε όνομα μωρού. Τι θα κάνετε εάν η συμβολοσειρά έχει ζυγό αριθμό χαρακτήρων;\nΥπάρχουν σημαντικές τάσεις στο μήκος των ονομάτων μωρών με την πάροδο του χρόνου;/ Τι γίνεται με τη δημοτικότητα των πρώτων και τελευταίων γραμμάτων;",
    "crumbs": [
      "Μετασχηματισμοί",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Συμβολοσειρές</span>"
    ]
  },
  {
    "objectID": "strings.html#sec-other-languages",
    "href": "strings.html#sec-other-languages",
    "title": "14  Συμβολοσειρές",
    "section": "\n14.6 Μη αγγλικό κείμενο",
    "text": "14.6 Μη αγγλικό κείμενο\nΜέχρι στιγμής, έχουμε επικεντρωθεί σε κείμενο αγγλικής γλώσσας με το οποίο είναι ιδιαίτερα εύκολο να δουλέψετε για δύο λόγους. Πρώτον, το αγγλικό αλφάβητο είναι σχετικά απλό: υπάρχουν μόνο 26 γράμματα. Δεύτερον (και ίσως πιο σημαντικό), η υπολογιστική υποδομή που χρησιμοποιούμε σήμερα σχεδιάστηκε κυρίως από αγγλόφωνους. Δυστυχώς, δεν έχουμε περιθώριο για να αντιμετωπίσουμε πλήρως γλώσσες πέρα από τα αγγλικά. Ωστόσο, θέλαμε να επιστήσουμε την προσοχή σας σε μερικές από τις μεγαλύτερες προκλήσεις που μπορεί να αντιμετωπίσετε: την κωδικοποίηση, τις παραλλαγές γραμμάτων και συναρτήσεις που εξαρτώνται από τις τοπικές ρυθμίσεις γλώσσας.\n\n14.6.1 Κωδικοποίηση\nΌταν εργάζεστε με μη αγγλικό κείμενο, η πρώτη πρόκληση είναι συχνά η κωδικοποίηση. Για να καταλάβουμε τι συμβαίνει, πρέπει να δούμε πώς οι υπολογιστές αναπαριστούν συμβολοσειρές. Στην R, μπορούμε να βρούμε την υποκείμενη αναπαράσταση μιας συμβολοσειράς χρησιμοποιώντας την charToRaw():\n\ncharToRaw(\"Hadley\")\n#&gt; [1] 48 61 64 6c 65 79\n\nΚαθένας από αυτούς τους έξι δεκαεξαδικούς αριθμούς αντιπροσωπεύει ένα γράμμα: το 48 είναι το H, το 61 είναι το a και ούτω καθεξής. Η αντιστοίχιση από δεκαεξαδικό αριθμό σε χαρακτήρα ονομάζεται κωδικοποίηση και σε αυτή την περίπτωση η κωδικοποίηση ονομάζεται ASCII. Η ASCII κάνει εξαιρετική δουλειά στην αναπαράσταση αγγλικών χαρακτήρων, επειδή είναι ο Αμερικανικός Πρότυπος Κώδικας για Ανταλλαγή Πληροφοριών (American Standard Code for Information Interchange).\nΤα πράγματα δεν είναι τόσο εύκολα για άλλες γλώσσες. Στις πρώτες μέρες των υπολογιστών, υπήρχαν πολλά ανταγωνιστικά πρότυπα για την κωδικοποίηση μη αγγλικών χαρακτήρων. Για παράδειγμα, υπήρχαν δύο διαφορετικές κωδικοποιήσεις για την Ευρώπη: η Latin1 (γνωστή και ως ISO-8859-1) χρησιμοποιήθηκε για τις δυτικοευρωπαϊκές γλώσσες και η Latin2 (γνωστή και ως ISO-8859-2) για τις γλώσσες της Κεντρικής Ευρώπης. Στη Latin1, το byte b1 είναι “±”, αλλά στη Latin2, είναι “ą”! Ευτυχώς, σήμερα υπάρχει ένα πρότυπο που υποστηρίζεται σχεδόν παντού: το UTF-8. Το UTF-8 μπορεί να κωδικοποιήσει σχεδόν κάθε χαρακτήρα που χρησιμοποιείται από τους ανθρώπους σήμερα, αλλά και πολλά επιπλέον σύμβολα όπως emojis.\nΗ readr χρησιμοποιεί UTF-8 παντού. Αυτή είναι μία καλή προεπιλογή, αλλά θα αποτύχει για δεδομένα που παράγονται από παλαιότερα συστήματα που δεν χρησιμοποιούν UTF-8. Εάν συμβεί αυτό, οι συμβολοσειρές σας θα φαίνονται περίεργα όταν τις εκτυπώνετε. Μερικές φορές μόνο ένας ή δύο χαρακτήρες μπορεί να είναι μπερδεμένοι. Αλλες φορές, υπάρχει πλήρης ασυναρτησία. Για παράδειγμα, ακολουθούν δύο ένθετα CSV με ασυνήθιστες κωδικοποιήσεις8:\n\nx1 &lt;- \"text\\nEl Ni\\xf1o was particularly bad this year\"\nread_csv(x1)$text\n#&gt; [1] \"El Ni\\xf1o was particularly bad this year\"\n\nx2 &lt;- \"text\\n\\x82\\xb1\\x82\\xf1\\x82\\xc9\\x82\\xbf\\x82\\xcd\"\nread_csv(x2)$text\n#&gt; [1] \"\\x82\\xb1\\x82\\xf1\\x82ɂ\\xbf\\x82\\xcd\"\n\nΓια να τα διαβάσετε σωστά, καθορίζετε την κωδικοποίηση μέσω του ορίσματος locale:\n\nread_csv(x1, locale = locale(encoding = \"Latin1\"))$text\n#&gt; [1] \"El Niño was particularly bad this year\"\n\nread_csv(x2, locale = locale(encoding = \"Shift-JIS\"))$text\n#&gt; [1] \"こんにちは\"\n\nΠώς βρίσκετε τη σωστή κωδικοποίηση;/ Εάν είστε τυχεροί, θα συμπεριληφθεί κάπου στις οδηγίες των δεδομένων. Δυστυχώς, αυτό συμβαίνει σπάνια, οπότε το πακέτο readr παρέχει την guess_encoding() για να σας βοηθήσει να την βρείτε. Δεν είναι αλάνθαστο και λειτουργεί καλύτερα όταν έχετε πολύ κείμενο (σε αντίθεση με εδώ), αλλά είναι ένα λογικό μέρος για να ξεκινήσετε. Να περιμένετε ότι θα δοκιμάσετε μερικές διαφορετικές κωδικοποιήσεις μέχρι να βρείτε τη σωστή.\nΟι κωδικοποιήσεις είναι ένα πλούσιο και πολύπλοκο θέμα. Μεχρι ώρας, έχουμε εξετάσει μόνο την επιφάνεια. Εάν θέλετε να μάθετε περισσότερα, συνιστούμε να διαβάσετε τις λεπτομέρειες στη διεύθυνση http://kunststube.net/encoding/.\n\n14.6.2 Παραλλαγές γραμμάτων\nΗ εργασία σε γλώσσες που χρησιμοποιούν τόνους αποτελεί σημαντική πρόκληση κατά τον προσδιορισμό της θέσης των γραμμάτων (π.χ. με την str_length() και την str_sub()), καθώς τα τονισμένα γράμματα μπορεί να κωδικοποιηθούν ως ένας μεμονωμένος χαρακτήρας (π.χ. το ü) ή ως δύο χαρακτήρες συνδυάζοντας ένα γράμμα χωρίς τόνο (π.χ., u) με ένα διακριτικό σημάδι (π.χ., ¨). Για παράδειγμα, αυτός ο κώδικας δείχνει δύο τρόπους αναπαράστασης του ü, που φαίνονται πανομοιότυποι:\n\nu &lt;- c(\"\\u00fc\", \"u\\u0308\")\nstr_view(u)\n#&gt; [1] │ ü\n#&gt; [2] │ ü\n\nΑλλά και οι δύο συμβολοσειρές διαφέρουν σε μήκος και οι πρώτοι χαρακτήρες τους είναι διαφορετικοί:\n\nstr_length(u)\n#&gt; [1] 1 2\nstr_sub(u, 1, 1)\n#&gt; [1] \"ü\" \"u\"\n\nΤέλος, σημειώστε ότι μία σύγκριση αυτών των συμβολοσειρών με το == ερμηνεύει αυτές τις συμβολοσειρές ως διαφορετικές, ενώ η εύχρηστη συνάρτηση str_equal() στο πακέτο stringr αναγνωρίζει ότι και οι δύο έχουν την ίδια εμφάνιση:\n\nu[[1]] == u[[2]]\n#&gt; [1] FALSE\n\nstr_equal(u[[1]], u[[2]])\n#&gt; [1] TRUE\n\n\n14.6.3 Συναρτήσεις που εξαρτώνται από την γεωγραφική τοποθεσία\nΤέλος, υπάρχει ένας αριθμός από συναρτήσεις του πακέτου stringr, των οποίων η συμπεριφορά εξαρτάται από την τοποθεσία σας. Μία ρύθμιση τοποθεσίας είναι παρόμοια με αυτή της γλώσσας, αλλά περιλαμβάνει έναν προαιρετικό προσδιοριστή περιοχής για τον χειρισμό τοπικών παραλλαγών σε μία γλώσσα. Μία ρύθμιση τοποθεσίας καθορίζεται από μία συντομογραφία γλώσσας με πεζά γράμματα, προαιρετικά ακολουθούμενη από ένα _ και ένα αναγνωριστικό περιοχής με κεφαλαία. Για παράδειγμα, το “en” είναι αγγλικά, το “en_GB” είναι τα βρετανικά αγγλικά και το “en_US” είναι τα αμερικανικά αγγλικά. Εάν δεν γνωρίζετε ήδη τον κώδικα για τη γλώσσα σας, η Wikipedia έχει μία καλή λίστα και μπορείτε να δείτε ποιοι κώδικες υποστηρίζονται στο πακέτο stringr εκτελώντας το stringi::stri_locale_list().\nΟι βασικές συναρτήσεις συμβολοσειράς της R χρησιμοποιούν αυτόματα τις τοπικές ρυθμίσεις που έχουν οριστεί από το λειτουργικό σας σύστημα. Αυτό σημαίνει ότι οι βασικές συναρτήσεις συμβολοσειράς της R κάνουν ό,τι περιμένετε για τη γλώσσα σας, αλλά ο κώδικάς σας μπορεί να λειτουργήσει διαφορετικά εάν τον μοιραστείτε με κάποιον που ζει σε διαφορετική χώρα. Για να αποφευχθεί αυτό το πρόβλημα, το πακέτο stringr ορίζει από προεπιλογή τους αγγλικούς κανόνες χρησιμοποιώντας την ρύθμιση “en” και για να το παρακάμψετε, απαιτεί από εσάς να καθορίσετε το όρισμα locale. Ευτυχώς, υπάρχουν δύο σύνολα συναρτήσεων όπου η ρύθμιση τοποθεσίας έχει πραγματικά σημασία: στην αλλαγή πεζών-κεφαλαίων και στην ταξινόμηση.\nΟι κανόνες για την αλλαγή των περιπτώσεων διαφέρουν μεταξύ των γλωσσών. Για παράδειγμα, τα τουρκικά έχουν δύο γράμματα i, με και χωρίς τελεία. Δεδομένου ότι είναι δύο διαφορετικά γράμματα, γράφονται διαφορετικά σε κεφαλαία:\n\nstr_to_upper(c(\"i\", \"ı\"))\n#&gt; [1] \"I\" \"I\"\nstr_to_upper(c(\"i\", \"ı\"), locale = \"tr\")\n#&gt; [1] \"İ\" \"I\"\n\nΗ ταξινόμηση των συμβολοσειρών εξαρτάται από τη σειρά του αλφαβήτου και η σειρά του αλφαβήτου δεν είναι ίδια σε κάθε γλώσσα9! Ακολουθεί ένα παράδειγμα: στα τσέχικα, το “ch” είναι ένα σύνθετο γράμμα που εμφανίζεται μετά το “h” στο αλφάβητο.\n\nstr_sort(c(\"a\", \"c\", \"ch\", \"h\", \"z\"))\n#&gt; [1] \"a\"  \"c\"  \"ch\" \"h\"  \"z\"\nstr_sort(c(\"a\", \"c\", \"ch\", \"h\", \"z\"), locale = \"cs\")\n#&gt; [1] \"a\"  \"c\"  \"h\"  \"ch\" \"z\"\n\nΑυτό εμφανίζεται επίσης στην ταξινόμηση συμβολοσειρών με την dplyr::arrange(), γι’ αυτό και περιέχει κι αυτή ένα όρισμα locale.",
    "crumbs": [
      "Μετασχηματισμοί",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Συμβολοσειρές</span>"
    ]
  },
  {
    "objectID": "strings.html#σύνοψη",
    "href": "strings.html#σύνοψη",
    "title": "14  Συμβολοσειρές",
    "section": "\n14.7 Σύνοψη",
    "text": "14.7 Σύνοψη\nΣε αυτό το κεφάλαιο, έχετε μάθει για ορισμένες από τις δυνατότητες του πακέτου stringr: πώς να δημιουργείτε, να συνδυάζετε και να εξάγετε συμβολοσειρές, καθώς και μερικές από τις προκλήσεις που ενδέχεται να αντιμετωπίσετε με μη αγγλικές συμβολοσειρές. Τώρα ήρθε η ώρα να μάθετε ένα από τα πιο σημαντικά και ισχυρά εργαλεία για την εργασία με συμβολοσειρές: τις κανονικές εκφράσεις. Οι κανονικές εκφράσεις είναι μία πολύ συνοπτική αλλά και πολύ εκφραστική γλώσσα για την περιγραφή μοτίβων μέσα σε συμβολοσειρές και αποτελούν το θέμα του επόμενου κεφαλαίου.",
    "crumbs": [
      "Μετασχηματισμοί",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Συμβολοσειρές</span>"
    ]
  },
  {
    "objectID": "strings.html#footnotes",
    "href": "strings.html#footnotes",
    "title": "14  Συμβολοσειρές",
    "section": "",
    "text": "Ή χρησιμοποιήστε τη βασική συνάρτηση της R writeLines().↩︎\nΔιατίθεται στην R 4.0.0 και νεότερες εκδόσεις.↩︎\nΗ str_view() χρησιμοποιεί επίσης χρώμα για να φέρει στην προσοχή σας στηλοθέτες, κενά, αντιστοιχίσεις κ.λπ. Τα χρώματα δεν εμφανίζονται προς το παρόν στο βιβλίο, αλλά θα τα παρατηρήσετε όταν εκτελείτε τον κώδικα.↩︎\nΑκόμα και εάν δεν χρησιμοποιείτε το πακέτο stringr, μπορείτε να το χρησιμοποιήσετε απευθείας με την glue::glue().↩︎\nΤο ισοδύναμο του βασικού συνόλου λειτουργιών της R είναι η paste() η οποία χρησιμοποιείται με το όρισμα collapse.↩︎\nΟι ίδιες αρχές ισχύουν για τις separate_wider_position() και separate_wider_regex().↩︎\nΕξετάζοντας τις εγγραφές, θα λέγαμε ότι τα δεδομένα ονομάτων μωρών αφαιρούν κενά ή παύλες και περικόπτονται μετά από 15 γράμματα.↩︎\nΕδώ χρησιμοποιώ το ειδικό \\x για να κωδικοποιήσω δυαδικά δεδομένα απευθείας σε μία συμβολοσειρά.↩︎\nΗ ταξινόμηση σε γλώσσες που δεν έχουν αλφάβητο, όπως τα κινέζικα, είναι ακόμα πιο περίπλοκη.↩︎",
    "crumbs": [
      "Μετασχηματισμοί",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Συμβολοσειρές</span>"
    ]
  },
  {
    "objectID": "regexps.html",
    "href": "regexps.html",
    "title": "15  Λογικές εκφράσεις",
    "section": "",
    "text": "15.1 Εισαγωγή\nΣτο Κεφάλαιο 14, μάθατε αρκετές χρήσιμες συναρτήσεις για να εργάζεστε με συμβολοσειρές. Το κεφάλαιο αυτό θα επικεντρωθεί σε συναρτήσεις που χρησιμοποιούν κανονικές εκφράσεις, μία συνοπτική και ισχυρή γλώσσα για την περιγραφή μοτίβων μέσα σε συμβολοσειρές. Ο όρος “κανονική έκφραση” είναι στα αγγλικά είναι “regular expression” και θεωρείται γλωσσοδέτης, επομένως οι περισσότεροι τον συντομεύουν σε “regex”1 ή “regexp”.\nΤο κεφάλαιο ξεκινά με τα βασικά των κανονικών εκφράσεων και τις πιο χρήσιμες συναρτήσεις του πακέτου stringr για ανάλυση δεδομένων. Στη συνέχεια, θα επεκτείνουμε τις γνώσεις σας σχετικά με τα μοτίβα και θα καλύψουμε επτά σημαντικά νέες θεματολογίες (διαφυγή, αγκύστρωση, κατηγορίες χαρακτήρων, κατηγορίες συντομογραφίας, ποσοτικοί δείκτες, ιεραρχία και ομαδοποίηση). Στη συνέχεια, θα μιλήσουμε για μερικούς από τους άλλους τύπους μοτίβων με τους οποίους οι συναρτήσεις του πακέτου stringr μπορούν να λειτουργήσουν και για τους διάφορους “δείκτες” που σας επιτρέπουν να τροποποιήσετε τη λειτουργία των κανονικών εκφράσεων. Θα ολοκληρώσουμε με μία επισκόπηση άλλων σημείων στο tidyverse και το βασικό σύνολο λειτουργιών της R όπου μπορείτε να χρησιμοποιήσετε regex.",
    "crumbs": [
      "Μετασχηματισμοί",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Λογικές εκφράσεις</span>"
    ]
  },
  {
    "objectID": "regexps.html#εισαγωγή",
    "href": "regexps.html#εισαγωγή",
    "title": "15  Λογικές εκφράσεις",
    "section": "",
    "text": "15.1.1 Προαπαιτούμενα\nΣε αυτό το κεφάλαιο, θα χρησιμοποιήσουμε συναρτήσεις κανονικής έκφρασης από το πακέτο stringr και το πακέτο tidyr, δύο βασικά μέλη του tidyverse, καθώς και δεδομένα από το πακέτο babynames.\n\nlibrary(tidyverse)\nlibrary(babynames)\n\nΜέσα από αυτό το κεφάλαιο, θα χρησιμοποιήσουμε έναν συνδυασμό πολύ απλών παραδειγμάτων ώστε να μπορείτε να πάρετε τη βασική ιδέα, τα δεδομένα ονομάτων μωρών και τρία διανύσματα χαρακτήρων από το πακέτο stringr:\n\nΤο διάνυσμα fruit περιέχει τα ονόματα 80 φρούτων.\nΤο words περιέχει 980 συχνές αγγλικές λέξεις.\nΤο sentences περιέχει 720 σύντομες προτάσεις.",
    "crumbs": [
      "Μετασχηματισμοί",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Λογικές εκφράσεις</span>"
    ]
  },
  {
    "objectID": "regexps.html#sec-reg-basics",
    "href": "regexps.html#sec-reg-basics",
    "title": "15  Λογικές εκφράσεις",
    "section": "\n15.2 Βασικές αρχές των μοτίβων",
    "text": "15.2 Βασικές αρχές των μοτίβων\nΘα χρησιμοποιήσουμε την str_view() για να μάθουμε πώς λειτουργούν τα μοτίβα σε regex. Χρησιμοποιήσαμε την str_view() στο προηγούμενο κεφάλαιο για να κατανοήσουμε καλύτερα μία συμβολοσειρά έναντι της εκτυπωμένης αναπαράστασής της, και τώρα θα τη χρησιμοποιήσουμε με το δεύτερο όρισμα της, μία κανονική έκφραση. Όταν παρέχεται, η str_view() θα εμφανίσει μόνο τα στοιχεία του διανύσματος συμβολοσειράς που ταιριάζουν, περιβάλλοντας κάθε αντιστοιχία με &lt;&gt; και, όπου είναι δυνατόν, επισημαίνοντας την αντιστοίχιση με μπλε χρώμα.\nΤα πιο απλά μοτίβα αποτελούνται από γράμματα και αριθμούς που ταιριάζουν ακριβώς με αυτούς τους χαρακτήρες:\n\nstr_view(fruit, \"berry\")\n#&gt;  [6] │ bil&lt;berry&gt;\n#&gt;  [7] │ black&lt;berry&gt;\n#&gt; [10] │ blue&lt;berry&gt;\n#&gt; [11] │ boysen&lt;berry&gt;\n#&gt; [19] │ cloud&lt;berry&gt;\n#&gt; [21] │ cran&lt;berry&gt;\n#&gt; ... and 8 more\n\nΤα γράμματα και οι αριθμοί που ταιριάζουν ακριβώς ονομάζονται σταθεροί χαρακτήρες. Οι περισσότεροι χαρακτήρες στίξης, όπως οι ., +, *, [, ] και ?, έχουν ειδικές έννοιες2 και ονομάζονται μεταχαρακτήρες. Για παράδειγμα, ο χαρακτήρας . θα ταιριάζει με οποιονδήποτε χαρακτήρα3, οπότε το a . θα ταιριάζει με κάθε συμβολοσειρά που περιέχει ένα a ακολουθούμενο από έναν άλλο χαρακτήρα :\n\nstr_view(c(\"a\", \"ab\", \"ae\", \"bd\", \"ea\", \"eab\"), \"a.\")\n#&gt; [2] │ &lt;ab&gt;\n#&gt; [3] │ &lt;ae&gt;\n#&gt; [6] │ e&lt;ab&gt;\n\nΉ θα μπορούσαμε να βρούμε όλα τα φρούτα που περιέχουν ένα “a”, ακολουθούμενο από τρία γράμματα και ένα “e”:\n\nstr_view(fruit, \"a...e\")\n#&gt;  [1] │ &lt;apple&gt;\n#&gt;  [7] │ bl&lt;ackbe&gt;rry\n#&gt; [48] │ mand&lt;arine&gt;\n#&gt; [51] │ nect&lt;arine&gt;\n#&gt; [62] │ pine&lt;apple&gt;\n#&gt; [64] │ pomegr&lt;anate&gt;\n#&gt; ... and 2 more\n\nΟι ποσοτικοί δείκτες ελέγχουν πόσες φορές μπορεί να ταιριάξει ένα μοτίβο:\n\nΤο ? κάνει ένα μοτίβο προαιρετικό (να ταιριάζει δηλαδή 0 ή 1 φορές)\nΤο + επιτρέπει σε ένα μοτίβο να επαναλαμβάνεται (να ταιριάζει δηλαδή τουλάχιστον μία φορά)\nΤο * επιτρέπει σε ένα μοτίβο να είναι προαιρετικό ή να επαναλαμβάνεται (να ταιριάζει δηλαδή με οποιονδήποτε αριθμό φορών, συμπεριλαμβανομένου του 0).\n\n\n# Το ab? αντιστοιχίζει ένα \"a\", που ακολουθείται προαιρετικά από ένα \"b\".\nstr_view(c(\"a\", \"ab\", \"abb\"), \"ab?\")\n#&gt; [1] │ &lt;a&gt;\n#&gt; [2] │ &lt;ab&gt;\n#&gt; [3] │ &lt;ab&gt;b\n\n# Το ab+ αντιστοιχίζει ένα \"a\", που ακολουθείται από τουλάχιστον ένα \"b\"\nstr_view(c(\"a\", \"ab\", \"abb\"), \"ab+\")\n#&gt; [2] │ &lt;ab&gt;\n#&gt; [3] │ &lt;abb&gt;\n\n# Το ab* αντιστοιχίζει ένα \"a\", που ακολουθείται από οποιονδήποτε αριθμό \"b\" (ακόμα και 0).\nstr_view(c(\"a\", \"ab\", \"abb\"), \"ab*\")\n#&gt; [1] │ &lt;a&gt;\n#&gt; [2] │ &lt;ab&gt;\n#&gt; [3] │ &lt;abb&gt;\n\nΟι κατηγορίες χαρακτήρων ορίζονται από το [] και σας επιτρέπουν να αντιστοιχίσετε ένα σύνολο χαρακτήρων. Για παράδειγμα, το [abcd] ταιριάζει με τους χαρακτήρες “a”, “b”, “c” ή “d”. Μπορείτε επίσης να αντιστρέψετε την αντιστοίχιση ξεκινώντας με το ^: Το [^abcd] αντιστοιχεί σε οτιδήποτε εκτός των “a”, “b”, “c” ή “d”. Μπορούμε να χρησιμοποιήσουμε αυτήν την ιδέα για να βρούμε τις λέξεις που περιέχουν ένα “x” που περιβάλλεται από φωνήεντα ή ένα “y” που περιβάλλεται από σύμφωνα:\n\nstr_view(words, \"[aeiou]x[aeiou]\")\n#&gt; [284] │ &lt;exa&gt;ct\n#&gt; [285] │ &lt;exa&gt;mple\n#&gt; [288] │ &lt;exe&gt;rcise\n#&gt; [289] │ &lt;exi&gt;st\nstr_view(words, \"[^aeiou]y[^aeiou]\")\n#&gt; [836] │ &lt;sys&gt;tem\n#&gt; [901] │ &lt;typ&gt;e\n\nΜπορείτε να χρησιμοποιήσετε την εναλλαγή, |, για να επιλέξετε ανάμεσα σε ένα ή περισσότερα εναλλακτικά μοτίβα. Για παράδειγμα, τα ακόλουθα μοτίβα αναζητούν φρούτα που περιέχουν “apple”, “melon” ή “nut” ή ένα επαναλαμβανόμενο φωνήεν.\n\nstr_view(fruit, \"apple|melon|nut\")\n#&gt;  [1] │ &lt;apple&gt;\n#&gt; [13] │ canary &lt;melon&gt;\n#&gt; [20] │ coco&lt;nut&gt;\n#&gt; [52] │ &lt;nut&gt;\n#&gt; [62] │ pine&lt;apple&gt;\n#&gt; [72] │ rock &lt;melon&gt;\n#&gt; ... and 1 more\nstr_view(fruit, \"aa|ee|ii|oo|uu\")\n#&gt;  [9] │ bl&lt;oo&gt;d orange\n#&gt; [33] │ g&lt;oo&gt;seberry\n#&gt; [47] │ lych&lt;ee&gt;\n#&gt; [66] │ purple mangost&lt;ee&gt;n\n\nΟι κανονικές εκφράσεις είναι πολύ συμπαγείς και χρησιμοποιούν πολλούς χαρακτήρες στίξης, έτσι μπορεί να φαίνονται δύσκολες και δυσανάγνωστες στην αρχή. Μην ανησυχείτε. θα γίνετε καλύτεροι με την εξάσκηση και τα απλά μοτίβα σύντομα θα γίνουν συνήθεια. Ας ξεκινήσουμε αυτή τη διαδικασία εξασκώντας μερικές χρήσιμες συναρτήσεις του πακέτου stringr.",
    "crumbs": [
      "Μετασχηματισμοί",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Λογικές εκφράσεις</span>"
    ]
  },
  {
    "objectID": "regexps.html#sec-stringr-regex-funs",
    "href": "regexps.html#sec-stringr-regex-funs",
    "title": "15  Λογικές εκφράσεις",
    "section": "\n15.3 Βασικές συναρτήσεις",
    "text": "15.3 Βασικές συναρτήσεις\nΤώρα που έχετε εμπεδώσει τα βασικά των κανονικών εκφράσεων, ας τις χρησιμοποιήσουμε με ορισμένες συναρτήσεις από το πακέτο stringr και το πακέτο tidyr. Στην επόμενη ενότητα, θα μάθετε πώς να ανιχνεύετε την παρουσία ή την απουσία μιας αντιστοίχισης, πώς να μετράτε τον αριθμό των αντιστοιχιών, πώς να αντικαθιστάτε μία αντιστοίχιση με σταθερό κείμενο και πώς να εξάγετε κείμενο χρησιμοποιώντας ένα μοτίβο.\n\n15.3.1 Ανίχνευση αντιστοιχιών\nΗ str_detect() επιστρέφει ένα λογικό διάνυσμα που είναι TRUE εάν το μοτίβο ταιριάζει με ένα στοιχείο του διανύσματος χαρακτήρων και FALSE σε διαφορετική περίπτωση:\n\nstr_detect(c(\"a\", \"b\", \"c\"), \"[aeiou]\")\n#&gt; [1]  TRUE FALSE FALSE\n\nΕφόσον η str_detect() επιστρέφει ένα λογικό διάνυσμα ίδιου μήκους με το αρχικό διάνυσμα, συνδυάζεται καλά με την filter(). Για παράδειγμα, αυτός ο κώδικας βρίσκει όλα τα πιο δημοφιλή ονόματα που περιέχουν ένα πεζό “x”:\n\nbabynames |&gt; \n  filter(str_detect(name, \"x\")) |&gt; \n  count(name, wt = n, sort = TRUE)\n#&gt; # A tibble: 974 × 2\n#&gt;   name           n\n#&gt;   &lt;chr&gt;      &lt;int&gt;\n#&gt; 1 Alexander 665492\n#&gt; 2 Alexis    399551\n#&gt; 3 Alex      278705\n#&gt; 4 Alexandra 232223\n#&gt; 5 Max       148787\n#&gt; 6 Alexa     123032\n#&gt; # ℹ 968 more rows\n\nΜπορούμε επίσης να χρησιμοποιήσουμε την str_detect() με την summarize() συνδυάζοντάς το με την sum() ή την mean(): Το sum(str_detect(x, pattern)) σας λέει τον αριθμό των παρατηρήσεων που ταιριάζουν, και η mean(str_detect(x, pattern)) σας λέει την αναλογία που ταιριάζει. Για παράδειγμα, το ακόλουθο απόσπασμα υπολογίζει και απεικονίζει την αναλογία των ονομάτων μωρών4 που περιέχουν το γράμμα “x”, ανά έτος. Φαίνεται ότι έχουν αυξηθεί πάρα πολύ σε δημοτικότητα τον τελευταίο καιρό!\n\nbabynames |&gt; \n  group_by(year) |&gt; \n  summarize(prop_x = mean(str_detect(name, \"x\"))) |&gt; \n  ggplot(aes(x = year, y = prop_x)) + \n  geom_line()\n\n\n\n\n\n\n\nΥπάρχουν δύο συναρτήσεις που σχετίζονται στενά με την str_detect(): η str_subset() και η str_which(). Η str_subset() επιστρέφει ένα διάνυσμα χαρακτήρων που περιέχει μόνο τις συμβολοσειρές που ταιριάζουν. Η str_which() επιστρέφει ένα ακέραιο διάνυσμα δίνοντας τις θέσεις των συμβολοσειρών που ταιριάζουν.\n\n15.3.2 Μετρήσεις αντιστοιχίσεων\nΤο επόμενο βήμα στην πολυπλοκότητα από την str_detect() είναι η str_count(): αντί να επιστρέψει κάποιο true ή false, σας λέει πόσες αντιστοιχίσεις υπάρχουν σε κάθε συμβολοσειρά.\n\nx &lt;- c(\"apple\", \"banana\", \"pear\")\nstr_count(x, \"p\")\n#&gt; [1] 2 0 1\n\nΣημειώστε ότι κάθε αντιστοίχιση ξεκινά στο τέλος της προηγούμενης αντιστοίχισης, δηλαδή οι αντιστοιχήσεις των regex δεν επικαλύπτονται ποτέ. Για παράδειγμα, στη συμβολοσειρά \"abababa\", πόσες φορές θα ταιριάξει το μοτίβο \"aba\";\nΟι κανονικές εκφράσεις λένε δύο, όχι τρεις:\n\nstr_count(\"abababa\", \"aba\")\n#&gt; [1] 2\nstr_view(\"abababa\", \"aba\")\n#&gt; [1] │ &lt;aba&gt;b&lt;aba&gt;\n\nΕίναι αναμενόμενο να χρησιμοποιείτε την str_count() με την mutate(). Το παρακάτω παράδειγμα χρησιμοποιεί την str_count() με κατηγορίες χαρακτήρων για να μετρήσει τον αριθμό των φωνηέντων και των συμφώνων σε κάθε όνομα.\n\nbabynames |&gt; \n  count(name) |&gt; \n  mutate(\n    vowels = str_count(name, \"[aeiou]\"),\n    consonants = str_count(name, \"[^aeiou]\")\n  )\n#&gt; # A tibble: 97,310 × 4\n#&gt;   name          n vowels consonants\n#&gt;   &lt;chr&gt;     &lt;int&gt;  &lt;int&gt;      &lt;int&gt;\n#&gt; 1 Aaban        10      2          3\n#&gt; 2 Aabha         5      2          3\n#&gt; 3 Aabid         2      2          3\n#&gt; 4 Aabir         1      2          3\n#&gt; 5 Aabriella     5      4          5\n#&gt; 6 Aada          1      2          2\n#&gt; # ℹ 97,304 more rows\n\nΑν κοιτάξετε προσεκτικά, θα παρατηρήσετε ότι κάτι δεν πάει καλά με τους υπολογισμούς μας: η συμβολοσειρά “Aaban” περιέχει τρία “a”, αλλά η σύνοψή μας αναφέρει μόνο δύο φωνήεντα. Αυτό συμβαίνει επειδή οι κανονικές εκφράσεις κάνουν διάκριση μεταξύ πεζών και κεφαλαίων. Υπάρχουν τρεις τρόποι με τους οποίους μπορούμε να το διορθώσουμε:\n\nΠροσθέστε τα κεφαλαία φωνήεντα στην κατηγορία χαρακτήρων: str_count(name, \"[aeiouAEIOU]\").\nΠείτε στην κανονική έκφραση να αγνοήσει τα πεζά γράμματα: str_count(name, regex(\"[aeiou]\", ignore_case = TRUE)). Θα μιλήσουμε για περισσότερα στην Ενότητα 15.5.1.\nΧρησιμοποιήστε την str_to_lower() για να μετατρέψετε τα ονόματα σε πεζά: str_count(str_to_lower(name), \"[aeiou]\").\n\nΑυτή η ποικιλία προσεγγίσεων είναι αρκετά χαρακτηριστική όταν εργάζεστε με συμβολοσειρές — υπάρχουν συχνά πολλοί τρόποι για να πετύχετε τον στόχο σας, είτε κάνοντας το μοτίβο σας πιο περίπλοκο είτε κάνοντας κάποια προεπεξεργασία στη συμβολοσειρά σας. Εάν κολλήσετε δοκιμάζοντας μία προσέγγιση, μπορεί συχνά να είναι χρήσιμο να μειώσετε ρυθμούς και να αντιμετωπίσετε το πρόβλημα με διαφορετική οπτική.\nΣε αυτήν την περίπτωση, καθώς εφαρμόζουμε δύο συναρτήσεις στο όνομα, νομίζω ότι είναι πιο εύκολο να το μετασχηματίσουμε πρώτα:\n\nbabynames |&gt; \n  count(name) |&gt; \n  mutate(\n    name = str_to_lower(name),\n    vowels = str_count(name, \"[aeiou]\"),\n    consonants = str_count(name, \"[^aeiou]\")\n  )\n#&gt; # A tibble: 97,310 × 4\n#&gt;   name          n vowels consonants\n#&gt;   &lt;chr&gt;     &lt;int&gt;  &lt;int&gt;      &lt;int&gt;\n#&gt; 1 aaban        10      3          2\n#&gt; 2 aabha         5      3          2\n#&gt; 3 aabid         2      3          2\n#&gt; 4 aabir         1      3          2\n#&gt; 5 aabriella     5      5          4\n#&gt; 6 aada          1      3          1\n#&gt; # ℹ 97,304 more rows\n\n\n15.3.3 Αντικατάσταση τιμών\nΕκτός από τον εντοπισμό και την καταμέτρηση αντιστοιχιών, μπορούμε και να τις τροποποιήσουμε με τις str_replace() και str_replace_all(). Η str_replace() αντικαθιστά την πρώτη αντιστοίχιση και, όπως υποδηλώνει το όνομα, η str_replace_all() αντικαθιστά όλες τις αντιστοιχίσεις.\n\nx &lt;- c(\"apple\", \"pear\", \"banana\")\nstr_replace_all(x, \"[aeiou]\", \"-\")\n#&gt; [1] \"-ppl-\"  \"p--r\"   \"b-n-n-\"\n\nΗ str_remove() και η str_remove_all() είναι εύχρηστες συντομεύσεις για την str_replace(x, pattern, \"\"):\n\nx &lt;- c(\"apple\", \"pear\", \"banana\")\nstr_remove_all(x, \"[aeiou]\")\n#&gt; [1] \"ppl\" \"pr\"  \"bnn\"\n\nΑυτές οι συναρτήσεις μπορούν να συνδυαστούν με την mutate() καθώς καθαρίζετε δεδομένα, και συχνά θα τις εφαρμόζετε επανειλημμένα για να αφαιρέσετε επίπεδα κακής μορφοποίησης.\n\n15.3.4 Εξαγωγή μεταβλητών\nΗ τελευταία συνάρτηση που θα συζητήσουμε χρησιμοποιεί κανονικές εκφράσεις για την εξαγωγή δεδομένων από μία στήλη σε μία ή περισσότερες νέες στήλες: η separate_wider_regex(). Η συνάρτηση αυτή συγγενεύει με τις συναρτήσεις separate_wider_position() και separate_wider_delim(), για τις οποίες μάθατε στην Ενότητα 14.4.2. Αυτές οι συναρτήσεις υπάρχουν στο πακέτο tidyr επειδή λειτουργούν σε (στήλες απο) πλαίσια δεδομένων και όχι σε μεμονωμένα διανύσματα.\nΑς δημιουργήσουμε ένα απλό σύνολο δεδομένων για να δείξουμε πώς λειτουργεί. Εδώ έχουμε λίγα δεδομένα που προέρχονται από το babynames, όπου έχουμε το όνομα, το φύλο και την ηλικία πολλών ανθρώπων σε μία μάλλον περίεργη μορφή5:\n\ndf &lt;- tribble(\n  ~str,\n  \"&lt;Sheryl&gt;-F_34\",\n  \"&lt;Kisha&gt;-F_45\", \n  \"&lt;Brandon&gt;-N_33\",\n  \"&lt;Sharon&gt;-F_38\", \n  \"&lt;Penny&gt;-F_58\",\n  \"&lt;Justin&gt;-M_41\", \n  \"&lt;Patricia&gt;-F_84\", \n)\n\nΓια να εξαγάγουμε αυτά τα δεδομένα χρησιμοποιώντας την separate_wider_regex() πρέπει απλώς να δημιουργήσουμε μία ακολουθία κανονικών εκφράσεων που να ταιριάζουν με κάθε κομμάτι. Αν θέλουμε τα περιεχόμενα αυτού του κομματιού να εμφανίζονται στην έξοδο, του δίνουμε ένα όνομα:\n\ndf |&gt; \n  separate_wider_regex(\n    str,\n    patterns = c(\n      \"&lt;\", \n      name = \"[A-Za-z]+\", \n      \"&gt;-\", \n      gender = \".\",\n      \"_\",\n      age = \"[0-9]+\"\n    )\n  )\n#&gt; # A tibble: 7 × 3\n#&gt;   name    gender age  \n#&gt;   &lt;chr&gt;   &lt;chr&gt;  &lt;chr&gt;\n#&gt; 1 Sheryl  F      34   \n#&gt; 2 Kisha   F      45   \n#&gt; 3 Brandon N      33   \n#&gt; 4 Sharon  F      38   \n#&gt; 5 Penny   F      58   \n#&gt; 6 Justin  M      41   \n#&gt; # ℹ 1 more row\n\nΕάν η αντιστοίχιση αποτύχει, μπορείτε να χρησιμοποιήσετε το too_few = \"debug\" για να καταλάβετε τι πήγε στραβά, όπως ακριβώς στην separate_wider_delim() και στην separate_wider_position().\n\n15.3.5 Ασκήσεις\n\nΠοιο όνομα μωρού έχει τα περισσότερα φωνήεντα;\nΠοιο όνομα έχει την υψηλότερη αναλογία φωνηέντων;\n(Υπόδειξη: ποιος είναι ο παρονομαστής;)\nΑντικαταστήστε όλες τις μπροστινές κάθετες στο \"a/b/c/d/e\" με ανάστροφες κάθετες. Τι συμβαίνει εάν επιχειρήσετε να αναιρέσετε τον μετασχηματισμό αντικαθιστώντας όλες τις ανάστροφες κάθετες με κάθετες προς τα εμπρός;\n(Θα συζητήσουμε το πρόβλημα πολύ σύντομα.)\nΥλοποιήστε μία απλή έκδοση της str_to_lower() χρησιμοποιώντας την str_replace_all().\nΔημιουργήστε μία κανονική έκφραση που θα ταιριάζει με τους αριθμούς τηλεφώνου, όπως συνήθως γράφονται στη χώρα σας.",
    "crumbs": [
      "Μετασχηματισμοί",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Λογικές εκφράσεις</span>"
    ]
  },
  {
    "objectID": "regexps.html#λεπτομέρειες-των-μοτίβων",
    "href": "regexps.html#λεπτομέρειες-των-μοτίβων",
    "title": "15  Λογικές εκφράσεις",
    "section": "\n15.4 Λεπτομέρειες των μοτίβων",
    "text": "15.4 Λεπτομέρειες των μοτίβων\nΤώρα που καταλαβαίνετε τα βασικά της γλώσσας μοτίβων και πώς να τη χρησιμοποιήσετε με ορισμένες λειτουργίες του πακέτου stringr και του πακέτου tidyr, ήρθε η ώρα να εμβαθύνετε σε περισσότερες λεπτομέρειες. Αρχικά, θα ξεκινήσουμε με τη διαφυγή, η οποία σας επιτρέπει να αντιστοιχίσετε μεταχαρακτήρες, που διαφορετικά θα αντιμετώπιζαν με ειδικό τρόπο. Μετά, θα μάθετε για τις αγκιστρώσεις που σας επιτρέπουν να ταιριάξετε την αρχή ή το τέλος της συμβολοσειράς. Στη συνέχεια, θα μάθετε περισσότερα για τις κατηγορίες χαρακτήρων και τις συντομεύσεις τους, οι οποίες σας επιτρέπουν να ταιριάξετε οποιονδήποτε χαρακτήρα από ένα σύνολο. Ακολούθως, θα μάθετε τις τελευταίες λεπτομέρειες των ποσοτικών δεικτών οι οποίοι ελέγχουν πόσες φορές μπορεί να ταιριάζει ένα μοτίβο. Επιπλέον, πρέπει να καλύψουμε το σημαντικό (αλλά πολύπλοκο) θέμα της ιεραρχίας τελεστή και τις παρενθέσεις. Και θα ολοκληρώσουμε με λίγες λεπτομέρειες σχετικά με την ομαδοποίηση των στοιχείων του μοτίβου.\nΟι όροι που χρησιμοποιούμε εδώ είναι οι τεχνικές ονομασίες για κάθε στοιχείο. Δεν θυμίζουν πάντα τον σκοπό τους, αλλά είναι πολύ χρήσιμο να γνωρίζετε τους σωστούς όρους εάν αργότερα θέλετε να τους γκουγκλάρετε για περισσότερες λεπτομέρειες.\n\n15.4.1 Διαφυγή\nΓια να αντιστοιχίσετε ένα σταθερό ., χρειάζεστε μία διαφυγή, η οποία λέει στην τυπική έκφραση να ταιριάζει κυριολεκτικά με μεταχαρακτήρες6. Όπως οι συμβολοσειρές, έτσι και οι κανονικές εκφράσεις, χρησιμοποιούν την ανάστροφη κάθετο για διαφυγή. Έτσι, για να αντιστοιχίσετε ένα ., χρειάζεστε το regexp \\.. Δυστυχώς αυτό δημιουργεί πρόβλημα. Χρησιμοποιούμε συμβολοσειρές για να αναπαραστήσουμε κανονικές εκφράσεις και το \\ χρησιμοποιείται ως σύμβολο διαφυγής σε συμβολοσειρές. Για να δημιουργήσουμε λοιπόν την κανονική έκφραση \\. χρειαζόμαστε τη συμβολοσειρά \"\\\\.\", όπως δείχνει το παρακάτω παράδειγμα.\n\n# Για να δημιουργήσετε την κανονική έκραση \\., πρέπει να χρησιμοποιήσουμε \\\\.\ndot &lt;- \"\\\\.\"\n\n# Η ίδια η έφραση, όμως, περιέχει ένα \\\nstr_view(dot)\n#&gt; [1] │ \\.\n\n# Και έτσι, αυτό λέει στην R να ψάξει για ένα κυριολεκτικό .\nstr_view(c(\"abc\", \"a.c\", \"bef\"), \"a\\\\.c\")\n#&gt; [2] │ &lt;a.c&gt;\n\nΣε αυτό το βιβλίο, συνήθως γράφουμε κανονικές εκφράσεις χωρίς εισαγωγικά, όπως η \\.. Εάν πρέπει να τονίσουμε τι θα πληκτρολογήσετε στην πραγματικότητα, θα το περιβάλουμε με εισαγωγικά και θα προσθέσουμε επιπλέον διαφυγές, όπως η \"\\\\.\".\nΕάν το \\ χρησιμοποιείται ως χαρακτήρας διαφυγής σε κανονικές εκφράσεις, πώς αντιστοιχίζετε ένα σταθερό \\;\nΠρέπει να το διαφύγετε, δημιουργώντας την κανονική έκφραση \\\\. Για να δημιουργήσετε αυτήν την κανονική έκφραση, πρέπει να χρησιμοποιήσετε μία συμβολοσειρά, η οποία πρέπει επίσης να διαφύγει από το \\. Αυτό σημαίνει ότι για να ταιριάξετε ένα κυριολεκτικό \\ πρέπει να γράψετε \"\\\\\\\\\" — χρειάζεστε δηλαδή τέσσερις ανάστροφες κάθετες για να ταιριάξετε μία!\n\nx &lt;- \"a\\\\b\"\nstr_view(x)\n#&gt; [1] │ a\\b\nstr_view(x, \"\\\\\\\\\")\n#&gt; [1] │ a&lt;\\&gt;b\n\nΕναλλακτικά, μπορεί να είναι πιο εύκολο να χρησιμοποιήσετε τις ακατέργαστες συμβολοσειρές που μάθατε στην Ενότητα 14.2.2). Αυτό σας επιτρέπει να αποφύγετε ένα επίπεδο διαφυγής:\n\nstr_view(x, r\"{\\\\}\")\n#&gt; [1] │ a&lt;\\&gt;b\n\nΕάν προσπαθείτε να αντιστοιχίσετε ένα σταθερό ., $, |, *, +, ?, {, }, (, ), υπάρχει μία εναλλακτική από τη χρήση μιας διαφυγής ανάστροφης κάθετου: μπορείτε να χρησιμοποιήσετε μία κατηγορία χαρακτήρων: [.], [$], [|], …, όπου όλα ταιριάζουν με τις σταθερές τιμές.\n\nstr_view(c(\"abc\", \"a.c\", \"a*c\", \"a c\"), \"a[.]c\")\n#&gt; [2] │ &lt;a.c&gt;\nstr_view(c(\"abc\", \"a.c\", \"a*c\", \"a c\"), \".[*]c\")\n#&gt; [3] │ &lt;a*c&gt;\n\n\n15.4.2 Αγκιστρώσεις\nΑπό προεπιλογή, οι κανονικές εκφράσεις θα ταιριάζουν με οποιοδήποτε μέρος μιας συμβολοσειράς. Εάν θέλετε να ταιριάξετε στην αρχή ή στο τέλος, πρέπει να αγκιστρώσετε την κανονική έκφραση χρησιμοποιώντας το ^ για να ταιριάζει με την αρχή, ή το $ για να ταιριάζει με το τέλος:\n\nstr_view(fruit, \"^a\")\n#&gt; [1] │ &lt;a&gt;pple\n#&gt; [2] │ &lt;a&gt;pricot\n#&gt; [3] │ &lt;a&gt;vocado\nstr_view(fruit, \"a$\")\n#&gt;  [4] │ banan&lt;a&gt;\n#&gt; [15] │ cherimoy&lt;a&gt;\n#&gt; [30] │ feijo&lt;a&gt;\n#&gt; [36] │ guav&lt;a&gt;\n#&gt; [56] │ papay&lt;a&gt;\n#&gt; [74] │ satsum&lt;a&gt;\n\nΕίναι δελεαστικό να πιστεύουμε ότι το $ πρέπει να ταιριάζει με την αρχή μιας συμβολοσειράς, γιατί έτσι συμβολίζουμε ποσά σε δολάρια, αλλά δεν είναι αυτός ο τρόπος που λειτουργούν οι κανονικές εκφράσεις.\nΓια να αναγκάσετε μία κανονική έκφραση να ταιριάζει μόνο με την πλήρη συμβολοσειρά, αγκιστρώστε την και με το ^ και με το $:\n\nstr_view(fruit, \"apple\")\n#&gt;  [1] │ &lt;apple&gt;\n#&gt; [62] │ pine&lt;apple&gt;\nstr_view(fruit, \"^apple$\")\n#&gt; [1] │ &lt;apple&gt;\n\nΜπορείτε επίσης να αντιστοιχίσετε το όριο μεταξύ των λέξεων (δηλαδή την αρχή ή το τέλος μιας λέξης) με \\b. Αυτό μπορεί να είναι ιδιαίτερα χρήσιμο όταν χρησιμοποιείτε το εργαλείο εύρεσης και αντικατάστασης του RStudio. Για παράδειγμα, για να βρείτε όλες τις χρήσεις της sum(), μπορείτε να αναζητήσετε \\bsum\\b για να αποφύγετε την αντιστοίχιση με τα summarize, summary, rowsum και ούτω καθεξής:\n\nx &lt;- c(\"summary(x)\", \"summarize(df)\", \"rowsum(x)\", \"sum(x)\")\nstr_view(x, \"sum\")\n#&gt; [1] │ &lt;sum&gt;mary(x)\n#&gt; [2] │ &lt;sum&gt;marize(df)\n#&gt; [3] │ row&lt;sum&gt;(x)\n#&gt; [4] │ &lt;sum&gt;(x)\nstr_view(x, \"\\\\bsum\\\\b\")\n#&gt; [4] │ &lt;sum&gt;(x)\n\nΌταν χρησιμοποιούνται μόνες τους, οι αγκιστρώσεις θα παράγουν μία αντιστοίχιση μηδενικού πλάτους:\n\nstr_view(\"abc\", c(\"$\", \"^\", \"\\\\b\"))\n#&gt; [1] │ abc&lt;&gt;\n#&gt; [2] │ &lt;&gt;abc\n#&gt; [3] │ &lt;&gt;abc&lt;&gt;\n\nΑυτό σας βοηθά να κατανοήσετε τι συμβαίνει όταν αντικαθιστάτε μία αυτόνομη αγκίστρωση:\n\nstr_replace_all(\"abc\", c(\"$\", \"^\", \"\\\\b\"), \"--\")\n#&gt; [1] \"abc--\"   \"--abc\"   \"--abc--\"\n\n\n15.4.3 Κατηγορίες χαρακτήρων\nΜία κατηγορία χαρακτήρων ή σύνολο χαρακτήρων, σας επιτρέπει να αντιστοιχίσετε οποιονδήποτε χαρακτήρα σε ένα σύνολο. Όπως συζητήσαμε παραπάνω, μπορείτε να δημιουργήσετε τα δικά σας σύνολα με το [], όπου το [abc] ταιριάζει με τα “a”, “b” ή “c”, και το [^abc] ταιριάζει με οποιονδήποτε χαρακτήρα εκτός από το “a” , “b” ή “c”. Εκτός από το ^, υπάρχουν δύο άλλοι χαρακτήρες που έχουν ιδιαίτερη σημασία μέσα στο []:\n\nΤο - ορίζει ένα εύρος, π.χ., το [a-z] αντιστοιχεί σε οποιοδήποτε πεζό γράμμα και το [0-9] αντιστοιχεί σε οποιονδήποτε αριθμό.\nΤο \\ διαφεύγει ειδικούς χαρακτήρες, επομένως το [\\^\\-\\]] ταιριάζει με τα ^, - ή ].\n\nΑκολουθούν μερικά παραδείγματα:\n\nx &lt;- \"abcd ABCD 12345 -!@#%.\"\nstr_view(x, \"[abc]+\")\n#&gt; [1] │ &lt;abc&gt;d ABCD 12345 -!@#%.\nstr_view(x, \"[a-z]+\")\n#&gt; [1] │ &lt;abcd&gt; ABCD 12345 -!@#%.\nstr_view(x, \"[^a-z0-9]+\")\n#&gt; [1] │ abcd&lt; ABCD &gt;12345&lt; -!@#%.&gt;\n\n# You need an escape to match characters that are otherwise\n# special inside of []\nstr_view(\"a-b-c\", \"[a-c]\")\n#&gt; [1] │ &lt;a&gt;-&lt;b&gt;-&lt;c&gt;\nstr_view(\"a-b-c\", \"[a\\\\-c]\")\n#&gt; [1] │ &lt;a&gt;&lt;-&gt;b&lt;-&gt;&lt;c&gt;\n\nΟρισμένες κατηγορίες χαρακτήρων χρησιμοποιούνται τόσο συχνά που έχουν τη δική τους συντόμευση. Έχετε ήδη δει το ., το οποίο ταιριάζει με οποιονδήποτε χαρακτήρα εκτός από μία νέα γραμμή. Υπάρχουν άλλα τρία ιδιαίτερα χρήσιμα ζεύγη7:\n\nΤο \\d αντιστοιχεί σε οποιοδήποτε ψηφίο. Το \\D αντιστοιχεί σε οτιδήποτε δεν είναι ψηφίο.\nΤο \\s αντιστοιχεί σε οποιοδήποτε κενό διάστημα (π.χ. κενό, tab, νέα γραμμή). Το \\S αντιστοιχεί σε οτιδήποτε δεν είναι κενό.\nΤο \\w ταιριάζει με οποιονδήποτε χαρακτήρα “λέξης”, π.χ. γράμματα και αριθμούς. Το \\W αντιστοιχεί σε οποιονδήποτε χαρακτήρα “μη λέξης”.\n\nΟ παρακάτω κώδικας δείχνει τις έξι συντομεύσεις με μία επιλογή από γράμματα, αριθμούς και χαρακτήρες στίξης.\n\nx &lt;- \"abcd ABCD 12345 -!@#%.\"\nstr_view(x, \"\\\\d+\")\n#&gt; [1] │ abcd ABCD &lt;12345&gt; -!@#%.\nstr_view(x, \"\\\\D+\")\n#&gt; [1] │ &lt;abcd ABCD &gt;12345&lt; -!@#%.&gt;\nstr_view(x, \"\\\\s+\")\n#&gt; [1] │ abcd&lt; &gt;ABCD&lt; &gt;12345&lt; &gt;-!@#%.\nstr_view(x, \"\\\\S+\")\n#&gt; [1] │ &lt;abcd&gt; &lt;ABCD&gt; &lt;12345&gt; &lt;-!@#%.&gt;\nstr_view(x, \"\\\\w+\")\n#&gt; [1] │ &lt;abcd&gt; &lt;ABCD&gt; &lt;12345&gt; -!@#%.\nstr_view(x, \"\\\\W+\")\n#&gt; [1] │ abcd&lt; &gt;ABCD&lt; &gt;12345&lt; -!@#%.&gt;\n\n\n15.4.4 Ποσοτικοί δείκτες\nΟι ποσοτικοί δείκτες ελέγχουν πόσες φορές ταιριάζει ένα μοτίβο. Στην Ενότητα 15.2 μάθατε για το ? (0 ή 1 αντιστοιχίσεις), το + (1 ή περισσότερες αντιστοιχίσεις) και το * (0 ή περισσότερες αντιστοιχίσεις). Για παράδειγμα, το colou?r θα ταιριάζει με την αμερικανική ή τη βρετανική ορθογραφία, το \\d+ θα ταιριάζει με ένα ή περισσότερα ψηφία και το \\s? θα ταιριάζει προαιρετικά με ένα μόνο στοιχείο κενού διαστήματος. Μπορείτε επίσης να καθορίσετε τον αριθμό των αντιστοιχιών με ακρίβεια με το {}:\n\nΤο {n} αντιστοιχεί ακριβώς n φορές.\nΤο {n,} αντιστοιχεί τουλάχιστον n φορές.\nΤο {n,m} αντιστοιχεί μεταξύ n και m φορών.\n\n15.4.5 Ιεραρχία τελεστή και παρενθέσεις\nΜε τι ταιριάζει το ab+;\nΤαιριάζει με το “a” ακολουθούμενο από ένα ή περισσότερα “b”, ή με το “ab” που επαναλαμβάνεται πολλές φορές;\nΜε τι ταιριάζει το ^a|b$;\nΤαιριάζει με την πλήρη συμβολοσειρά a, την πλήρη συμβολοσειρά b, ή μήπως ταιριάζει με μία συμβολοσειρά που αρχίζει με a, ή μία συμβολοσειρά που τελειώνει με b;\nΗ απάντηση σε αυτές τις ερωτήσεις καθορίζεται από την ιεραρχία του τελεστή, παρόμοια με τους κανόνες PEMDAS ή BEDMAS, που μπορεί να έχετε μάθει στο σχολείο. (Αυτό ισχυεί για την Αμερική. Στην Ελλάδα έχουμε απλά την προτεραιότητα των πράξεων). Γνωρίζετε ότι το a + b * c είναι ισοδύναμο με το a + (b * c), κι όχι με το (a + b) * c, επειδή το * έχει μεγαλύτερη προτεραιότητα, και το + έχει χαμηλότερη προτεραιότητα: άρα υπολογίζετε το * (πολλαπλασιασμό) πριν από το + (πρόσθεση).\nΟμοίως, οι κανονικές εκφράσεις έχουν τους δικούς τους κανόνες προτεραιότητας: οι ποσοτικοί δείκτες έχουν υψηλή προτεραιότητα και η εναλλαγή έχει χαμηλή προτεραιότητα που σημαίνει ότι το ab+ είναι ισοδύναμο με το a(b+) και το ^a|b$ είναι ισοδύναμο με το (^a )|(b$). Όπως και με την άλγεβρα, μπορείτε να χρησιμοποιήσετε παρενθέσεις για να παρακάμψετε τη συνήθη σειρά. Αλλά σε αντίθεση με την άλγεβρα, στις κανονικές εκφράσεις, είναι απίθανο να θυμάστε τους κανόνες προτεραιότητας, γι’ αυτό μη διστάσετε να χρησιμοποιήσετε τις παρενθέσεις ελεύθερα.\n\n15.4.6 Ομαδοποίηση και αποτύπωση\nΕκτός από την υπέρβαση της προτεραιότητας τελεστή, οι παρενθέσεις έχουν ένα άλλο σημαντικό αποτέλεσμα: δημιουργούν ομάδες καταγραφής που σας επιτρέπουν να χρησιμοποιείτε δευτερεύοντα στοιχεία της αντιστοίχισης.\nΟ πρώτος τρόπος για να χρησιμοποιήσετε μία ομάδα καταγραφής είναι να ανατρέξετε σε αυτήν μέσα σε μία αντιστοίχιση με την οπίσθια αναφορά: το \\1 αναφέρεται στην αντιστοίχιση που περιέχεται στην πρώτη παρένθεση, το \\2 στη δεύτερη παρένθεση και ούτω καθεξής. Για παράδειγμα, το ακόλουθο μοτίβο βρίσκει όλα τα φρούτα που έχουν ένα επαναλαμβανόμενο ζευγάρι γραμμάτων:\n\nstr_view(fruit, \"(..)\\\\1\")\n#&gt;  [4] │ b&lt;anan&gt;a\n#&gt; [20] │ &lt;coco&gt;nut\n#&gt; [22] │ &lt;cucu&gt;mber\n#&gt; [41] │ &lt;juju&gt;be\n#&gt; [56] │ &lt;papa&gt;ya\n#&gt; [73] │ s&lt;alal&gt; berry\n\nΚαι αυτό βρίσκει όλες τις λέξεις που ξεκινούν και τελειώνουν με το ίδιο ζεύγος γραμμάτων:\n\nstr_view(words, \"^(..).*\\\\1$\")\n#&gt; [152] │ &lt;church&gt;\n#&gt; [217] │ &lt;decide&gt;\n#&gt; [617] │ &lt;photograph&gt;\n#&gt; [699] │ &lt;require&gt;\n#&gt; [739] │ &lt;sense&gt;\n\nΜπορείτε επίσης να χρησιμοποιήσετε οπίσθιες αναφορά στην str_replace(). Για παράδειγμα, αυτός ο κώδικας αλλάζει τη σειρά της δεύτερης και της τρίτης λέξης στο sentences:\n\nsentences |&gt; \n  str_replace(\"(\\\\w+) (\\\\w+) (\\\\w+)\", \"\\\\1 \\\\3 \\\\2\") |&gt; \n  str_view()\n#&gt; [1] │ The canoe birch slid on the smooth planks.\n#&gt; [2] │ Glue sheet the to the dark blue background.\n#&gt; [3] │ It's to easy tell the depth of a well.\n#&gt; [4] │ These a days chicken leg is a rare dish.\n#&gt; [5] │ Rice often is served in round bowls.\n#&gt; [6] │ The of juice lemons makes fine punch.\n#&gt; ... and 714 more\n\nΕάν θέλετε να εξάγετε τις αντιστοιχίσεις για κάθε ομάδα, μπορείτε να χρησιμοποιήσετε την str_match(). Η str_match() όμως επιστρέφει ένα μητρώο, επομένως δεν είναι ιδιαίτερα εύκολη στη χρήση της8:\n\nsentences |&gt; \n  str_match(\"the (\\\\w+) (\\\\w+)\") |&gt; \n  head()\n#&gt;      [,1]                [,2]     [,3]    \n#&gt; [1,] \"the smooth planks\" \"smooth\" \"planks\"\n#&gt; [2,] \"the sheet to\"      \"sheet\"  \"to\"    \n#&gt; [3,] \"the depth of\"      \"depth\"  \"of\"    \n#&gt; [4,] NA                  NA       NA      \n#&gt; [5,] NA                  NA       NA      \n#&gt; [6,] NA                  NA       NA\n\nΘα μπορούσατε όμως να το μετατρέψετε σε ένα tibble και να ονομάσετε τις στήλες κατάλληλα:\n\nsentences |&gt; \n  str_match(\"the (\\\\w+) (\\\\w+)\") |&gt; \n  as_tibble(.name_repair = \"minimal\") |&gt; \n  set_names(\"match\", \"word1\", \"word2\")\n#&gt; # A tibble: 720 × 3\n#&gt;   match             word1  word2 \n#&gt;   &lt;chr&gt;             &lt;chr&gt;  &lt;chr&gt; \n#&gt; 1 the smooth planks smooth planks\n#&gt; 2 the sheet to      sheet  to    \n#&gt; 3 the depth of      depth  of    \n#&gt; 4 &lt;NA&gt;              &lt;NA&gt;   &lt;NA&gt;  \n#&gt; 5 &lt;NA&gt;              &lt;NA&gt;   &lt;NA&gt;  \n#&gt; 6 &lt;NA&gt;              &lt;NA&gt;   &lt;NA&gt;  \n#&gt; # ℹ 714 more rows\n\nΣτην ουσία έχετε δημιουργήσει ξανά τη δική σας έκδοση της separate_wider_regex(). Πράγματι, στο παρασκήνιο, η separate_wider_regex() μετατρέπει το διάνυσμα των μοτίβων σας σε μία ενιαία κανονική έκφραση που χρησιμοποιεί ομαδοποίηση για την καταγραφή των ονομαζόμενων στοιχείων.\nΠεριστασιακά, θα θέλετε να χρησιμοποιήσετε παρενθέσεις χωρίς να δημιουργήσετε αντίστοιχες ομάδες. Μπορείτε να δημιουργήσετε μία ομάδα χωρίς καταγραφή με το (?:).\n\nx &lt;- c(\"a gray cat\", \"a grey dog\")\nstr_match(x, \"gr(e|a)y\")\n#&gt;      [,1]   [,2]\n#&gt; [1,] \"gray\" \"a\" \n#&gt; [2,] \"grey\" \"e\"\nstr_match(x, \"gr(?:e|a)y\")\n#&gt;      [,1]  \n#&gt; [1,] \"gray\"\n#&gt; [2,] \"grey\"\n\n\n15.4.7 Ασκήσεις\n\nΠώς θα αντιστοιχίζατε με την σταθερή συμβολοσειρά \"'\\;\nΠώς με την \"$^$\";\nΕξηγήστε γιατί καθένα από αυτά τα μοτίβα δεν ταιριάζει με ένα \\: \"\\\", \"\\\\\", \"\\\\\\\".\n\nΔεδομένου του κειμένου των κοινών λέξεων στο stringr::words, δημιουργήστε κανονικές εκφράσεις που βρίσκουν όλες τις λέξεις που:\n\nΞεκινούν με “y”.\nΔεν ξεκινούν με “y”.\nΤελειώνουν με “x”.\nΕίναι ακριβώς τρία γράμματα. (Μην κλέψετε χρησιμοποιώντας την εύκολη λύση με τηνstr_length()!)\nΈχουν επτά γράμματα ή περισσότερα.\nΠεριέχουν ένα ζεύγος φωνήεντος-σύμφωνου.\nΠεριέχουν τουλάχιστον δύο ζεύγη φωνήεντος-συμφώνου στη σειρά.\nΑποτελούνται μόνο από επαναλαμβανόμενα ζεύγη φωνήεντος-συμφώνου.\n\n\nΔημιουργήστε 11 κανονικές εκφράσεις που να ταιριάζουν με τη βρετανική ή την αμερικανική ορθογραφία για καθεμία από τις ακόλουθες λέξεις: airplane/aeroplane, aluminum/aluminium, analog/analogue, ass/arse, center/centre, defense/defence, donut/doughnut, gray/grey, modeling/modelling, skeptic/sceptic, summarize/summarise. Δοκιμάστε και κατασκευάστε το συντομότερο δυνατό regex!\nΑλλάξτε το πρώτο και το τελευταίο γράμμα στο words. Ποιες από αυτές τις συμβολοσειρές είναι ακόμα στο words;\n\nΠεριγράψτε με λέξεις τι ταιριάζουν οι ακόλουθες κανονικές εκφράσεις: (Διαβάστε προσεκτικά για να δείτε αν κάθε καταχώρηση είναι μία κανονική έκφραση ή μία συμβολοσειρά που ορίζει μία κανονική έκφραση.)\n\n^.*$\n\"\\\\{.+\\\\}\"\n\\d{4}-\\d{2}-\\d{2}\n\"\\\\\\\\{4}\"\n\\..\\..\\..\n(.)\\1\\1\n\"(..)\\\\1\"\n\n\nΛύστε τα σταυρόλεξα για αρχάριους regexp στη διεύθυνση https://regexcrossword.com/challenges/beginner.",
    "crumbs": [
      "Μετασχηματισμοί",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Λογικές εκφράσεις</span>"
    ]
  },
  {
    "objectID": "regexps.html#έλεγχος-μοτίβων",
    "href": "regexps.html#έλεγχος-μοτίβων",
    "title": "15  Λογικές εκφράσεις",
    "section": "\n15.5 Έλεγχος μοτίβων",
    "text": "15.5 Έλεγχος μοτίβων\nΕίναι εφικτό να ασκήσετε επιπλέον έλεγχο στις λεπτομέρειες της αντιστοίχισης χρησιμοποιώντας ένα αντικείμενο μοτίβου αντί απλώς μία συμβολοσειρά. Αυτό σας επιτρέπει να ελέγχετε τους λεγόμενους δείκτες regex και να ταιριάζετε διάφορους τύπους σταθερών συμβολοσειρών, όπως περιγράφεται παρακάτω.\n\n15.5.1 Δείκτες regex\nΥπάρχει ένας αριθμός ρυθμίσεων που μπορούν να χρησιμοποιηθούν για τον έλεγχο των λεπτομερειών του regexp. Αυτές οι ρυθμίσεις ονομάζονται συχνά δείκτες σε άλλες γλώσσες προγραμματισμού. Στο πακέτο stringr, μπορείτε να τα χρησιμοποιήσετε ενθυλακώνοντας το μοτίβο σε μία κλήση της regex(). Ο πιο χρήσιμος δείκτης είναι πιθανώς το ignore_case = TRUE, επειδή επιτρέπει στους χαρακτήρες να ταιριάζουν είτε με κεφαλαία είτε με πεζά γράμματα:\n\nbananas &lt;- c(\"banana\", \"Banana\", \"BANANA\")\nstr_view(bananas, \"banana\")\n#&gt; [1] │ &lt;banana&gt;\nstr_view(bananas, regex(\"banana\", ignore_case = TRUE))\n#&gt; [1] │ &lt;banana&gt;\n#&gt; [2] │ &lt;Banana&gt;\n#&gt; [3] │ &lt;BANANA&gt;\n\nΕάν δουλεύετε αρκετά με συμβολοσειρές πολλαπλών γραμμών (δηλαδή συμβολοσειρές που περιέχουν \\n), το dotall και το multiline μπορούν επίσης να είναι χρήσιμα:\n\n\nΤο dotall = TRUE επιτρέπει στο . να ταιριάζει με τα πάντα, συμπεριλαμβανομένου του \\n:\n\nx &lt;- \"Line 1\\nLine 2\\nLine 3\"\nstr_view(x, \".Line\")\nstr_view(x, regex(\".Line\", dotall = TRUE))\n#&gt; [1] │ Line 1&lt;\n#&gt;     │ Line&gt; 2&lt;\n#&gt;     │ Line&gt; 3\n\n\n\nΤο multiline = TRUE κάνει τα ^ και $ να ταιριάζουν με την αρχή και το τέλος κάθε γραμμής αντί για την αρχή και το τέλος της πλήρους συμβολοσειράς:\n\nx &lt;- \"Line 1\\nLine 2\\nLine 3\"\nstr_view(x, \"^Line\")\n#&gt; [1] │ &lt;Line&gt; 1\n#&gt;     │ Line 2\n#&gt;     │ Line 3\nstr_view(x, regex(\"^Line\", multiline = TRUE))\n#&gt; [1] │ &lt;Line&gt; 1\n#&gt;     │ &lt;Line&gt; 2\n#&gt;     │ &lt;Line&gt; 3\n\n\n\nΤέλος, εάν γράφετε μία περίπλοκη κανονική έκφραση και ανησυχείτε ότι μπορεί να μην την καταλάβετε στο μέλλον, μπορείτε να δοκιμάσετε το comments = TRUE. Προσαρμόζει τη γλώσσα του μοτίβου ώστε να αγνοεί τα κενά και τις νέες γραμμές, καθώς και τα πάντα μετά το #. Αυτό σας επιτρέπει να χρησιμοποιείτε σχόλια και κενά διαστήματα για να κάνετε πιο κατανοητές σύνθετες κανονικές εκφράσεις9, όπως στο ακόλουθο παράδειγμα:\n\nphone &lt;- regex(\n  r\"(\n    \\(?     # optional opening parens\n    (\\d{3}) # area code\n    [)\\-]?  # optional closing parens or dash\n    \\ ?     # optional space\n    (\\d{3}) # another three numbers\n    [\\ -]?  # optional space or dash\n    (\\d{4}) # four more numbers\n  )\", \n  comments = TRUE\n)\n\nstr_extract(c(\"514-791-8141\", \"(123) 456 7890\", \"123456\"), phone)\n#&gt; [1] \"514-791-8141\"   \"(123) 456 7890\" NA\n\nΕάν χρησιμοποιείτε σχόλια και θέλετε να αντιστοιχίσετε ένα κενό διάστημα, μία νέα γραμμή ή ένα #, θα πρέπει να τα διαφύγετε με το \\.\n\n15.5.2 Σταθερές αντιστοιχίσεις\nΜπορείτε να επιλέξετε να μην χρησιμοποιήσετε κανονικές εκφράσεις με το fixed():\n\nstr_view(c(\"\", \"a\", \".\"), fixed(\".\"))\n#&gt; [3] │ &lt;.&gt;\n\nΤο fixed() σας δίνει επίσης τη δυνατότητα να αγνοήσετε πεζά και κεφαλαία:\n\nstr_view(\"x X\", \"X\")\n#&gt; [1] │ x &lt;X&gt;\nstr_view(\"x X\", fixed(\"X\", ignore_case = TRUE))\n#&gt; [1] │ &lt;x&gt; &lt;X&gt;\n\nΕάν εργάζεστε με μη αγγλικό κείμενο, πιθανότατα θα θέλετε το coll() αντί για το fixed(), καθώς εφαρμόζει τους πλήρεις κανόνες για τη χρήση κεφαλαίων, όπως χρησιμοποιείται από τις τοπικές ρυθμίσεις γλώσσας που καθορίζετε. Δείτε την Ενότητα 14.6 για περισσότερες λεπτομέρειες σχετικά με τις τοπικές ρυθμίσεις γλώσσας.\n\nstr_view(\"i İ ı I\", fixed(\"İ\", ignore_case = TRUE))\n#&gt; [1] │ i &lt;İ&gt; ı I\nstr_view(\"i İ ı I\", coll(\"İ\", ignore_case = TRUE, locale = \"tr\"))\n#&gt; [1] │ &lt;i&gt; &lt;İ&gt; ı I",
    "crumbs": [
      "Μετασχηματισμοί",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Λογικές εκφράσεις</span>"
    ]
  },
  {
    "objectID": "regexps.html#εξάσκηση",
    "href": "regexps.html#εξάσκηση",
    "title": "15  Λογικές εκφράσεις",
    "section": "\n15.6 Εξάσκηση",
    "text": "15.6 Εξάσκηση\nΓια να εφαρμόσουμε αυτές τις ιδέες θα λύσουμε στη συνέχεια μερικά ημι-αυθεντικά προβλήματα. Θα συζητήσουμε τρεις γενικές τεχνικές:\n\nΈλεγχος της εργασία σας δημιουργώντας απλούς θετικούς και αρνητικούς ελέγχους.\nΣυνδυασμός κανονικών εκφράσεων με άλγεβρα Boole.\nΔημιουργία σύνθετων μοτίβων χρησιμοποιώντας με τον χειρισμό συμβολοσειρών.\n\n\n15.6.1 Ελέγξτε την εργασία σας\nΑρχικά, ας βρούμε όλες τις προτάσεις που ξεκινούν με “The”. Η χρήση του αγκίστρου ^ από μόνο του δεν αρκεί:\n\nstr_view(sentences, \"^The\")\n#&gt;  [1] │ &lt;The&gt; birch canoe slid on the smooth planks.\n#&gt;  [4] │ &lt;The&gt;se days a chicken leg is a rare dish.\n#&gt;  [6] │ &lt;The&gt; juice of lemons makes fine punch.\n#&gt;  [7] │ &lt;The&gt; box was thrown beside the parked truck.\n#&gt;  [8] │ &lt;The&gt; hogs were fed chopped corn and garbage.\n#&gt; [11] │ &lt;The&gt; boy was there when the sun rose.\n#&gt; ... and 271 more\n\nΕπειδή αυτό το μοτίβο ταιριάζει επίσης με προτάσεις που ξεκινούν με λέξεις όπως They ή These. Πρέπει να βεβαιωθούμε ότι το “e” είναι το τελευταίο γράμμα της λέξης, το οποίο μπορούμε να κάνουμε προσθέτοντας ένα όριο λέξης:\n\nstr_view(sentences, \"^The\\\\b\")\n#&gt;  [1] │ &lt;The&gt; birch canoe slid on the smooth planks.\n#&gt;  [6] │ &lt;The&gt; juice of lemons makes fine punch.\n#&gt;  [7] │ &lt;The&gt; box was thrown beside the parked truck.\n#&gt;  [8] │ &lt;The&gt; hogs were fed chopped corn and garbage.\n#&gt; [11] │ &lt;The&gt; boy was there when the sun rose.\n#&gt; [13] │ &lt;The&gt; source of the huge river is the clear spring.\n#&gt; ... and 250 more\n\nΤι γίνεται με την εύρεση όλων των προτάσεων που ξεκινούν με μία αντωνυμία;\n\nstr_view(sentences, \"^She|He|It|They\\\\b\")\n#&gt;  [3] │ &lt;It&gt;'s easy to tell the depth of a well.\n#&gt; [15] │ &lt;He&gt;lp the woman get back to her feet.\n#&gt; [27] │ &lt;He&gt;r purse was full of useless trash.\n#&gt; [29] │ &lt;It&gt; snowed, rained, and hailed the same morning.\n#&gt; [63] │ &lt;He&gt; ran half way to the hardware store.\n#&gt; [90] │ &lt;He&gt; lay prone and hardly moved a limb.\n#&gt; ... and 57 more\n\nΜία γρήγορη επιθεώρηση των αποτελεσμάτων δείχνει ότι παίρνουμε κάποιες λάθος αντιστοιχίσεις. Αυτό συμβαίνει επειδή έχουμε ξεχάσει να χρησιμοποιήσουμε παρενθέσεις:\n\nstr_view(sentences, \"^(She|He|It|They)\\\\b\")\n#&gt;   [3] │ &lt;It&gt;'s easy to tell the depth of a well.\n#&gt;  [29] │ &lt;It&gt; snowed, rained, and hailed the same morning.\n#&gt;  [63] │ &lt;He&gt; ran half way to the hardware store.\n#&gt;  [90] │ &lt;He&gt; lay prone and hardly moved a limb.\n#&gt; [116] │ &lt;He&gt; ordered peach pie with ice cream.\n#&gt; [127] │ &lt;It&gt; caught its hind paw in a rusty trap.\n#&gt; ... and 51 more\n\nΊσως αναρωτιέστε πώς θα μπορούσατε να εντοπίσετε ένα τέτοιο λάθος αν δεν συνέβαινε στις πρώτες αντιστοιχίσεις. Μία καλή τεχνική είναι να δημιουργήσετε μερικές θετικές και αρνητικές αντιστοιχίσεις και να τις χρησιμοποιήσετε για να ελέγξετε ότι το μοτίβο σας λειτουργεί όπως αναμένεται:\n\npos &lt;- c(\"He is a boy\", \"She had a good time\")\nneg &lt;- c(\"Shells come from the sea\", \"Hadley said 'It's a great day'\")\n\npattern &lt;- \"^(She|He|It|They)\\\\b\"\nstr_detect(pos, pattern)\n#&gt; [1] TRUE TRUE\nstr_detect(neg, pattern)\n#&gt; [1] FALSE FALSE\n\nΣυνήθως είναι πολύ πιο εύκολο να βρείτε καλά θετικά παραδείγματα, παρά αρνητικά, μιας και χρειάζεται χρόνος για να είστε αρκετά καλοί με τις κανονικές εκφράσεις, έτσι ώστε να προβλέψετε πού βρίσκονται οι αδυναμίες σας. Ωστόσο, εξακολουθούν να είναι χρήσιμα: καθώς εργάζεστε πάνω στο πρόβλημα, μπορείτε σιγά-σιγά να συγκεντρώσετε μία συλλογή από τα λάθη σας, διασφαλίζοντας ότι δεν θα κάνετε ποτέ το ίδιο λάθος δύο φορές.\n\n15.6.2 Boolean λειτουργίες\nΦανταστείτε ότι θέλουμε να βρούμε λέξεις που περιέχουν μόνο σύμφωνα. Μία τεχνική είναι να δημιουργήσετε μία κατηγορία χαρακτήρων που περιέχει όλα τα γράμματα εκτός από τα φωνήεντα ([^aeiou]), στη συνέχεια να επιτρέψετε να ταιριάζει με οποιονδήποτε αριθμό γραμμάτων ([^aeiou]+) και στη συνέχεια να την αναγκάσετε να ταιριάζει με ολόκληρη τη συμβολοσειρά αγκιστρώνοντας στην αρχή και στο τέλος (^[^aeiou]+$):\n\nstr_view(words, \"^[^aeiou]+$\")\n#&gt; [123] │ &lt;by&gt;\n#&gt; [249] │ &lt;dry&gt;\n#&gt; [328] │ &lt;fly&gt;\n#&gt; [538] │ &lt;mrs&gt;\n#&gt; [895] │ &lt;try&gt;\n#&gt; [952] │ &lt;why&gt;\n\nΜπορείτε όμως να κάνετε αυτό το πρόβλημα λίγο πιο εύκολο αναστρέφοντάς το. Αντί να αναζητούμε λέξεις που περιέχουν μόνο σύμφωνα, θα μπορούσαμε να αναζητήσουμε λέξεις που δεν περιέχουν φωνήεντα:\n\nstr_view(words[!str_detect(words, \"[aeiou]\")])\n#&gt; [1] │ by\n#&gt; [2] │ dry\n#&gt; [3] │ fly\n#&gt; [4] │ mrs\n#&gt; [5] │ try\n#&gt; [6] │ why\n\nΑυτή είναι μία χρήσιμη τεχνική για κάθε φορά που έχετε να κάνετε με λογικούς συνδυασμούς, ιδιαίτερα αυτούς που περιλαμβάνουν “και” ή “όχι”. Για παράδειγμα, φανταστείτε ότι θέλετε να βρείτε όλες τις λέξεις που περιέχουν “a” και “b”. Δεν υπάρχει ενσωματωμένος τελεστής “και” στις κανονικές εκφράσεις, επομένως πρέπει να το αντιμετωπίσουμε αναζητώντας όλες τις λέξεις που περιέχουν ένα “a” ακολουθούμενο από ένα “b”, ή ένα “b” ακολουθούμενο από ένα “a”:\n\nstr_view(words, \"a.*b|b.*a\")\n#&gt;  [2] │ &lt;ab&gt;le\n#&gt;  [3] │ &lt;ab&gt;out\n#&gt;  [4] │ &lt;ab&gt;solute\n#&gt; [62] │ &lt;availab&gt;le\n#&gt; [66] │ &lt;ba&gt;by\n#&gt; [67] │ &lt;ba&gt;ck\n#&gt; ... and 24 more\n\nΕίναι πιο απλό να συνδυάσετε τα αποτελέσματα δύο κλήσεων στην str_detect():\n\nwords[str_detect(words, \"a\") & str_detect(words, \"b\")]\n#&gt;  [1] \"able\"      \"about\"     \"absolute\"  \"available\" \"baby\"      \"back\"     \n#&gt;  [7] \"bad\"       \"bag\"       \"balance\"   \"ball\"      \"bank\"      \"bar\"      \n#&gt; [13] \"base\"      \"basis\"     \"bear\"      \"beat\"      \"beauty\"    \"because\"  \n#&gt; [19] \"black\"     \"board\"     \"boat\"      \"break\"     \"brilliant\" \"britain\"  \n#&gt; [25] \"debate\"    \"husband\"   \"labour\"    \"maybe\"     \"probable\"  \"table\"\n\nΤι θα γινόταν αν θέλαμε να δούμε αν υπάρχει μία λέξη που περιέχει όλα τα φωνήεντα;  Αν το κάναμε με μοτίβα θα έπρεπε να δημιουργήσουμε 5! διαφορετικά μοτίβα, δηλαδή 120 διαφορετικά μοτίβα:\n\nwords[str_detect(words, \"a.*e.*i.*o.*u\")]\n# ...\nwords[str_detect(words, \"u.*o.*i.*e.*a\")]\n\nΕίναι πολύ πιο απλό να συνδυάσετε πέντε κλήσεις της str_detect():\n\nwords[\n  str_detect(words, \"a\") &\n  str_detect(words, \"e\") &\n  str_detect(words, \"i\") &\n  str_detect(words, \"o\") &\n  str_detect(words, \"u\")\n]\n#&gt; character(0)\n\nΓενικά, αν κολλήσετε προσπαθώντας να δημιουργήσετε ένα ενιαίο regexp που λύνει το πρόβλημά σας, κάντε ένα βήμα πίσω και σκεφτείτε αν θα μπορούσατε να σπάσετε το πρόβλημα σε μικρότερα κομμάτια, λύνοντας κάθε πτυχή πριν προχωρήσετε στην επόμενη.\n\n15.6.3 Δημιουργία μοτίβου με κώδικα\nΤι θα γινόταν αν θέλαμε να βρούμε όλες τις προτάσεις (sentences) που αναφέρουν ένα χρώμα;\nΗ βασική ιδέα είναι απλή: απλώς συνδυάζουμε την εναλλαγή με τα όρια λέξεων.\n\nstr_view(sentences, \"\\\\b(red|green|blue)\\\\b\")\n#&gt;   [2] │ Glue the sheet to the dark &lt;blue&gt; background.\n#&gt;  [26] │ Two &lt;blue&gt; fish swam in the tank.\n#&gt;  [92] │ A wisp of cloud hung in the &lt;blue&gt; air.\n#&gt; [148] │ The spot on the blotter was made by &lt;green&gt; ink.\n#&gt; [160] │ The sofa cushion is &lt;red&gt; and of light weight.\n#&gt; [174] │ The sky that morning was clear and bright &lt;blue&gt;.\n#&gt; ... and 20 more\n\nΑλλά καθώς ο αριθμός των χρωμάτων αυξάνεται, το να κατασκευάσετε αυτό το μοτίβο με το χέρι θα γινόταν γρήγορα κουραστικό. Δεν θα ήταν ωραίο αν μπορούσαμε να αποθηκεύσουμε τα χρώματα σε ένα διάνυσμα;\n\nrgb &lt;- c(\"red\", \"green\", \"blue\")\n\nΛοιπόν, μπορούμε! Απλώς θα χρειαστεί να δημιουργήσουμε το μοτίβο από το διάνυσμα χρησιμοποιώντας την str_c() και την str_flatten():\n\nstr_c(\"\\\\b(\", str_flatten(rgb, \"|\"), \")\\\\b\")\n#&gt; [1] \"\\\\b(red|green|blue)\\\\b\"\n\nΘα μπορούσαμε να κάνουμε αυτό το μοτίβο ακόμη πιο ολοκληρωμένο αν είχαμε μία καλή λίστα χρωμάτων. Ένα μέρος από το οποίο θα μπορούσαμε να ξεκινήσουμε είναι η λίστα των ενσωματωμένων χρωμάτων που μπορεί να χρησιμοποιήσει η R για γραφικά:\n\nstr_view(colors())\n#&gt; [1] │ white\n#&gt; [2] │ aliceblue\n#&gt; [3] │ antiquewhite\n#&gt; [4] │ antiquewhite1\n#&gt; [5] │ antiquewhite2\n#&gt; [6] │ antiquewhite3\n#&gt; ... and 651 more\n\nΑς εξαλείψουμε όμως πρώτα τις αριθμημένες παραλλαγές:\n\ncols &lt;- colors()\ncols &lt;- cols[!str_detect(cols, \"\\\\d\")]\nstr_view(cols)\n#&gt; [1] │ white\n#&gt; [2] │ aliceblue\n#&gt; [3] │ antiquewhite\n#&gt; [4] │ aquamarine\n#&gt; [5] │ azure\n#&gt; [6] │ beige\n#&gt; ... and 137 more\n\nΤότε μπορούμε να το μετατρέψουμε σε ένα μεγάλο μοτίβο. Δεν θα δείξουμε το μοτίβο εδώ επειδή είναι μεγάλο, αλλά μπορείτε να το δείτε να λειτουργεί:\n\npattern &lt;- str_c(\"\\\\b(\", str_flatten(cols, \"|\"), \")\\\\b\")\nstr_view(sentences, pattern)\n#&gt;   [2] │ Glue the sheet to the dark &lt;blue&gt; background.\n#&gt;  [12] │ A rod is used to catch &lt;pink&gt; &lt;salmon&gt;.\n#&gt;  [26] │ Two &lt;blue&gt; fish swam in the tank.\n#&gt;  [66] │ Cars and busses stalled in &lt;snow&gt; drifts.\n#&gt;  [92] │ A wisp of cloud hung in the &lt;blue&gt; air.\n#&gt; [112] │ Leaves turn &lt;brown&gt; and &lt;yellow&gt; in the fall.\n#&gt; ... and 57 more\n\nΣε αυτό το παράδειγμα, το cols περιέχει μόνο αριθμούς και γράμματα, επομένως δεν χρειάζεται να ανησυχείτε για μεταχαρακτήρες. Γενικά όμως, κάθε φορά που δημιουργείτε μοτίβα από υπάρχουσες συμβολοσειρές, είναι καλό να τα περνάτε μέσα από την str_escape() για να διασφαλίσετε ότι ταιριάζουν κυριολεκτικά.\n\n15.6.4 Ασκήσεις\n\n\nΓια καθεμία από τις παρακάτω προκλήσεις, δοκιμάστε να την λύσετε χρησιμοποιώντας τόσο μία απλή κανονική έκφραση όσο και έναν συνδυασμό πολλαπλών κλήσεων της str_detect().\n\nΒρείτε όλες τις λέξεις (words) που ξεκινούν ή τελειώνουν με x.\nΒρείτε όλες τις λέξεις που ξεκινούν από φωνήεν και τελειώνουν σε σύμφωνο.\nΥπάρχουν λέξεις που περιέχουν τουλάχιστον ένα από κάθε διαφορετικό φωνήεν;\n\n\nΚατασκευάστε μοτίβα για να βρείτε στοιχεία υπέρ και κατά του κανόνα “i πριν από e εκτός από το c”.\nH colors() περιέχει έναν αριθμό τροποποιητών, όπως “lightgray” και “darkblue”. Πώς θα μπορούσατε να αναγνωρίσετε αυτόματα αυτούς τους τροποποιητές;\n(Σκεφτείτε πώς μπορείτε να εντοπίσετε και, στη συνέχεια, αφαιρέστε τα χρώματα που έχουν τροποποιηθεί).\nΔημιουργήστε μία κανονική έκφραση που βρίσκει οποιοδήποτε βασικό σύνολο δεδομένων της R. Μπορείτε να λάβετε μία λίστα με αυτά τα σύνολα δεδομένων μέσω μιας ειδικής χρήσης της συνάρτησης data(): data(package = \"datasets\")$results[, \"Item\"]. Σημειώστε ότι ορισμένα παλιά σύνολα δεδομένων είναι μεμονωμένα διανύσματα. Αυτά περιέχουν το όνομα του ομαδοποιημένου “πλαισίου δεδομένων” σε παρένθεση, επομένως θα πρέπει να τα αφαιρέσετε.",
    "crumbs": [
      "Μετασχηματισμοί",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Λογικές εκφράσεις</span>"
    ]
  },
  {
    "objectID": "regexps.html#κανονικές-εκφράσεις-σε-άλλα-μέρη",
    "href": "regexps.html#κανονικές-εκφράσεις-σε-άλλα-μέρη",
    "title": "15  Λογικές εκφράσεις",
    "section": "\n15.7 Κανονικές εκφράσεις σε άλλα μέρη",
    "text": "15.7 Κανονικές εκφράσεις σε άλλα μέρη\nΑκριβώς όπως και στις συναρτήσεις του πακέτου stringr και του πακέτου tidyr, υπάρχουν πολλά άλλα μέρη στην R όπου μπορείτε να χρησιμοποιήσετε κανονικές εκφράσεις. Οι ακόλουθες ενότητες περιγράφουν μερικές άλλες χρήσιμες λειτουργίες στο ευρύτερο tidyverse και στο βασικό πακέτο λειτουργιών της R.\n\n15.7.1 tidyverse\nΥπάρχουν τρία άλλα ιδιαίτερα χρήσιμα μέρη όπου μπορεί να θέλετε να χρησιμοποιήσετε κανονικές εκφράσεις\n\nΗ match(pattern) θα επιλέξει όλες τις μεταβλητές των οποίων το όνομα ταιριάζει με το παρεχόμενο μοτίβο. Είναι μία συνάρτηση που χρησιμοποιεί κανόνες “tidyselect” και μπορείτε να τη χρησιμοποιήσετε οπουδήποτε σε οποιαδήποτε συνάρτηση της tidyverse που επιλέγει μεταβλητές (π.χ. select(), rename_with() και across()).\nΤο όρισμα names_pattern της pivot_longer() παίρνει ένα διάνυσμα κανονικών εκφράσεων, ακριβώς όπως και η separate_wider_regex(). Είναι χρήσιμο κατά την εξαγωγή δεδομένων από ονόματα μεταβλητών με σύνθετη δομή.\nΤο όρισμα delim της separate_longer_delim() και της separate_wider_delim() συνήθως ταιριάζει με μία σταθερή συμβολοσειρά, αλλά μπορείτε να χρησιμοποιήσετε την regex() για να το κάνετε να ταιριάζει με ένα μοτίβο. Αυτό είναι χρήσιμο, για παράδειγμα, εάν θέλετε να ταιριάξετε ένα κόμμα που προαιρετικά ακολουθείται από ένα κενό, όπως για παράδειγμα με το regex(\", ?\").\n\n15.7.2 Βασικό σύνολο λειτουργιών της R\nΗ apropos(pattern) αναζητά όλα τα διαθέσιμα αντικείμενα από το περιβάλλον της R που ταιριάζουν με το συγκεκριμένο μοτίβο. Αυτό είναι χρήσιμο εάν δεν μπορείτε να θυμηθείτε το όνομα μιας συνάρτησης:\n\napropos(\"replace\")\n#&gt; [1] \"%+replace%\"       \"replace\"          \"replace_na\"      \n#&gt; [4] \"setReplaceMethod\" \"str_replace\"      \"str_replace_all\" \n#&gt; [7] \"str_replace_na\"   \"theme_replace\"\n\nH list.files(path, pattern) παραθέτει όλα τα αρχεία στο μονοπάτι path που ταιριάζουν με μία κανονική έκφραση pattern. Για παράδειγμα, μπορείτε να βρείτε όλα τα αρχεία R Markdown στον τρέχοντα κατάλογο με:\n\nhead(list.files(pattern = \"\\\\.Rmd$\"))\n#&gt; character(0)\n\nΑξίζει να σημειωθεί ότι η γλώσσα μοτίβων που χρησιμοποιείται από τη βασικό σύνολο λειτουργιών της R είναι ελαφρώς διαφορετική από αυτή που χρησιμοποιείται από το πακέτο stringr. Αυτό συμβαίνει επειδή το πακέτο stringr είναι χτισμένο πάνω από το πακέτο stringi, το οποίο με τη σειρά του είναι χτισμένο πάνω από το ICU engine, ενώ οι βασικές συναρτήσεις της R χρησιμοποιούν είτε το TRE engine είτε το PCRE engine, ανάλογα με το αν έχετε ορίσει ή όχι perl = TRUE. Ευτυχώς, τα βασικά στοιχεία των κανονικών εκφράσεων είναι τόσο καλά εδραιωμένα που θα συναντήσετε λίγες παραλλαγές όταν εργάζεστε με τα μοτίβα που θα μάθετε σε αυτό το βιβλίο. Χρειάζεται μόνο να γνωρίζετε τη διαφορά όταν αρχίσετε να βασίζεστε σε προηγμένες δυνατότητες, όπως σύνθετες περιοχές χαρακτήρων Unicode, ή ειδικές δυνατότητες που χρησιμοποιούν τη σύνταξη τύπου (?…).",
    "crumbs": [
      "Μετασχηματισμοί",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Λογικές εκφράσεις</span>"
    ]
  },
  {
    "objectID": "regexps.html#σύνοψη",
    "href": "regexps.html#σύνοψη",
    "title": "15  Λογικές εκφράσεις",
    "section": "\n15.8 Σύνοψη",
    "text": "15.8 Σύνοψη\nΜε κάθε χαρακτήρα στίξης να είναι υπερφορτωμένος με νόημα, οι κανονικές εκφράσεις είναι μία από τις πιο συμπαγείς γλώσσες. Σίγουρα προκαλούν σύγχυση στην αρχή, αλλά καθώς εκπαιδεύετε τα μάτια σας να τα διαβάζουν, και τον εγκέφαλό σας να τα κατανοεί, ξεκλειδώνετε μία ισχυρή δεξιότητα που μπορείτε να χρησιμοποιήσετε στην R και σε πολλά άλλα μέρη.\nΣε αυτό το κεφάλαιο, ξεκινήσατε το ταξίδι σας για να κατακτήσετε τις κανονικές εκφράσεις μαθαίνοντας τις πιο χρήσιμες συναρτήσεις του πακέτου stringr και τα πιο σημαντικά στοιχεία της γλώσσας της κανονικής έκφρασης. Υπάρχουν πολλές πηγές για να μάθετε περισσότερα.\nΈνα καλό μέρος για να ξεκινήσετε είναι το vignette(\"regular-expressions, package = \"stringr\"): τεκμηριώνει το πλήρες σύνολο της σύνταξης που υποστηρίζεται από το πακέτο stringr. Μία άλλη χρήσιμη αναφορά είναι το https://www.regular-expressions.info/. Δεν είναι συγκεκριμένο για την R, αλλά μπορείτε να το χρησιμοποιήσετε για να μάθετε για τις πιο προηγμένες δυνατότητες των regexes και πώς λειτουργούν στο παρασκήνιο.\nΕίναι επίσης καλό να γνωρίζετε ότι το πακέτο stringr υλοποιείται πάνω από το πακέτο stringi από τον Marek Gagolewski. Αν δυσκολεύεστε να βρείτε μία συνάρτηση που κάνει ό,τι χρειάζεστε στο πακέτο stringr, μην φοβάστε να ψάξετε στην stringi. Θα βρείτε την stringi πολύ εύκολη να μάθετε επειδή ακολουθεί πολλές από τις ίδιες συμβάσεις με το πακέτο stringr.\nΣτο επόμενο κεφάλαιο, θα μιλήσουμε για μία δομή δεδομένων που σχετίζεται στενά με συμβολοσειρές: τους παράγοντες. Οι παράγοντες χρησιμοποιούνται για την αναπαράσταση κατηγορικών δεδομένων στην R, δηλαδή δεδομένων με ένα σταθερό και γνωστό σύνολο πιθανών τιμών, που προσδιορίζονται από ένα διάνυσμα συμβολοσειρών.",
    "crumbs": [
      "Μετασχηματισμοί",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Λογικές εκφράσεις</span>"
    ]
  },
  {
    "objectID": "regexps.html#footnotes",
    "href": "regexps.html#footnotes",
    "title": "15  Λογικές εκφράσεις",
    "section": "",
    "text": "Μπορείτε να το προφέρετε είτε με “γκ” (ρέγκεξ) είτε με “τζ” (ρέτζεξ).↩︎\nΘα μάθετε πώς να δισφύγετε αυτές τις ειδικές έννοιες στην Ενότητα 15.4.1.↩︎\nΠρακτικά, οποιοσδήποτε χαρακτήρας εκτός από το \\n.↩︎\nΑυτό μας δίνει την αναλογία των ονομάτων που περιέχουν ένα “x”. Εάν θέλατε την αναλογία των μωρών, των οποίων το όνομα περιέχει ένα x, θα έπρεπε να υπολογίσετε μία σταθμισμένη μέση τιμή.↩︎\nΕυχόμαστε να μπορούσαμε να σας διαβεβαιώσουμε ότι δεν θα δείτε ποτέ κάτι τόσο περίεργο σε πραγματικές συνθήκες, αλλά δυστυχώς κατά τη διάρκεια της καριέρας σας είναι πιθανό να δείτε πολύ πιο περίεργες περιπτώσεις!↩︎\nΤο πλήρες σύνολο μεταχαρακτήρων είναι .^$\\|*+?{}[]()↩︎\nΘυμηθείτε, για να δημιουργήσετε μία κανονική έκφραση που περιέχει τα \\d ή \\s, θα πρέπει να διαφύγετε το \\ για τη συμβολοσειρά, επομένως θα πληκτρολογήσετε \"\\\\d\" ή \"\\\\s\".↩︎\nΚυρίως επειδή δεν συζητάμε ποτέ μητρώα σε αυτό το βιβλίο!↩︎\nΤο comments = TRUE είναι ιδιαίτερα αποτελεσματικό σε συνδυασμό με μία ακατέργαστη συμβολοσειρά, όπως το χρησιμοποιούμε εδώ.↩︎",
    "crumbs": [
      "Μετασχηματισμοί",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Λογικές εκφράσεις</span>"
    ]
  },
  {
    "objectID": "factors.html",
    "href": "factors.html",
    "title": "16  Παράγοντες",
    "section": "",
    "text": "16.1 Εισαγωγή\nΟι παράγοντες χρησιμοποιούνται για κατηγορικές μεταβλητές, μεταβλητές που έχουν ένα σταθερό και γνωστό σύνολο πιθανών τιμών. Είναι επίσης χρήσιμοι όταν θέλετε να εμφανίσετε διανύσματα χαρακτήρων με μία μη αλφαβητική σειρά.\nΘα ξεκινήσουμε δίνοντας κίνητρα για τους λόγους που χρειάζονται στην ανάλυση δεδομένων1 και πώς μπορείτε να τους δημιουργήσετε με την factor(). Στη συνέχεια, θα σας παρουσιάσουμε το σύνολο δεδομένων gss_cat που περιέχει αρκετές κατηγορικές μεταβλητές για πειραματισμό. Στη συνέχεια, θα χρησιμοποιήσετε αυτό το σύνολο δεδομένων για να εξασκηθείτε στην τροποποίηση της σειράς και των τιμών των παραγόντων, προτού ολοκληρώσουμε τη συζήτηση για τους διατεταγμένους παράγοντες.",
    "crumbs": [
      "Μετασχηματισμοί",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Παράγοντες</span>"
    ]
  },
  {
    "objectID": "factors.html#εισαγωγή",
    "href": "factors.html#εισαγωγή",
    "title": "16  Παράγοντες",
    "section": "",
    "text": "16.1.1 Προαπαιτούμενα\nΤο βασικό πακέτο λειτουργιών της R παρέχει μερικά εργαλεία για τη δημιουργία και τον χειρισμό παραγόντων. Θα τα συμπληρώσουμε με το πακέτο forcats, το οποίο αποτελεί μέρος του tidyverse. Παρέχει εργαλεία για την διαχείριση κατηγορικών μεταβλητών χρησιμοποιώντας ένα ευρύ φάσμα βοηθητικών συναρτήσεων για την εργασία με παράγοντες.\n\nlibrary(tidyverse)",
    "crumbs": [
      "Μετασχηματισμοί",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Παράγοντες</span>"
    ]
  },
  {
    "objectID": "factors.html#βασικές-αρχές-παραγόντων",
    "href": "factors.html#βασικές-αρχές-παραγόντων",
    "title": "16  Παράγοντες",
    "section": "\n16.2 Βασικές αρχές παραγόντων",
    "text": "16.2 Βασικές αρχές παραγόντων\nΦανταστείτε ότι έχετε μία μεταβλητή που καταγράφει έναν μήνα:\n\nx1 &lt;- c(\"Dec\", \"Apr\", \"Jan\", \"Mar\")\n\nΗ χρήση μιας συμβολοσειράς για την εγγραφή αυτής της μεταβλητής έχει δύο προβλήματα:\n\n\nΥπάρχουν μόνο δώδεκα πιθανοί μήνες και τίποτα δεν σας γλυτώνει από τυπογραφικά λάθη:\n\nx2 &lt;- c(\"Dec\", \"Apr\", \"Jam\", \"Mar\")\n\n\n\nΔεν ταξινομείται με χρήσιμο τρόπο:\n\nsort(x1)\n#&gt; [1] \"Apr\" \"Dec\" \"Jan\" \"Mar\"\n\n\n\nΤα δύο αυτά προβλήματα διορθώνονται με έναν παράγοντα. Για να δημιουργήσετε έναν παράγοντα, πρέπει να ξεκινήσετε δημιουργώντας ένα διάνυσμα με έγκυρα επίπεδα:\n\nmonth_levels &lt;- c(\n  \"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \n  \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"\n)\n\nΜπορείτε τώρα να δημιουργήσετε έναν παράγοντα:\n\ny1 &lt;- factor(x1, levels = month_levels)\ny1\n#&gt; [1] Dec Apr Jan Mar\n#&gt; Levels: Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec\n\nsort(y1)\n#&gt; [1] Jan Mar Apr Dec\n#&gt; Levels: Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec\n\nΚαι οποιεσδήποτε τιμές δεν βρίσκονται στα επίπεδα, θα μετατραπούν σε NA χωρίς προειδοποίηση:\n\ny2 &lt;- factor(x2, levels = month_levels)\ny2\n#&gt; [1] Dec  Apr  &lt;NA&gt; Mar \n#&gt; Levels: Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec\n\nΑυτό φαίνεται επικίνδυνο, επομένως μπορεί αντ’ αυτού να θέλετε να χρησιμοποιήσετε την forcats::fct():\n\ny2 &lt;- fct(x2, levels = month_levels)\n#&gt; Error in `fct()`:\n#&gt; ! All values of `x` must appear in `levels` or `na`\n#&gt; ℹ Missing level: \"Jam\"\n\nΕάν παραλείψετε τα επίπεδα, θα ληφθούν από τα δεδομένα με αλφαβητική σειρά:\n\nfactor(x1)\n#&gt; [1] Dec Apr Jan Mar\n#&gt; Levels: Apr Dec Jan Mar\n\nΗ αλφαβητική ταξινόμηση είναι ελαφρώς επικίνδυνη, καθώς κάθε υπολογιστής δεν ταξινομεί συμβολοσειρές με τον ίδιο τρόπο. Η forcats::fct() ταξινομεί βάση της πρώτης εμφάνισης:\n\nfct(x1)\n#&gt; [1] Dec Apr Jan Mar\n#&gt; Levels: Dec Apr Jan Mar\n\nΕάν ποτέ χρειαστεί να αποκτήσετε απευθείας πρόσβαση στο σύνολο έγκυρων επιπέδων, μπορείτε να το κάνετε με την levels():\n\nlevels(y2)\n#&gt;  [1] \"Jan\" \"Feb\" \"Mar\" \"Apr\" \"May\" \"Jun\" \"Jul\" \"Aug\" \"Sep\" \"Oct\" \"Nov\" \"Dec\"\n\nΜπορείτε επίσης να δημιουργήσετε έναν παράγοντα κατά την ανάγνωση των δεδομένων σας χρησιμοποιώντας το col_factor() στην readr:\n\ncsv &lt;- \"\nmonth,value\nJan,12\nFeb,56\nMar,12\"\n\ndf &lt;- read_csv(csv, col_types = cols(month = col_factor(month_levels)))\ndf$month\n#&gt; [1] Jan Feb Mar\n#&gt; Levels: Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec",
    "crumbs": [
      "Μετασχηματισμοί",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Παράγοντες</span>"
    ]
  },
  {
    "objectID": "factors.html#general-social-survey",
    "href": "factors.html#general-social-survey",
    "title": "16  Παράγοντες",
    "section": "\n16.3 General Social Survey",
    "text": "16.3 General Social Survey\nΓια το υπόλοιπο αυτού του κεφαλαίου, θα χρησιμοποιήσουμε το forcats::gss_cat. Είναι ένα δείγμα δεδομένων από την General Social Survey, μία μακροχρόνια έρευνα στις ΗΠΑ που διενεργήθηκε από τον ανεξάρτητο ερευνητικό οργανισμό NORC στο Πανεπιστήμιο του Σικάγο. Η έρευνα έχει χιλιάδες ερωτήσεις, για αυτό τον λόγο ο Hadley επέλεξε κάποιες που μπορούν να δώσουν την εικόνα για μερικές συχνές προκλήσεις που θα αντιμετωπίσετε όταν εργάζεστε με παράγοντες.\n\ngss_cat\n#&gt; # A tibble: 21,483 × 9\n#&gt;    year marital         age race  rincome        partyid           \n#&gt;   &lt;int&gt; &lt;fct&gt;         &lt;int&gt; &lt;fct&gt; &lt;fct&gt;          &lt;fct&gt;             \n#&gt; 1  2000 Never married    26 White $8000 to 9999  Ind,near rep      \n#&gt; 2  2000 Divorced         48 White $8000 to 9999  Not str republican\n#&gt; 3  2000 Widowed          67 White Not applicable Independent       \n#&gt; 4  2000 Never married    39 White Not applicable Ind,near rep      \n#&gt; 5  2000 Divorced         25 White Not applicable Not str democrat  \n#&gt; 6  2000 Married          25 White $20000 - 24999 Strong democrat   \n#&gt; # ℹ 21,477 more rows\n#&gt; # ℹ 3 more variables: relig &lt;fct&gt;, denom &lt;fct&gt;, tvhours &lt;int&gt;\n\n(Θυμηθείτε, καθώς αυτό το σύνολο δεδομένων παρέχεται από μία βιβλιοθήκη, μπορείτε να λάβετε περισσότερες πληροφορίες σχετικά με τις μεταβλητές που περιέχει εκτελώντας το ?gss_cat.)\nΌταν οι παράγοντες αποθηκεύονται σε ένα tibble, δεν μπορείτε να δείτε τα επίπεδά τους τόσο εύκολα. Ένας τρόπος για να τα δείτε είναι με την count():\n\ngss_cat |&gt;\n  count(race)\n#&gt; # A tibble: 3 × 2\n#&gt;   race      n\n#&gt;   &lt;fct&gt; &lt;int&gt;\n#&gt; 1 Other  1959\n#&gt; 2 Black  3129\n#&gt; 3 White 16395\n\nΌταν εργάζεστε με παράγοντες, οι δύο πιο συνηθισμένες λειτουργίες είναι η αλλαγή της σειράς των επιπέδων και η αλλαγή των τιμών των επιπέδων. Οι λειτουργίες αυτές περιγράφονται στις παρακάτω ενότητες.\n\n16.3.1 Ασκήσεις\n\nΕξερευνήστε την κατανομή της rincome (δηλωθέν εισόδημα). Τι κάνει το προεπιλεγμένο ραβδόγραμμα δύσκολο να κατανοηθεί;\nΠώς θα μπορούσατε να βελτιώσετε το διάγραμμα;\nΠοια είναι η πιο συχνή τιμή της μεταβλητής relig σε αυτήν την έρευνα;\nΠοιο είναι η πιο συνηθισμένη τιμή της partyid;\nΣε ποιες τιμές της relig αντιστοιχούν οι τιμές της denom;\nΠώς μπορείτε να το μάθετε με έναν πίνακα;\nΠώς μπορείτε να το μάθετε με μία απεικόνιση;",
    "crumbs": [
      "Μετασχηματισμοί",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Παράγοντες</span>"
    ]
  },
  {
    "objectID": "factors.html#sec-modifying-factor-order",
    "href": "factors.html#sec-modifying-factor-order",
    "title": "16  Παράγοντες",
    "section": "\n16.4 Τροποποίηση σειράς παραγόντων",
    "text": "16.4 Τροποποίηση σειράς παραγόντων\nΕίναι συχνά χρήσιμο να αλλάζετε τη σειρά των επιπέδων των παραγόντων σας σε μία απεικόνιση. Για παράδειγμα, φανταστείτε ότι θέλετε να εξερευνήσετε τον μέσο αριθμό ωρών παρακολούθησης τηλεόρασης ανά ημέρα ανάλογα με τη θρησκεία:\n\nrelig_summary &lt;- gss_cat |&gt;\n  group_by(relig) |&gt;\n  summarize(\n    tvhours = mean(tvhours, na.rm = TRUE),\n    n = n()\n  )\n\nggplot(relig_summary, aes(x = tvhours, y = relig)) + \n  geom_point()\n\n\n\n\n\n\n\nΤο διάγραμμα αυτό είναι δύσκολο να διαβαστεί γιατί δεν υπάρχει κάποιο συνολικό μοτίβο. Μπορούμε να το βελτιώσουμε αναδιατάσσοντας τα επίπεδα της relig χρησιμοποιώντας την fct_reorder(). Η fct_reorder() παίρνει τρία ορίσματα:\n\n\n.f, ο παράγοντας του οποίου τα επίπεδα θέλετε να τροποποιήσετε.\n\n.x, ένα αριθμητικό διάνυσμα που θέλετε να χρησιμοποιήσετε για να αναδιατάξετε τα επίπεδα.\n\n.fun, μία προαιρετική συνάρτηση που χρησιμοποιείται σε περιπτώσεις που υπάρχουν πολλές τιμές του .x για κάθε τιμή του .f. Η προεπιλεγμένη τιμή είναι median.\n\n\nggplot(relig_summary, aes(x = tvhours, y = fct_reorder(relig, tvhours))) +\n  geom_point()\n\n\n\n\n\n\n\nΗ αναδιάταξη της θρησκείας καθιστά πολύ πιο εύκολο να δούμε ότι τα άτομα στην κατηγορία “Don’t know” παρακολουθούν πολύ περισσότερη τηλεόραση και ότι ο Ινδουισμός και οι άλλες ανατολικές θρησκείες παρακολουθούν πολύ λιγότερη.\nΚαθώς αρχίζετε να κάνετε πιο περίπλοκους μετασχηματισμούς, συνιστούμε να τους μετακινήσετε από την aes() σε μία ξεχωριστή mutate(). Για παράδειγμα, μπορείτε να ξαναγράψετε το παραπάνω διάγραμμα ως εξής:\n\nrelig_summary |&gt;\n  mutate(\n    relig = fct_reorder(relig, tvhours)\n  ) |&gt;\n  ggplot(aes(x = tvhours, y = relig)) +\n  geom_point()\n\nΤι θα συμβεί αν δημιουργήσουμε ένα παρόμοιο διάγραμμα εξερευνώντας το πώς διαφέρει η μέση ηλικία ανάλογα με το επίπεδο δηλωθέντος εισοδήματος;\n\nrincome_summary &lt;- gss_cat |&gt;\n  group_by(rincome) |&gt;\n  summarize(\n    age = mean(age, na.rm = TRUE),\n    n = n()\n  )\n\nggplot(rincome_summary, aes(x = age, y = fct_reorder(rincome, age))) + \n  geom_point()\n\n\n\n\n\n\n\nΕδώ, η αυθαίρετη αναδιάταξη των επιπέδων δεν είναι καλή ιδέα! Αυτό συμβαίνει επειδή η rincome έχει ήδη μία λογική κατάταξη με την οποία δεν πρέπει να εμπλακούμε. Κρατήστε την fct_reorder() για παράγοντες των οποίων τα επίπεδα ταξινομούνται αυθαίρετα.\nΩστόσο, είναι λογικό να βάλετε το “Not applicable” στις πρώτες θέσεις μαζί με άλλα ειδικά επίπεδα. Μπορείτε να χρησιμοποιήσετε την fct_relevel(). Χρειάζεται έναν παράγοντας, .f και, στη συνέχεια, οποιονδήποτε αριθμό επιπέδων που θέλετε να μετακινήσετε στην πρώτη θέση.\n\nggplot(rincome_summary, aes(x = age, y = fct_relevel(rincome, \"Not applicable\"))) +\n  geom_point()\n\n\n\n\n\n\n\nΓιατί πιστεύετε ότι ο μέσος όρος ηλικίας για το “Not applicable” είναι τόσο υψηλός;\nΌταν χρωματίζετε τις γραμμές σε ένα διάγραμμα, ένας άλλος τύπος αναδιάταξης είναι επίσης χρήσιμος. Η fct_reorder2(.f, .x, .y) αναδιατάσσει τον παράγοντα .f κατά τις τιμές του .y που σχετίζονται με τις μεγαλύτερες τιμές του .x. Αυτό καθιστά το διάγραμμα πιο ευανάγνωστο καθώς τα χρώματα της γραμμής στη δεξιά άκρη του διαγράμματος θα ευθυγραμμιστούν με το υπόμνημα.\nby_age &lt;- gss_cat |&gt;\n  filter(!is.na(age)) |&gt; \n  count(age, marital) |&gt;\n  group_by(age) |&gt;\n  mutate(\n    prop = n / sum(n)\n  )\n\nggplot(by_age, aes(x = age, y = prop, color = marital)) +\n  geom_line(linewidth = 1) + \n  scale_color_brewer(palette = \"Set1\")\n\nggplot(by_age, aes(x = age, y = prop, color = fct_reorder2(marital, age, prop))) +\n  geom_line(linewidth = 1) +\n  scale_color_brewer(palette = \"Set1\") + \n  labs(color = \"marital\") \n\n\n\n\n\n\n\n\n\n\nΤέλος, για ραβδογράμματα, μπορείτε να χρησιμοποιήσετε την fct_infreq() για να ταξινομήσετε επίπεδα σε φθίνουσα συχνότητα: αυτός είναι ο απλούστερος τύπος αναδιάταξης, μιας και δεν χρειάζεται επιπλέον μεταβλητές. Συνδυάστε τη με την fct_rev() εάν θέλετε να διατάξετε τα δεδομένα με αυξανόμενη συχνότητα, έτσι ώστε στο ραβδόγραμμα οι μεγαλύτερες τιμές να βρίσκονται στα δεξιά και όχι στα αριστερά.\n\ngss_cat |&gt;\n  mutate(marital = marital |&gt; fct_infreq() |&gt; fct_rev()) |&gt;\n  ggplot(aes(x = marital)) +\n  geom_bar()\n\n\n\n\n\n\n\n\n16.4.1 Ασκήσεις\n\nΥπάρχουν κάποιες υψηλές τιμές στην tvhours που είναι ύποπτες. Είναι η μέση τιμή μία καλή επιλογή για σύνοψη;\nΓια κάθε παράγοντα στο gss_cat προσδιορίστε εάν η σειρά των επιπέδων είναι αυθαίρετη ή με βάση κάποια λογική.\nΓιατί η μετακίνηση του “Not applicable” στην αρχή των επιπέδων το μετακίνησε στο κάτω μέρος του διαγράμματος;",
    "crumbs": [
      "Μετασχηματισμοί",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Παράγοντες</span>"
    ]
  },
  {
    "objectID": "factors.html#τροποποίηση-επιπέδων-παραγόντων",
    "href": "factors.html#τροποποίηση-επιπέδων-παραγόντων",
    "title": "16  Παράγοντες",
    "section": "\n16.5 Τροποποίηση επιπέδων παραγόντων",
    "text": "16.5 Τροποποίηση επιπέδων παραγόντων\nΠιο ισχυρή διαδικασία από την αλλαγή της σειράς των επιπέδων είναι η αλλαγή των τιμών τους. Αυτό σας επιτρέπει να διευκρινίσετε τις ετικέτες προς δημοσίευση και να συμπτύξετε τα επίπεδα για πιο γενικές αναλύσεις. Το πιο γενικό και ισχυρό εργαλείο είναι η fct_recode(). Σας επιτρέπει να επανακωδικοποιήσετε ή να αλλάξετε την τιμή κάθε επιπέδου. Για παράδειγμα, πάρτε τη μεταβλητή partyid από το πλαίσιο δεδομένων gss_cat:\n\ngss_cat |&gt; count(partyid)\n#&gt; # A tibble: 10 × 2\n#&gt;   partyid                n\n#&gt;   &lt;fct&gt;              &lt;int&gt;\n#&gt; 1 No answer            154\n#&gt; 2 Don't know             1\n#&gt; 3 Other party          393\n#&gt; 4 Strong republican   2314\n#&gt; 5 Not str republican  3032\n#&gt; 6 Ind,near rep        1791\n#&gt; # ℹ 4 more rows\n\nΤα επίπεδα είναι συνοπτικά και ασυνεπή. Ας τα αλλάξουμε ώστε να είναι μεγαλύτερα και ας χρησιμοποιήσουμε παράλληλη κατασκευή. Όπως και οι περισσότερες συναρτήσεις μετονομασίας και επανακωδικοποίησης στο tidyverse, οι νέες τιμές εμφανίζονται στα αριστερά και οι παλιές τιμές στα δεξιά:\n\ngss_cat |&gt;\n  mutate(\n    partyid = fct_recode(partyid,\n      \"Republican, strong\"    = \"Strong republican\",\n      \"Republican, weak\"      = \"Not str republican\",\n      \"Independent, near rep\" = \"Ind,near rep\",\n      \"Independent, near dem\" = \"Ind,near dem\",\n      \"Democrat, weak\"        = \"Not str democrat\",\n      \"Democrat, strong\"      = \"Strong democrat\"\n    )\n  ) |&gt;\n  count(partyid)\n#&gt; # A tibble: 10 × 2\n#&gt;   partyid                   n\n#&gt;   &lt;fct&gt;                 &lt;int&gt;\n#&gt; 1 No answer               154\n#&gt; 2 Don't know                1\n#&gt; 3 Other party             393\n#&gt; 4 Republican, strong     2314\n#&gt; 5 Republican, weak       3032\n#&gt; 6 Independent, near rep  1791\n#&gt; # ℹ 4 more rows\n\nΗ fct_recode() θα αφήσει τα επίπεδα που δεν αναφέρονται ρητά ως έχουν, και θα σας προειδοποιήσει εάν κατά λάθος αναφερθείτε σε ένα επίπεδο που δεν υπάρχει.\nΓια να συνδυάσετε ομάδες, μπορείτε να αντιστοιχίσετε πολλά παλιά επίπεδα στο ίδιο νέο επίπεδο:\n\ngss_cat |&gt;\n  mutate(\n    partyid = fct_recode(partyid,\n      \"Republican, strong\"    = \"Strong republican\",\n      \"Republican, weak\"      = \"Not str republican\",\n      \"Independent, near rep\" = \"Ind,near rep\",\n      \"Independent, near dem\" = \"Ind,near dem\",\n      \"Democrat, weak\"        = \"Not str democrat\",\n      \"Democrat, strong\"      = \"Strong democrat\",\n      \"Other\"                 = \"No answer\",\n      \"Other\"                 = \"Don't know\",\n      \"Other\"                 = \"Other party\"\n    )\n  )\n\nΧρησιμοποιήστε αυτήν την τεχνική με προσοχή: εάν ομαδοποιήσετε κατηγορίες που είναι πραγματικά διαφορετικές, θα καταλήξετε με παραπλανητικά αποτελέσματα.\nΕάν θέλετε να συμπτύξετε πολλά επίπεδα, η fct_collapse() είναι μία χρήσιμη παραλλαγή της fct_recode(). Για κάθε νέα μεταβλητή, μπορείτε να παρέχετε ένα διάνυσμα των παλιών επιπέδων:\n\ngss_cat |&gt;\n  mutate(\n    partyid = fct_collapse(partyid,\n      \"other\" = c(\"No answer\", \"Don't know\", \"Other party\"),\n      \"rep\" = c(\"Strong republican\", \"Not str republican\"),\n      \"ind\" = c(\"Ind,near rep\", \"Independent\", \"Ind,near dem\"),\n      \"dem\" = c(\"Not str democrat\", \"Strong democrat\")\n    )\n  ) |&gt;\n  count(partyid)\n#&gt; # A tibble: 4 × 2\n#&gt;   partyid     n\n#&gt;   &lt;fct&gt;   &lt;int&gt;\n#&gt; 1 other     548\n#&gt; 2 rep      5346\n#&gt; 3 ind      8409\n#&gt; 4 dem      7180\n\nΜερικές φορές θέλετε απλώς να συγκεντρώσετε τις μικρές ομάδες για να κάνετε ένα διάγραμμα ή έναν πίνακα πιο απλό. Αυτή είναι η δουλειά της οικογένειας συναρτήσεων fct_lump_*(). Η fct_lump_lowfreq() είναι ένα απλό σημείο εκκίνησης που συγκεντρώνει σταδιακά τις μικρότερες κατηγορίες ομάδων στην κατηγορία “Other”, διατηρώντας πάντα την “Other” ως τη μικρότερη κατηγορία.\n\ngss_cat |&gt;\n  mutate(relig = fct_lump_lowfreq(relig)) |&gt;\n  count(relig)\n#&gt; # A tibble: 2 × 2\n#&gt;   relig          n\n#&gt;   &lt;fct&gt;      &lt;int&gt;\n#&gt; 1 Protestant 10846\n#&gt; 2 Other      10637\n\nΣε αυτήν την περίπτωση, δεν είναι πολύ χρήσιμο: είναι αλήθεια ότι η πλειοψηφία των Αμερικανών σε αυτήν την έρευνα είναι Προτεστάντες, αλλά μάλλον θα θέλαμε να δούμε περισσότερες λεπτομέρειες! Αντίθετα, μπορούμε να χρησιμοποιήσουμε την fct_lump_n() για να καθορίσουμε ότι θέλουμε ακριβώς 10 ομάδες:\n\ngss_cat |&gt;\n  mutate(relig = fct_lump_n(relig, n = 10)) |&gt;\n  count(relig, sort = TRUE)\n#&gt; # A tibble: 10 × 2\n#&gt;   relig          n\n#&gt;   &lt;fct&gt;      &lt;int&gt;\n#&gt; 1 Protestant 10846\n#&gt; 2 Catholic    5124\n#&gt; 3 None        3523\n#&gt; 4 Christian    689\n#&gt; 5 Other        458\n#&gt; 6 Jewish       388\n#&gt; # ℹ 4 more rows\n\nΔιαβάστε τις οδηγίες για να μάθετε για τις fct_lump_min() και fct_lump_prop() οι οποίες είναι χρήσιμες σε άλλες περιπτώσεις.\n\n16.5.1 Ασκήσεις\n\nΠώς έχουν αλλάξει οι αναλογίες των ατόμων που ταυτίζονται ως Δημοκρατικοί, Ρεπουμπλικάνοι και Ανεξάρτητοι με την πάροδο του χρόνου;\nΠώς θα μπορούσατε να συμπτύξετε την rincome σε ένα μικρό σύνολο κατηγοριών;\nΠαρατηρήστε ότι υπάρχουν 9 ομάδες (εκτός της other) στο παραπάνω παράδειγμα fct_lump. Γιατί όχι 10;\n(Συμβουλή: εκτελέστε ?fct_lump και βρείτε ότι η προεπιλεγμένη τιμή του ορίσματος other_level είναι “Other”.)",
    "crumbs": [
      "Μετασχηματισμοί",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Παράγοντες</span>"
    ]
  },
  {
    "objectID": "factors.html#sec-ordered-factors",
    "href": "factors.html#sec-ordered-factors",
    "title": "16  Παράγοντες",
    "section": "\n16.6 Διατεταγμένοι παράγοντες",
    "text": "16.6 Διατεταγμένοι παράγοντες\nΠριν συνεχίσουμε, υπάρχει ένας ειδικός τύπος παραγόντων που πρέπει να αναφερθεί εν συντομία: οι διατεταγμένοι παράγοντες. Οι διατεταγμένοι παράγοντες, που δημιουργούνται με την ordered(), συνεπάγονται μία αυστηρή ταξινόμηση με ίση απόσταση μεταξύ των επιπέδων τους: το πρώτο επίπεδο είναι «μικρότερο» από το δεύτερο επίπεδο κατά το ίδιο ποσό που το δεύτερο επίπεδο είναι «μικρότερο από» το τρίτο επίπεδο, και ούτω καθεξής. Μπορείτε να τα αναγνωρίσετε κατά την εκτύπωση επειδή χρησιμοποιούν &lt; μεταξύ των επιπέδων:\n\nordered(c(\"a\", \"b\", \"c\"))\n#&gt; [1] a b c\n#&gt; Levels: a &lt; b &lt; c\n\nΣτην πράξη, οι παράγοντες της ordered() συμπεριφέρονται πολύ παρόμοια με τους κανονικούς παράγοντες. Υπάρχουν μόνο δύο μέρη όπου μπορεί να παρατηρήσετε διαφορετική συμπεριφορά:\n\nΕάν χρησιμοποιήσετε έναν διατεταγμένο παράγοντα για να χρωματίσετε ή να γεμίσετε σχήματα στο πακέτο ggplot2, από προεπιλογή θα πάρει την τιμή scale_color_viridis()/scale_fill_viridis(), η οποία είναι μία χρωματική κλίμακα που υποδηλώνει μία κατάταξη.\nΕάν χρησιμοποιείτε μία διατεταγμένη συνάρτηση σε ένα γραμμικό μοντέλο, θα χρησιμοποιήσει “πολυγωνικές αντιθέσεις”. Είναι σχετικά χρήσιμες, αλλά είναι απίθανο να έχετε ακούσει για αυτές, εκτός και αν έχετε διδακτορικό στη Στατιστική, και ακόμα και τότε πιθανότατα δεν τις ερμηνεύετε συχνά. Αν θέλετε να μάθετε περισσότερα, προτείνουμε το vignette(\"contrasts\", package = \"faux\") από τη Lisa DeBruine.\n\nΔεδομένης της αμφισβητούμενης χρησιμότητας αυτών των διαφορών, δεν συνιστούμε γενικά τη χρήση διατεταγμένων παραγόντων.",
    "crumbs": [
      "Μετασχηματισμοί",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Παράγοντες</span>"
    ]
  },
  {
    "objectID": "factors.html#σύνοψη",
    "href": "factors.html#σύνοψη",
    "title": "16  Παράγοντες",
    "section": "\n16.7 Σύνοψη",
    "text": "16.7 Σύνοψη\nΑυτό το κεφάλαιο σας παρουσίασε το εύχρηστο πακέτο forcats για την εργασία με παράγοντες, εισάγοντας σας στις πιο συχνά χρησιμοποιούμενες αντίστοιχες συναρτήσεις. Το forcats περιέχει αρκετές άλλων βοηθητικές συναρτήσεις που δεν είχαμε χώρο να συζητήσουμε εδώ, επομένως κάθε φορά που αντιμετωπίζετε μία πρόκληση ανάλυσης παραγόντων που δεν έχετε αντιμετωπίσει στο παρελθόν, συνιστώ ανεπιφύλακτα να διαβάσετε το reference index για να ελέγξετε εάν υπάρχει κάποια συνάρτηση που μπορεί να σας βοηθήσει να λύσετε το πρόβλημά σας.\nΕάν θέλετε να μάθετε περισσότερα σχετικά με τους παράγοντες μετά την ανάγνωση αυτού του κεφαλαίου, σας συνιστούμε να διαβάσετε την εργασία της Amelia McNamara και του Nicholas Horton, Wrangling categorical data in R. Αυτό το άρθρο παρουσιάζει μέρος της ιστορίας που συζητήθηκε στα stringsAsFactors: An unautorized biography και stringsAsFactors = &lt;sigh&gt; και συγκρίνει τις tidy προσεγγίσεις των κατηγορικών δεδομένων που περιγράφονται σε αυτό το βιβλίο με τις μεθόδους του βασικού συνόλου λειτουργιών της R. Μία αρχική έκδοση αυτού του άρθρου συνέβαλε ως κίνητρο και προεργασία για το πακέτο forcats. Ευχαριστώ Amelia & Nick!\nΣτο επόμενο κεφάλαιο θα αλλάξουμε ταχύτητα για να αρχίσουμε να μαθαίνουμε για τις ημερομηνίες και ώρες στην R. Οι ημερομηνίες και οι ώρες φαίνονται παραπλανητικά απλές, αλλά όπως θα δείτε σύντομα, όσο περισσότερα μαθαίνετε γι’ αυτές, τόσο πιο περίπλοκες φαίνονται!",
    "crumbs": [
      "Μετασχηματισμοί",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Παράγοντες</span>"
    ]
  },
  {
    "objectID": "factors.html#footnotes",
    "href": "factors.html#footnotes",
    "title": "16  Παράγοντες",
    "section": "",
    "text": "Είναι επίσης ιδιαίτερα σημαντικοί για την μοντελοποίηση.↩︎",
    "crumbs": [
      "Μετασχηματισμοί",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Παράγοντες</span>"
    ]
  },
  {
    "objectID": "datetimes.html",
    "href": "datetimes.html",
    "title": "17  Ημερομηνίες και ώρες",
    "section": "",
    "text": "17.1 Εισαγωγή\nΑυτό το κεφάλαιο θα σας δείξει πώς να εργάζεστε με ημερομηνίες και ώρες στην R. Με μία πρώτη ματιά, οι ημερομηνίες και οι ώρες φαίνονται απλές. Τα χρησιμοποιείτε όλη την ώρα στην κανονική σας ζωή και δεν φαίνεται να προκαλούν μεγάλη σύγχυση. Ωστόσο, όσο περισσότερα μαθαίνετε για τις ημερομηνίες και τις ώρες, τόσο πιο περίπλοκες φαίνονται να γίνονται!\nΓια να προετοιμαστείτε, σκεφτείτε πόσες ημέρες υπάρχουν σε ένα χρόνο και πόσες ώρες σε μία μέρα. Πιθανότατα θυμηθήκατε ότι τα περισσότερα χρόνια έχουν 365 ημέρες, αλλά τα δίσεκτα έχουν 366. Γνωρίζετε τον πλήρη κανόνα για να προσδιορίσετε εάν ένα έτος είναι δίσεκτο1; Ο αριθμός των ωρών σε μία ημέρα είναι λίγο λιγότερο προφανής: οι περισσότερες μέρες έχουν 24 ώρες, αλλά σε μέρη που χρησιμοποιούν θερινή ώρα (Daylight saving time; DST), μία μέρα κάθε χρόνο έχει 23 ώρες και μία άλλη έχει 25.\nΟι ημερομηνίες και οι ώρες είναι δύσκολες γιατί πρέπει να συμβιβάσουν δύο φυσικά φαινόμενα (την περιστροφή της Γης και την τροχιά της γύρω από τον ήλιο) με μία ολόκληρη σειρά γεωπολιτικών φαινομένων, συμπεριλαμβανομένων των μηνών, των ζωνών ώρας και της θερινής ώρας. Αυτό το κεφάλαιο δεν θα σας διδάξει και την παραμικρή λεπτομέρεια σχετικά με τις ημερομηνίες και τις ώρες, αλλά θα σας δώσει μία σταθερή βάση πρακτικών δεξιοτήτων που θα σας βοηθήσουν με κοινές προκλήσεις ανάλυσης δεδομένων.\nΘα ξεκινήσουμε δείχνοντάς σας πώς να δημιουργείτε ημερομηνίες-ώρες από διάφορες εισόδους και, στη συνέχεια, αφού έχετε μία ημερομηνία-ώρα, πώς μπορείτε να εξάγετε στοιχεία όπως το έτος, ο μήνας και η ημέρα. Στη συνέχεια, θα βουτήξουμε στο δύσκολο θέμα της εργασίας με χρονικά διαστήματα, τα οποία είναι διαθέσιμα σε εύρος επιλογών ανάλογα με το τι προσπαθείτε να κάνετε. Θα κλείσουμε με μία σύντομη συζήτηση των πρόσθετων προκλήσεων που δημιουργούν οι ζώνες ώρας.",
    "crumbs": [
      "Μετασχηματισμοί",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Ημερομηνίες και ώρες</span>"
    ]
  },
  {
    "objectID": "datetimes.html#εισαγωγή",
    "href": "datetimes.html#εισαγωγή",
    "title": "17  Ημερομηνίες και ώρες",
    "section": "",
    "text": "17.1.1 Προαπαιτούμενα\nΑυτό το κεφάλαιο θα επικεντρωθεί στο πακέτο lubridate, το οποίο διευκολύνει την εργασία με ημερομηνίες και ώρες στην R. Από την τελευταία κυκλοφορία του tidyverse, το lubridate αποτελεί μέρος του core tidyverse. Θα χρειαστούμε επίσης το nycflights13 για δεδομένα εξάσκησης.\n\nlibrary(tidyverse)\nlibrary(nycflights13)",
    "crumbs": [
      "Μετασχηματισμοί",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Ημερομηνίες και ώρες</span>"
    ]
  },
  {
    "objectID": "datetimes.html#sec-creating-datetimes",
    "href": "datetimes.html#sec-creating-datetimes",
    "title": "17  Ημερομηνίες και ώρες",
    "section": "\n17.2 Δημιουργώντας ημερομηνίες/ώρες",
    "text": "17.2 Δημιουργώντας ημερομηνίες/ώρες\nΥπάρχουν τρεις τύποι δεδομένων ημερομηνίας/ώρας που αναφέρονται σε μία συγκεκριμένη χρονική στιγμή:\n\nΜία ημερομηνία. Τα tibbles την εκτυπώνουν ως &lt;date&gt;.\nΜία ώρα μέσα σε μία μέρα. Τα tibbles την εκτυπώνουν ως &lt;time&gt;.\nΜία ημερομηνία-ώρα είναι ο συνδυασμός μιας ημερομηνίας με μία ώρα και προσδιορίζει μοναδικά μία στιγμή στο χρόνο (συνήθως στο πλησιέστερο δευτερόλεπτο). Τα tibbles την εκτυπώνουν ως &lt;dttm&gt;. Η βασική έκδοση της R τα ονομάζει POSIXct, όχι και το πιο εύκολο να προφέρουμε όνομα.\n\nΣε αυτό το κεφάλαιο θα εστιάσουμε σε ημερομηνίες και ημερομηνίες-ώρες, καθώς η R δεν έχει εγγενή κλάση για την αποθήκευση της ώρας μόνο.\nΕάν χρειάζεστε κάτι τέτοιο, μπορείτε να χρησιμοποιήσετε το πακέτο hms.\nΘα πρέπει πάντα να χρησιμοποιείτε τον απλούστερο δυνατό τύπο δεδομένων που λειτουργεί για τις ανάγκες σας. Αυτό σημαίνει ότι αν μπορείτε να χρησιμοποιήσετε μία ημερομηνία αντί για μία ημερομηνία-ώρα, θα είναι καλύτερα να το κάνετε. Οι ημερομηνίες-ώρες είναι πολύ πιο περίπλοκες λόγω της ανάγκης χειρισμού των ζωνών ώρας, στις οποίες θα επανέλθουμε στο τέλος του κεφαλαίου.\nΓια να λάβετε την τρέχουσα ημερομηνία ή ημερομηνία-ώρα, μπορείτε να χρησιμοποιήσετε τις συναρτήσεις today() ή now():\n\ntoday()\n#&gt; [1] \"2024-04-21\"\nnow()\n#&gt; [1] \"2024-04-21 10:53:33 UTC\"\n\nΕναλλακτικά, οι ακόλουθες ενότητες περιγράφουν τους τέσσερις τρόπους με τους οποίους μπορείτε να δημιουργήσετε μία ημερομηνία/ώρα:\n\nΚατά την ανάγνωση ενός αρχείου με το πακέτο readr.\nΑπό μία συμβολοσειρά.\nΑπό μεμονωμένα στοιχεία ημερομηνίας-ώρας.\nΑπό ένα υπάρχον αντικείμενο ημερομηνίας/ώρας.\n\n\n17.2.1 Κατά την εισαγωγή\nΕάν το CSV αρχείο σας περιέχει μία ημερομηνία ή ημερομηνία-ώρα που ακολουθεί το πρότυπο ISO8601, δεν χρειάζεται να κάνετε τίποτα - το πακέτο readr θα το αναγνωρίσει αυτόματα:\n\ncsv &lt;- \"\n  date,datetime\n  2022-01-02,2022-01-02 05:12\n\"\nread_csv(csv)\n#&gt; # A tibble: 1 × 2\n#&gt;   date       datetime           \n#&gt;   &lt;date&gt;     &lt;dttm&gt;             \n#&gt; 1 2022-01-02 2022-01-02 05:12:00\n\nΕάν δεν έχετε ακούσει για το ISO8601 πριν, είναι ένα διεθνές πρότυπο2 για τη σύνταξη ημερομηνιών όπου τα στοιχεία μιας ημερομηνίας είναι οργανωμένα από το μεγαλύτερο στο μικρότερο και χωρίζονται με -. Για παράδειγμα, στο ISO8601, η 3 Μαΐου 2022 γράφετε ως 2022-05-03. Οι ημερομηνίες ISO8601 μπορούν επίσης να περιλαμβάνουν ώρες, όπου οι ώρες, τα λεπτά και τα δευτερόλεπτα διαχωρίζονται με : και τα στοιχεία ημερομηνίας και ώρας διαχωρίζονται είτε με ένα T ή ένα διάστημα. Για παράδειγμα, θα μπορούσατε να γράψετε το “4:26 μ.μ. στις 3 Μαΐου 2022” είτε ως 2022-05-03 16:26 είτε ως 2022-05-03T16:26.\nΓια άλλες μορφές ημερομηνίας-ώρας, θα χρειαστεί να χρησιμοποιήσετε τα ορίσματα col_types και col_date() ή col_datetime() μαζί με ένα πρότυπο ημερομηνίας-ώρας. Το πρότυπο ημερομηνίας-ώρας που χρησιμοποιείται από το πακέτο readr είναι ένα πρότυπο που χρησιμοποιείται σε πολλές γλώσσες προγραμματισμού, και περιγράφει ένα στοιχείο ημερομηνίας με ένα % ακολουθούμενο από έναν μόνο χαρακτήρα. Για παράδειγμα, το %Y-%m-%d καθορίζει μία ημερομηνία που αφορά ένα έτος, -, μήνα (ως αριθμό) -, ημέρα. Ο πίνακας Πίνακας 17.1 παραθέτει όλες τις επιλογές.\n\n\nΠίνακας 17.1: Όλα τα πρότυπα που γίνονται κατανοητά από το πακέτο readr\n\n\n\nΤύπος\nΚωδικός\nΕξήγηση\nΠαράδειγμα\n\n\n\nΈτος\n%Y\nΧρονολογία με 4 ψηφία\n2021\n\n\n\n%y\nΧρονολογία με 2 ψηφία\n21\n\n\nΜήνας\n%m\nΑριθμός\n2\n\n\n\n%b\nΣυνοπτικό όνομα\nFeb\n\n\n\n%B\nΠλήρες όνομα\nFebruary\n\n\nΜέρα\n%d\nΈνα ή δύο ψηφία\n2\n\n\n\n%e\nΔύο ψηφία\n02\n\n\nΏρα\n%H\n24ωρη μορφή\n13\n\n\n\n%I\n12ωρη μορφή\n1\n\n\n\n%p\nΠΜ/ΜΜ\npm\n\n\n\n%M\nΛεπτά\n35\n\n\n\n%S\nΔευτερόλεπτα\n45\n\n\n\n%OS\nΔευτερόλεπτα με δεκαδικά\n45.35\n\n\n\n%Z\nΌνομα ζώνης ώρας\nAmerica/Chicago\n\n\n\n%z\nΑπόκλιση από την UTC\n+0800\n\n\nΛοιπά\n%.\nΠαράλειψη ενός μη ψηφίου\n:\n\n\n\n%*\nΠαράλειψη όλων των μη ψηφίων\n\n\n\n\n\n\n\nΚαι ο παρακάτω κώδικας δείχνει την εφαρμογή μερικών επιλογών σε μία πολύ ασαφή ημερομηνία:\n\ncsv &lt;- \"\n  date\n  01/02/15\n\"\n\nread_csv(csv, col_types = cols(date = col_date(\"%m/%d/%y\")))\n#&gt; # A tibble: 1 × 1\n#&gt;   date      \n#&gt;   &lt;date&gt;    \n#&gt; 1 2015-01-02\n\nread_csv(csv, col_types = cols(date = col_date(\"%d/%m/%y\")))\n#&gt; # A tibble: 1 × 1\n#&gt;   date      \n#&gt;   &lt;date&gt;    \n#&gt; 1 2015-02-01\n\nread_csv(csv, col_types = cols(date = col_date(\"%y/%m/%d\")))\n#&gt; # A tibble: 1 × 1\n#&gt;   date      \n#&gt;   &lt;date&gt;    \n#&gt; 1 2001-02-15\n\nΣημειώστε ότι ανεξάρτητα από το πώς προσδιορίζετε τη μορφή της ημερομηνίας, εμφανίζεται πάντα με τον ίδιο τρόπο μόλις τη διαβάσετε στην R.\nΕάν χρησιμοποιείτε το %b ή το %B και εργάζεστε με μη αγγλικές ημερομηνίες, θα πρέπει επίσης να παρέχετε ένα locale(). Δείτε τη λίστα των ενσωματωμένων γλωσσών με την συνάρτηση date_names_langs() ή δημιουργήστε τη δική σας με τη date_names(),\n\n17.2.2 Από συμβολοσειρές\nΗ γλώσσα προσδιορισμού της ημερομηνίας-ώρας είναι ένα ισχυρό όρισμα, αλλά απαιτεί προσεκτική ανάλυση του προτύπου γραφής της ημερομηνίας. Μία εναλλακτική προσέγγιση είναι η χρήση βοηθητικών συναρτήσεων του πακέτου lubridate που προσπαθούν να προσδιορίσουν αυτόματα τη μορφή μόλις καθορίσετε τη σειρά των διαφόρων στοιχείων. Για να τις χρησιμοποιήσετε, προσδιορίστε τη σειρά με την οποία εμφανίζονται το έτος, ο μήνας και η ημέρα στις ημερομηνίες σας και, στη συνέχεια, τακτοποιήστε τα “y”, “m” και “d” με την ίδια σειρά. Αυτό σας δίνει το όνομα της lubridate συνάρτησης που θα αναλύσει την ημερομηνία σας. Για παράδειγμα:\n\nymd(\"2017-01-31\")\n#&gt; [1] \"2017-01-31\"\nmdy(\"January 31st, 2017\")\n#&gt; [1] \"2017-01-31\"\ndmy(\"31-Jan-2017\")\n#&gt; [1] \"2017-01-31\"\n\nΗ ymd() και οι όμοιες της συναρτήσεις δημιουργούν ημερομηνίες. Για να δημιουργήσετε μία ημερομηνία-ώρα, προσθέστε μία υπογράμμιση και ένα ή περισσότερα από τα “h”, “m” και “s” στο όνομα της συνάρτησης που διαβάζει την ημερομηνία:\n\nymd_hms(\"2017-01-31 20:11:59\")\n#&gt; [1] \"2017-01-31 20:11:59 UTC\"\nmdy_hm(\"01/31/2017 08:01\")\n#&gt; [1] \"2017-01-31 08:01:00 UTC\"\n\nΜπορείτε επίσης να επιβάλετε τη δημιουργία μιας ημερομηνίας-ώρας από μία ημερομηνία παρέχοντας μία ζώνη ώρας:\n\nymd(\"2017-01-31\", tz = \"UTC\")\n#&gt; [1] \"2017-01-31 UTC\"\n\nΕδώ χρησιμοποιώ τη ζώνη ώρας UTC3, την οποία ίσως γνωρίζετε και ως GMT, ή ώρα Γκρίνουϊτς, την ώρα δηλαδή σε γεωγραφικό μήκος 0°4 . Δεν χρησιμοποιεί θερινή ώρα, καθιστώντας λίγο πιο εύκολους τους υπολογισμούς .\n\n17.2.3 Από μεμονωμένα στοιχεία\nΑντί για μία συμβολοσειρά, μερικές φορές θα έχετε τα μεμονωμένα στοιχεία της ημερομηνίας-ώρας κατανεμημένα σε πολλές στήλες. Αυτό έχουμε στα δεδομένα του flights:\n\nflights |&gt; \n  select(year, month, day, hour, minute)\n#&gt; # A tibble: 336,776 × 5\n#&gt;    year month   day  hour minute\n#&gt;   &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt;  &lt;dbl&gt;\n#&gt; 1  2013     1     1     5     15\n#&gt; 2  2013     1     1     5     29\n#&gt; 3  2013     1     1     5     40\n#&gt; 4  2013     1     1     5     45\n#&gt; 5  2013     1     1     6      0\n#&gt; 6  2013     1     1     5     58\n#&gt; # ℹ 336,770 more rows\n\nΓια να δημιουργήσετε μία ημερομηνία/ώρα από αυτό το είδος εισόδου, χρησιμοποιήστε τη make_date() για ημερομηνίες ή το make_datetime() για τις ημερομηνίες-ώρες:\n\nflights |&gt; \n  select(year, month, day, hour, minute) |&gt; \n  mutate(departure = make_datetime(year, month, day, hour, minute))\n#&gt; # A tibble: 336,776 × 6\n#&gt;    year month   day  hour minute departure          \n#&gt;   &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt;  &lt;dbl&gt; &lt;dttm&gt;             \n#&gt; 1  2013     1     1     5     15 2013-01-01 05:15:00\n#&gt; 2  2013     1     1     5     29 2013-01-01 05:29:00\n#&gt; 3  2013     1     1     5     40 2013-01-01 05:40:00\n#&gt; 4  2013     1     1     5     45 2013-01-01 05:45:00\n#&gt; 5  2013     1     1     6      0 2013-01-01 06:00:00\n#&gt; 6  2013     1     1     5     58 2013-01-01 05:58:00\n#&gt; # ℹ 336,770 more rows\n\nΑς κάνουμε το ίδιο πράγμα για καθεμία από τις τέσσερις στήλες του flights με δεδομένα ημερομηνίας. Οι ώρες αναπαρίστανται σε μία ελαφρώς περίεργη μορφή, επομένως χρησιμοποιούμε αριθμητική υπολοίπων για να εξάγουμε τα στοιχεία της ώρας και των λεπτών. Αφού δημιουργήσουμε τις μεταβλητές ημερομηνίας-ώρας, εστιάζουμε στις μεταβλητές που θα εξερευνήσουμε στο υπόλοιπο κεφάλαιο.\n\nmake_datetime_100 &lt;- function(year, month, day, time) {\n  make_datetime(year, month, day, time %/% 100, time %% 100)\n}\n\nflights_dt &lt;- flights |&gt; \n  filter(!is.na(dep_time), !is.na(arr_time)) |&gt; \n  mutate(\n    dep_time = make_datetime_100(year, month, day, dep_time),\n    arr_time = make_datetime_100(year, month, day, arr_time),\n    sched_dep_time = make_datetime_100(year, month, day, sched_dep_time),\n    sched_arr_time = make_datetime_100(year, month, day, sched_arr_time)\n  ) |&gt; \n  select(origin, dest, ends_with(\"delay\"), ends_with(\"time\"))\n\nflights_dt\n#&gt; # A tibble: 328,063 × 9\n#&gt;   origin dest  dep_delay arr_delay dep_time            sched_dep_time     \n#&gt;   &lt;chr&gt;  &lt;chr&gt;     &lt;dbl&gt;     &lt;dbl&gt; &lt;dttm&gt;              &lt;dttm&gt;             \n#&gt; 1 EWR    IAH           2        11 2013-01-01 05:17:00 2013-01-01 05:15:00\n#&gt; 2 LGA    IAH           4        20 2013-01-01 05:33:00 2013-01-01 05:29:00\n#&gt; 3 JFK    MIA           2        33 2013-01-01 05:42:00 2013-01-01 05:40:00\n#&gt; 4 JFK    BQN          -1       -18 2013-01-01 05:44:00 2013-01-01 05:45:00\n#&gt; 5 LGA    ATL          -6       -25 2013-01-01 05:54:00 2013-01-01 06:00:00\n#&gt; 6 EWR    ORD          -4        12 2013-01-01 05:54:00 2013-01-01 05:58:00\n#&gt; # ℹ 328,057 more rows\n#&gt; # ℹ 3 more variables: arr_time &lt;dttm&gt;, sched_arr_time &lt;dttm&gt;, …\n\nΜε αυτά τα δεδομένα μπορούμε να απεικονίσουμε την κατανομή των ωρών αναχώρησης κατά τη διάρκεια του έτους:\n\nflights_dt |&gt; \n  ggplot(aes(x = dep_time)) + \n  geom_freqpoly(binwidth = 86400) # 86400 seconds = 1 day\n\n\n\n\n\n\n\nΉ στη διάρκεια μιας μέρας:\n\nflights_dt |&gt; \n  filter(dep_time &lt; ymd(20130102)) |&gt; \n  ggplot(aes(x = dep_time)) + \n  geom_freqpoly(binwidth = 600) # 600 s = 10 minutes\n\n\n\n\n\n\n\nΣημειώστε ότι όταν χρησιμοποιείτε ημερομηνίες-ώρες σε ένα αριθμητικό πλαίσιο (όπως για παράδειγμα σε ένα ιστόγραμμα), το 1 σημαίνει 1 δευτερόλεπτο, επομένως ένα πλάτος bin 86400 σημαίνει μία ημέρα. Για ημερομηνίες, 1 σημαίνει 1 ημέρα.\n\n17.2.4 Από άλλους τύπους\nΜπορεί να θέλετε να κάνετε εναλλαγή μεταξύ ημερομηνίας-ώρας και ημερομηνίας. Αυτή είναι η δουλειά των as_datetime() και as_date():\n\nas_datetime(today())\n#&gt; [1] \"2024-04-21 UTC\"\nas_date(now())\n#&gt; [1] \"2024-04-21\"\n\nΜερικές φορές θα λάβετε δεδομένα ημερομηνίας/ώρας ως αριθμητικές μετατοπίσεις από την “Unix εποχή”, δηλαδή από την 1970-01-01. Εάν η μετατόπιση είναι σε δευτερόλεπτα, χρησιμοποιήστε το as_datetime(), ενώ εάν είναι σε ημέρες, χρησιμοποιήστε το as_date().\n\nas_datetime(60 * 60 * 10)\n#&gt; [1] \"1970-01-01 10:00:00 UTC\"\nas_date(365 * 10 + 2)\n#&gt; [1] \"1980-01-01\"\n\n\n17.2.5 Ασκήσεις\n\n\nΤι συμβαίνει εάν διαβάσετε μία συμβολοσειρά που περιέχει μη έγκυρες ημερομηνίες;\n\nymd(c(\"2010-10-10\", \"bananas\"))\n\n\nΠοιος είναι ο ρόλος του ορίσματος tzone στη συνάρτηση today(); Γιατί είναι σημαντικό;\n\nΓια κάθε μία από τις παρακάτω ημερομηνίες-ώρες δείξτε πως θα τις διαβάζατε χρησιμοποιώντας προδιαγραφές στηλών από το πακέτο readr και μία από τις συναρτήσεις του lubridate.\n\nd1 &lt;- \"January 1, 2010\"\nd2 &lt;- \"2015-Mar-07\"\nd3 &lt;- \"06-Jun-2017\"\nd4 &lt;- c(\"August 19 (2015)\", \"July 1 (2015)\")\nd5 &lt;- \"12/30/14\" # Dec 30, 2014\nt1 &lt;- \"1705\"\nt2 &lt;- \"11:15:10.12 PM\"",
    "crumbs": [
      "Μετασχηματισμοί",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Ημερομηνίες και ώρες</span>"
    ]
  },
  {
    "objectID": "datetimes.html#στοιχεία-ημερομηνίας-ώρας",
    "href": "datetimes.html#στοιχεία-ημερομηνίας-ώρας",
    "title": "17  Ημερομηνίες και ώρες",
    "section": "\n17.3 Στοιχεία ημερομηνίας-ώρας",
    "text": "17.3 Στοιχεία ημερομηνίας-ώρας\nΤώρα που ξέρετε πώς να μεταφέρετε δεδομένα ημερομηνίας-ώρας στις δομές δεδομένων ημερομηνίας-ώρας της R, ας εξερευνήσουμε τι μπορείτε να κάνετε με αυτά. Αυτή η ενότητα θα επικεντρωθεί στις συναρτήσεις του accessor που σας επιτρέπουν να λαμβάνετε και να ορίζετε μεμονωμένα στοιχεία. Η επόμενη ενότητα θα εξετάσει πώς λειτουργεί η αριθμητική σε δεδομένα ημερομηνίας-ώρας.\n\n17.3.1 Εξαγωγή στοιχείων\nΜπορείτε να εξάγετε μεμονωμένα μέρη της ημερομηνίας με τις συναρτήσεις του πακέτου accessor year(), month(), mday() (ημέρα του μήνα), yday() (ημέρα του έτους), wday() (ημέρα της εβδομάδας), hour(), minute() και second(). Αυτές είναι ουσιαστικά το αντίθετο της make_datetime().\n\ndatetime &lt;- ymd_hms(\"2026-07-08 12:34:56\")\n\nyear(datetime)\n#&gt; [1] 2026\nmonth(datetime)\n#&gt; [1] 7\nmday(datetime)\n#&gt; [1] 8\n\nyday(datetime)\n#&gt; [1] 189\nwday(datetime)\n#&gt; [1] 4\n\nΓια τις month() και wday() μπορείτε να ορίσετε το label = TRUE για να επιστρέφει τη συντομογραφία του μήνα ή της ημέρας της εβδομάδας. Ορίστε abbr = FALSE για να λαμβάνετε το πλήρες όνομα.\n\nmonth(datetime, label = TRUE)\n#&gt; [1] Jul\n#&gt; 12 Levels: Jan &lt; Feb &lt; Mar &lt; Apr &lt; May &lt; Jun &lt; Jul &lt; Aug &lt; Sep &lt; ... &lt; Dec\nwday(datetime, label = TRUE, abbr = FALSE)\n#&gt; [1] Wednesday\n#&gt; 7 Levels: Sunday &lt; Monday &lt; Tuesday &lt; Wednesday &lt; Thursday &lt; ... &lt; Saturday\n\nΜπορούμε να χρησιμοποιήσουμε τη wday() για να δούμε ότι περισσότερες πτήσεις αναχωρούν στη διάρκεια της εβδομάδας παρά κατά το σαββατοκύριακο:\n\nflights_dt |&gt; \n  mutate(wday = wday(dep_time, label = TRUE)) |&gt; \n  ggplot(aes(x = wday)) +\n  geom_bar()\n\n\n\n\n\n\n\nΜπορούμε επίσης να δούμε τη μέση καθυστέρηση αναχώρησης ανά λεπτό μέσα στην ώρα. Υπάρχει ένα ενδιαφέρον μοτίβο: οι πτήσεις που αναχωρούν μεταξύ των λεπτών 20-30 και 50-60 έχουν πολύ μικρότερες καθυστερήσεις από πτήσεις που αναχωρούν την υπόλοιπη ώρα!\n\nflights_dt |&gt; \n  mutate(minute = minute(dep_time)) |&gt; \n  group_by(minute) |&gt; \n  summarize(\n    avg_delay = mean(dep_delay, na.rm = TRUE),\n    n = n()\n  ) |&gt; \n  ggplot(aes(x = minute, y = avg_delay)) +\n  geom_line()\n\n\n\n\n\n\n\nΕίναι ενδιαφέρον ότι, αν κοιτάξουμε την προγραμματισμένη ώρα αναχώρησης, δεν βλέπουμε τόσο ισχυρό μοτίβο:\n\nsched_dep &lt;- flights_dt |&gt; \n  mutate(minute = minute(sched_dep_time)) |&gt; \n  group_by(minute) |&gt; \n  summarize(\n    avg_delay = mean(arr_delay, na.rm = TRUE),\n    n = n()\n  )\n\nggplot(sched_dep, aes(x = minute, y = avg_delay)) +\n  geom_line()\n\n\n\n\n\n\n\nΓιατί λοιπόν βλέπουμε αυτό το μοτίβο με τις πραγματικές ώρες αναχώρησης; Λοιπόν, όπως πολλά δεδομένα που συλλέγονται από ανθρώπους, υπάρχει μία ισχυρή προκατάληψη για πτήσεις που αναχωρούν σε «ωραίες» ώρες αναχώρησης, όπως δείχνει το Σχήμα 17.1. Να είστε πάντα σε εγρήγορση για αυτού του είδους τα μοτίβα κάθε φορά που εργάζεστε με δεδομένα που περιλαμβάνουν ανθρώπινη κρίση!\n\n\n\n\n\n\n\nΣχήμα 17.1: Ένα πολύγωνο συχνότητας που δείχνει τον αριθμό των πτήσεων που έχουν προγραμματιστεί να αναχωρήσουν κάθε ώρα. Μπορείτε να δείτε μια ισχυρή προτίμηση για στρογγυλούς αριθμούς όπως το 0 και το 30 και γενικά για αριθμούς που είναι πολλαπλάσιοι του πέντε.\n\n\n\n\n\n17.3.2 Στρογγυλοποίηση\nΜία εναλλακτική προσέγγιση για τη γραφική αναπαράσταση μεμονωμένων στοιχείων είναι η στρογγυλοποίηση της ημερομηνίας σε μία κοντινή μονάδα χρόνου, χρησιμοποιώντας τις floor_date(), round_date(), και ceiling_date() Κάθε συνάρτηση χρειάζεται ένα διάνυσμα ημερομηνιών για προσαρμογή και, στη συνέχεια, το όνομα της μονάδας για στρογγυλοποίηση προς τα κάτω (floor), προς τα πάνω (ceiling) ή προς σε αυτή. Αυτό, για παράδειγμα, μας επιτρέπει να αναπαραστήσουμε τον αριθμό των πτήσεων ανά εβδομάδα:\n\nflights_dt |&gt; \n  count(week = floor_date(dep_time, \"week\")) |&gt; \n  ggplot(aes(x = week, y = n)) +\n  geom_line() + \n  geom_point()\n\n\n\n\n\n\n\nΜπορείτε να χρησιμοποιήσετε τη στρογγυλοποίηση για να παρουσιάσετε την κατανομή των πτήσεων στη διάρκεια μιας ημέρας, υπολογίζοντας τη διαφορά μεταξύ του dep_time και της νωρίτερης στιγμής εκείνης της ημέρας:\n\nflights_dt |&gt; \n  mutate(dep_hour = dep_time - floor_date(dep_time, \"day\")) |&gt; \n  ggplot(aes(x = dep_hour)) +\n  geom_freqpoly(binwidth = 60 * 30)\n#&gt; Don't know how to automatically pick scale for object of type &lt;difftime&gt;.\n#&gt; Defaulting to continuous.\n\n\n\n\n\n\n\nΟ υπολογισμός της διαφοράς μεταξύ ενός ζεύγους τιμών ημερομηνίας-ώρας επιστρέφει ένα difftime (θα δούμε περισσότερα για αυτό στα Ενότητα 17.4.3). Μπορούμε να το μετατρέψουμε σε αντικείμενο hms για να πάρουμε έναν πιο χρήσιμο άξονα x:\n\nflights_dt |&gt; \n  mutate(dep_hour = hms::as_hms(dep_time - floor_date(dep_time, \"day\"))) |&gt; \n  ggplot(aes(x = dep_hour)) +\n  geom_freqpoly(binwidth = 60 * 30)\n\n\n\n\n\n\n\n\n17.3.3 Τροποποίηση στοιχείων\nΜπορείτε επίσης να χρησιμοποιήσετε κάθε συνάρτηση του accessor για να τροποποιήσετε τα στοιχεία μιας ημερομηνίας/ώρας. Αυτό δεν συναντάται ιδιαίτερα στην ανάλυση δεδομένων, αλλά μπορεί να είναι χρήσιμο κατά τον καθαρισμό δεδομένων που έχουν σαφώς εσφαλμένες ημερομηνίες.\n\n(datetime &lt;- ymd_hms(\"2026-07-08 12:34:56\"))\n#&gt; [1] \"2026-07-08 12:34:56 UTC\"\n\nyear(datetime) &lt;- 2030\ndatetime\n#&gt; [1] \"2030-07-08 12:34:56 UTC\"\nmonth(datetime) &lt;- 01\ndatetime\n#&gt; [1] \"2030-01-08 12:34:56 UTC\"\nhour(datetime) &lt;- hour(datetime) + 1\ndatetime\n#&gt; [1] \"2030-01-08 13:34:56 UTC\"\n\nΕναλλακτικά, αντί να τροποποιήσετε μία υπάρχουσα μεταβλητή, μπορείτε να δημιουργήσετε μία νέα ημερομηνία-ώρα με την update(). Αυτό σας επιτρέπει επίσης να ορίσετε πολλές τιμές σε ένα βήμα:\n\nupdate(datetime, year = 2030, month = 2, mday = 2, hour = 2)\n#&gt; [1] \"2030-02-02 02:34:56 UTC\"\n\nΕάν οι τιμές είναι πολύ μεγάλες, θα περάσουν στην επόμενη γραμμή:\n\nupdate(ymd(\"2023-02-01\"), mday = 30)\n#&gt; [1] \"2023-03-02\"\nupdate(ymd(\"2023-02-01\"), hour = 400)\n#&gt; [1] \"2023-02-17 16:00:00 UTC\"\n\n\n17.3.4 Ασκήσεις\n\nΠώς αλλάζει η κατανομή των χρόνων πτήσης μέσα σε μία ημέρα κατά τη διάρκεια του έτους;\nΣυγκρίνετε τις dep_time, sched_dep_time και dep_delay. Είναι συνεπείς; Εξηγήστε τα ευρήματά σας.\nΣυγκρίνετε τη μεταβλητή air_time με τη διάρκεια μεταξύ της αναχώρησης και της άφιξης. Εξηγήστε τα ευρήματά σας. (Υπόδειξη: λάβετε υπόψη την τοποθεσία του αεροδρομίου.)\nΠώς αλλάζει ο μέσος χρόνος καθυστέρησης κατά τη διάρκεια μιας ημέρας; Θα πρέπει να χρησιμοποιήσετε το dep_time ή το sched_dep_time; Γιατί;\nΠοια ημέρα της εβδομάδας πρέπει να φύγετε αν θέλετε να ελαχιστοποιήσετε την πιθανότητα καθυστέρησης;\nΤι κάνει την κατανομή των diamonds$carat και flights$sched_dep_time παρόμοια;\nΕπιβεβαιώστε την υπόθεσή μας ότι οι πρόωρες αναχωρήσεις πτήσεων στα λεπτά 20-30 και 50-60 προκαλούνται από προγραμματισμένες πτήσεις που αναχωρούν νωρίς. Υπόδειξη: δημιουργήστε μία δυαδική μεταβλητή που σας ενημερώνει εάν μία πτήση καθυστέρησε ή όχι.",
    "crumbs": [
      "Μετασχηματισμοί",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Ημερομηνίες και ώρες</span>"
    ]
  },
  {
    "objectID": "datetimes.html#χρονικά-διαστήματα",
    "href": "datetimes.html#χρονικά-διαστήματα",
    "title": "17  Ημερομηνίες και ώρες",
    "section": "\n17.4 Χρονικά διαστήματα",
    "text": "17.4 Χρονικά διαστήματα\nΣτη συνέχεια θα μάθετε πώς λειτουργεί η αριθμητική με ημερομηνίες, συμπεριλαμβανομένης της αφαίρεσης, της πρόσθεσης και της διαίρεσης. Στην πορεία, θα μάθετε για τρεις σημαντικές κλάσεις που αντιπροσωπεύουν χρονικά διαστήματα:\n\n\nDurations (διάρκειες), που αντιπροσωπεύουν έναν ακριβή αριθμό δευτερολέπτων.\n\nPeriods (περίοδοι), που αντιπροσωπεύουν ανθρώπινες μονάδες μέτρησης του χρόνου, όπως εβδομάδες και μήνες.\n\nIntervals (διαστήματα), τα οποία αντιπροσωπεύουν ένα σημείο αρχής και τέλους\n\nΠώς επιλέγετε μεταξύ διάρκειας, περιόδων και διαστημάτων; Όπως πάντα, επιλέξτε την απλούστερη δομή δεδομένων που λύνει το πρόβλημά σας. Εάν ενδιαφέρεστε μόνο για τον φυσικό χρόνο, χρησιμοποιήστε τη διάρκεια. Εάν χρειάζεται να προσθέσετε ανθρώπινους χρόνους, χρησιμοποιήστε μία περίοδο εάν πρέπει να υπολογίσετε πόσο μεγάλο είναι ένα διάστημα σε ανθρώπινες μονάδες, χρησιμοποιήστε ένα διάστημα.\n\n17.4.1 Διάρκειες\nΣτην R, όταν αφαιρείτε δύο ημερομηνίες, λαμβάνετε ένα αντικείμενο difftime:\n\n# Πόσο χρονών είναι ο Hadley?\nh_age &lt;- today() - ymd(\"1979-10-14\")\nh_age\n#&gt; Time difference of 16261 days\n\nΈνα αντικείμενο κλάσης difftime καταγράφει ένα χρονικό διάστημα δευτερολέπτων, λεπτών, ωρών, ημερών ή εβδομάδων. Αυτή η ασάφεια μπορεί να δυσκολέψει την εργασία με τα difftimes, οπότε το lubridate παρέχει μία εναλλακτική λύση που χρησιμοποιεί πάντα δευτερόλεπτα: τη διάρκεια (duration).\n\nas.duration(h_age)\n#&gt; [1] \"1404950400s (~44.52 years)\"\n\nΟι διάρκειες συνοδεύονται από μία σειρά από βολικές συναρτήσεις για την κατασκευή τους:\n\ndseconds(15)\n#&gt; [1] \"15s\"\ndminutes(10)\n#&gt; [1] \"600s (~10 minutes)\"\ndhours(c(12, 24))\n#&gt; [1] \"43200s (~12 hours)\" \"86400s (~1 days)\"\nddays(0:5)\n#&gt; [1] \"0s\"                \"86400s (~1 days)\"  \"172800s (~2 days)\"\n#&gt; [4] \"259200s (~3 days)\" \"345600s (~4 days)\" \"432000s (~5 days)\"\ndweeks(3)\n#&gt; [1] \"1814400s (~3 weeks)\"\ndyears(1)\n#&gt; [1] \"31557600s (~1 years)\"\n\nΟι διάρκειες καταγράφουν πάντα το χρονικό διάστημα σε δευτερόλεπτα. Μεγαλύτερες μονάδες δημιουργούνται μετατρέποντας λεπτά, ώρες, ημέρες, εβδομάδες και χρόνια σε δευτερόλεπτα: 60 δευτερόλεπτα σε ένα λεπτό, 60 λεπτά σε μία ώρα, 24 ώρες την ημέρα και 7 ημέρες την εβδομάδα. Οι μεγαλύτερες μονάδες χρόνου είναι πιο προβληματικές. Ένα έτος χρησιμοποιεί τον “μέσο” αριθμό ημερών σε ένα έτος, δηλαδή 365,25. Δεν υπάρχει τρόπος να μετατραπεί ένας μήνας σε διάρκεια, γιατί απλά υπάρχει μεγάλη διακύμανση.\nΕπίσης, μπορείτε να προσθέσετε και να πολλαπλασιάσετε τις διάρκειες:\n\n2 * dyears(1)\n#&gt; [1] \"63115200s (~2 years)\"\ndyears(1) + dweeks(12) + dhours(15)\n#&gt; [1] \"38869200s (~1.23 years)\"\n\nΜπορείτε να προσθέσετε και να αφαιρέσετε διάρκειες σε και από ημέρες:\n\ntomorrow &lt;- today() + ddays(1)\nlast_year &lt;- today() - dyears(1)\n\nΩστόσο, επειδή οι διάρκειες αντιπροσωπεύουν έναν ακριβή αριθμό δευτερολέπτων, μερικές φορές μπορεί να έχετε ένα απροσδόκητο αποτέλεσμα:\n\none_am &lt;- ymd_hms(\"2026-03-08 01:00:00\", tz = \"America/New_York\")\n\none_am\n#&gt; [1] \"2026-03-08 01:00:00 EST\"\none_am + ddays(1)\n#&gt; [1] \"2026-03-09 02:00:00 EDT\"\n\nΓιατί μία μέρα αμέσως μετά τη 1 π.μ. της 8ης Μαρτίου, η αντίστοιχη ώρα και μέρα είναι 2 π.μ. της 9ης Μαρτίου; Εάν κοιτάξετε προσεκτικά την ημερομηνία, μπορεί επίσης να παρατηρήσετε ότι οι ζώνες ώρας έχουν αλλάξει. Η 8η Μαρτίου έχει μόνο 23 ώρες, επειδή είναι η έναρξη της θερινής ώρας, οπότε αν προσθέσουμε ολόκληρες ημέρες σύμφωνα με τη διάρκεια τους σε δευτερόλεπτα, καταλήγουμε σε διαφορετική ώρα.\n\n17.4.2 Περίοδοι\nΓια την επίλυση αυτού του προβλήματος, το lubridate παρέχει περιόδους. Οι περίοδοι είναι χρονικά διαστήματα, αλλά δεν έχουν σταθερή διάρκεια σε δευτερόλεπτα. Αντίθετα λειτουργούν με “ανθρώπινους” χρόνους, όπως ημέρες και μήνες. Αυτό τους επιτρέπει να εργάζονται με πιο διαισθητικό τρόπο:\n\none_am\n#&gt; [1] \"2026-03-08 01:00:00 EST\"\none_am + days(1)\n#&gt; [1] \"2026-03-09 01:00:00 EDT\"\n\nΌπως και οι διάρκειες, οι περίοδοι μπορούν να δημιουργηθούν με μία σειρά από βοηθητικές συναρτήσεις για την κατασκευή τους.\n\nhours(c(12, 24))\n#&gt; [1] \"12H 0M 0S\" \"24H 0M 0S\"\ndays(7)\n#&gt; [1] \"7d 0H 0M 0S\"\nmonths(1:6)\n#&gt; [1] \"1m 0d 0H 0M 0S\" \"2m 0d 0H 0M 0S\" \"3m 0d 0H 0M 0S\" \"4m 0d 0H 0M 0S\"\n#&gt; [5] \"5m 0d 0H 0M 0S\" \"6m 0d 0H 0M 0S\"\n\nΜπορείτε να προσθέσετε και να πολλαπλασιάσετε περιόδους:\n\n10 * (months(6) + days(1))\n#&gt; [1] \"60m 10d 0H 0M 0S\"\ndays(50) + hours(25) + minutes(2)\n#&gt; [1] \"50d 25H 2M 0S\"\n\nΚαι φυσικά, να τις προσθέσετε σε ημερομηνίες. Σε σύγκριση με τις διάρκειες, οι περίοδοι είναι πιο πιθανό να κάνουν αυτό που θα περιμένατε:\n\n# Ένα δίσεκτο έτος\nymd(\"2024-01-01\") + dyears(1)\n#&gt; [1] \"2024-12-31 06:00:00 UTC\"\nymd(\"2024-01-01\") + years(1)\n#&gt; [1] \"2025-01-01\"\n\n# Θερινή ώρα\none_am + ddays(1)\n#&gt; [1] \"2026-03-09 02:00:00 EDT\"\none_am + days(1)\n#&gt; [1] \"2026-03-09 01:00:00 EDT\"\n\nΑς χρησιμοποιήσουμε περιόδους για να διορθώσουμε ένα παράδοξο που σχετίζεται με τις ημερομηνίες της πτήσης μας. Μερικά αεροπλάνα φαίνεται να έφτασαν στον προορισμό τους πριν αναχωρήσουν από τη Νέα Υόρκη.\n\nflights_dt |&gt; \n  filter(arr_time &lt; dep_time) \n#&gt; # A tibble: 10,633 × 9\n#&gt;   origin dest  dep_delay arr_delay dep_time            sched_dep_time     \n#&gt;   &lt;chr&gt;  &lt;chr&gt;     &lt;dbl&gt;     &lt;dbl&gt; &lt;dttm&gt;              &lt;dttm&gt;             \n#&gt; 1 EWR    BQN           9        -4 2013-01-01 19:29:00 2013-01-01 19:20:00\n#&gt; 2 JFK    DFW          59        NA 2013-01-01 19:39:00 2013-01-01 18:40:00\n#&gt; 3 EWR    TPA          -2         9 2013-01-01 20:58:00 2013-01-01 21:00:00\n#&gt; 4 EWR    SJU          -6       -12 2013-01-01 21:02:00 2013-01-01 21:08:00\n#&gt; 5 EWR    SFO          11       -14 2013-01-01 21:08:00 2013-01-01 20:57:00\n#&gt; 6 LGA    FLL         -10        -2 2013-01-01 21:20:00 2013-01-01 21:30:00\n#&gt; # ℹ 10,627 more rows\n#&gt; # ℹ 3 more variables: arr_time &lt;dttm&gt;, sched_arr_time &lt;dttm&gt;, …\n\nΠρόκειται για ολονύχτιες πτήσεις. Χρησιμοποιήσαμε τις ίδιες πληροφορίες ημερομηνίας τόσο για τις ώρες αναχώρησης όσο και για τις ώρες άφιξης, αλλά αυτές οι πτήσεις έφτασαν την επόμενη μέρα. Μπορούμε να το διορθώσουμε προσθέτοντας το days(1) στην ώρα άφιξης κάθε ολονύκτιας πτήσης.\n\nflights_dt &lt;- flights_dt |&gt; \n  mutate(\n    overnight = arr_time &lt; dep_time,\n    arr_time = arr_time + days(overnight),\n    sched_arr_time = sched_arr_time + days(overnight)\n  )\n\nΤώρα όλες μας οι πτήσεις υπακούν στους νόμους της φυσικής.\n\nflights_dt |&gt; \n  filter(arr_time &lt; dep_time) \n#&gt; # A tibble: 0 × 10\n#&gt; # ℹ 10 variables: origin &lt;chr&gt;, dest &lt;chr&gt;, dep_delay &lt;dbl&gt;,\n#&gt; #   arr_delay &lt;dbl&gt;, dep_time &lt;dttm&gt;, sched_dep_time &lt;dttm&gt;, …\n\n\n17.4.3 Διαστήματα\nΤι επιστρέφει το dyears(1) / ddays(365); Δεν είναι ακριβώς μονάδα, επειδή το dyears() ορίζεται ως ο αριθμός των δευτερολέπτων ανά μέσο χρόνο, που είναι 365,25 ημέρες.\nΤι επιστρέφει το years(1) / days(1); Εάν το έτος ήταν 2015 θα έπρεπε να επιστρέψει 365, αλλά αν ήταν 2016, θα έπρεπε να επιστρέψει 366! Δεν υπάρχουν επαρκείς πληροφορίες ώστε το lubridate να δώσει μία σαφή απάντηση. Αυτό που κάνει είναι να δώσει μία εκτίμηση:\n\nyears(1) / days(1)\n#&gt; [1] 365.25\n\nΕάν θέλετε μία πιο ακριβή μέτρηση, θα πρέπει να χρησιμοποιήσετε ένα διάστημα. Ένα διάστημα είναι ένα ζεύγος χρόνων ημερομηνίας αρχής και τέλους ή μπορείτε να το σκεφτείτε ως μία διάρκεια με ένα σημείο εκκίνησης.\nΜπορείτε να δημιουργήσετε ένα διάστημα γράφοντας start %--% end:\n\ny2023 &lt;- ymd(\"2023-01-01\") %--% ymd(\"2024-01-01\")\ny2024 &lt;- ymd(\"2024-01-01\") %--% ymd(\"2025-01-01\")\n\ny2023\n#&gt; [1] 2023-01-01 UTC--2024-01-01 UTC\ny2024\n#&gt; [1] 2024-01-01 UTC--2025-01-01 UTC\n\nΣτη συνέχεια, θα μπορούσατε να το διαιρέσετε με την days() για να μάθετε πόσες ημέρες υπάρχουν μέσα στο έτος:\n\ny2023 / days(1)\n#&gt; [1] 365\ny2024 / days(1)\n#&gt; [1] 366\n\n\n17.4.4 Ασκήσεις\n\nΕξηγήστε τα days(!overnight) και days(overnight) σε κάποιον που μόλις άρχισε να μαθαίνει R. Ποιο είναι το βασικό στοιχείο που πρέπει να γνωρίζετε;\nΔημιουργήστε ένα διάνυσμα ημερομηνιών δίνοντας την πρώτη ημέρα κάθε μήνα το 2015. Δημιουργήστε ένα διάνυσμα ημερομηνιών δίνοντας την πρώτη ημέρα κάθε μήνα στο τρέχον έτος.\nΓράψτε μία συνάρτηση που με βάση τα γενέθλιά σας (ως ημερομηνία), να εμφανίζει πόσο χρονών είστε σε χρόνια.\nΓιατί δεν μπορεί να λειτουργήσει το (today() %--% (today() + years(1))) / months(1);",
    "crumbs": [
      "Μετασχηματισμοί",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Ημερομηνίες και ώρες</span>"
    ]
  },
  {
    "objectID": "datetimes.html#ζώνες-ώρας",
    "href": "datetimes.html#ζώνες-ώρας",
    "title": "17  Ημερομηνίες και ώρες",
    "section": "\n17.5 Ζώνες ώρας",
    "text": "17.5 Ζώνες ώρας\nΟι ζώνες ώρας είναι ένα εξαιρετικά περίπλοκο θέμα λόγω της αλληλεπίδρασής τους με γεωπολιτικές οντότητες. Ευτυχώς δεν χρειάζεται να εμβαθύνουμε σε όλες τις λεπτομέρειες, καθώς δεν είναι όλες σημαντικές για την ανάλυση δεδομένων, αλλά υπάρχουν μερικές προκλήσεις που θα πρέπει να αντιμετωπίσουμε κατά μέτωπο.\n\nΗ πρώτη πρόκληση είναι ότι τα καθημερινά ονόματα των ζωνών ώρας τείνουν να είναι ασαφή. Για παράδειγμα, εάν είστε Αμερικανός, πιθανότατα είστε εξοικειωμένοι με την EST ή την ανατολική τυπική ώρα. Ωστόσο, τόσο η Αυστραλία όσο και ο Καναδάς έχουν επίσης EST! Για να αποφευχθεί η σύγχυση, η R χρησιμοποιεί τις διεθνείς τυποποιημένες ζώνες ώρας IANA. Αυτές χρησιμοποιούν ένα συνεπές σχήμα ονοματοδοσίας {area}/{location}, συνήθως με τη μορφή {continent}/{city} ή {ocean}/{city}. Μερικά παραδείγματα είναι τα “America/New_York”, “Europe/Paris” και “Pacific/Auckland”.\nΊσως αναρωτιέστε γιατί η ζώνη ώρας χρησιμοποιεί μία πόλη, όταν συνήθως σκέφτεστε ότι οι ζώνες ώρας σχετίζονται με μία χώρα ή περιοχή σε μία χώρα. Αυτό συμβαίνει επειδή η βάση δεδομένων IANA πρέπει να καταγράφει κανόνες ζώνης ώρας για δεκαετίες. Κατά τη διάρκεια των δεκαετιών, οι χώρες αλλάζουν ονόματα (ή διασπώνται) αρκετά συχνά, αλλά τα ονόματα των πόλεων τείνουν να παραμένουν ίδια. Ένα άλλο πρόβλημα είναι ότι το όνομα πρέπει να αντικατοπτρίζει όχι μόνο την τρέχουσα συμπεριφορά, αλλά και την πλήρη ιστορία. Για παράδειγμα, υπάρχουν ζώνες ώρας και για το “America/New_York” όσο και για το “America/Detroit”. Και οι δύο αυτές πόλεις χρησιμοποιούν αυτήν τη στιγμή την Ανατολική Τυπική Ώρα, αλλά το 1969-1972 το Μίσιγκαν (η πολιτεία στην οποία βρίσκεται το Ντιτρόιτ), δεν ακολούθησε την DST, επομένως χρειάζεται διαφορετικό όνομα. Αξίζει να διαβάσετε την ακατέργαστη βάση δεδομένων ζώνης ώρας (διαθέσιμη στο https://www.iana.org/time-zones) μόνο για να διαβάσετε μερικές από αυτές τις ιστορίες!\nΜπορείτε να μάθετε τι πιστεύει η R για την τρέχουσα ζώνη ώρας σας με το Sys.timezone():\n\nSys.timezone()\n#&gt; [1] \"UTC\"\n\n(Εάν η R δεν γνωρίζει, θα σας επιστρέψει NA.)\nΔείτε την πλήρη λίστα όλων των ζωνών ώρας με τη βοήθεια της συνάρτησης OlsonNames():\n\nlength(OlsonNames())\n#&gt; [1] 597\nhead(OlsonNames())\n#&gt; [1] \"Africa/Abidjan\"     \"Africa/Accra\"       \"Africa/Addis_Ababa\"\n#&gt; [4] \"Africa/Algiers\"     \"Africa/Asmara\"      \"Africa/Asmera\"\n\nΣτην R, η ζώνη ώρας είναι ένα χαρακτηριστικό της ημερομηνίας-ώρας που ελέγχει μόνο το πως τυπώνετε η πληροφορία. Για παράδειγμα, αυτά τα τρία αντικείμενα αντιπροσωπεύουν την ίδια χρονική στιγμή:\n\nx1 &lt;- ymd_hms(\"2024-06-01 12:00:00\", tz = \"America/New_York\")\nx1\n#&gt; [1] \"2024-06-01 12:00:00 EDT\"\n\nx2 &lt;- ymd_hms(\"2024-06-01 18:00:00\", tz = \"Europe/Copenhagen\")\nx2\n#&gt; [1] \"2024-06-01 18:00:00 CEST\"\n\nx3 &lt;- ymd_hms(\"2024-06-02 04:00:00\", tz = \"Pacific/Auckland\")\nx3\n#&gt; [1] \"2024-06-02 04:00:00 NZST\"\n\nΜπορείτε να επαληθεύσετε ότι όντως αφορούν την ίδια χρονική στιγμή χρησιμοποιώντας την αφαίρεση:\n\nx1 - x2\n#&gt; Time difference of 0 secs\nx1 - x3\n#&gt; Time difference of 0 secs\n\nΕκτός εάν ορίζεται κάπως διαφορετικά, το lubridate χρησιμοποιεί πάντα τη UTC. Η Coordinated Universal Time, UTC (Συντονισμένη Παγκόσμια Ώρα), είναι η τυπική ζώνη ώρας που χρησιμοποιείται από την επιστημονική κοινότητα και είναι περίπου ισοδύναμη με τη Greenwich Mean Time, GMT (μέση ώρα Γκρίνουϊτς). Δεν έχει την DST, κάτι το οποίο την κάνει μία βολική αναπαράσταση για τους υπολογισμούς. Λειτουργίες που συνδυάζουν ημερομηνίες-ώρα, όπως η c(), συχνά αγνοούν τη ζώνη ώρας. Σε αυτήν την περίπτωση, οι ημερομηνίες-ώρες θα εμφανίζονται στη ζώνη ώρας του πρώτου στοιχείου:\n\nx4 &lt;- c(x1, x2, x3)\nx4\n#&gt; [1] \"2024-06-01 12:00:00 EDT\" \"2024-06-01 12:00:00 EDT\"\n#&gt; [3] \"2024-06-01 12:00:00 EDT\"\n\nΜπορείτε να αλλάξετε τη ζώνη ώρας με δύο τρόπους:\n\n\nΔιατηρήστε τη χρονική στιγμή σταθερή και αλλάξτε τον τρόπο με τον οποίο αυτό παρουσιάζεται. Ακολουθήστε αυτή την προσέγγιση όταν η χρονική στιγμή είναι σωστή, αλλά θέλετε μία πιο συνηθισμένη αναπαράσταση της.\n\nx4a &lt;- with_tz(x4, tzone = \"Australia/Lord_Howe\")\nx4a\n#&gt; [1] \"2024-06-02 02:30:00 +1030\" \"2024-06-02 02:30:00 +1030\"\n#&gt; [3] \"2024-06-02 02:30:00 +1030\"\nx4a - x4\n#&gt; Time differences in secs\n#&gt; [1] 0 0 0\n\n(Αυτό δείχνει επίσης μία άλλη πρόκληση των ζωνών ώρας: δεν είναι όλες μετατοπίσεις ακέραιων ωρών!)\n\n\nΑλλάξτε την υποκείμενη χρονική στιγμή. Χρησιμοποιήστε το όταν έχετε ένα στιγμιότυπο που έχει επισημανθεί με εσφαλμένη ζώνη ώρας και πρέπει να το διορθώσετε.\n\nx4b &lt;- force_tz(x4, tzone = \"Australia/Lord_Howe\")\nx4b\n#&gt; [1] \"2024-06-01 12:00:00 +1030\" \"2024-06-01 12:00:00 +1030\"\n#&gt; [3] \"2024-06-01 12:00:00 +1030\"\nx4b - x4\n#&gt; Time differences in hours\n#&gt; [1] -14.5 -14.5 -14.5",
    "crumbs": [
      "Μετασχηματισμοί",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Ημερομηνίες και ώρες</span>"
    ]
  },
  {
    "objectID": "datetimes.html#σύνοψη",
    "href": "datetimes.html#σύνοψη",
    "title": "17  Ημερομηνίες και ώρες",
    "section": "\n17.6 Σύνοψη",
    "text": "17.6 Σύνοψη\nΑυτό το κεφάλαιο σας παρουσίασε τα εργαλεία που παρέχει το lubridate για να σας βοηθήσουν να εργαστείτε με δεδομένα ημερομηνίας-ώρας. Η εργασία με ημερομηνίες και ώρες μπορεί να φαίνεται πιο δύσκολη από όσο χρειάζεται, αλλά ελπίζουμε ότι αυτό το κεφάλαιο σας βοήθησε να καταλάβετε γιατί συμβαίνει αυτό — οι ημερομηνίες-ώρες είναι πιο περίπλοκες από ό,τι φαίνονται με την πρώτη ματιά, και ο χειρισμός κάθε πιθανής κατάστασης προσθέτει πολυπλοκότητα. Ακόμα κι αν τα δεδομένα σας δεν ξεπερνούν ποτέ τα όρια της θερινής ώρας ή δεν περιλαμβάνουν ένα δίσεκτο έτος, οι συναρτήσεις θα πρέπει να μπορούν να χειριστούν κι αυτές τις καταστάσεις.\nΤο επόμενο κεφάλαιο εστιάζει στις κενές τιμές. Τις έχετε συναντήσει σε μερικά σημεία και χωρίς αμφιβολία θα τις συναντήσετε και στη δική σας ανάλυση, οπότε ήρθε η ώρα να μάθετε μία σειρά με χρήσιμες τεχνικές για την αντιμετώπισή τους.",
    "crumbs": [
      "Μετασχηματισμοί",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Ημερομηνίες και ώρες</span>"
    ]
  },
  {
    "objectID": "datetimes.html#footnotes",
    "href": "datetimes.html#footnotes",
    "title": "17  Ημερομηνίες και ώρες",
    "section": "",
    "text": "Ένα έτος είναι δίσεκτο εάν διαιρείται με το 4, εκτός αν διαιρείται επίσης με το 100, εκτός εάν διαιρείται επίσης με το 400. Με άλλα λόγια, σε κάθε σύνολο 400 ετών, υπάρχουν 97 δίσεκτα έτη.↩︎\nhttps://xkcd.com/1179/↩︎\nΊσως αναρωτιέστε τι σημαίνει το UTC. Είναι ένας συμβιβασμός μεταξύ του αγγλικού “Coordinated Universal Time” και του γαλλικού “Temps Universel Coordonné”.↩︎\nΔεν θα πάρετε κάποιο βραβείο αν καταφέρετε να μαντέψετε ποια χώρα δημιούργησε το σύστημα γεωγραφικού μήκους.↩︎",
    "crumbs": [
      "Μετασχηματισμοί",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Ημερομηνίες και ώρες</span>"
    ]
  },
  {
    "objectID": "missing-values.html",
    "href": "missing-values.html",
    "title": "18  Κενές τιμές",
    "section": "",
    "text": "18.1 Εισαγωγή\nΈχετε ήδη μάθει τα βασικά για τις κενές τιμές νωρίτερα στο βιβλίο. Τις είδατε για πρώτη φορά στο Κεφάλαιο 1 όπου οδήγησαν σε μία προειδοποίηση κατά τη δημιουργία μιας γραφικής παράστασης, καθώς και στην Ενότητα 3.5.2 όπου παρενέβησαν στον υπολογισμό στατιστικών μέτρων σύνοψης και μάθατε για τη μολυσματική τους φύση και για το πώς να ελέγχετε για τυχόν παρουσία τους στην Ενότητα 12.2.2. Τώρα θα επανέλθουμε σε αυτά σε μεγαλύτερο βάθος, ώστε να μάθετε περισσότερες λεπτομέρειες.\nΘα ξεκινήσουμε συζητώντας ορισμένα γενικά εργαλεία για την εργασία με τιμές που λείπουν και έχουν καταγραφεί ως NA. Στη συνέχεια, θα διερευνήσουμε την ιδέα των τιμών που λείπουν σιωπηρά, τιμές που απλώς απουσιάζουν από τα δεδομένα σας και θα δείξουμε ορισμένα εργαλεία που μπορείτε να χρησιμοποιήσετε για να τις καταστήσετε σαφείς. Θα ολοκληρώσουμε με μία σχετική συζήτηση για κενές ομάδες, που προκαλούνται από επίπεδα παραγόντων που δεν εμφανίζονται στα δεδομένα.",
    "crumbs": [
      "Μετασχηματισμοί",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Κενές τιμές</span>"
    ]
  },
  {
    "objectID": "missing-values.html#εισαγωγή",
    "href": "missing-values.html#εισαγωγή",
    "title": "18  Κενές τιμές",
    "section": "",
    "text": "18.1.1 Προαπαιτούμενα\nΟι συναρτήσεις με τις οποίες εργαζόμαστε με ελλιπή δεδομένα προέρχονται κυρίως από τις βιβλιοθήκες dplyr και tidyr, οι οποίες είναι βασικά μέλη του tidyverse.\n\nlibrary(tidyverse)",
    "crumbs": [
      "Μετασχηματισμοί",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Κενές τιμές</span>"
    ]
  },
  {
    "objectID": "missing-values.html#ρητά-κενές-τιμές",
    "href": "missing-values.html#ρητά-κενές-τιμές",
    "title": "18  Κενές τιμές",
    "section": "\n18.2 Ρητά κενές τιμές",
    "text": "18.2 Ρητά κενές τιμές\nΞεκινώντας, ας εξερευνήσουμε μερικά χρήσιμα εργαλεία για τη δημιουργία ή την εξάλειψη ρητά κενών τιμών, περιπτώσεων δηλαδή όπου σε ένα κελί βλέπετε την τιμή NA.\n\n18.2.1 Τελευταία παρατήρηση που μεταφέρθηκε\nΜία κοινή χρήση για τις κενές τιμές είναι ως διευκόλυνση κατά την εισαγωγή δεδομένων. Όταν τα δεδομένα εισάγονται χειροκίνητα, μερικές φορές οι κενές τιμές υποδεικνύουν ότι επαναλαμβάνεται (μεταφέρεται) η τιμή της προηγούμενης γραμμής:\n\ntreatment &lt;- tribble(\n  ~person,           ~treatment, ~response,\n  \"Derrick Whitmore\", 1,         7,\n  NA,                 2,         10,\n  NA,                 3,         NA,\n  \"Katherine Burke\",  1,         4\n)\n\nΜπορείτε να συμπληρώσετε αυτές τις κενές τιμές χρησιμοποιώντας τη συνάρτηση tidyr::fill(). Δουλεύει όπως η select(), λαμβάνοντας ως είσοδο ένα σύνολο στηλών.\n\ntreatment |&gt;\n  fill(everything())\n#&gt; # A tibble: 4 × 3\n#&gt;   person           treatment response\n#&gt;   &lt;chr&gt;                &lt;dbl&gt;    &lt;dbl&gt;\n#&gt; 1 Derrick Whitmore         1        7\n#&gt; 2 Derrick Whitmore         2       10\n#&gt; 3 Derrick Whitmore         3       10\n#&gt; 4 Katherine Burke          1        4\n\nΑυτή η αντιμετώπιση μερικές φορές ονομάζεται “μεταφορά της τελευταίας παρατήρησης” (“last observation carried forward”), ή locf για συντομία. Μπορείτε να χρησιμοποιήσετε το όρισμα .direction για να συμπληρώσετε τις κενές τιμές που έχουν δημιουργηθεί με άλλους τρόπους.\n\n18.2.2 Σταθερές τιμές\nΜερικές φορές οι κενές τιμές αντιπροσωπεύουν κάποια σταθερή και γνωστή τιμή, συνηθέστερα το 0. Μπορείτε να χρησιμοποιήσετε τη συνάρτηση dplyr::coalesce() για να τις αντικαταστήσετε:\n\nx &lt;- c(1, 4, 5, 7, NA)\ncoalesce(x, 0)\n#&gt; [1] 1 4 5 7 0\n\nΜερικές φορές θα αντιμετωπίσετε το αντίθετο πρόβλημα, όπου κάποια συγκεκριμένη τιμή αντιπροσωπεύει στην πραγματικότητα μία κενή τιμή. Αυτό συνήθως προκύπτει σε δεδομένα που δημιουργούνται από παλαιότερο λογισμικό που δεν έχει κατάλληλο τρόπο να αναπαραστήσει τις κενές τιμές, κι επομένως πρέπει να χρησιμοποιήσει κάποια ειδική τιμή, όπως το 99 ή το -999.\nΕάν είναι δυνατόν, χειριστείτε αυτές τις περιπτώσεις κατάλληλα ήδη κατά την ανάγνωση των δεδομένων, για παράδειγμα, χρησιμοποιώντας το όρισμα na στην readr::read_csv(), π.χ., read_csv(διαδρομή, na = \"99\"). Εάν ανακαλύψετε το πρόβλημα αργότερα ή η πηγή δεδομένων σας δεν παρέχει τρόπο να το χειριστείτε κατά την ανάγνωση, μπορείτε να χρησιμοποιήσετε την συνάρτηση dplyr::na_if():\n\nx &lt;- c(1, 4, 5, 7, -99)\nna_if(x, -99)\n#&gt; [1]  1  4  5  7 NA\n\n\n18.2.3 NaN\nΠριν συνεχίσουμε, υπάρχει ένας ειδικός τύπος κενών τιμών που θα συναντάτε κατά καιρούς: η τιμή NaN (προφέρεται “ναν”), ή not a number. Δεν είναι τόσο σημαντικό να το γνωρίζετε γιατί γενικά συμπεριφέρεται ακριβώς όπως το NA:\n\nx &lt;- c(NA, NaN)\nx * 10\n#&gt; [1]  NA NaN\nx == 1\n#&gt; [1] NA NA\nis.na(x)\n#&gt; [1] TRUE TRUE\n\nΓια τη σπάνια περίπτωση που θα πρέπει να διακρίνεται το NA από το NaN, μπορείτε να χρησιμοποιήσετε τον έλεγχο is.nan(x).\nΓενικά, θα συναντήσετε τη NaN όταν εκτελείτε μία μαθηματική πράξη της οποίας το αποτέλεσμα είναι απροσδιόριστο:\n\n0 / 0 \n#&gt; [1] NaN\n0 * Inf\n#&gt; [1] NaN\nInf - Inf\n#&gt; [1] NaN\nsqrt(-1)\n#&gt; Warning in sqrt(-1): NaNs produced\n#&gt; [1] NaN",
    "crumbs": [
      "Μετασχηματισμοί",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Κενές τιμές</span>"
    ]
  },
  {
    "objectID": "missing-values.html#sec-missing-implicit",
    "href": "missing-values.html#sec-missing-implicit",
    "title": "18  Κενές τιμές",
    "section": "\n18.3 Έμμεσα κενές τιμές",
    "text": "18.3 Έμμεσα κενές τιμές\nΜέχρι στιγμής, έχουμε μιλήσει για ρητά κενές τιμές, δηλαδή περιπτώσεις όπου μπορείτε να δείτε ένα NA στα δεδομένα σας. Ωστόσο, οι κενές τιμές μπορεί να λείπουν έμμεσα, εάν μία ολόκληρη γραμμή δεδομένων απλώς λείπει από τα δεδομένα. Ας δείξουμε τη διαφορά με ένα απλό σύνολο δεδομένων που καταγράφει την τιμή ορισμένων μετοχών για κάθε τρίμηνο:\n\nstocks &lt;- tibble(\n  year  = c(2020, 2020, 2020, 2020, 2021, 2021, 2021),\n  qtr   = c(   1,    2,    3,    4,    2,    3,    4),\n  price = c(1.88, 0.59, 0.35,   NA, 0.92, 0.17, 2.66)\n)\n\nΑυτό το σύνολο δεδομένων έχει δύο παρατηρήσεις που λείπουν:\n\nΗ price στο τέταρτο τρίμηνο του 2020 λείπει ρητά, επειδή η τιμή της είναι NA.\nΗ price για το πρώτο τρίμηνο του 2021 λείπει έμμεσα, επειδή απλώς δεν εμφανίζεται στο σύνολο δεδομένων.\n\nΈνας τρόπος για να σκεφτείτε τη διαφορά είναι με αυτό το κοάν που θυμίζει Ζεν (Zen-like koan):\n\nΜία ρητά κενή τιμή είναι η παρουσία μιας απουσίας.\nΜία έμμεσα κενή τιμή είναι η απουσία μιας παρουσίας.\n\nΜερικές φορές θέλετε να κάνετε τις έμμεσα κενές τιμές ξεκάθαρες, για να έχετε κάτι απτό να εργαστείτε. Σε άλλες περιπτώσεις, η δομή των δεδομένων σας επιβάλλει ρητά κενές τιμές και θέλετε να απαλλαγείτε από αυτές. Οι ενότητες που ακολουθούν συζητούν ορισμένα εργαλεία για τη μετάβαση μεταξύ έμμεσα και ρητά κενών τιμών.\n\n18.3.1 Περιστροφή (Pivoting)\nΈχετε ήδη δει ένα εργαλείο που μπορεί να κάνει τις έμμεσα κενές τιμές ρητές και το αντίστροφο: την περιστροφή (pivoting). Η διεύρυνση των δεδομένων (wider) μπορεί να κάνει ρητές τις έμμεσα κενές τιμές, επειδή κάθε συνδυασμός γραμμών και νέων στηλών πρέπει να έχει κάποια τιμή. Για παράδειγμα, αν περιστρέψουμε το stocks για να βάλουμε το quarter στις στήλες, και οι δύο τιμές που λείπουν γίνονται ρητά κενές τιμές:\n\nstocks |&gt;\n  pivot_wider(\n    names_from = qtr, \n    values_from = price\n  )\n#&gt; # A tibble: 2 × 5\n#&gt;    year   `1`   `2`   `3`   `4`\n#&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n#&gt; 1  2020  1.88  0.59  0.35 NA   \n#&gt; 2  2021 NA     0.92  0.17  2.66\n\nΑπό προεπιλογή, η επιμήκυνση των δεδομένων διατηρεί τις ρητά κενές τιμές, αλλά εάν υπάρχουν δομικά κενές τιμές που υπάρχουν μόνο επειδή τα δεδομένα δεν είναι τακτοποιημένα, μπορείτε να τις απορρίψετε (να τις κάνετε έμμεσες) με το όρισμα values_drop_na = TRUE. Δείτε τα παραδείγματα στην Ενότητα 5.2 για περισσότερες λεπτομέρειες.\n\n18.3.2 Πλήρη (Complete) δεδομένα\nΗ συνάρτηση tidyr::complete() σας επιτρέπει να δημιουργήσετε ρητά κενές τιμές παρέχοντας ένα σύνολο μεταβλητών που ορίζουν τον συνδυασμό των γραμμών που θα πρέπει να υπάρχουν. Για παράδειγμα, γνωρίζουμε ότι όλοι οι συνδυασμοί των year και qtr θα πρέπει να υπάρχουν στα δεδομένα του stocks:\n\nstocks |&gt;\n  complete(year, qtr)\n#&gt; # A tibble: 8 × 3\n#&gt;    year   qtr price\n#&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n#&gt; 1  2020     1  1.88\n#&gt; 2  2020     2  0.59\n#&gt; 3  2020     3  0.35\n#&gt; 4  2020     4 NA   \n#&gt; 5  2021     1 NA   \n#&gt; 6  2021     2  0.92\n#&gt; # ℹ 2 more rows\n\nΣυνήθως, θα καλέσετε την complete() χρησιμοποιώντας τα ονόματα μεταβλητών που υπάρχουν στα δεδομένα σας, συμπληρώνοντας τους συνδυασμούς που λείπουν. Ωστόσο, μερικές φορές οι μεμονωμένες μεταβλητές είναι οι ίδιες ημιτελείς, επομένως μπορείτε να παρέχετε τα δικά σας δεδομένα. Για παράδειγμα, μπορεί να γνωρίζετε ότι το σύνολο δεδομένων stocks υποτίθεται ότι καλύπτει το διάστημα από το 2019 έως το 2021, επομένως θα μπορούσατε να παρέχετε ρητά αυτές τις τιμές για τη μεταβλητή year:\n\nstocks |&gt;\n  complete(year = 2019:2021, qtr)\n#&gt; # A tibble: 12 × 3\n#&gt;    year   qtr price\n#&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n#&gt; 1  2019     1 NA   \n#&gt; 2  2019     2 NA   \n#&gt; 3  2019     3 NA   \n#&gt; 4  2019     4 NA   \n#&gt; 5  2020     1  1.88\n#&gt; 6  2020     2  0.59\n#&gt; # ℹ 6 more rows\n\nΕάν το εύρος μιας μεταβλητής είναι σωστό, αλλά δεν υπάρχουν όλες οι τιμές, θα μπορούσατε να χρησιμοποιήσετε τη συνάρτηση full_seq(x, 1) για να δημιουργήσετε όλες τις τιμές από min(x) έως max(x), με απόσταση 1 τιμής κάθε φορά.\nΣε ορισμένες περιπτώσεις, το πλήρες σύνολο των παρατηρήσεων δεν μπορεί να δημιουργηθεί με έναν απλό συνδυασμό μεταβλητών. Σε αυτήν την περίπτωση, μπορείτε να κάνετε με μη αυτόματο τρόπο ό,τι κάνει η complete() για εσάς: δημιουργήστε ένα πλαίσιο δεδομένων που περιέχει όλες τις γραμμές που θα πρέπει να υπάρχουν (χρησιμοποιώντας οποιονδήποτε συνδυασμό τεχνικών χρειάζεστε), στη συνέχεια συνδυάστε το με το αρχικό σας σύνολο δεδομένων με την dplyr ::full_join().\n\n18.3.3 Ενώσεις\nΑυτό μας φέρνει σε έναν άλλο σημαντικό τρόπο εντοπισμού έμμεσα κενών τιμών: τις ενώσεις. Θα μάθετε περισσότερα για τις ενώσεις στο Κεφάλαιο 19, αλλά θέλαμε να σας τις αναφέρουμε γρήγορα εδώ, καθώς συχνά μπορεί να παρατηρήσετε ότι λείπουν τιμές από ένα σύνολο δεδομένων μόνο όταν το συγκρίνετε με ένα άλλο.\nΗ dplyr::anti_join(x, y) είναι ένα ιδιαίτερα χρήσιμο εργαλείο σε αυτή την περίπτωση επειδή επιλέγει μόνο τις γραμμές του x που δεν έχουν αντιστοιχία στο y. Για παράδειγμα, μπορούμε να χρησιμοποιήσουμε δύο anti_join() για να αποκαλύψουμε ότι μας λείπουν πληροφορίες για τέσσερα αεροδρόμια και 722 αεροπλάνα που αναφέρονται στο flights:\n\nlibrary(nycflights13)\n\nflights |&gt; \n  distinct(faa = dest) |&gt; \n  anti_join(airports)\n#&gt; Joining with `by = join_by(faa)`\n#&gt; # A tibble: 4 × 1\n#&gt;   faa  \n#&gt;   &lt;chr&gt;\n#&gt; 1 BQN  \n#&gt; 2 SJU  \n#&gt; 3 STT  \n#&gt; 4 PSE\n\nflights |&gt; \n  distinct(tailnum) |&gt; \n  anti_join(planes)\n#&gt; Joining with `by = join_by(tailnum)`\n#&gt; # A tibble: 722 × 1\n#&gt;   tailnum\n#&gt;   &lt;chr&gt;  \n#&gt; 1 N3ALAA \n#&gt; 2 N3DUAA \n#&gt; 3 N542MQ \n#&gt; 4 N730MQ \n#&gt; 5 N9EAMQ \n#&gt; 6 N532UA \n#&gt; # ℹ 716 more rows\n\n\n18.3.4 Ασκήσεις\n\nΜπορείτε να βρείτε κάποια σχέση μεταξύ του αερομεταφορέα και των γραμμών που φαίνεται να λείπουν από τα planes;",
    "crumbs": [
      "Μετασχηματισμοί",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Κενές τιμές</span>"
    ]
  },
  {
    "objectID": "missing-values.html#παράγοντες-και-κενές-ομάδες",
    "href": "missing-values.html#παράγοντες-και-κενές-ομάδες",
    "title": "18  Κενές τιμές",
    "section": "\n18.4 Παράγοντες και κενές ομάδες",
    "text": "18.4 Παράγοντες και κενές ομάδες\nΈνας τελευταίος τύπος ελλιπούς πληροφορίας είναι η κενή ομάδα, μία ομάδα που δεν περιέχει παρατηρήσεις, η οποία μπορεί να προκύψει όταν εργάζεστε με παράγοντες. Για παράδειγμα, φανταστείτε ότι έχουμε ένα σύνολο δεδομένων που περιέχει πληροφορίες σχετικά με την υγεία διαφόρων ατόμων:\n\nhealth &lt;- tibble(\n  name   = c(\"Ikaia\", \"Oletta\", \"Leriah\", \"Dashay\", \"Tresaun\"),\n  smoker = factor(c(\"no\", \"no\", \"no\", \"no\", \"no\"), levels = c(\"yes\", \"no\")),\n  age    = c(34, 88, 75, 47, 56),\n)\n\nΕμείς θέλουμε να υπολογίσουμε το πλήθος των καπνιστών με την dplyr::count():\n\nhealth |&gt; count(smoker)\n#&gt; # A tibble: 1 × 2\n#&gt;   smoker     n\n#&gt;   &lt;fct&gt;  &lt;int&gt;\n#&gt; 1 no         5\n\nΑυτό το σύνολο δεδομένων περιέχει μόνο μη καπνιστές, αλλά γνωρίζουμε ότι υπάρχουν καπνιστές - η ομάδα των καπνιστών είναι άδεια. Μπορούμε να ζητήσουμε από την count() να διατηρήσει όλες τις ομάδες, ακόμη και αυτές που δεν φαίνονται στα δεδομένα χρησιμοποιώντας το .drop = FALSE:\n\nhealth |&gt; count(smoker, .drop = FALSE)\n#&gt; # A tibble: 2 × 2\n#&gt;   smoker     n\n#&gt;   &lt;fct&gt;  &lt;int&gt;\n#&gt; 1 yes        0\n#&gt; 2 no         5\n\nΗ ίδια αρχή ισχύει για τους διακριτούς άξονες στο πακέτο ggplot2, οι οποίοι επίσης απορρίπτουν επίπεδα που δεν έχουν τιμές. Εναλλακτικά, μπορείτε να τους αναγκάσετε να τα εμφανιστούν παρέχοντας το όρισμα drop = FALSE στον κατάλληλο διακριτό άξονα:\nggplot(health, aes(x = smoker)) +\n  geom_bar() +\n  scale_x_discrete()\n\nggplot(health, aes(x = smoker)) +\n  geom_bar() +\n  scale_x_discrete(drop = FALSE)\n\n\n\n\n\n\n\n\n\n\nΓενικά, το ίδιο πρόβλημα προκύπτει πιο συχνά με την dplyr::group_by(). Και πάλι μπορείτε να χρησιμοποιήσετε το .drop = FALSE για να διατηρήσει όλα τα επίπεδα των παραγόντων:\n\nhealth |&gt; \n  group_by(smoker, .drop = FALSE) |&gt; \n  summarize(\n    n = n(),\n    mean_age = mean(age),\n    min_age = min(age),\n    max_age = max(age),\n    sd_age = sd(age)\n  )\n#&gt; # A tibble: 2 × 6\n#&gt;   smoker     n mean_age min_age max_age sd_age\n#&gt;   &lt;fct&gt;  &lt;int&gt;    &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt;  &lt;dbl&gt;\n#&gt; 1 yes        0      NaN     Inf    -Inf   NA  \n#&gt; 2 no         5       60      34      88   21.6\n\nΕδώ προκύπτουν μερικά ενδιαφέροντα αποτελέσματα επειδή όταν συνοψίζουμε μία κενή ομάδα, οι συναρτήσεις σύνοψης εφαρμόζονται σε διανύσματα μηδενικού μήκους. Υπάρχει μία σημαντική διάκριση μεταξύ των κενών διανυσμάτων, που έχουν μήκος 0, και των κενών τιμών, καθένα από τα οποία έχει μήκος 1.\n\n# Ένα διάνυσμα που περιέχει δύο κενές τιμές\nx1 &lt;- c(NA, NA)\nlength(x1)\n#&gt; [1] 2\n\n# Ένα διάνυσμα που δεν περιέχει τίποτα\nx2 &lt;- numeric()\nlength(x2)\n#&gt; [1] 0\n\nΌλες οι συναρτήσεις σύνοψης λειτουργούν με διανύσματα μηδενικού μήκους, αλλά μπορεί να επιστρέφουν αποτελέσματα που εκπλήσσουν με την πρώτη ματιά. Εδώ βλέπουμε ότι το mean(age) επιστρέφει NaN επειδή το mean(age) = sum(age)/length(age) που εδώ είναι 0/0. Τα max() και min() επιστρέφουν -Inf και Inf για κενά διανύσματα, οπότε αν συνδυάσετε τα αποτελέσματα με ένα μη κενό διάνυσμα νέων δεδομένων και υπολογίσετε εκ νέου, θα λάβετε το ελάχιστο ή το μέγιστο των νέων δεδομένων1.\nΜερικές φορές μία απλούστερη προσέγγιση είναι να εκτελέσετε τη σύνοψη και στη συνέχεια να κάνετε τις έμμεσα κενές τιμές ρητές με την complete().\n\nhealth |&gt; \n  group_by(smoker) |&gt; \n  summarize(\n    n = n(),\n    mean_age = mean(age),\n    min_age = min(age),\n    max_age = max(age),\n    sd_age = sd(age)\n  ) |&gt; \n  complete(smoker)\n#&gt; # A tibble: 2 × 6\n#&gt;   smoker     n mean_age min_age max_age sd_age\n#&gt;   &lt;fct&gt;  &lt;int&gt;    &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt;  &lt;dbl&gt;\n#&gt; 1 yes       NA       NA      NA      NA   NA  \n#&gt; 2 no         5       60      34      88   21.6\n\nΤο κύριο μειονέκτημα αυτής της προσέγγισης είναι ότι λαμβάνετε ένα NA στην καταμέτρηση, παρόλο που γνωρίζετε ότι θα πρέπει να είναι μηδέν.",
    "crumbs": [
      "Μετασχηματισμοί",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Κενές τιμές</span>"
    ]
  },
  {
    "objectID": "missing-values.html#σύνοψη",
    "href": "missing-values.html#σύνοψη",
    "title": "18  Κενές τιμές",
    "section": "\n18.5 Σύνοψη",
    "text": "18.5 Σύνοψη\nΟι κενές τιμές είναι περίεργες! Μερικές φορές καταγράφονται ρητά ως NA, ενώ άλλες φορές τις παρατηρείτε μόνο από την απουσία τους. Αυτό το κεφάλαιο σας έδωσε μερικά εργαλεία για την εργασία με ρητές κενές τιμές, εργαλεία για την αποκάλυψη έμμεσα κενών τιμών και συζητήσαμε μερικούς από τους τρόπους με τους οποίους οι έμμεσα κενές τιμές μπορούν να γίνουν ρητές και το αντίστροφο.\nΣτο επόμενο κεφάλαιο, ασχολούμαστε με το τελευταίο κεφάλαιο σε αυτό το μέρος του βιβλίου: τις ενώσεις. Αυτή είναι μία μικρή αλλαγή σε σχέση με τα μέχρι τώρα κεφάλαια, επειδή πρόκειται να συζητήσουμε εργαλεία που λειτουργούν με πλαίσια δεδομένων στο σύνολό τους, όχι κάτι που βάζετε μέσα σε ένα πλαίσιο δεδομένων.",
    "crumbs": [
      "Μετασχηματισμοί",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Κενές τιμές</span>"
    ]
  },
  {
    "objectID": "missing-values.html#footnotes",
    "href": "missing-values.html#footnotes",
    "title": "18  Κενές τιμές",
    "section": "",
    "text": "Με άλλα λόγια, το min(c(x, y)) είναι πάντα ίσο με min(min(x), min(y)).↩︎",
    "crumbs": [
      "Μετασχηματισμοί",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Κενές τιμές</span>"
    ]
  },
  {
    "objectID": "joins.html",
    "href": "joins.html",
    "title": "19  Ενώσεις",
    "section": "",
    "text": "19.1 Εισαγωγή\nΕίναι σπάνιο μία ανάλυση δεδομένων να περιλαμβάνει μόνο ένα πλαίσιο δεδομένων. Συνήθως έχετε πολλά πλαίσια δεδομένων και πρέπει να τα ενώσετε για να απαντήσετε στις ερωτήσεις που σας ενδιαφέρουν. Αυτό το κεφάλαιο θα σας παρουσιάσει δύο σημαντικούς τύπους ενώσεων:\nΘα ξεκινήσουμε συζητώντας τα κλειδιά, τις μεταβλητές που χρησιμοποιούνται για να συνδέσουν ένα ζεύγος πλαισίων δεδομένων σε μία ένωση. Θα εδραιώσουμε τη θεωρία εξετάζοντας τα κλειδιά στα σύνολα δεδομένων του πακέτου nycflights13 και, στη συνέχεια, χρησιμοποιούμε αυτή τη γνώση για να αρχίσουμε να ενώνουμε πλαίσια δεδομένων μεταξύ τους. Στη συνέχεια θα συζητήσουμε το πώς λειτουργούν οι ενώσεις, εστιάζοντας στη δράση τους στις γραμμές. Τέλος, Θα ολοκληρώσουμε με μία συζήτηση για ενώσεις που δεν είναι ισοδύναμες, μία οικογένεια ενώσεων που παρέχουν έναν πιο ευέλικτο τρόπο αντιστοίχισης κλειδιών από την προεπιλεγμένη σχέση ισότητας.",
    "crumbs": [
      "Μετασχηματισμοί",
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>Ενώσεις</span>"
    ]
  },
  {
    "objectID": "joins.html#εισαγωγή",
    "href": "joins.html#εισαγωγή",
    "title": "19  Ενώσεις",
    "section": "",
    "text": "Ενώσεις αλλαγής, οι οποίες προσθέτουν νέες μεταβλητές σε ένα πλαίσιο δεδομένων, οι οποίες προέρχονται από αντιστοιχισμένες παρατηρήσεις σε ένα άλλο πλαίσιο δεδομένων.\nΕνώσεις φιλτραρίσματος (filtering joins), οι οποίες φιλτράρουν τις παρατηρήσεις από ένα πλαίσιο δεδομένων με βάση το αν ταιριάζουν ή όχι με μία παρατήρηση σε ένα άλλο.\n\n\n\n19.1.1 Προαπαιτούμενα\nΣε αυτό το κεφάλαιο, θα εξερευνήσουμε τα πέντε σχετικά σύνολα δεδομένων από το nycflights13 χρησιμοποιώντας τις συναρτήσεις ένωσης (join) της dplyr.\n\nlibrary(tidyverse)\nlibrary(nycflights13)",
    "crumbs": [
      "Μετασχηματισμοί",
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>Ενώσεις</span>"
    ]
  },
  {
    "objectID": "joins.html#κλειδιά",
    "href": "joins.html#κλειδιά",
    "title": "19  Ενώσεις",
    "section": "\n19.2 Κλειδιά",
    "text": "19.2 Κλειδιά\nΓια να κατανοήσετε τις ενώσεις, πρέπει πρώτα να κατανοήσετε πώς δύο πίνακες μπορούν να συνδεθούν μέσω ενός ζεύγους κλειδιών, που υπάρχουν σε κάθε πίνακα. Σε αυτήν την ενότητα, θα μάθετε για τους δύο τύπους κλειδιών και θα δείτε παραδείγματα και των δύο στα σύνολα δεδομένων του πακέτου nycflights13. Θα μάθετε επίσης πώς να ελέγχετε ότι τα κλειδιά σας είναι έγκυρα και τι να κάνετε εάν ο πίνακας σας δεν διαθέτει κλειδί.\n\n19.2.1 Πρωτεύοντα και δευτερεύοντα (ξένα) κλειδιά\nΚάθε ένωση περιλαμβάνει ένα ζεύγος κλειδιών: ένα πρωτεύον (ή κύριο) κλειδί και ένα ξένο (ή δευτερεύον) κλειδί. Ένα πρωτεύον κλειδί είναι μία μεταβλητή ή ένα σύνολο μεταβλητών που προσδιορίζει μοναδικά κάθε παρατήρηση. Όταν χρειάζονται περισσότερες από μία μεταβλητές, το κλειδί ονομάζεται σύνθετο κλειδί. Για παράδειγμα, στο nycflights13:\n\n\nΤο πλαίσιο δεδομένων airlines καταγράφει για κάθε αεροπορική εταιρεία δύο στοιχεία: τον κωδικό της εταιρείας και το πλήρες όνομά της. Μπορείτε να προσδιορίσετε μία αεροπορική εταιρεία με τον κωδικό δύο γραμμάτων που της αντιστοιχεί, καθιστώντας τη μεταβλητή carrier το πρωτεύον κλειδί.\n\nairlines\n#&gt; # A tibble: 16 × 2\n#&gt;   carrier name                    \n#&gt;   &lt;chr&gt;   &lt;chr&gt;                   \n#&gt; 1 9E      Endeavor Air Inc.       \n#&gt; 2 AA      American Airlines Inc.  \n#&gt; 3 AS      Alaska Airlines Inc.    \n#&gt; 4 B6      JetBlue Airways         \n#&gt; 5 DL      Delta Air Lines Inc.    \n#&gt; 6 EV      ExpressJet Airlines Inc.\n#&gt; # ℹ 10 more rows\n\n\n\nΤο airports καταγράφει δεδομένα για κάθε αεροδρόμιο. Μπορείτε να προσδιορίσετε κάθε αεροδρόμιο με τον κωδικό τριών γραμμάτων που του αντιστοιχεί, καθιστώντας τη μεταβλητή faa το πρωτεύον κλειδί.\n\nairports\n#&gt; # A tibble: 1,458 × 8\n#&gt;   faa   name                            lat   lon   alt    tz dst  \n#&gt;   &lt;chr&gt; &lt;chr&gt;                         &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt;\n#&gt; 1 04G   Lansdowne Airport              41.1 -80.6  1044    -5 A    \n#&gt; 2 06A   Moton Field Municipal Airport  32.5 -85.7   264    -6 A    \n#&gt; 3 06C   Schaumburg Regional            42.0 -88.1   801    -6 A    \n#&gt; 4 06N   Randall Airport                41.4 -74.4   523    -5 A    \n#&gt; 5 09J   Jekyll Island Airport          31.1 -81.4    11    -5 A    \n#&gt; 6 0A9   Elizabethton Municipal Airpo…  36.4 -82.2  1593    -5 A    \n#&gt; # ℹ 1,452 more rows\n#&gt; # ℹ 1 more variable: tzone &lt;chr&gt;\n\n\n\nΤο planes καταγράφει δεδομένα για κάθε αεροπλάνο. Μπορείτε να προσδιορίσετε ένα αεροπλάνο με τον αναγνωριστικό κωδικό του, καθιστώντας τη μεταβλητή tailnum το πρωτεύον κλειδί.\n\nplanes\n#&gt; # A tibble: 3,322 × 9\n#&gt;   tailnum  year type              manufacturer    model     engines\n#&gt;   &lt;chr&gt;   &lt;int&gt; &lt;chr&gt;             &lt;chr&gt;           &lt;chr&gt;       &lt;int&gt;\n#&gt; 1 N10156   2004 Fixed wing multi… EMBRAER         EMB-145XR       2\n#&gt; 2 N102UW   1998 Fixed wing multi… AIRBUS INDUSTR… A320-214        2\n#&gt; 3 N103US   1999 Fixed wing multi… AIRBUS INDUSTR… A320-214        2\n#&gt; 4 N104UW   1999 Fixed wing multi… AIRBUS INDUSTR… A320-214        2\n#&gt; 5 N10575   2002 Fixed wing multi… EMBRAER         EMB-145LR       2\n#&gt; 6 N105UW   1999 Fixed wing multi… AIRBUS INDUSTR… A320-214        2\n#&gt; # ℹ 3,316 more rows\n#&gt; # ℹ 3 more variables: seats &lt;int&gt;, speed &lt;int&gt;, engine &lt;chr&gt;\n\n\n\nΤο weather καταγράφει δεδομένα για τον καιρό στο αεροδρόμιο αναχώρησης. Μπορείτε να προσδιορίσετε κάθε παρατήρηση από το συνδυασμό τοποθεσίας και ώρας, καθιστώντας τις μεταβλητές origin και time_hour το σύνθετο πρωτεύον κλειδί.\n\nweather\n#&gt; # A tibble: 26,115 × 15\n#&gt;   origin  year month   day  hour  temp  dewp humid wind_dir\n#&gt;   &lt;chr&gt;  &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;    &lt;dbl&gt;\n#&gt; 1 EWR     2013     1     1     1  39.0  26.1  59.4      270\n#&gt; 2 EWR     2013     1     1     2  39.0  27.0  61.6      250\n#&gt; 3 EWR     2013     1     1     3  39.0  28.0  64.4      240\n#&gt; 4 EWR     2013     1     1     4  39.9  28.0  62.2      250\n#&gt; 5 EWR     2013     1     1     5  39.0  28.0  64.4      260\n#&gt; 6 EWR     2013     1     1     6  37.9  28.0  67.2      240\n#&gt; # ℹ 26,109 more rows\n#&gt; # ℹ 6 more variables: wind_speed &lt;dbl&gt;, wind_gust &lt;dbl&gt;, …\n\n\n\nΈνα ξένο κλειδί είναι μία μεταβλητή (ή σύνολο μεταβλητών) που αντιστοιχεί στο πρωτεύον κλειδί από έναν άλλο πίνακα. Για παράδειγμα:\n\nΗ μεταβλητή flights$tailnum είναι ένα ξένο κλειδί που αντιστοιχεί στο πρωτεύον κλειδί planes$tailnum.\nΗ μεταβλητή flights$carrier είναι ένα ξένο κλειδί που αντιστοιχεί στο πρωτεύον κλειδί airlines$carrier.\nΗ μεταβλητή flights$origin είναι ένα ξένο κλειδί που αντιστοιχεί στο πρωτεύον κλειδί airports$faa.\nΗ μεταβλητή flights$dest είναι ένα ξένο κλειδί που αντιστοιχεί στο πρωτεύον κλειδί airports$faa.\nΗ μεταβλητή flights$origin-flights$time_hour είναι ένα σύνθετο ξένο κλειδί που αντιστοιχεί στο σύνθετο πρωτεύον κλειδί weather$origin-weather$time_hour.\n\nΑυτές οι σχέσεις συνοψίζονται και οπτικά στο Σχήμα 19.1.\n\n\n\n\n\n\n\nΣχήμα 19.1: Συνδέσεις μεταξύ και των πέντε πλαισίων δεδομένων στο πακέτο nycflights13. Οι μεταβλητές που αποτελούν ένα πρωτεύον κλειδί έχουν γκρι χρώμα, και συνδέονται με τα αντίστοιχα ξένα κλειδιά τους με βέλη.\n\n\n\n\nΘα παρατηρήσετε ένα ωραίο χαρακτηριστικό στο σχεδιασμό αυτών των κλειδιών: το πρωτεύον και το ξένο κλειδί έχουν σχεδόν πάντα τα ίδια ονόματα, κάτι που, όπως θα δείτε σύντομα, θα κάνει πολύ πιο εύκολη τη ζωή σας όταν κάνετε ενώσεις. Αξίζει επίσης να σημειωθεί και η αντίθετη σχέση: σχεδόν κάθε όνομα μεταβλητής που χρησιμοποιείται σε πολλούς πίνακες έχει την ίδια σημασία σε κάθε μέρος. Υπάρχει μόνο μία εξαίρεση: η μεταβλητή year υποδηλώνει το έτος αναχώρησης στο πλαίσιο δεδομένων flights το έτος του κατασκευαστή στο πλαίσιο δεδομένων planes. Αυτό θα γίνει σημαντικό όταν αρχίσουμε να ενώνουμε πίνακες μαζί.\n\n19.2.2 Έλεγχος πρωτευόντων κλειδιών\nΤώρα που προσδιορίσαμε τα κύρια κλειδιά σε κάθε πίνακα, είναι καλή πρακτική να επαληθεύσουμε ότι όντως προσδιορίζουν μοναδικά κάθε παρατήρηση. Ένας τρόπος για να γίνει αυτό είναι να μετρώντας τις τιμές που αντιστοιχούν στα κύρια κλειδιά με την count() και να εστιάσουμε σε παρατηρήσεις όπου το πλήθος τιμών (n) είναι μεγαλύτερο από ένα. Αυτός ο έλεγχος αποκαλύπτει ότι οι μεταβλητές planes και weather δείχνουν και οι δύο καλά:\n\nplanes |&gt; \n  count(tailnum) |&gt; \n  filter(n &gt; 1)\n#&gt; # A tibble: 0 × 2\n#&gt; # ℹ 2 variables: tailnum &lt;chr&gt;, n &lt;int&gt;\n\nweather |&gt; \n  count(time_hour, origin) |&gt; \n  filter(n &gt; 1)\n#&gt; # A tibble: 0 × 3\n#&gt; # ℹ 3 variables: time_hour &lt;dttm&gt;, origin &lt;chr&gt;, n &lt;int&gt;\n\nΘα πρέπει επίσης να ελέγξετε για την ύπαρξη κενών τιμών στα κύρια κλειδιά σας — εάν λείπει μία τιμή, αυτό σημαίνει ότι μία παρατήρηση δεν μπορεί να αναγνωριστεί!\n\nplanes |&gt; \n  filter(is.na(tailnum))\n#&gt; # A tibble: 0 × 9\n#&gt; # ℹ 9 variables: tailnum &lt;chr&gt;, year &lt;int&gt;, type &lt;chr&gt;, manufacturer &lt;chr&gt;,\n#&gt; #   model &lt;chr&gt;, engines &lt;int&gt;, seats &lt;int&gt;, speed &lt;int&gt;, engine &lt;chr&gt;\n\nweather |&gt; \n  filter(is.na(time_hour) | is.na(origin))\n#&gt; # A tibble: 0 × 15\n#&gt; # ℹ 15 variables: origin &lt;chr&gt;, year &lt;int&gt;, month &lt;int&gt;, day &lt;int&gt;,\n#&gt; #   hour &lt;int&gt;, temp &lt;dbl&gt;, dewp &lt;dbl&gt;, humid &lt;dbl&gt;, wind_dir &lt;dbl&gt;, …\n\n\n19.2.3 Υποκατάστατα κλειδιά\nΜέχρι στιγμής δεν έχουμε μιλήσει για το πρωτεύον κλειδί στο πλαίσιο δεδομένων flights. Δεν είναι πολύ σημαντικό εδώ, επειδή δεν υπάρχουν πλαίσια δεδομένων που να το χρησιμοποιούν ως ξένο κλειδί, αλλά παραμένει χρήσιμο να το αναφέρουμε γιατί είναι πιο εύκολο να εργαστούμε με παρατηρήσεις, αν έχουμε κάποιο τρόπο να τις περιγράψουμε σε άλλους.\nΜετά από λίγη σκέψη και πειραματισμό, αποφασίσαμε ότι υπάρχουν τρεις μεταβλητές που μαζί προσδιορίζουν μοναδικά κάθε πτήση:\n\nflights |&gt; \n  count(time_hour, carrier, flight) |&gt; \n  filter(n &gt; 1)\n#&gt; # A tibble: 0 × 4\n#&gt; # ℹ 4 variables: time_hour &lt;dttm&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;, n &lt;int&gt;\n\nΚάνει αυτόματα η απουσία διπλότυπων τιμών τον συνδυασμό time_hour-carrier-flight ένα πρωτεύον κλειδί; Είναι σίγουρα μία καλή αρχή, ωστόσο δεν αποτελεί εγγύηση. Για παράδειγμα, είναι το υψόμετρο και το γεωγραφικό πλάτος ένα καλό πρωτεύον κλειδί για το πλαίσιο airports;\n\nairports |&gt;\n  count(alt, lat) |&gt; \n  filter(n &gt; 1)\n#&gt; # A tibble: 1 × 3\n#&gt;     alt   lat     n\n#&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt;\n#&gt; 1    13  40.6     2\n\nΗ αναγνώριση ενός αεροδρομίου με βάση το υψόμετρο και το γεωγραφικό του πλάτος είναι σαφώς κακή ιδέα και γενικά δεν είναι δυνατό να γνωρίζουμε μόνο από τα δεδομένα εάν ένας συνδυασμός μεταβλητών αποτελεί ένα καλό πρωτεύον κλειδί ή όχι. Ωστόσο, για τις πτήσεις, ο συνδυασμός των μεταβλητών time_hour, carrier, και flight φαίνεται λογικός γιατί θα προκαλούσε σύγχυση για μία αεροπορική εταιρεία και τους πελάτες της εάν υπήρχαν πολλές πτήσεις με τον ίδιο αριθμό πτήσης στον αέρα ταυτόχρονα .\nΈχοντας ξεκαθαρίσει αυτό το σημείο, ίσως είναι καλύτερα να εισάγουμε ένα απλό αριθμητικό υποκατάστατο κλειδί χρησιμοποιώντας τον αριθμό κάθε γραμμής:\n\nflights2 &lt;- flights |&gt; \n  mutate(id = row_number(), .before = 1)\nflights2\n#&gt; # A tibble: 336,776 × 20\n#&gt;      id  year month   day dep_time sched_dep_time dep_delay arr_time\n#&gt;   &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;\n#&gt; 1     1  2013     1     1      517            515         2      830\n#&gt; 2     2  2013     1     1      533            529         4      850\n#&gt; 3     3  2013     1     1      542            540         2      923\n#&gt; 4     4  2013     1     1      544            545        -1     1004\n#&gt; 5     5  2013     1     1      554            600        -6      812\n#&gt; 6     6  2013     1     1      554            558        -4      740\n#&gt; # ℹ 336,770 more rows\n#&gt; # ℹ 12 more variables: sched_arr_time &lt;int&gt;, arr_delay &lt;dbl&gt;, …\n\nΤα υποκατάστατα κλειδιά μπορούν να είναι ιδιαίτερα χρήσιμα όταν επικοινωνείτε με άλλους ανθρώπους: είναι πολύ πιο εύκολο να πείτε σε κάποιον να ρίξει μία ματιά στην πτήση 2001 παρά να του πείτε να δει την UA430 που αναχώρησε στις 9 π.μ., στις 03-01-2013.\n\n19.2.4 Ασκήσεις\n\nΞεχάσαμε να σχεδιάσουμε τη σχέση μεταξύ weather και airports στο Σχήμα 19.1. Ποια είναι η σχέση και πώς πρέπει να εμφανίζεται στο διάγραμμα;\nΗ μεταβλητή weather περιέχει μόνο πληροφορίες για τα τρία αεροδρόμια αναχώρησης στη Νέα Υόρκη. Εάν περιείχε αρχεία καιρού για όλα τα αεροδρόμια των ΗΠΑ, ποια πρόσθετη σύνδεση θα έκανε με το πλαίσιο δεδομένων flights;\nΟι μεταβλητές year, month, day, hour, και origin σχεδόν σχηματίζουν ένα σύνθετο κλειδί για το πλαίσιο δεδομένων weather, ωστόσο υπάρχει μία τιμή ώρας που έχει διπλότυπες παρατηρήσεις. Μπορείτε να καταλάβετε τι το ιδιαίτερο έχει αυτή η ώρα;\nΓνωρίζουμε ότι κάποιες μέρες του χρόνου είναι ιδιαίτερες και λιγότεροι άνθρωποι από το συνηθισμένο επιλέγουν να πετάξουν αυτές τις μέρες (για παράδειγμα, παραμονή και ανήμερα Χριστουγέννων). Πώς μπορείτε να αναπαραστήσετε αυτά τα δεδομένα ως πλαίσιο δεδομένων; Ποιο θα ήταν το πρωτεύον κλειδί; Πώς θα συνδεόταν με τα υπάρχοντα πλαίσια δεδομένων;\nΣχεδιάστε ένα διάγραμμα που απεικονίζει τις συνδέσεις μεταξύ των πλαισίων δεδομένων Batting, People, και Salariesστο πακέτο Lahman. Σχεδιάστε ένα άλλο διάγραμμα που δείχνει τη σχέση μεταξύ των People, Managers, AwardsManagers. Πώς θα χαρακτηρίζατε τη σχέση μεταξύ των πλαισίων δεδομένων Batting, Pitching, και Fielding;",
    "crumbs": [
      "Μετασχηματισμοί",
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>Ενώσεις</span>"
    ]
  },
  {
    "objectID": "joins.html#sec-mutating-joins",
    "href": "joins.html#sec-mutating-joins",
    "title": "19  Ενώσεις",
    "section": "\n19.3 Βασικές ενώσεις",
    "text": "19.3 Βασικές ενώσεις\nΤώρα που καταλαβαίνετε πως συνδέονται τα πλαίσια δεδομένων με τη βοήθεια κλειδιών, μπορούμε να αρχίσουμε να χρησιμοποιούμε ενώσεις για να κατανοήσουμε καλύτερα το σύνολο δεδομένων flights. Η dplyr προσφέρει έξι συναρτήσεις ένωσης: left_join(), inner_join(), right_join(), full_join(), semi_join(), και anti_join(). Όλες έχουν την ίδια διεπαφή: παίρνουν ένα ζευγάρι πλαισίων δεδομένων (x και y) και επιστρέφουν ένα πλαίσιο δεδομένων. Η σειρά των γραμμών και στηλών στην έξοδο καθορίζεται κυρίως από το x.\nΣε αυτήν την ενότητα, θα μάθετε πώς να χρησιμοποιείτε μία ένωση αλλαγής, την left_join(), και δύο filtering ενώσεις, τις semi_join() και anti_join(). Στην επόμενη ενότητα, θα μάθετε πώς ακριβώς λειτουργούν αυτές οι συναρτήσεις, καθώς και για τις υπόλοιπες: inner_join(), right_join() και full_join().\n\n19.3.1 Ενώσεις αλλαγής\nΜία ένωση αλλαγής σας επιτρέπει να συνδυάσετε μεταβλητές από δύο πλαίσια δεδομένων: πρώτα αντιστοιχίζει παρατηρήσεις με βάση τα κλειδιά τους και μετά αντιγράφει παρατηρήσεις μεταξύ των μεταβλητών από το ένα πλαίσιο δεδομένων στο άλλο. Όπως και η mutate(), οι συναρτήσεις ένωσης προσθέτουν μεταβλητές στα δεξιά, οπότε αν το σύνολο δεδομένων σας έχει πολλές μεταβλητές, δεν θα δείτε τις νέες. Για αυτά τα παραδείγματα, θα διευκολύνουμε την παρατήρηση του τι συμβαίνει δημιουργώντας ένα πιο στενό σύνολο δεδομένων με έξι μόνο μεταβλητές1:\n\nflights2 &lt;- flights |&gt; \n  select(year, time_hour, origin, dest, tailnum, carrier)\nflights2\n#&gt; # A tibble: 336,776 × 6\n#&gt;    year time_hour           origin dest  tailnum carrier\n#&gt;   &lt;int&gt; &lt;dttm&gt;              &lt;chr&gt;  &lt;chr&gt; &lt;chr&gt;   &lt;chr&gt;  \n#&gt; 1  2013 2013-01-01 05:00:00 EWR    IAH   N14228  UA     \n#&gt; 2  2013 2013-01-01 05:00:00 LGA    IAH   N24211  UA     \n#&gt; 3  2013 2013-01-01 05:00:00 JFK    MIA   N619AA  AA     \n#&gt; 4  2013 2013-01-01 05:00:00 JFK    BQN   N804JB  B6     \n#&gt; 5  2013 2013-01-01 06:00:00 LGA    ATL   N668DN  DL     \n#&gt; 6  2013 2013-01-01 05:00:00 EWR    ORD   N39463  UA     \n#&gt; # ℹ 336,770 more rows\n\nΥπάρχουν τέσσερις τύποι ενώσεων αλλαγής, ωστόσο ένας είναι που θα χρησιμοποιείτε σχεδόν συνέχεια: left_join(). Αυτό είναι ιδιαίτερο γιατί η έξοδος θα έχει πάντα τις ίδιες γραμμές με το x, το πλαίσιο δεδομένων προς το οποίο συνδέετε2. Η κύρια χρήση του left_join() είναι η προσθήκη επιπλέον μεταδεδομένων. Για παράδειγμα, μπορούμε να χρησιμοποιήσουμε το left_join() για να προσθέσουμε το πλήρες όνομα της αεροπορικής εταιρείας στα δεδομένα του flights2:\n\nflights2 |&gt;\n  left_join(airlines)\n#&gt; Joining with `by = join_by(carrier)`\n#&gt; # A tibble: 336,776 × 7\n#&gt;    year time_hour           origin dest  tailnum carrier name                \n#&gt;   &lt;int&gt; &lt;dttm&gt;              &lt;chr&gt;  &lt;chr&gt; &lt;chr&gt;   &lt;chr&gt;   &lt;chr&gt;               \n#&gt; 1  2013 2013-01-01 05:00:00 EWR    IAH   N14228  UA      United Air Lines In…\n#&gt; 2  2013 2013-01-01 05:00:00 LGA    IAH   N24211  UA      United Air Lines In…\n#&gt; 3  2013 2013-01-01 05:00:00 JFK    MIA   N619AA  AA      American Airlines I…\n#&gt; 4  2013 2013-01-01 05:00:00 JFK    BQN   N804JB  B6      JetBlue Airways     \n#&gt; 5  2013 2013-01-01 06:00:00 LGA    ATL   N668DN  DL      Delta Air Lines Inc.\n#&gt; 6  2013 2013-01-01 05:00:00 EWR    ORD   N39463  UA      United Air Lines In…\n#&gt; # ℹ 336,770 more rows\n\nΉ θα μπορούσαμε να μάθουμε τη θερμοκρασία και την ταχύτητα του ανέμου όταν κάθε αεροπλάνο αναχωρούσε:\n\nflights2 |&gt; \n  left_join(weather |&gt; select(origin, time_hour, temp, wind_speed))\n#&gt; Joining with `by = join_by(time_hour, origin)`\n#&gt; # A tibble: 336,776 × 8\n#&gt;    year time_hour           origin dest  tailnum carrier  temp wind_speed\n#&gt;   &lt;int&gt; &lt;dttm&gt;              &lt;chr&gt;  &lt;chr&gt; &lt;chr&gt;   &lt;chr&gt;   &lt;dbl&gt;      &lt;dbl&gt;\n#&gt; 1  2013 2013-01-01 05:00:00 EWR    IAH   N14228  UA       39.0       12.7\n#&gt; 2  2013 2013-01-01 05:00:00 LGA    IAH   N24211  UA       39.9       15.0\n#&gt; 3  2013 2013-01-01 05:00:00 JFK    MIA   N619AA  AA       39.0       15.0\n#&gt; 4  2013 2013-01-01 05:00:00 JFK    BQN   N804JB  B6       39.0       15.0\n#&gt; 5  2013 2013-01-01 06:00:00 LGA    ATL   N668DN  DL       39.9       16.1\n#&gt; 6  2013 2013-01-01 05:00:00 EWR    ORD   N39463  UA       39.0       12.7\n#&gt; # ℹ 336,770 more rows\n\nΉ τι μέγεθος αεροπλάνου πετούσε:\n\nflights2 |&gt; \n  left_join(planes |&gt; select(tailnum, type, engines, seats))\n#&gt; Joining with `by = join_by(tailnum)`\n#&gt; # A tibble: 336,776 × 9\n#&gt;    year time_hour           origin dest  tailnum carrier type                \n#&gt;   &lt;int&gt; &lt;dttm&gt;              &lt;chr&gt;  &lt;chr&gt; &lt;chr&gt;   &lt;chr&gt;   &lt;chr&gt;               \n#&gt; 1  2013 2013-01-01 05:00:00 EWR    IAH   N14228  UA      Fixed wing multi en…\n#&gt; 2  2013 2013-01-01 05:00:00 LGA    IAH   N24211  UA      Fixed wing multi en…\n#&gt; 3  2013 2013-01-01 05:00:00 JFK    MIA   N619AA  AA      Fixed wing multi en…\n#&gt; 4  2013 2013-01-01 05:00:00 JFK    BQN   N804JB  B6      Fixed wing multi en…\n#&gt; 5  2013 2013-01-01 06:00:00 LGA    ATL   N668DN  DL      Fixed wing multi en…\n#&gt; 6  2013 2013-01-01 05:00:00 EWR    ORD   N39463  UA      Fixed wing multi en…\n#&gt; # ℹ 336,770 more rows\n#&gt; # ℹ 2 more variables: engines &lt;int&gt;, seats &lt;int&gt;\n\nΌταν η left_join() δεν βρει ταίριασμα για μία γραμμή στο x, συμπληρώνει τις νέες μεταβλητές με κενές τιμές. Για παράδειγμα, δεν υπάρχουν πληροφορίες σχετικά με το αεροπλάνο με αναγνωριστικό κωδικό N3ALAA, οπότε οι τιμές στις στήλες type, engines, και seats θα λείπουν:\n\nflights2 |&gt; \n  filter(tailnum == \"N3ALAA\") |&gt; \n  left_join(planes |&gt; select(tailnum, type, engines, seats))\n#&gt; Joining with `by = join_by(tailnum)`\n#&gt; # A tibble: 63 × 9\n#&gt;    year time_hour           origin dest  tailnum carrier type  engines seats\n#&gt;   &lt;int&gt; &lt;dttm&gt;              &lt;chr&gt;  &lt;chr&gt; &lt;chr&gt;   &lt;chr&gt;   &lt;chr&gt;   &lt;int&gt; &lt;int&gt;\n#&gt; 1  2013 2013-01-01 06:00:00 LGA    ORD   N3ALAA  AA      &lt;NA&gt;       NA    NA\n#&gt; 2  2013 2013-01-02 18:00:00 LGA    ORD   N3ALAA  AA      &lt;NA&gt;       NA    NA\n#&gt; 3  2013 2013-01-03 06:00:00 LGA    ORD   N3ALAA  AA      &lt;NA&gt;       NA    NA\n#&gt; 4  2013 2013-01-07 19:00:00 LGA    ORD   N3ALAA  AA      &lt;NA&gt;       NA    NA\n#&gt; 5  2013 2013-01-08 17:00:00 JFK    ORD   N3ALAA  AA      &lt;NA&gt;       NA    NA\n#&gt; 6  2013 2013-01-16 06:00:00 LGA    ORD   N3ALAA  AA      &lt;NA&gt;       NA    NA\n#&gt; # ℹ 57 more rows\n\nΘα επανέλθουμε σε αυτό το πρόβλημα μερικές φορές στο υπόλοιπο αυτού του κεφαλαίου.\n\n19.3.2 Καθορισμός κλειδιών ένωσης\nΑπό προεπιλογή, η left_join() θα χρησιμοποιεί όλες τις μεταβλητές που εμφανίζονται και στα δύο πλαίσια δεδομένων ως κλειδί ένωση, τη λεγόμενη φυσική (natural) ένωση. Αυτός είναι ένα χρήσιμος κανόνας, αλλά δεν λειτουργεί πάντα. Για παράδειγμα, τι θα συμβεί αν προσπαθήσουμε να ενώσουμε το flights2 με το πλήρες σύνολο δεδομένων planes;\n\nflights2 |&gt; \n  left_join(planes)\n#&gt; Joining with `by = join_by(year, tailnum)`\n#&gt; # A tibble: 336,776 × 13\n#&gt;    year time_hour           origin dest  tailnum carrier type  manufacturer\n#&gt;   &lt;int&gt; &lt;dttm&gt;              &lt;chr&gt;  &lt;chr&gt; &lt;chr&gt;   &lt;chr&gt;   &lt;chr&gt; &lt;chr&gt;       \n#&gt; 1  2013 2013-01-01 05:00:00 EWR    IAH   N14228  UA      &lt;NA&gt;  &lt;NA&gt;        \n#&gt; 2  2013 2013-01-01 05:00:00 LGA    IAH   N24211  UA      &lt;NA&gt;  &lt;NA&gt;        \n#&gt; 3  2013 2013-01-01 05:00:00 JFK    MIA   N619AA  AA      &lt;NA&gt;  &lt;NA&gt;        \n#&gt; 4  2013 2013-01-01 05:00:00 JFK    BQN   N804JB  B6      &lt;NA&gt;  &lt;NA&gt;        \n#&gt; 5  2013 2013-01-01 06:00:00 LGA    ATL   N668DN  DL      &lt;NA&gt;  &lt;NA&gt;        \n#&gt; 6  2013 2013-01-01 05:00:00 EWR    ORD   N39463  UA      &lt;NA&gt;  &lt;NA&gt;        \n#&gt; # ℹ 336,770 more rows\n#&gt; # ℹ 5 more variables: model &lt;chr&gt;, engines &lt;int&gt;, seats &lt;int&gt;, …\n\nΘα λάβουμε πολλές περιπτώσεις χωρίς αντιστοίχιση επειδή η ένωση μας προσπαθεί να χρησιμοποιήσει τις μεταβλητές tailnum και year ως σύνθετο κλειδί. Και τα δύο σύνολα, flights και planes, περιέχουν μία στήλη year, ωστόσο αυτή η στήλη έχει σημαίνει διαφορετικά πράγματα σε κάθε περίπτωση: η flights$year είναι το έτος που πραγματοποιήθηκε η πτήση και η planes$year είναι το έτος κατασκευής του αεροπλάνου. Θέλουμε να πραγματοποιήσουμε ένωση μόνο με βάση την tailnum, επομένως πρέπει να παρέχουμε μία ρητή προδιαγραφή με το join_by():\n\nflights2 |&gt; \n  left_join(planes, join_by(tailnum))\n#&gt; # A tibble: 336,776 × 14\n#&gt;   year.x time_hour           origin dest  tailnum carrier year.y\n#&gt;    &lt;int&gt; &lt;dttm&gt;              &lt;chr&gt;  &lt;chr&gt; &lt;chr&gt;   &lt;chr&gt;    &lt;int&gt;\n#&gt; 1   2013 2013-01-01 05:00:00 EWR    IAH   N14228  UA        1999\n#&gt; 2   2013 2013-01-01 05:00:00 LGA    IAH   N24211  UA        1998\n#&gt; 3   2013 2013-01-01 05:00:00 JFK    MIA   N619AA  AA        1990\n#&gt; 4   2013 2013-01-01 05:00:00 JFK    BQN   N804JB  B6        2012\n#&gt; 5   2013 2013-01-01 06:00:00 LGA    ATL   N668DN  DL        1991\n#&gt; 6   2013 2013-01-01 05:00:00 EWR    ORD   N39463  UA        2012\n#&gt; # ℹ 336,770 more rows\n#&gt; # ℹ 7 more variables: type &lt;chr&gt;, manufacturer &lt;chr&gt;, model &lt;chr&gt;, …\n\nΣημειώστε ότι η προέλευση των μεταβλητών year αποσαφηνίζεται στην έξοδο με ένα επίθημα (year.x και year.y), το οποίο μας λέει εάν η μεταβλητή προήλθε από το όρισμα x ή y. Μπορείτε να παρακάμψετε τα προεπιλεγμένα επιθήματα με το όρισμα suffix.\nΤο join_by(tailnum) είναι η σύντομη εκδοχή του join_by(tailnum == tailnum). Είναι σημαντικό να γνωρίζετε αυτήν την πληρέστερη εκδοχή για δύο λόγους. Πρώτον, γιατί περιγράφει τη σχέση μεταξύ των δύο πινάκων: τα κλειδιά πρέπει να είναι ίσα (equal). Αυτός είναι ο λόγος για τον οποίο αυτός ο τύπος ένωσης ονομάζεται συχνά equi ένωση. Θα μάθετε για τις non-equi ενώσεις στην Ενότητα 19.5.\nΔεύτερον, γιατί δείχνει τον τρόπο με τον οποίο καθορίζετε διαφορετικά κλειδιά ένωσης σε κάθε πίνακα. Για παράδειγμα, υπάρχουν δύο τρόποι για να ενώσετε τους πίνακες flight2 και airports: είτε με βάση το dest (τον προορισμό) είτε το origin (την προέλευση):\n\nflights2 |&gt; \n  left_join(airports, join_by(dest == faa))\n#&gt; # A tibble: 336,776 × 13\n#&gt;    year time_hour           origin dest  tailnum carrier name                \n#&gt;   &lt;int&gt; &lt;dttm&gt;              &lt;chr&gt;  &lt;chr&gt; &lt;chr&gt;   &lt;chr&gt;   &lt;chr&gt;               \n#&gt; 1  2013 2013-01-01 05:00:00 EWR    IAH   N14228  UA      George Bush Interco…\n#&gt; 2  2013 2013-01-01 05:00:00 LGA    IAH   N24211  UA      George Bush Interco…\n#&gt; 3  2013 2013-01-01 05:00:00 JFK    MIA   N619AA  AA      Miami Intl          \n#&gt; 4  2013 2013-01-01 05:00:00 JFK    BQN   N804JB  B6      &lt;NA&gt;                \n#&gt; 5  2013 2013-01-01 06:00:00 LGA    ATL   N668DN  DL      Hartsfield Jackson …\n#&gt; 6  2013 2013-01-01 05:00:00 EWR    ORD   N39463  UA      Chicago Ohare Intl  \n#&gt; # ℹ 336,770 more rows\n#&gt; # ℹ 6 more variables: lat &lt;dbl&gt;, lon &lt;dbl&gt;, alt &lt;dbl&gt;, tz &lt;dbl&gt;, …\n\nflights2 |&gt; \n  left_join(airports, join_by(origin == faa))\n#&gt; # A tibble: 336,776 × 13\n#&gt;    year time_hour           origin dest  tailnum carrier name               \n#&gt;   &lt;int&gt; &lt;dttm&gt;              &lt;chr&gt;  &lt;chr&gt; &lt;chr&gt;   &lt;chr&gt;   &lt;chr&gt;              \n#&gt; 1  2013 2013-01-01 05:00:00 EWR    IAH   N14228  UA      Newark Liberty Intl\n#&gt; 2  2013 2013-01-01 05:00:00 LGA    IAH   N24211  UA      La Guardia         \n#&gt; 3  2013 2013-01-01 05:00:00 JFK    MIA   N619AA  AA      John F Kennedy Intl\n#&gt; 4  2013 2013-01-01 05:00:00 JFK    BQN   N804JB  B6      John F Kennedy Intl\n#&gt; 5  2013 2013-01-01 06:00:00 LGA    ATL   N668DN  DL      La Guardia         \n#&gt; 6  2013 2013-01-01 05:00:00 EWR    ORD   N39463  UA      Newark Liberty Intl\n#&gt; # ℹ 336,770 more rows\n#&gt; # ℹ 6 more variables: lat &lt;dbl&gt;, lon &lt;dbl&gt;, alt &lt;dbl&gt;, tz &lt;dbl&gt;, …\n\nΣε παλαιότερο κώδικα, ενδέχεται να δείτε έναν διαφορετικό τρόπο καθορισμού των κλειδιών ένωσης, χρησιμοποιώντας ένα διάνυσμα χαρακτήρων:\n\nΤο by = \"x\" αντιστοιχεί στο join_by(x).\nΤο by = c(\"a\" = \"x\") αντιστοιχεί στο join_by(a == x).\n\nΩστόσο, προτιμούμε το join_by() που υπάρχει πλέον, αφού παρέχει ένα πιο ξεκάθαρο και πιο ευέλικτο τρόπο προσδιορισμού.\nΟι inner_join(), right_join(), και full_join() έχουν την ίδια διεπαφή με τη left_join(). Η διαφορά εντοπίζετε στο ποιες γραμμές διατηρούν: η αριστερή ένωση (left_join()) διατηρεί όλες τις γραμμές από το x, η δεξιά ένωση (right_join()) διατηρεί όλες τις γραμμές από το y, η πλήρης ένωση (full_join()) διατηρεί όλες τις γραμμές, είτε προέρχονται από το x είτε από το y και η εσωτερική ένωση (inner_join()) διατηρεί μόνο τις γραμμές που εμφανίζονται και στο x και στο y. Θα επανέλθουμε σε αυτά με περισσότερες λεπτομέρειες αργότερα.\n\n19.3.3 Ενώσεις φιλτραρίσματος\nΌπως μπορείτε να μαντέψετε, η κύρια ενέργεια μιας filtering ένωσης είναι το φιλτράρισμα των γραμμών Υπάρχουν δύο τύποι: ημι-ενώσεις και αντι-ενώσεις. Οι ημι-ενώσεις (semi-joins) διατηρούν όλες τις σειρές στο x που έχουν αντιστοιχία στο y. Για παράδειγμα, θα μπορούσαμε να χρησιμοποιήσουμε μία ημι-ένωση για να φιλτράρουμε το σύνολο δεδομένων airports για να διατηρήσουμε μόνο τα αεροδρόμια προέλευσης:\n\nairports |&gt; \n  semi_join(flights2, join_by(faa == origin))\n#&gt; # A tibble: 3 × 8\n#&gt;   faa   name                  lat   lon   alt    tz dst   tzone           \n#&gt;   &lt;chr&gt; &lt;chr&gt;               &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;           \n#&gt; 1 EWR   Newark Liberty Intl  40.7 -74.2    18    -5 A     America/New_York\n#&gt; 2 JFK   John F Kennedy Intl  40.6 -73.8    13    -5 A     America/New_York\n#&gt; 3 LGA   La Guardia           40.8 -73.9    22    -5 A     America/New_York\n\nΉ μόνο τους προορισμούς:\n\nairports |&gt; \n  semi_join(flights2, join_by(faa == dest))\n#&gt; # A tibble: 101 × 8\n#&gt;   faa   name                     lat    lon   alt    tz dst   tzone          \n#&gt;   &lt;chr&gt; &lt;chr&gt;                  &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;          \n#&gt; 1 ABQ   Albuquerque Internati…  35.0 -107.   5355    -7 A     America/Denver \n#&gt; 2 ACK   Nantucket Mem           41.3  -70.1    48    -5 A     America/New_Yo…\n#&gt; 3 ALB   Albany Intl             42.7  -73.8   285    -5 A     America/New_Yo…\n#&gt; 4 ANC   Ted Stevens Anchorage…  61.2 -150.    152    -9 A     America/Anchor…\n#&gt; 5 ATL   Hartsfield Jackson At…  33.6  -84.4  1026    -5 A     America/New_Yo…\n#&gt; 6 AUS   Austin Bergstrom Intl   30.2  -97.7   542    -6 A     America/Chicago\n#&gt; # ℹ 95 more rows\n\nΟι αντι-ενώσεις (anti-joins) είναι το αντίθετο: επιστρέφουν όλες τις γραμμές από το x που δεν έχουν αντιστοιχία στο y. Είναι χρήσιμα για την εύρεση κενών τιμών που είναι έμμεσες στα δεδομένα, το θέμα του Ενότητα 18.3. Οι τιμές που λείπουν σιωπηρά δεν εμφανίζονται ως NA αλλά υπάρχουν μόνο ως απουσία. Για παράδειγμα, μπορούμε να βρούμε γραμμές που λείπουν από το airports αναζητώντας πτήσεις που δεν έχουν αντίστοιχο αεροδρόμιο προορισμού:\n\nflights2 |&gt; \n  anti_join(airports, join_by(dest == faa)) |&gt; \n  distinct(dest)\n#&gt; # A tibble: 4 × 1\n#&gt;   dest \n#&gt;   &lt;chr&gt;\n#&gt; 1 BQN  \n#&gt; 2 SJU  \n#&gt; 3 STT  \n#&gt; 4 PSE\n\nΉ μπορούμε να βρούμε ποιες τιμές της μεταβλητής tailnum λείπουν από το planes:\n\nflights2 |&gt;\n  anti_join(planes, join_by(tailnum)) |&gt; \n  distinct(tailnum)\n#&gt; # A tibble: 722 × 1\n#&gt;   tailnum\n#&gt;   &lt;chr&gt;  \n#&gt; 1 N3ALAA \n#&gt; 2 N3DUAA \n#&gt; 3 N542MQ \n#&gt; 4 N730MQ \n#&gt; 5 N9EAMQ \n#&gt; 6 N532UA \n#&gt; # ℹ 716 more rows\n\n\n19.3.4 Ασκήσεις\n\nΕντοπίστε τις 48 ώρες (κατά τη διάρκεια ολόκληρου του έτους) που έχουν τις χειρότερες καθυστερήσεις. Διασταυρώστε το με τα δεδομένα του weather. Μπορείτε να δείτε κάποιο μοτίβο;\n\nΦανταστείτε ότι έχετε βρει τους 10 πιο δημοφιλείς προορισμούς χρησιμοποιώντας αυτόν τον κώδικα:\n\ntop_dest &lt;- flights2 |&gt;\n  count(dest, sort = TRUE) |&gt;\n  head(10)\n\nΠώς μπορείτε να βρείτε όλες τις πτήσεις προς αυτούς τους προορισμούς;\n\nΈχει κάθε πτήση που αναχωρεί αντίστοιχα δεδομένα καιρού για εκείνη την ώρα;\nΤι κοινό έχουν οι αναγνωριστικοί κωδικοί των αεροσκαφών που δεν έχουν αντίστοιχη εγγραφή στο planes; (Υπόδειξη: μία μεταβλητή εξηγεί ~90% των προβλημάτων.)\nΠροσθέστε μία στήλη στο planes που αναφέρει κάθε carrier που έχει χρησιμοποιήσει αυτό το αεροπλάνο. Μπορεί να περιμένετε ότι υπάρχει μία έμμεση σχέση μεταξύ αεροπλάνου και αεροπορικής εταιρείας, επειδή κάθε αεροπλάνο πετά με μία μόνο αεροπορική εταιρεία. Επιβεβαιώστε ή απορρίψτε αυτήν την υπόθεση χρησιμοποιώντας τα εργαλεία που έχετε μάθει σε προηγούμενα κεφάλαια.\nΠροσθέστε το γεωγραφικό πλάτος και μήκος του αεροδρομίου προέλευσης και προορισμού στο πλαίσιο δεδομένων flights. Είναι πιο εύκολο να μετονομάσετε τις στήλες πριν ή αφού κάνετε την ένωση;\n\nΥπολογίστε τη μέση καθυστέρηση ανά προορισμό και, στη συνέχεια, ενώστε την πληροφορία στο airports, ώστε να μπορέσετε να παρουσιάσετε την κατανομή των καθυστερήσεων γεωγραφικά. Ακολουθεί ένας εύκολος τρόπος για να σχεδιάσετε έναν χάρτη των Ηνωμένων Πολιτειών:\n\nairports |&gt;\n  semi_join(flights, join_by(faa == dest)) |&gt;\n  ggplot(aes(x = lon, y = lat)) +\n    borders(\"state\") +\n    geom_point() +\n    coord_quickmap()\n\nΜπορεί να θέλετε να χρησιμοποιήσετε το size ή το color των σημείων για να εμφανίσετε τη μέση καθυστέρηση για κάθε αεροδρόμιο.\n\nΤι συνέβη στις 13 Ιουνίου 2013; Σχεδιάστε έναν χάρτη με τις καθυστερήσεις και, στη συνέχεια, χρησιμοποιήστε το Google για να διασταυρώσετε τα δεδομένα για τον καιρό.",
    "crumbs": [
      "Μετασχηματισμοί",
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>Ενώσεις</span>"
    ]
  },
  {
    "objectID": "joins.html#πώς-λειτουργούν-οι-ενώσεις",
    "href": "joins.html#πώς-λειτουργούν-οι-ενώσεις",
    "title": "19  Ενώσεις",
    "section": "\n19.4 Πώς λειτουργούν οι ενώσεις;",
    "text": "19.4 Πώς λειτουργούν οι ενώσεις;\nΤώρα που έχετε χρησιμοποιήσει ενώσεις κάποιες φορές, ήρθε η ώρα να μάθετε περισσότερα σχετικά με τον τρόπο λειτουργίας τους, εστιάζοντας στο πώς κάθε γραμμή στο x αντιστοιχίζεται με τις γραμμές στο y. Θα ξεκινήσουμε εισάγοντας μία οπτική αναπαράσταση των ενώσεων, χρησιμοποιώντας τα απλά tibbles που ορίζονται παρακάτω και εμφανίζονται στο Σχήμα 19.2. Σε αυτά τα παραδείγματα θα χρησιμοποιήσουμε ένα μόνο κλειδί που ονομάζεται key και μία στήλη με μία τιμή (val_x και val_y), αλλά όλες οι ιδέες που χρησιμοποιούνται εδώ γενικεύονται σε πολλά κλειδιά και πολλαπλές τιμές.\n\nx &lt;- tribble(\n  ~key, ~val_x,\n     1, \"x1\",\n     2, \"x2\",\n     3, \"x3\"\n)\ny &lt;- tribble(\n  ~key, ~val_y,\n     1, \"y1\",\n     2, \"y2\",\n     4, \"y3\"\n)\n\n\n\n\n\n\n\n\nΣχήμα 19.2: Γραφική αναπαράσταση των δύο απλών πινάκων. Οι χρωματισμένες στήλες key αντιστοιχίζουν το χρώμα υποβάθρου στην τιμή του κλειδιού. Οι γκρι στήλες αντιπροσωπεύουν τις στήλες τιμών που μεταφέρονται στην πορεία.\n\n\n\n\nΤο Σχήμα 19.3 εισάγει τη βάση για την οπτική μας αναπαράσταση. Εμφανίζει όλες τις πιθανές αντιστοιχίσεις μεταξύ των x και y ως τομή μεταξύ των γραμμών που σχεδιάζονται από κάθε γραμμή του x και κάθε γραμμής του y. Οι γραμμές και οι στήλες στην έξοδο καθορίζονται κυρίως από το x, επομένως ο πίνακας x είναι οριζόντιος και ευθυγραμμίζεται με την έξοδο.\n\n\n\n\n\n\n\nΣχήμα 19.3: Για να κατανοήσετε πως δουλεύουν οι ενώσεις, είναι χρήσιμο να σκεφτείτε κάθε πιθανό συνδυασμό. Εδώ το δείχνουμε αυτό με ένα πλέγμα συνδεόμενων γραμμών.\n\n\n\n\nΓια να περιγράψουμε έναν συγκεκριμένο τύπο ένωσης, υποδεικνύουμε τις αντιστοιχίσεις με τελείες. Οι αντιστοιχίσεις καθορίζουν τις γραμμές στην έξοδο, ένα νέο πλαίσιο δεδομένων που περιέχει το κλειδί, τις τιμές x και τις τιμές y. Για παράδειγμα, το Σχήμα 19.4 δείχνει μία εσωτερική ένωση, όπου οι γραμμές διατηρούνται εάν και μόνο εάν τα κλειδιά είναι ίσα.\n\n\n\n\n\n\n\nΣχήμα 19.4: Μία εσωτερική ένωση αντιστοιχίζει κάθε γραμμή του x στη γραμμή του y που έχει την ίδια τιμή στο key. Κάθε συνδυασμός γίνεται μια γραμμή στην έξοδο.\n\n\n\n\nΜπορούμε να εφαρμόσουμε τις ίδιες αρχές για να εξηγήσουμε τις εξωτερικές ενώσεις (outer joins), οι οποίες διατηρούν τις παρατηρήσεις που εμφανίζονται σε τουλάχιστον ένα από τα πλαίσια δεδομένων. Αυτές οι ενώσεις λειτουργούν προσθέτοντας μία πρόσθετη “εικονική” παρατήρηση σε κάθε πλαίσιο δεδομένων. Αυτή η παρατήρηση έχει ένα κλειδί που ταιριάζει αν δεν ταιριάζει άλλο κλειδί, και τιμές γεμάτες με NA. Υπάρχουν τρεις τύποι εξωτερικών ενώσεων:\n\n\nΜία αριστερή ένωση (left join) διατηρεί όλες τις παρατηρήσεις του x, Σχήμα 19.5. Κάθε γραμμή του x διατηρείται στην έξοδο, μιας και μπορεί να αντιστοιχιστεί σε μία γραμμή με NA του y.\n\n\n\n\n\n\n\nΣχήμα 19.5: Μία οπτική αναπαράσταση της αριστερής ένωσης όπου κάθε γραμμή του x εμφανίζεται στην έξοδο.\n\n\n\n\n\n\nΜία δεξιά ένωση (right join) διατηρεί όλες τις παρατηρήσεις του y, Σχήμα 19.6. Κάθε γραμμή του y διατηρείται στην έξοδο, επειδή μπορεί να αντιστοιχιστεί σε μία γραμμή με NA του x. Η έξοδος εξακολουθεί να ταιριάζει με το x όσο το δυνατόν περισσότερο, ενώ τυχόν επιπλέον σειρές από το y προστίθενται στο τέλος.\n\n\n\n\n\n\n\nΣχήμα 19.6: Μία οπτική αναπαράσταση της δεξιάς ένωσης όπου κάθε γραμμή του y εμφανίζεται στην έξοδο.\n\n\n\n\n\n\nΜία πλήρης ένωση (full join) διατηρεί όλες τις παρατηρήσεις που εμφανίζονται είτε στο x είτε στο y, Σχήμα 19.7. Κάθε γραμμή των x και y περιλαμβάνεται στην έξοδο επειδή και τα x και y περιλαμβάνουν μία εναλλακτική γραμμή με NA. Και πάλι, η έξοδος ξεκινά με όλες τις γραμμές από το x, ακολουθούμενες από τις υπόλοιπες γραμμές του y που δεν αντιστοιχίστηκαν σε συγκεκριμένη γραμμή του x.\n\n\n\n\n\n\n\nΣχήμα 19.7: Μία οπτική αναπαράσταση της πλήρους ένωσης όπου κάθε γραμμή τουx και του y εμφανίζεται στην έξοδο.\n\n\n\n\n\n\nΈνας άλλος τρόπος για να δείξετε τις διαφορές ανάμεσα στους διάφορους τύπους της εξωτερικής ένωσης είναι με ένα διάγραμμα Venn, όπως στο Σχήμα 19.8. Ωστόσο, αυτή δεν είναι μία καλή αναπαράσταση, επειδή, ενώ μπορεί να φρεσκάρει τη μνήμη σας σχετικά με το ποιες γραμμές διατηρούνται, αποτυγχάνει όμως να επεξηγήσει τι συμβαίνει με τις στήλες.\n\n\n\n\n\n\n\nΣχήμα 19.8: Διαγάμματα Venn που δείχνουν τη διαφορά ανάμεσα σε εσωτερικές, αριστερές, δεξιές και πλήρεις ενώσεις.\n\n\n\n\nΟι ενώσεις που φαίνονται εδώ είναι οι λεγόμενες equi ενωσεις (ενώσεις ισοτιμίας), όπου οι γραμμές αντιστοιχίζονται εάν τα κλειδιά είναι ίσα. Οι ενώσεις ισοτιμίας είναι ο πιο συνηθισμένος τύπος ένωσης, επομένως συνήθως παραλείπουμε το πρόθεμα equi και απλώς λέμε “inner join” αντί για “equi inner join”. Θα επανέλθουμε στις non-equi ενώσεις στην Ενότητα 19.5.\n\n19.4.1 Αντιστοίχιση γραμμών\nΜέχρι στιγμής έχουμε εξερευνήσει τι συμβαίνει εάν μία γραμμή από το x ταιριάζει με μία ή καμμία γραμμή στο y. Τι συμβαίνει όμως αν ταιριάζει με περισσότερες από μία γραμμές; Για να κατανοήσουμε τι συμβαίνει, ας εστιάσουμε την προσοχή μας στο inner_join() και ας σχεδιάσουμε μία εικόνα, Σχήμα 19.9.\n\n\n\n\n\n\n\nΣχήμα 19.9: Οι τρεις τρόποι με τους οποίους μπορεί να αντιστοιχιστεί μια γραμμή στο x. Το x1 αντιστοιχεί σε μία γραμμή στο y, το x2 αντιστοιχεί σε δύο γραμμές στο y, το x3 δεν αντιστοιχεί σε καμία γραμμή στο y. Σημειώστε ότι ενώ υπάρχουν τρεις γραμμές στο x και τρεις γραμμές στην έξοδο, δεν υπάρχει άμεση αντιστοιχία μεταξύ των γραμμών.\n\n\n\n\nΥπάρχουν τρία πιθανά αποτελέσματα για μία γραμμή στο x:\n\nΑν δεν ταιριάζει με τίποτα, απορρίπτεται.\nΕάν ταιριάζει με 1 γραμμή στο y, διατηρείται.\nΕάν αντιστοιχεί σε περισσότερες από 1 γραμμές στο y, γίνεται διπλότυπη μία φορά για κάθε αντιστοίχιση\n\nΚατ’ αρχήν, αυτό σημαίνει ότι δεν υπάρχει εγγυημένη αντιστοιχία μεταξύ των γραμμών στην έξοδο και των γραμμών στο x, αλλά πρακτικά, αυτό σπάνια προκαλεί προβλήματα. Υπάρχει, ωστόσο, μία ιδιαίτερα επικίνδυνη περίπτωση που μπορεί να προκαλέσει μία συνδυαστική έκρηξη γραμμών. Φανταστείτε ότι ενώνετε τους παρακάτω δύο πίνακες:\n\ndf1 &lt;- tibble(key = c(1, 2, 2), val_x = c(\"x1\", \"x2\", \"x3\"))\ndf2 &lt;- tibble(key = c(1, 2, 2), val_y = c(\"y1\", \"y2\", \"y3\"))\n\nΕνώ η πρώτη γραμμή του df1 αντιστοιχίζεται με μία μόνο γραμμή του df2, η δεύτερη και η τρίτη γραμμή αντιστοιχίζονται με από δύο γραμμές η καθεμία. Αυτό μπορεί να το συναντήσετε ως ένωση πολλά-με-πολλά, και θα έχει ως αποτέλεσμα το πακέτο dplyr να επιστρέψει μία προειδοποίηση:\n\ndf1 |&gt; \n  inner_join(df2, join_by(key))\n#&gt; Warning in inner_join(df1, df2, join_by(key)): Detected an unexpected many-to-many relationship between `x` and `y`.\n#&gt; ℹ Row 2 of `x` matches multiple rows in `y`.\n#&gt; ℹ Row 2 of `y` matches multiple rows in `x`.\n#&gt; ℹ If a many-to-many relationship is expected, set `relationship =\n#&gt;   \"many-to-many\"` to silence this warning.\n#&gt; # A tibble: 5 × 3\n#&gt;     key val_x val_y\n#&gt;   &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;\n#&gt; 1     1 x1    y1   \n#&gt; 2     2 x2    y2   \n#&gt; 3     2 x2    y3   \n#&gt; 4     2 x3    y2   \n#&gt; 5     2 x3    y3\n\nΕάν το κάνετε αυτό σκόπιμα, μπορείτε να ορίσετε relationship = \"many-to-many\",, όπως προτείνει η προειδοποίηση.\n\n19.4.2 Ενώσεις φιλτραρίσματος\nΟ αριθμός των αντιστοιχιών καθορίζει επίσης τη συμπεριφορά των ενώσεων φιλτραρίσματος. Η ημι-ένωση (semi-join) διατηρεί γραμμές στο x που έχουν μία ή περισσότερες αντιστοιχίσεις στο y, όπως στο Σχήμα 19.10. Η αντι-ένωση (anti-join) διατηρεί γραμμές στο x που δεν ταιριάζουν με καμία γραμμή στο y, όπως στο Σχήμα 19.11. Και στις δύο περιπτώσεις, μόνο η ύπαρξη μιας αντιστοίχισης είναι σημαντική, και όχι το πλήθος των αντιστοιχίσεων. Αυτό σημαίνει ότι οι ενώσεις φιλτραρίσματος δεν δημιουργούν ποτέ διπλότυπες γραμμές όπως κάνουν οι ενώσεις αλλαγής.\n\n\n\n\n\n\n\nΣχήμα 19.10: Σε μια ημι-ένωση το μόνο που έχει σημασία είναι να υπάρχει μια αντιστοίχιση, διαφορετικά οι τιμές στο πλαίσιο δεδομένων y δεν επηρεάζουν την έξοδο.\n\n\n\n\n\n\n\n\n\n\n\nΣχήμα 19.11: Μία αντι-ένωση είναι το αντίστροφο μιας ημι-ένωσης, αφαιρώντας γραμμές από το x που αντιστοιχίζονται με το y.",
    "crumbs": [
      "Μετασχηματισμοί",
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>Ενώσεις</span>"
    ]
  },
  {
    "objectID": "joins.html#sec-non-equi-joins",
    "href": "joins.html#sec-non-equi-joins",
    "title": "19  Ενώσεις",
    "section": "\n19.5 Non-equi ενώσεις",
    "text": "19.5 Non-equi ενώσεις\nΜέχρι στιγμής έχετε δει μόνο ενώσεις ισοτιμίας, ενώσεις όπου οι γραμμές ταιριάζουν εάν το κλειδί του x ισούται με το κλειδί στο y. Τώρα θα χαλαρώσουμε αυτόν τον περιορισμό και θα συζητήσουμε άλλους τρόπους για να προσδιορίσουμε εάν ένα ζευγάρι γραμμών ταιριάζει.\nΑλλά προτού μπορέσουμε να το κάνουμε αυτό, πρέπει να επανεξετάσουμε μία απλοποίηση που κάναμε παραπάνω. Σε ισότιμες ενώσεις (equi joins) τα κλειδιά των x και y είναι πάντα ίσα, οπότε αρκεί να εμφανίσουμε μόνο ένα στην έξοδο. Μπορούμε να ζητήσουμε από το πακέτο dplyr να διατηρήσει και τα δύο κλειδιά με το όρισμα keep = TRUE, οδηγώντας στον παρακάτω κώδικα και στο επανασχεδιασμένο inner_join() στο Σχήμα 19.12.\n\nx |&gt; inner_join(y, join_by(key == key), keep = TRUE)\n#&gt; # A tibble: 2 × 4\n#&gt;   key.x val_x key.y val_y\n#&gt;   &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt;\n#&gt; 1     1 x1        1 y1   \n#&gt; 2     2 x2        2 y2\n\n\n\n\n\n\n\n\nΣχήμα 19.12: Μία εσωτερική ένωση που δείνει τα κλειδιά των x και y στην έξοδο.\n\n\n\n\nΌταν απομακρυνόμαστε από τις equi ενώσεις, θα εμφανίζουμε πάντα τα κλειδιά, επειδή οι τιμές των κλειδιών συχνά θα είναι διαφορετικές. Για παράδειγμα, αντί να κάνουμε την αντιστοίχιση μόνο όταν το x$key και το y$key είναι ίσα, θα μπορούσαμε να κάνουμε την αντιστοίχιση κάθε φορά που το x$key είναι μεγαλύτερο ή ίσο με το y$key, που οδηγεί στο Σχήμα 19.13. Οι συναρτήσεις ένωσης της dplyr κατανοούν αυτή τη διάκριση ανάμεσα σε ισοδύναμες και μη ισοδύναμες ενώσεις, επομένως θα εμφανίζουν πάντα και τα δύο κλειδιά όταν εκτελείτε μία ένωση χωρίς ισοδυναμία.\n\n\n\n\n\n\n\nΣχήμα 19.13: Μία non-equi ένωση, όπου το κλειδί του x πρέπει να είναι μεγαλύτερο ή ίσο του κλειδιού του y. Πολλές γραμμές δημιουργούν πολλαπλές αντιστοιχίσεις.\n\n\n\n\nΟ όρος “non-equi” ενώσεις δεν είναι ιδιαίτερα χρήσιμος, επειδή μας λέει μόνο τι δεν είναι η ένωση, όχι τι είναι. Η dplyr βοηθά προσδιορίζοντας τέσσερις ιδιαίτερα χρήσιμους τύπους non-equi join:\n\nΟι διασταυρούμενες ενώσεις (Cross joins) αντιστοιχίζουν κάθε ζεύγος γραμμών\nΟι ενώσεις ανισότητας (Inequality joins) χρησιμοποιούν τα &lt;, &lt;=, &gt;, και &gt;= αντί του ==.\nΟι κυλιόμενες ενώσεις (Rolling joins) είναι παρόμοιες με τις ενώσεις ανισότητας αλλά βρίσκουν μόνο την πλησιέστερη αντιστοιχία.\nΟι ενώσεις επικάλυψης (Overlap joins) είναι ένας ειδικός τύπος ένωσης ανισότητας που έχει σχεδιαστεί για να λειτουργεί με εύρη.\n\nΚάθε μία από αυτές περιγράφεται λεπτομερέστερα στις επόμενες ενότητες.\n\n19.5.1 Διασταυρούμενες ενώσεις\nΜία διασταυρούμενη ένωση ταιριάζει με τα πάντα, όπως στο Σχήμα 19.14, δημιουργώντας το καρτεσιανό γινόμενο των γραμμών. Αυτό σημαίνει ότι η έξοδος θα έχει nrow(x) * nrow(y) γραμμές.\n\n\n\n\n\n\n\nΣχήμα 19.14: Μία διασταυρούμενη ένωησ αντιστοιχίζει κάθε γραμμή του x με κάθε γραμμή του y.\n\n\n\n\nΟι διασταυρούμενες ενώσεις είναι χρήσιμες κατά τη δημιουργία συνδυασμών. Για παράδειγμα, ο παρακάτω κώδικας δημιουργεί κάθε πιθανό ζεύγος ονομάτων. Εφόσον ενώνουμε το df με τον εαυτό του, αυτό μερικές φορές ονομάζεται αυτο-ένωση (self-join). Οι διασταυρούμενες ενώσεις χρησιμοποιούν διαφορετική συνάρτηση ένωσης επειδή δεν υπάρχει διάκριση μεταξύ εσωτερικές/αριστερές/δεξιές/πλήρεις ενώσεις όταν η αντιστοίχιση αφορά κάθε γραμμή.\n\ndf &lt;- tibble(name = c(\"John\", \"Simon\", \"Tracy\", \"Max\"))\ndf |&gt; cross_join(df)\n#&gt; # A tibble: 16 × 2\n#&gt;   name.x name.y\n#&gt;   &lt;chr&gt;  &lt;chr&gt; \n#&gt; 1 John   John  \n#&gt; 2 John   Simon \n#&gt; 3 John   Tracy \n#&gt; 4 John   Max   \n#&gt; 5 Simon  John  \n#&gt; 6 Simon  Simon \n#&gt; # ℹ 10 more rows\n\n\n19.5.2 Ενώσεις ανισότητας\nΟι ενώσεις ανισότητας χρησιμοποιούν τους τελεστές &lt;, &lt;=, &gt;=, ή &gt; για να περιορίσουν το σύνολο των πιθανών αντιστοιχίσεων, όπως στο Σχήμα 19.13 και το Σχήμα 19.15.\n\n\n\n\n\n\n\nΣχήμα 19.15: Μία ένωση ανισότητας όπου το x ενώνεται με το y στις γραμμές όπου το κλειδί του x είναι μικρότερο από το κλειδί του y. Αυτό δημιουργεί ένα τριγωνικό σχήμα στην πάρω αριστερή γωνία.\n\n\n\n\nΟι ενώσεις ανισότητας είναι εξαιρετικά γενικές, τόσο γενικές που είναι δύσκολο να βρούμε ουσιαστικές συγκεκριμένες περιπτώσεις χρήσης. Μία μικρή χρήσιμη τεχνική είναι να τις χρησιμοποιούμε για να περιορίσουμε τη διασταυρούμενη ένωση έτσι ώστε αντί να δημιουργούμε όλες τις μεταθέσεις, να δημιουργούμε όλους τους συνδυασμούς:\n\ndf &lt;- tibble(id = 1:4, name = c(\"John\", \"Simon\", \"Tracy\", \"Max\"))\n\ndf |&gt; inner_join(df, join_by(id &lt; id))\n#&gt; # A tibble: 6 × 4\n#&gt;    id.x name.x  id.y name.y\n#&gt;   &lt;int&gt; &lt;chr&gt;  &lt;int&gt; &lt;chr&gt; \n#&gt; 1     1 John       2 Simon \n#&gt; 2     1 John       3 Tracy \n#&gt; 3     1 John       4 Max   \n#&gt; 4     2 Simon      3 Tracy \n#&gt; 5     2 Simon      4 Max   \n#&gt; 6     3 Tracy      4 Max\n\n\n19.5.3 Κυλιόμενες ενώσεις\nΟι κυλιόμενες ενώσεις είναι ένας ειδικός τύπος ένωσης ανισότητας όπου αντί να λαμβάνουμε κάθε γραμμή που ικανοποιεί την ανισότητα, παίρνουμε μόνο την πλησιέστερη γραμμή, όπως στο Σχήμα 19.16. Μπορείτε να μετατρέψετε οποιαδήποτε ένωση ανισότητας σε κυλιόμενη ένωση προσθέτοντας το όρισμα closest(). Για παράδειγμα, το join_by(closest(x &lt;= y)) αντιστοιχεί στο μικρότερο y που είναι μεγαλύτερο ή ίσο με το x και το join_by(closest(x &gt; y)) αντιστοιχεί στο μεγαλύτερο y που είναι μικρότερο από το x.\n\n\n\n\n\n\n\nΣχήμα 19.16: Μία κυλιώμενη ένωση είναι παρόμοια με μία μεγαλύτερο-από-ή-ίσο ένωση ανισότητας, αλλά αντιστοιχίζει μόνο την πρώτη τιμή.\n\n\n\n\nΟι κυλιόμενες ενώσεις είναι ιδιαίτερα χρήσιμες όταν έχετε δύο πίνακες ημερομηνιών που δεν ευθυγραμμίζονται τέλεια και θέλετε να βρείτε (για παράδειγμα) την πλησιέστερη ημερομηνία στον πίνακα 1 που είναι πριν (ή μετά) κάποια ημερομηνία στον πίνακα 2.\nΓια παράδειγμα, φανταστείτε ότι είστε υπεύθυνος της επιτροπής σχεδιασμού εορτασμών για το γραφείο σας. Η εταιρεία σας θέλει να μην ξοδέψει πολλά χρήματα, επομένως αντί να κάνετε μεμονωμένα πάρτι, θα κάνετε ένα πάρτι μόνο, μία φορά το τρίμηνο. Οι κανόνες για τον καθορισμό του πότε θα γίνει ένα πάρτι είναι λίγο περίπλοκοι: τα πάρτι γίνονται πάντα Δευτέρα, παραλείπετε την πρώτη εβδομάδα του Ιανουαρίου, καθώς πολλοί είναι σε διακοπές, ενώ και η πρώτη Δευτέρα του τρίτου τριμήνου 2022 είναι στις 4 Ιουλίου, οπότε και σε αυτή την περίπτωση η ημερομηνία του πάρτι θα πρέπει να μεταφερθεί κατά μία εβδομάδα αργότερα. Αυτό οδηγεί στις ακόλουθες διαθέσιμες ημέρες για τα πάρτι:\n\nparties &lt;- tibble(\n  q = 1:4,\n  party = ymd(c(\"2022-01-10\", \"2022-04-04\", \"2022-07-11\", \"2022-10-03\"))\n)\n\nΤώρα φανταστείτε ότι έχετε έναν πίνακα με τα γενέθλια των εργαζομένων:\n\nset.seed(123)\nemployees &lt;- tibble(\n  name = sample(babynames::babynames$name, 100),\n  birthday = ymd(\"2022-01-01\") + (sample(365, 100, replace = TRUE) - 1)\n)\nemployees\n#&gt; # A tibble: 100 × 2\n#&gt;   name     birthday  \n#&gt;   &lt;chr&gt;    &lt;date&gt;    \n#&gt; 1 Kemba    2022-01-22\n#&gt; 2 Orean    2022-06-26\n#&gt; 3 Kirstyn  2022-02-11\n#&gt; 4 Amparo   2022-11-11\n#&gt; 5 Belen    2022-03-25\n#&gt; 6 Rayshaun 2022-01-11\n#&gt; # ℹ 94 more rows\n\nΚαι για κάθε εργαζόμενο θέλουμε να βρούμε τη πρώτη διαθέσιμη ημερομηνία για πάρτι που έρχεται μετά (ή πάνω στα) γενέθλιά του. Μπορούμε να το εκφράσουμε με μία κυλιόμενη ένωση:\n\nemployees |&gt; \n  left_join(parties, join_by(closest(birthday &gt;= party)))\n#&gt; # A tibble: 100 × 4\n#&gt;   name     birthday       q party     \n#&gt;   &lt;chr&gt;    &lt;date&gt;     &lt;int&gt; &lt;date&gt;    \n#&gt; 1 Kemba    2022-01-22     1 2022-01-10\n#&gt; 2 Orean    2022-06-26     2 2022-04-04\n#&gt; 3 Kirstyn  2022-02-11     1 2022-01-10\n#&gt; 4 Amparo   2022-11-11     4 2022-10-03\n#&gt; 5 Belen    2022-03-25     1 2022-01-10\n#&gt; 6 Rayshaun 2022-01-11     1 2022-01-10\n#&gt; # ℹ 94 more rows\n\nΥπάρχει, ωστόσο, ένα πρόβλημα με αυτήν την προσέγγιση: οι άνθρωποι με γενέθλια πριν από τις 10 Ιανουαρίου δεν κάνουν πάρτι:\n\nemployees |&gt; \n  anti_join(parties, join_by(closest(birthday &gt;= party)))\n#&gt; # A tibble: 2 × 2\n#&gt;   name   birthday  \n#&gt;   &lt;chr&gt;  &lt;date&gt;    \n#&gt; 1 Maks   2022-01-07\n#&gt; 2 Nalani 2022-01-04\n\nΓια να το λύσουμε αυτό, θα χρειαστεί να αντιμετωπίσουμε το πρόβλημα με διαφορετικό τρόπο, χρησιμοποιώντας ενώσεις επικάλυψης.\n\n19.5.4 Ενώσεις επικάλυψης\nΟι ενώσεις επικάλυψης παρέχουν τρεις βοηθητικές συναρτήσεις που χρησιμοποιούν ενώσεις ανισότητας για να διευκολύνουν την εργασία με διαστήματα:\n\nΗ between(x, y_lower, y_upper) είναι η συντομογραφία του x &gt;= y_lower, x &lt;= y_upper.\nΗ within(x_lower, x_upper, y_lower, y_upper) είναι η συντομογραφία του x_lower &gt;= y_lower, x_upper &lt;= y_upper.\nΗ overlaps(x_lower, x_upper, y_lower, y_upper) είναι η συντομογραφία του x_lower &lt;= y_upper, x_upper &gt;= y_lower.\n\nΑς συνεχίσουμε με το παράδειγμα γενεθλίων για να δούμε πώς μπορείτε να τα χρησιμοποιήσετε. Υπάρχει ένα πρόβλημα με τη στρατηγική που χρησιμοποιήσαμε παραπάνω: δεν υπάρχει πάρτι που να προηγείται των γενεθλίων που είναι μεταξύ 1-9 Ιανουαρίου. Επομένως, ίσως είναι καλύτερο να είμαστε σαφείς σχετικά με το εύρος ημερομηνιών που καλύπτει κάθε πάρτι και να κάνουμε μία ειδική περίπτωση για αυτά τα πρώιμα γενέθλια:\n\nparties &lt;- tibble(\n  q = 1:4,\n  party = ymd(c(\"2022-01-10\", \"2022-04-04\", \"2022-07-11\", \"2022-10-03\")),\n  start = ymd(c(\"2022-01-01\", \"2022-04-04\", \"2022-07-11\", \"2022-10-03\")),\n  end = ymd(c(\"2022-04-03\", \"2022-07-11\", \"2022-10-02\", \"2022-12-31\"))\n)\nparties\n#&gt; # A tibble: 4 × 4\n#&gt;       q party      start      end       \n#&gt;   &lt;int&gt; &lt;date&gt;     &lt;date&gt;     &lt;date&gt;    \n#&gt; 1     1 2022-01-10 2022-01-01 2022-04-03\n#&gt; 2     2 2022-04-04 2022-04-04 2022-07-11\n#&gt; 3     3 2022-07-11 2022-07-11 2022-10-02\n#&gt; 4     4 2022-10-03 2022-10-03 2022-12-31\n\nΟ Hadley είναι απελπιστικά κακός στην εισαγωγή δεδομένων, έτσι ήθελε επίσης να ελέγξει ότι οι περίοδοι που οργανώνονται τα πάρτι δεν αλληλεπικαλύπτονται. Ένας τρόπος για να το κάνετε αυτό είναι χρησιμοποιώντας μία αυτο-ένωση για να ελέγξετε εάν κάποιο διάστημα έναρξης-λήξης επικαλύπτεται με κάποιο άλλο:\n\nparties |&gt; \n  inner_join(parties, join_by(overlaps(start, end, start, end), q &lt; q)) |&gt; \n  select(start.x, end.x, start.y, end.y)\n#&gt; # A tibble: 1 × 4\n#&gt;   start.x    end.x      start.y    end.y     \n#&gt;   &lt;date&gt;     &lt;date&gt;     &lt;date&gt;     &lt;date&gt;    \n#&gt; 1 2022-04-04 2022-07-11 2022-07-11 2022-10-02\n\nΥπάρχει μία επικάλυψη, οπότε ας διορθώσουμε αυτό το πρόβλημα και ας συνεχίσουμε:\n\nparties &lt;- tibble(\n  q = 1:4,\n  party = ymd(c(\"2022-01-10\", \"2022-04-04\", \"2022-07-11\", \"2022-10-03\")),\n  start = ymd(c(\"2022-01-01\", \"2022-04-04\", \"2022-07-11\", \"2022-10-03\")),\n  end = ymd(c(\"2022-04-03\", \"2022-07-10\", \"2022-10-02\", \"2022-12-31\"))\n)\n\nΤώρα μπορούμε να ταιριάξουμε κάθε εργαζόμενο με το πάρτι του. Αυτό είναι ένα καλό παράδειγμα για να χρησιμοποιήσετε το όρισμα unmatched = \"error\", επειδή θέλουμε να μάθουμε γρήγορα εάν σε κάποιους υπαλλήλους δεν ανατέθηκε πάρτι.\n\nemployees |&gt; \n  inner_join(parties, join_by(between(birthday, start, end)), unmatched = \"error\")\n#&gt; # A tibble: 100 × 6\n#&gt;   name     birthday       q party      start      end       \n#&gt;   &lt;chr&gt;    &lt;date&gt;     &lt;int&gt; &lt;date&gt;     &lt;date&gt;     &lt;date&gt;    \n#&gt; 1 Kemba    2022-01-22     1 2022-01-10 2022-01-01 2022-04-03\n#&gt; 2 Orean    2022-06-26     2 2022-04-04 2022-04-04 2022-07-10\n#&gt; 3 Kirstyn  2022-02-11     1 2022-01-10 2022-01-01 2022-04-03\n#&gt; 4 Amparo   2022-11-11     4 2022-10-03 2022-10-03 2022-12-31\n#&gt; 5 Belen    2022-03-25     1 2022-01-10 2022-01-01 2022-04-03\n#&gt; 6 Rayshaun 2022-01-11     1 2022-01-10 2022-01-01 2022-04-03\n#&gt; # ℹ 94 more rows\n\n\n19.5.5 Ασκήσεις\n\n\nΜπορείτε να εξηγήσετε τι συμβαίνει με τα κλειδιά σε αυτή την ένωση ισοδυναμίας; Γιατί είναι διαφορετικά;\n\nx |&gt; full_join(y, join_by(key == key))\n#&gt; # A tibble: 4 × 3\n#&gt;     key val_x val_y\n#&gt;   &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;\n#&gt; 1     1 x1    y1   \n#&gt; 2     2 x2    y2   \n#&gt; 3     3 x3    &lt;NA&gt; \n#&gt; 4     4 &lt;NA&gt;  y3\n\nx |&gt; full_join(y, join_by(key == key), keep = TRUE)\n#&gt; # A tibble: 4 × 4\n#&gt;   key.x val_x key.y val_y\n#&gt;   &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt;\n#&gt; 1     1 x1        1 y1   \n#&gt; 2     2 x2        2 y2   \n#&gt; 3     3 x3       NA &lt;NA&gt; \n#&gt; 4    NA &lt;NA&gt;      4 y3\n\n\nΓια να βρούμε εάν οι περίοδοι των πάρτι επικαλύπτονται με άλλα πάρτι χρησιμοποιήσαμε το q &lt; q στην join_by(). Γιατί; Τι συμβαίνει εάν αφαιρέσουμε αυτή την ανισότητα;",
    "crumbs": [
      "Μετασχηματισμοί",
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>Ενώσεις</span>"
    ]
  },
  {
    "objectID": "joins.html#σύνοψη",
    "href": "joins.html#σύνοψη",
    "title": "19  Ενώσεις",
    "section": "\n19.6 Σύνοψη",
    "text": "19.6 Σύνοψη\nΣε αυτό το κεφάλαιο, μάθατε πώς να χρησιμοποιείτε ενώσεις αλλαγής και ενώσεις φιλτραρίσματος για να συνδυάσετε δεδομένα από ένα ζεύγος πλαισίων δεδομένων. Στην πορεία μάθατε πώς να αναγνωρίζετε κλειδιά και τη διαφορά μεταξύ πρωτεύοντος και ξένου κλειδιού. Καταλαβαίνετε επίσης πώς λειτουργούν οι ενώσεις και πώς να υπολογίσετε πόσες γραμμές θα έχει η έξοδος. Τέλος, ρίξατε μία ματιά στη δύναμη των non-equi ενώσεων και έχετε δει μερικές ενδιαφέρουσες περιπτώσεις χρήσης.\nΑυτό το κεφάλαιο ολοκληρώνει το μέρος “Μετασχηματισμός” αυτού του βιβλίου, όπου η το ενδιαφέρον μας ήταν στα εργαλεία που θα μπορούσατε να χρησιμοποιήσετε με μεμονωμένες στήλες και tibbles. Μάθατε για συναρτήσεις από το πακέτο dplyr και από το βασικό σύνολο συναρτήσεων της R για εργασία με λογικά διανύσματα, αριθμούς και πλήρεις πίνακες, τις συναρτήσεις του πακέτου stringr για εργασία με συμβολοσειρές, τις συναρτήσεις του πακέτου lubridate για εργασία με ημερομηνίες-ώρες και τις συναρτήσεις του forcats για εργασία με παράγοντες.\nΣτο επόμενο μέρος του βιβλίου, θα μάθετε περισσότερα σχετικά με τη μετατροπή διαφόρων τύπων δεδομένων στην R σε μία τακτοποιημένη (tidy) μορφή.",
    "crumbs": [
      "Μετασχηματισμοί",
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>Ενώσεις</span>"
    ]
  },
  {
    "objectID": "joins.html#footnotes",
    "href": "joins.html#footnotes",
    "title": "19  Ενώσεις",
    "section": "",
    "text": "Να θυμάστε ότι στο RStudio μπορείτε επίσης να χρησιμοποιήσετε το View() για να αποφύγετε αυτό το πρόβλημα.↩︎\nΑυτό δεν είναι 100% αλήθεια, αλλά θα λαμβάνετε μία προειδοποίηση όποτε δεν είναι.↩︎",
    "crumbs": [
      "Μετασχηματισμοί",
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>Ενώσεις</span>"
    ]
  },
  {
    "objectID": "import.html",
    "href": "import.html",
    "title": "Εισαγωγή δεδομένων",
    "section": "",
    "text": "Σε αυτό το σημείο του βιβλίου, θα μάθετε πώς να εισάγετε διαφορετικούς τύπους δεδομένων στην R, καθώς και πώς να τα μετατρέψετε σε μία μορφή χρήσιμη για ανάλυση. Μερικές φορές χρειάζεται απλά η κλήση μιας συνάρτησης από το κατάλληλο πακέτο εισαγωγής δεδομένων. Σε πιο περίπλοκες περιπτώσεις όμως, μπορεί να χρειαστεί τόσο η τακτοποίηση όσο και ο μετασχηματισμός, για να καταλήξετε στη τακτοποιημένη μορφή πίνακα με την οποία θα προτιμούσατε να εργαστείτε.\n\n\n\n\n\n\n\nΣχήμα 1: Η εισαγωγή δεδομένων είναι η αρχή της διαδικασίας της επιστήμης των δεδομένων. Χωρίς δεδομένα δεν μπορείτε να εφαρμόσετε την επιστήμη των δεδομένων!\n\n\n\n\nΣε αυτό το σημείο του βιβλίου θα μάθετε πώς να αποκτήσετε πρόσβαση σε δεδομένα που είναι αποθηκευμένα με τους ακόλουθους τρόπους:\n\nΣτο 20  Υπολογιστικά φύλλα, θα μάθετε πώς να εισάγετε δεδομένα από Excel και Google Sheets.\nΣτο 21  Βάσεις Δεδομένων, θα μάθετε πώς να εξάγετε δεδομένα από μία βάση δεδομένων και να τα εισάγετε στην R (θα μάθετε επίσης και μερικά πράγματα για το πώς να μεταφέρετε δεδομένα από την R σε μία βάση δεδομένων).\nΣτο 22  Arrow, θα μάθετε για το Arrow, ένα ισχυρό εργαλείο για να δουλεύετε με δεδομένα που δεν χωράνε στη μνήμη, ιδιαίτερα όταν είναι αποθηκευμένα σε μορφή parquet.\nΣτο 23  Ιεραρχικά δεδομένα, θα μάθετε πώς να εργάζεστε με ιεραρχικά δεδομένα, συμπεριλαμβανομένων των πολυεπίπεδων λιστών που παράγονται από δεδομένα που είναι αποθηκευμένα σε μορφή JSON.\nΣτο 24  Ιστοσυγκομιδή, θα μάθετε την ιστοσυγκομιδή (web “scraping”), την τέχνη και επιστήμη της εξαγωγής δεδομένων από ιστοσελίδες.\n\nΥπάρχουν δύο σημαντικά πακέτα του tidyverse που δεν συζητάμε εδώ: το haven και το xml2. Εάν εργάζεστε με δεδομένα από αρχεία SPSS, Stata και SAS, ρίξτε μία ματιά στο πακέτο haven, https://haven.tidyverse.org. Εάν εργάζεστε με δεδομένα XML, ρίξτε μία ματιά στο πακέτο xml2, https://xml2.r-lib.org. Διαφορετικά, θα χρειαστεί να κάνετε λίγη έρευνα για να καταλάβετε ποιο πακέτο θα χρειαστεί να χρησιμοποιήσετε κάθε φορά. Το Google, σε αυτή την περίπτωση, είναι φίλος σας 😃.",
    "crumbs": [
      "Εισαγωγή δεδομένων"
    ]
  },
  {
    "objectID": "spreadsheets.html",
    "href": "spreadsheets.html",
    "title": "20  Υπολογιστικά φύλλα",
    "section": "",
    "text": "20.1 Εισαγωγή\nΣτο Κεφάλαιο 7 μάθατε για την εισαγωγή δεδομένων από αρχεία απλού κειμένου, όπως .csv και .tsv. Τώρα ήρθε η ώρα να μάθετε πώς να εξάγετε δεδομένα από ένα υπολογιστικό φύλλο, είτε από Excel, είτε από Google Sheet. Θα βασιστούμε σε πολλά από αυτά που έχετε μάθει στο Κεφάλαιο 7, θα συζητήσουμε όμως πρόσθετες οπτικές και δυσκολίες κατά την εργασία σας με δεδομένα από υπολογιστικά φύλλα.\nΕάν εσείς ή οι συνεργάτες σας χρησιμοποιείτε υπολογιστικά φύλλα για την οργάνωση δεδομένων, συνιστούμε ανεπιφύλακτα να διαβάσετε τη δημοσίευση “Data Organization in Spreadsheets” των Karl Broman και Kara Woo: https://doi.org/10.1080/00031305.2017.1375989. Οι βέλτιστες πρακτικές που παρουσιάζονται θα σας γλυτώσουν από αρκετούς πονοκεφάλους καθώς εισάγετε δεδομένα από ένα υπολογιστικό φύλλο στην R για αναλύσετε και να οπτικοποιήσετε.",
    "crumbs": [
      "Εισαγωγή δεδομένων",
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>Υπολογιστικά φύλλα</span>"
    ]
  },
  {
    "objectID": "spreadsheets.html#excel",
    "href": "spreadsheets.html#excel",
    "title": "20  Υπολογιστικά φύλλα",
    "section": "\n20.2 Excel",
    "text": "20.2 Excel\nΤο Microsoft Excel είναι ένα ευρέως χρησιμοποιούμενο πρόγραμμα λογισμικού υπολογιστικών φύλλων, όπου τα δεδομένα οργανώνονται σε φύλλα εργασίας μέσα σε αρχεία υπολογιστικών φύλλων.\n\n20.2.1 Προαπαιτούμενα\nΣε αυτήν την ενότητα, θα μάθετε πώς να φορτώνετε δεδομένα από υπολογιστικά φύλλα Excel στην R με το πακέτο readxl. Αυτό το πακέτο δεν είναι βασικό στο tidyverse, επομένως πρέπει να το φορτώσετε ξεχωριστά. Εγκαθίσταται όμως αυτόματα όταν εγκαθιστάτε το tidyverse. Αργότερα, θα χρησιμοποιήσουμε επίσης το πακέτο writexl, το οποίο μας επιτρέπει να δημιουργήσουμε υπολογιστικά φύλλα Excel.\n\nlibrary(readxl)\nlibrary(tidyverse)\nlibrary(writexl)\n\n\n20.2.2 Ξεκινώντας\nΟι περισσότερες από τις λειτουργίες του πακέτου readxl σας επιτρέπουν να φορτώνετε υπολογιστικά φύλλα Excel στην R:\n\nΗ read_xls() διαβάζει αρχεία Excel με μορφή xls.\nΗ read_xlsx() διαβάζει αρχεία Excel με μορφή xlsx.\nΗ read_excel() μπορεί να διαβάζει αρχεία τόσο με τη μορφή xls αλλά και xlsx. Αυτό γίνεται μαντεύοντας τον τύπο του αρχείου με βάση την είσοδο.\n\nΑυτές οι συναρτήσεις έχουν παρόμοια σύνταξη όπως και άλλες συναρτήσεις για τις οποίες έχουμε μιλήσει προηγουμένως για την ανάγνωση άλλων τύπων αρχείων, π.χ., read_csv(), read_table() κ.λπ. Για το υπόλοιπο του κεφαλαίου θα επικεντρωθούμε στη χρήση της read_excel().\n\n20.2.3 Διαβάζοντας υπολογιστικά φύλλα Excel\nΤο Σχήμα 20.1 δείχνει πώς φαίνεται στο Excel το υπολογιστικό φύλλο που θα διαβάσουμε στην R. Μπορείτε να το κατεβάσετε ως αρχείο Excel από το https://docs.google.com/spreadsheets/d/1V1nPp1tzOuutXFLb3G9Eyxi3qxeEhnOXUzL5_BcCQ0w/.\n\n\n\n\n\n\n\nΣχήμα 20.1: Υπολογιστικό φύλλο με όνομα students.xlsx στο Excel.\n\n\n\n\nΤο πρώτο όρισμα της read_excel() είναι το μονοπάτι του αρχείου προς ανάγνωση.\n\nstudents &lt;- read_excel(\"data/students.xlsx\")\n\nΗ read_excel() θα διαβάσει το αρχείο ως tibble.\n\nstudents\n#&gt; # A tibble: 6 × 5\n#&gt;   `Student ID` `Full Name`      favourite.food     mealPlan            AGE  \n#&gt;          &lt;dbl&gt; &lt;chr&gt;            &lt;chr&gt;              &lt;chr&gt;               &lt;chr&gt;\n#&gt; 1            1 Sunil Huffmann   Strawberry yoghurt Lunch only          4    \n#&gt; 2            2 Barclay Lynn     French fries       Lunch only          5    \n#&gt; 3            3 Jayendra Lyne    N/A                Breakfast and lunch 7    \n#&gt; 4            4 Leon Rossini     Anchovies          Lunch only          &lt;NA&gt; \n#&gt; 5            5 Chidiegwu Dunkel Pizza              Breakfast and lunch five \n#&gt; 6            6 Güvenç Attila    Ice cream          Lunch only          6\n\nΈχουμε έξι μαθητές στα δεδομένα και πέντε μεταβλητές για κάθε μαθητή. Ωστόσο, υπάρχουν μερικά πράγματα που ίσως θέλουμε να αντιμετωπίσουμε σε αυτό το σύνολο δεδομένων:\n\n\nΤα ονόματα των στηλών δεν είναι ορισμένα με συνέπεια. Μπορείτε να παρέχετε ονόματα στηλών που ακολουθούν μία συνεπή μορφή. Συνιστούμε τη μορφή snake_case χρησιμοποιώντας το όρισμα col_names.\n\nread_excel(\n  \"data/students.xlsx\",\n  col_names = c(\"student_id\", \"full_name\", \"favourite_food\", \"meal_plan\", \"age\")\n)\n#&gt; # A tibble: 7 × 5\n#&gt;   student_id full_name        favourite_food     meal_plan           age  \n#&gt;   &lt;chr&gt;      &lt;chr&gt;            &lt;chr&gt;              &lt;chr&gt;               &lt;chr&gt;\n#&gt; 1 Student ID Full Name        favourite.food     mealPlan            AGE  \n#&gt; 2 1          Sunil Huffmann   Strawberry yoghurt Lunch only          4    \n#&gt; 3 2          Barclay Lynn     French fries       Lunch only          5    \n#&gt; 4 3          Jayendra Lyne    N/A                Breakfast and lunch 7    \n#&gt; 5 4          Leon Rossini     Anchovies          Lunch only          &lt;NA&gt; \n#&gt; 6 5          Chidiegwu Dunkel Pizza              Breakfast and lunch five \n#&gt; 7 6          Güvenç Attila    Ice cream          Lunch only          6\n\nΔυστυχώς, αυτό δεν δούλεψε πολύ καλά. Τώρα, έχουμε τα ονόματα των μεταβλητών που θέλουμε, αλλά αυτό που προηγουμένως ήταν η γραμμή με τα ονόματα των στηλών, τώρα εμφανίζεται ως η πρώτη παρατήρηση στα δεδομένα. Μπορείτε να παραλείψετε αυτή τη γραμμή χρησιμοποιώντας το όρισμα skip.\n\nread_excel(\n  \"data/students.xlsx\",\n  col_names = c(\"student_id\", \"full_name\", \"favourite_food\", \"meal_plan\", \"age\"),\n  skip = 1\n)\n#&gt; # A tibble: 6 × 5\n#&gt;   student_id full_name        favourite_food     meal_plan           age  \n#&gt;        &lt;dbl&gt; &lt;chr&gt;            &lt;chr&gt;              &lt;chr&gt;               &lt;chr&gt;\n#&gt; 1          1 Sunil Huffmann   Strawberry yoghurt Lunch only          4    \n#&gt; 2          2 Barclay Lynn     French fries       Lunch only          5    \n#&gt; 3          3 Jayendra Lyne    N/A                Breakfast and lunch 7    \n#&gt; 4          4 Leon Rossini     Anchovies          Lunch only          &lt;NA&gt; \n#&gt; 5          5 Chidiegwu Dunkel Pizza              Breakfast and lunch five \n#&gt; 6          6 Güvenç Attila    Ice cream          Lunch only          6\n\n\n\nΣτη στήλη favourite_food, μία από τις παρατηρήσεις είναι N/A, το οποίο σημαίνει “μη διαθέσιμο (not available)”, αλλά επί του παρόντος δεν αναγνωρίζεται ως τιμή ΝΑ (σημειώστε την αντίθεση μεταξύ του N/A και της ηλικίας του τέταρτου μαθητή στη λίστα). Μπορείτε να καθορίσετε ποιες τιμές χαρακτήρων θα αναγνωρίζονται ως NA με το όρισμα na. Από προεπιλογή, μόνο το \"\" (κενή συμβολοσειρά ή, στην περίπτωση ανάγνωσης από υπολογιστικό φύλλο, ένα κενό κελί, ή ένα κελί με τον τύπο =NA()) αναγνωρίζεται ως NA.\n\nread_excel(\n  \"data/students.xlsx\",\n  col_names = c(\"student_id\", \"full_name\", \"favourite_food\", \"meal_plan\", \"age\"),\n  skip = 1,\n  na = c(\"\", \"N/A\")\n)\n#&gt; # A tibble: 6 × 5\n#&gt;   student_id full_name        favourite_food     meal_plan           age  \n#&gt;        &lt;dbl&gt; &lt;chr&gt;            &lt;chr&gt;              &lt;chr&gt;               &lt;chr&gt;\n#&gt; 1          1 Sunil Huffmann   Strawberry yoghurt Lunch only          4    \n#&gt; 2          2 Barclay Lynn     French fries       Lunch only          5    \n#&gt; 3          3 Jayendra Lyne    &lt;NA&gt;               Breakfast and lunch 7    \n#&gt; 4          4 Leon Rossini     Anchovies          Lunch only          &lt;NA&gt; \n#&gt; 5          5 Chidiegwu Dunkel Pizza              Breakfast and lunch five \n#&gt; 6          6 Güvenç Attila    Ice cream          Lunch only          6\n\n\n\nΈνα άλλο ζήτημα που απομένει είναι ότι η στήλη age διαβάζεται ως μεταβλητή χαρακτήρων, αλλά στην πραγματικότητα θα έπρεπε να είναι αριθμητική. Ακριβώς όπως με τη read_csv() και τις παρόμοιες συναρτήσεις για ανάγνωση δεδομένων από flat αρχεία, μπορείτε να παρέχετε το όρισμα col_types στη read_excel() και να καθορίσετε τους τύπους των στηλών για τις μεταβλητές που διαβάζετε. Ωστόσο, η σύνταξη είναι λίγο διαφορετική. Οι επιλογές σας είναι skip\", \"guess\", \"logical\", \"numeric\", \"date\", \"text\" ή \"list\".\n\nread_excel(\n  \"data/students.xlsx\",\n  col_names = c(\"student_id\", \"full_name\", \"favourite_food\", \"meal_plan\", \"age\"),\n  skip = 1,\n  na = c(\"\", \"N/A\"),\n  col_types = c(\"numeric\", \"text\", \"text\", \"text\", \"numeric\")\n)\n#&gt; Warning: Expecting numeric in E6 / R6C5: got 'five'\n#&gt; # A tibble: 6 × 5\n#&gt;   student_id full_name        favourite_food     meal_plan             age\n#&gt;        &lt;dbl&gt; &lt;chr&gt;            &lt;chr&gt;              &lt;chr&gt;               &lt;dbl&gt;\n#&gt; 1          1 Sunil Huffmann   Strawberry yoghurt Lunch only              4\n#&gt; 2          2 Barclay Lynn     French fries       Lunch only              5\n#&gt; 3          3 Jayendra Lyne    &lt;NA&gt;               Breakfast and lunch     7\n#&gt; 4          4 Leon Rossini     Anchovies          Lunch only             NA\n#&gt; 5          5 Chidiegwu Dunkel Pizza              Breakfast and lunch    NA\n#&gt; 6          6 Güvenç Attila    Ice cream          Lunch only              6\n\nΩστόσο, ούτε και αυτό έφερε το επιθυμητό αποτέλεσμα. Καθορίζοντας ότι η στήλη age πρέπει να είναι αριθμητική, έχουμε μετατρέψει το ένα κελί με τη μη αριθμητική καταχώρηση (που είχε την τιμή five) σε NA. Σε αυτήν την περίπτωση, θα πρέπει να διαβάσουμε την ηλικία ως κείμενο (\"text\") και στη συνέχεια να κάνουμε την αλλαγή μόλις τα δεδομένα φορτωθούν στην R.\n\nstudents &lt;- read_excel(\n  \"data/students.xlsx\",\n  col_names = c(\"student_id\", \"full_name\", \"favourite_food\", \"meal_plan\", \"age\"),\n  skip = 1,\n  na = c(\"\", \"N/A\"),\n  col_types = c(\"numeric\", \"text\", \"text\", \"text\", \"text\")\n)\n\nstudents &lt;- students |&gt;\n  mutate(\n    age = if_else(age == \"five\", \"5\", age),\n    age = parse_number(age)\n  )\n\nstudents\n#&gt; # A tibble: 6 × 5\n#&gt;   student_id full_name        favourite_food     meal_plan             age\n#&gt;        &lt;dbl&gt; &lt;chr&gt;            &lt;chr&gt;              &lt;chr&gt;               &lt;dbl&gt;\n#&gt; 1          1 Sunil Huffmann   Strawberry yoghurt Lunch only              4\n#&gt; 2          2 Barclay Lynn     French fries       Lunch only              5\n#&gt; 3          3 Jayendra Lyne    &lt;NA&gt;               Breakfast and lunch     7\n#&gt; 4          4 Leon Rossini     Anchovies          Lunch only             NA\n#&gt; 5          5 Chidiegwu Dunkel Pizza              Breakfast and lunch     5\n#&gt; 6          6 Güvenç Attila    Ice cream          Lunch only              6\n\n\n\nΜας χρειάστηκαν πολλά βήματα και δοκιμές για να φορτώσουμε τα δεδομένα ακριβώς στη μορφή που θέλουμε, και αυτό δεν είναι απροσδόκητο. Η επιστήμη των δεδομένων είναι μία επαναληπτική διαδικασία, και η διαδικασία της επανάληψης μπορεί να είναι ακόμη πιο κουραστική κατά την ανάγνωση δεδομένων από υπολογιστικά φύλλα σε σύγκριση με άλλα αρχεία απλού κειμένου, ή αρχεία δεδομένων σε μορφή πίνακα, επειδή οι άνθρωποι τείνουν να εισάγουν δεδομένα σε υπολογιστικά φύλλα, και να τα χρησιμοποιούν όχι μόνο για αποθήκευση, αλλά και για κοινή χρήση και επικοινωνία.\nΔεν υπάρχει τρόπος να γνωρίζετε ακριβώς πώς θα είναι τα δεδομένα μέχρι να τα φορτώσετε και να τα δείτε. Βασικά, στην πραγματικότητα, υπάρχει. Μπορείτε να ρίξετε μία ματιά ανοίγοντας το αρχείο στο Excel. Εάν πρόκειται να το κάνετε, συνιστούμε να δημιουργήσετε ένα αντίγραφο του αρχείου Excel για να το ανοίξετε και να περιηγηθείτε διαδραστικά και να αφήσετε ως έχει το αρχικό αρχείο που θα διαβάσετε στην R. Αυτό θα διασφαλίσει ότι δεν θα αντικαταστήσετε κατά λάθος κάτι μέσα στο υπολογιστικό φύλλο όσο το εξερευνείτε. Επίσης, δεν πρέπει να φοβάστε να κάνετε αυτό που κάναμε εδώ: φορτώστε τα δεδομένα, ρίξτε μία ματιά, κάντε προσαρμογές στον κώδικά σας, φορτώστε το αρχείο ξανά και επαναλάβετε μέχρι να είστε ευχαριστημένοι με το αποτέλεσμα.\n\n20.2.4 Διαβάζοντας φύλλα εργασίας\nΈνα σημαντικό χαρακτηριστικό που ξεχωρίζει τα υπολογιστικά φύλλα από τα flat αρχεία είναι η έννοια των πολλαπλών φύλλων, που ονομάζονται φύλλα εργασίας. Το Σχήμα 20.2 εμφανίζει ένα υπολογιστικό φύλλο Excel με πολλά φύλλα εργασίας. Τα δεδομένα προέρχονται από το πακέτο palmerpenguins ενώ μπορείτε να κατεβάσετε το υπολογιστικό φύλλο ως αρχείο Excel από το https://docs.google.com/spreadsheets/d/1aFu8lnD_g0yjF5O-K6SFgSEWiHPpgvFCF0NY9D6LXnY/. Κάθε φύλλο εργασίας περιέχει πληροφορίες για πιγκουίνους από διαφορετικά νησιά.\n\n\n\n\n\n\n\nΣχήμα 20.2: Υπολογιστικό φύλλο με όνομα penguins.xlsx στο Excel που περιέχει τρία φύλλα εργασίας.\n\n\n\n\nΜπορείτε να διαβάσετε ένα μεμονωμένο φύλλο εργασίας από ένα υπολογιστικό φύλλο με το όρισμα sheet στη read_excel(). Η προεπιλογή, στην οποία βασιζόμασταν μέχρι τώρα, είναι το πρώτο φύλλο.\n\nread_excel(\"data/penguins.xlsx\", sheet = \"Torgersen Island\")\n#&gt; # A tibble: 52 × 8\n#&gt;   species island    bill_length_mm     bill_depth_mm      flipper_length_mm\n#&gt;   &lt;chr&gt;   &lt;chr&gt;     &lt;chr&gt;              &lt;chr&gt;              &lt;chr&gt;            \n#&gt; 1 Adelie  Torgersen 39.1               18.7               181              \n#&gt; 2 Adelie  Torgersen 39.5               17.399999999999999 186              \n#&gt; 3 Adelie  Torgersen 40.299999999999997 18                 195              \n#&gt; 4 Adelie  Torgersen NA                 NA                 NA               \n#&gt; 5 Adelie  Torgersen 36.700000000000003 19.3               193              \n#&gt; 6 Adelie  Torgersen 39.299999999999997 20.6               190              \n#&gt; # ℹ 46 more rows\n#&gt; # ℹ 3 more variables: body_mass_g &lt;chr&gt;, sex &lt;chr&gt;, year &lt;dbl&gt;\n\nΟρισμένες μεταβλητές που φαίνεται να περιέχουν αριθμητικά δεδομένα διαβάζονται ως χαρακτήρες λόγω του ότι η συμβολοσειρά χαρακτήρων \"NA\" δεν αναγνωρίζεται ως πραγματικό NA.\n\npenguins_torgersen &lt;- read_excel(\"data/penguins.xlsx\", sheet = \"Torgersen Island\", na = \"NA\")\n\npenguins_torgersen\n#&gt; # A tibble: 52 × 8\n#&gt;   species island    bill_length_mm bill_depth_mm flipper_length_mm\n#&gt;   &lt;chr&gt;   &lt;chr&gt;              &lt;dbl&gt;         &lt;dbl&gt;             &lt;dbl&gt;\n#&gt; 1 Adelie  Torgersen           39.1          18.7               181\n#&gt; 2 Adelie  Torgersen           39.5          17.4               186\n#&gt; 3 Adelie  Torgersen           40.3          18                 195\n#&gt; 4 Adelie  Torgersen           NA            NA                  NA\n#&gt; 5 Adelie  Torgersen           36.7          19.3               193\n#&gt; 6 Adelie  Torgersen           39.3          20.6               190\n#&gt; # ℹ 46 more rows\n#&gt; # ℹ 3 more variables: body_mass_g &lt;dbl&gt;, sex &lt;chr&gt;, year &lt;dbl&gt;\n\nΕναλλακτικά, μπορείτε να χρησιμοποιήσετε την excel_sheets() για να πάρετε πληροφορίες για όλα τα φύλλα εργασίας σε ένα υπολογιστικό φύλλο Excel και, στη συνέχεια, να διαβάσετε μόνο αυτά που σας ενδιαφέρουν.\n\nexcel_sheets(\"data/penguins.xlsx\")\n#&gt; [1] \"Torgersen Island\" \"Biscoe Island\"    \"Dream Island\"\n\nΕάν γνωρίζετε τα ονόματα των φύλλων εργασίας, μπορείτε να τα διαβάσετε μεμονωμένα με τη read_excel().\n\npenguins_biscoe &lt;- read_excel(\"data/penguins.xlsx\", sheet = \"Biscoe Island\", na = \"NA\")\npenguins_dream  &lt;- read_excel(\"data/penguins.xlsx\", sheet = \"Dream Island\", na = \"NA\")\n\nΣε αυτήν την περίπτωση, το πλήρες σύνολο δεδομένων penguins κατανέμεται σε τρία φύλλα εργασίας μέσα στο υπολογιστικό φύλλο. Κάθε φύλλο εργασίας έχει τον ίδιο αριθμό στηλών αλλά διαφορετικό αριθμό σειρών.\n\ndim(penguins_torgersen)\n#&gt; [1] 52  8\ndim(penguins_biscoe)\n#&gt; [1] 168   8\ndim(penguins_dream)\n#&gt; [1] 124   8\n\nΜπορούμε να τα ενώσουμε με την bind_rows().\n\npenguins &lt;- bind_rows(penguins_torgersen, penguins_biscoe, penguins_dream)\npenguins\n#&gt; # A tibble: 344 × 8\n#&gt;   species island    bill_length_mm bill_depth_mm flipper_length_mm\n#&gt;   &lt;chr&gt;   &lt;chr&gt;              &lt;dbl&gt;         &lt;dbl&gt;             &lt;dbl&gt;\n#&gt; 1 Adelie  Torgersen           39.1          18.7               181\n#&gt; 2 Adelie  Torgersen           39.5          17.4               186\n#&gt; 3 Adelie  Torgersen           40.3          18                 195\n#&gt; 4 Adelie  Torgersen           NA            NA                  NA\n#&gt; 5 Adelie  Torgersen           36.7          19.3               193\n#&gt; 6 Adelie  Torgersen           39.3          20.6               190\n#&gt; # ℹ 338 more rows\n#&gt; # ℹ 3 more variables: body_mass_g &lt;dbl&gt;, sex &lt;chr&gt;, year &lt;dbl&gt;\n\nΣτο Κεφάλαιο 26 θα μιλήσουμε για τρόπους εκτέλεσης αυτού του είδους εργασίας χωρίς επαναλαμβανόμενο κώδικα.\n\n20.2.5 Διαβάζοντας μέρος ενός φύλλου\nΔεδομένου ότι πολλοί χρησιμοποιούν υπολογιστικά φύλλα Excel για παρουσίαση καθώς και για αποθήκευση δεδομένων, είναι πολύ συνηθισμένο να βρίσκουμε καταχωρήσεις κελιών σε ένα υπολογιστικό φύλλο που δεν αποτελούν μέρος των δεδομένων που θέλετε να διαβάσετε στην R. Το Σχήμα 20.3 δείχνει ένα τέτοιο υπολογιστικό φύλλο: στη μέση του φύλλου υπάρχει κάτι που μοιάζει με πλαίσιο δεδομένων. Υπάρχει όμως εξωτερικό κείμενο στα κελιά πάνω και κάτω από τα δεδομένα.\n\n\n\n\n\n\n\nΣχήμα 20.3: Υπολογσιτικό φύλλο με όνομα deaths.xlsx στο Excel.\n\n\n\n\nΑυτό το υπολογιστικό φύλλο είναι ένα από τα παραδείγματα που παρέχονται στο πακέτο readxl. Μπορείτε να χρησιμοποιήσετε τη συνάρτηση readxl_example() για να εντοπίσετε το υπολογιστικό φύλλο στο σύστημά σας στον κατάλογο όπου είναι εγκατεστημένο το πακέτο. Αυτή η συνάρτηση επιστρέφει το μονοπάτι προς το υπολογιστικό φύλλο, το οποίο μπορείτε να χρησιμοποιήσετε στην read_excel() ως συνήθως.\n\ndeaths_path &lt;- readxl_example(\"deaths.xlsx\")\ndeaths &lt;- read_excel(deaths_path)\n#&gt; New names:\n#&gt; • `` -&gt; `...2`\n#&gt; • `` -&gt; `...3`\n#&gt; • `` -&gt; `...4`\n#&gt; • `` -&gt; `...5`\n#&gt; • `` -&gt; `...6`\ndeaths\n#&gt; # A tibble: 18 × 6\n#&gt;   `Lots of people`    ...2       ...3  ...4     ...5          ...6           \n#&gt;   &lt;chr&gt;               &lt;chr&gt;      &lt;chr&gt; &lt;chr&gt;    &lt;chr&gt;         &lt;chr&gt;          \n#&gt; 1 simply cannot resi… &lt;NA&gt;       &lt;NA&gt;  &lt;NA&gt;     &lt;NA&gt;          some notes     \n#&gt; 2 at                  the        top   &lt;NA&gt;     of            their spreadsh…\n#&gt; 3 or                  merging    &lt;NA&gt;  &lt;NA&gt;     &lt;NA&gt;          cells          \n#&gt; 4 Name                Profession Age   Has kids Date of birth Date of death  \n#&gt; 5 David Bowie         musician   69    TRUE     17175         42379          \n#&gt; 6 Carrie Fisher       actor      60    TRUE     20749         42731          \n#&gt; # ℹ 12 more rows\n\nΟι τρεις επάνω γραμμές και οι τέσσερις κάτω γραμμές δεν αποτελούν μέρος του πλαισίου δεδομένων. Οι εξωτερικές γραμμές μπορούν να αποφευχθούν χρησιμοποιώντας τα ορίσματα skip και n_max, συνιστούμε όμως τη χρήση εύρους κελιών. Στο Excel, το επάνω αριστερό κελί είναι το A1. Καθώς μετακινείστε στις στήλες προς τα δεξιά, η ετικέτα του κελιού μετακινείται προς τα κάτω στο αλφάβητο, δηλαδή B1, C1, κ.λπ. Και καθώς μετακινείστε προς τα κάτω σε μία στήλη, ο αριθμός στην ετικέτα του κελιού αυξάνεται, για παράδειγμα A2, A3 κ.λπ.\nΕδώ τα δεδομένα που θέλουμε να διαβάσουμε ξεκινούν στο κελί A5 και τελειώνουν στο κελί F15. Σε όρους υπολογιστικών φύλλων, αυτό μεταφράζεται σε A5:F1, το οποίο και παρέχουμε στο όρισμα range:\n\nread_excel(deaths_path, range = \"A5:F15\")\n#&gt; # A tibble: 10 × 6\n#&gt;   Name          Profession   Age `Has kids` `Date of birth`    \n#&gt;   &lt;chr&gt;         &lt;chr&gt;      &lt;dbl&gt; &lt;lgl&gt;      &lt;dttm&gt;             \n#&gt; 1 David Bowie   musician      69 TRUE       1947-01-08 00:00:00\n#&gt; 2 Carrie Fisher actor         60 TRUE       1956-10-21 00:00:00\n#&gt; 3 Chuck Berry   musician      90 TRUE       1926-10-18 00:00:00\n#&gt; 4 Bill Paxton   actor         61 TRUE       1955-05-17 00:00:00\n#&gt; 5 Prince        musician      57 TRUE       1958-06-07 00:00:00\n#&gt; 6 Alan Rickman  actor         69 FALSE      1946-02-21 00:00:00\n#&gt; # ℹ 4 more rows\n#&gt; # ℹ 1 more variable: `Date of death` &lt;dttm&gt;\n\n\n20.2.6 Τύποι δεδομένων\nΣε αρχεία CSV, όλες οι τιμές είναι συμβολοσειρές. Αυτό δεν ισχύει ιδιαίτερα για τα δεδομένα κάθε φορά, αλλά είναι απλό: όλα είναι μία συμβολοσειρά.\nΤα υποκείμενα δεδομένα στα υπολογιστικά φύλλα του Excel είναι πιο περίπλοκα. Ένα κελί μπορεί να είναι ένα από τέσσερα πράγματα:\n\nΒoolean, όπως TRUE, FALSE ή NA.\nΑριθμός, όπως 10 ή 10,5.\nΗμερομηνία, η οποία μπορεί επίσης να περιλαμβάνει και πληροφορία ώρας όπως 11/1/21 ή 11/1/21 3:00 PM.\nΜία συμβολοσειρά, όπως “δέκα”.\n\nΌταν εργάζεστε με δεδομένα από υπολογιστικά φύλλα, είναι σημαντικό να θυμάστε ότι τα υποκείμενα δεδομένα μπορεί να είναι πολύ διαφορετικά από αυτά που βλέπετε στο κελί. Για παράδειγμα, το Excel δεν ορίζει την έννοια του ακέραιου αριθμού. Όλοι οι αριθμοί αποθηκεύονται ως στοιχεία με κινητή υποδιαστολή. Μπορείτε όμως να επιλέξετε τα δεδομένα να εμφανίζονται με έναν προσαρμόσιμο αριθμό δεκαδικών ψηφίων. Ομοίως, οι ημερομηνίες αποθηκεύονται ως αριθμοί, συγκεκριμένα ο αριθμός των δευτερολέπτων από την 1η Ιανουαρίου 1970. Μπορείτε να προσαρμόσετε τον τρόπο εμφάνισης της ημερομηνίας εφαρμόζοντας κάποια μορφοποίηση στο Excel. Συνεχίζοντας με τη σύγχυση, είναι επίσης πιθανό να έχετε κάτι που μοιάζει με αριθμό, αλλά στην πραγματικότητα να είναι μία συμβολοσειρά (π.χ. πληκτρολογήστε 10 σε ένα κελί στο Excel).\nΟι διαφορές μεταξύ του τρόπου αποθήκευσης των υποκείμενων δεδομένων και του τρόπου εμφάνισής τους μπορεί να προκαλέσουν εκπλήξεις όταν τα δεδομένα φορτώνονται στην R. Από προεπιλογή, το πακέτο readxl θα μαντέψει τον τύπο δεδομένων για κάθε στήλη. Ένας συνιστώμενος τρόπος εργασίας είναι να επιτρέψετε στην readxl να μαντέψει τους τύπους των στηλών, να επιβεβαιώσει ότι είστε ικανοποιημένοι με αυτούς που μάντεψε και, αν όχι, να επιστρέψετε και να εισάγετε ξανά προσδιορίζοντας το col_types όπως φαίνεται στην Ενότητα 20.2.3.\nΜία άλλη πρόκληση είναι όταν έχετε μία στήλη στο υπολογιστικό φύλλο του Excel που περιέχει έναν συνδυασμό αυτών των τύπων, π.χ. ορισμένα κελιά είναι αριθμητικά, άλλα κείμενο, άλλα ημερομηνίες. Κατά την εισαγωγή των δεδομένων στην R, το πακέτο readxl πρέπει να λάβει κάποιες αποφάσεις. Σε αυτές τις περιπτώσεις, μπορείτε να ορίσετε τον τύπο αυτής της στήλης σε λίστα (\"list\"), η οποία θα φορτώσει τη στήλη ως λίστα διανυσμάτων μήκους 1, όπου μαντεύεται ο τύπος κάθε στοιχείου του διανύσματος.\n\n\n\n\n\n\nΜερικές φορές τα δεδομένα αποθηκεύονται με πιο ιδιαίτερους τρόπους, όπως το χρώμα του φόντου του κελιού ή αν το κείμενο είναι έντονο ή όχι. Σε τέτοιες περιπτώσεις, μπορεί να βρείτε χρήσιμο το πακέτο tidyxl. Ανατρέξτε στο https://nacnudus.github.io/spreadsheet-munging-strategies/ για περισσότερα σχετικά με τις στρατηγικές εργασίας με δεδομένα που δεν ειναι σε μορφή πίνακα από το Excel.\n\n\n\n\n20.2.7 Γράφοντας σε Excel\nΑς δημιουργήσουμε ένα μικρό πλαίσιο δεδομένων που μπορούμε στη συνέχεια να το γράψουμε σε ένα αρχείο. Σημειώστε ότι το item είναι μία παραγοντική μεταβλητή και το quantity είναι ακέραιος.\n\nbake_sale &lt;- tibble(\n  item     = factor(c(\"brownie\", \"cupcake\", \"cookie\")),\n  quantity = c(10, 5, 8)\n)\n\nbake_sale\n#&gt; # A tibble: 3 × 2\n#&gt;   item    quantity\n#&gt;   &lt;fct&gt;      &lt;dbl&gt;\n#&gt; 1 brownie       10\n#&gt; 2 cupcake        5\n#&gt; 3 cookie         8\n\nΜπορείτε να γράψετε δεδομένα στον δίσκο ως αρχείο Excel χρησιμοποιώντας την write_xlsx() από το πακέτο writexl:\n\nwrite_xlsx(bake_sale, path = \"data/bake-sale.xlsx\")\n\nΤο Σχήμα 20.4 δείχνει πως φαίνονται τα δεδομένα στο Excel. Σημειώστε ότι τα ονόματα των στηλών περιλαμβάνονται και είναι με έντονη γραφή. Αυτά μπορούν να απενεργοποιηθούν θέτοντας τα ορίσματα col_names και format_headers σε FALSE.\n\n\n\n\n\n\n\nΣχήμα 20.4: Υπολογιστικό φύλλο με όνομα bake_sale.xlsx στο Excel.\n\n\n\n\nΑκριβώς όπως και κατά την ανάγνωση από ένα CSV, οι πληροφορίες σχετικά με τον τύπο δεδομένων χάνονται όταν διαβάζουμε ξανά τα δεδομένα. Αυτό καθιστά τα αρχεία Excel αναξιόπιστα για την προσωρινή αποθήκευση ενδιάμεσων αποτελεσμάτων. Για εναλλακτικές, ανατρέξτε στην Ενότητα 7.5.\n\nread_excel(\"data/bake-sale.xlsx\")\n#&gt; # A tibble: 3 × 2\n#&gt;   item    quantity\n#&gt;   &lt;chr&gt;      &lt;dbl&gt;\n#&gt; 1 brownie       10\n#&gt; 2 cupcake        5\n#&gt; 3 cookie         8\n\n\n20.2.8 Μορφοποιημένη έξοδος\nΤο πακέτο writexl είναι μία απλή λύση για τη σύνταξη ενός απλού υπολογιστικού φύλλου Excel, αλλά αν σας ενδιαφέρουν πρόσθετες δυνατότητες όπως η εγγραφή σε φύλλα μέσα σε ένα υπολογιστικό φύλλο και το στυλ, θα θέλετε να χρησιμοποιήσετε το πακέτο openxlsx. Δεν θα μπούμε σε λεπτομέρειες σχετικά με τη χρήση αυτού του πακέτου, αλλά συνιστούμε να διαβάσετε το https://ycphs.github.io/openxlsx/articles/Formatting.html για μία εκτενή συζήτηση σχετικά με την περαιτέρω λειτουργικότητα μορφοποίησης για δεδομένα που έχουν γραφτεί από την R σε Excel με την openxlsx.\nΣημειώστε ότι αυτό το πακέτο δεν αποτελεί μέρος του tidyverse, επομένως οι λειτουργίες και οι ροές εργασίας μπορεί να σας φαίνονται άγνωστες. Για παράδειγμα, τα ονόματα συναρτήσεων είναι γραμμένα σε camelCase, πολλαπλές συναρτήσεις δεν μπορούν να συντεθούν με pipes και τα ορίσματα έχουν διαφορετική σειρά από αυτή που είναι στο tidyverse. Ωστόσο, αυτό είναι εντάξει. Καθώς η εκμάθηση και η χρήση της R επεκτείνονται εκτός αυτού του βιβλίου, θα συναντήσετε πολλούς διαφορετικούς τρόπους γραφής που χρησιμοποιούνται σε διάφορα πακέτα της R, τα οποία μπορεί να χρησιμοποιήσετε για να επιτύχετε συγκεκριμένους στόχους. Ένας καλός τρόπος για να εξοικειωθείτε με το στυλ προγραμματισμού που χρησιμοποιείται σε ένα νέο πακέτο είναι να εκτελέσετε τα παραδείγματα που παρέχονται στις οδηγίες των συναρτήσεων για να πάρετε μία ιδέα της σύνταξης και των μορφών εξόδου, καθώς και να διαβάσετε τυχόν εγχειρίδια που μπορεί να συνοδεύουν το πακέτο.\n\n20.2.9 Ασκήσεις\n\n\nΣε ένα αρχείο Excel, δημιουργήστε το ακόλουθο σύνολο δεδομένων και αποθηκεύστε το ως survey.xlsx. Εναλλακτικά, μπορείτε να το κατεβάσετε ως αρχείο Excel από εδώ.\n\n\n\n\n\n\n\n\nΣτη συνέχεια, διαβάστε το στην R, με την survey_id ως μεταβλητή χαρακτήρα και την n_pets ως αριθμητική μεταβλητή.\n\n#&gt; # A tibble: 6 × 2\n#&gt;   survey_id n_pets\n#&gt;   &lt;chr&gt;      &lt;dbl&gt;\n#&gt; 1 1              0\n#&gt; 2 2              1\n#&gt; 3 3             NA\n#&gt; 4 4              2\n#&gt; 5 5              2\n#&gt; 6 6             NA\n\n\n\nΣε ένα άλλο αρχείο Excel, δημιουργήστε το ακόλουθο σύνολο δεδομένων και αποθηκεύστε το ως roster.xlsx. Εναλλακτικά, μπορείτε να το κατεβάσετε ως αρχείο Excel από εδώ.\n\n\n\n\n\n\n\n\nΣτη συνέχεια, διαβάστε το στην R. Το πλαίσιο δεδομένων που προκύπτει θα πρέπει να ονομάζεται roster και θα πρέπει να μοιάζει με το ακόλουθο.\n\n#&gt; # A tibble: 12 × 3\n#&gt;    group subgroup    id\n#&gt;    &lt;dbl&gt; &lt;chr&gt;    &lt;dbl&gt;\n#&gt;  1     1 A            1\n#&gt;  2     1 A            2\n#&gt;  3     1 A            3\n#&gt;  4     1 B            4\n#&gt;  5     1 B            5\n#&gt;  6     1 B            6\n#&gt;  7     1 B            7\n#&gt;  8     2 A            8\n#&gt;  9     2 A            9\n#&gt; 10     2 B           10\n#&gt; 11     2 B           11\n#&gt; 12     2 B           12\n\n\n\nΣε ένα νέο αρχείο Excel, δημιουργήστε το ακόλουθο σύνολο δεδομένων και αποθηκεύστε το ως sales.xlsx. Εναλλακτικά, μπορείτε να το κατεβάσετε ως αρχείο Excel από εδώ.\n\n\n\n\n\n\n\n\n\nΔιαβάστε το sales.xlsx και αποθηκεύστε ως sales. Το πλαίσιο δεδομένων θα πρέπει να μοιάζει με το ακόλουθο, με τα id και n ως ονόματα στηλών και με 9 γραμμές.\n\n\n#&gt; # A tibble: 9 × 2\n#&gt;   id      n    \n#&gt;   &lt;chr&gt;   &lt;chr&gt;\n#&gt; 1 Brand 1 n    \n#&gt; 2 1234    8    \n#&gt; 3 8721    2    \n#&gt; 4 1822    3    \n#&gt; 5 Brand 2 n    \n#&gt; 6 3333    1    \n#&gt; 7 2156    3    \n#&gt; 8 3987    6    \n#&gt; 9 3216    5\n\n\nΤροποποιήστε περαιτέρω το sales για να το μεταφέρετε στην ακόλουθη tidy μορφή με τρεις στήλες (brand, id και n) και 7 γραμμές. Σημειώστε ότι οι id και n είναι αριθμητικές, η brand είναι μεταβλητή χαρακτήρα.\n\n\n#&gt; # A tibble: 7 × 3\n#&gt;   brand      id     n\n#&gt;   &lt;chr&gt;   &lt;dbl&gt; &lt;dbl&gt;\n#&gt; 1 Brand 1  1234     8\n#&gt; 2 Brand 1  8721     2\n#&gt; 3 Brand 1  1822     3\n#&gt; 4 Brand 2  3333     1\n#&gt; 5 Brand 2  2156     3\n#&gt; 6 Brand 2  3987     6\n#&gt; 7 Brand 2  3216     5\n\n\nΔημιουργήστε ξανά το πλαίσιο δεδομένων bake_sale, και γράψτε το σε ένα αρχείο Excel χρησιμοποιώντας τη συνάρτηση write.xlsx() από το πακέτο openxlsx.\nΣτο Κεφάλαιο 7 μάθατε για τη συνάρτηση janitor::clean_names() για τη μετατροπή των ονομάτων των στηλών σε snake case. Διαβάστε το αρχείο students.xlsx που παρουσιάσαμε νωρίτερα σε αυτήν την ενότητα και χρησιμοποιήστε αυτήν τη συνάρτηση για να “καθαρίσετε” τα ονόματα των στηλών.\nΤι συμβαίνει αν προσπαθήσετε να διαβάσετε σε ένα αρχείο με επέκταση .xlsx με την read_xls();",
    "crumbs": [
      "Εισαγωγή δεδομένων",
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>Υπολογιστικά φύλλα</span>"
    ]
  },
  {
    "objectID": "spreadsheets.html#google-sheets",
    "href": "spreadsheets.html#google-sheets",
    "title": "20  Υπολογιστικά φύλλα",
    "section": "\n20.3 Google Sheets",
    "text": "20.3 Google Sheets\nΤο Google Sheets είναι ένα άλλο ευρέως χρησιμοποιούμενο πρόγραμμα υπολογιστικών φύλλων. Είναι δωρεάν και online. Ακριβώς όπως και με το Excel, στο Google Sheets τα δεδομένα οργανώνονται σε φύλλα εργασίας μέσα σε αρχεία υπολογιστικών φύλλων.\n\n20.3.1 Προαπαιτούμενα\nΑυτή η ενότητα θα επικεντρωθεί επίσης σε υπολογιστικά φύλλα, αλλά αυτή τη φορά θα φορτώνετε δεδομένα από ένα Google Sheet με το πακέτο googlesheets4. Αυτό το πακέτο επίσης δεν είναι στο tidyverse, πρέπει να το φορτώσετε ξεχωριστά.\n\nlibrary(googlesheets4)\nlibrary(tidyverse)\n\nΜία γρήγορη σημείωση σχετικά με το όνομα του πακέτου: το googlesheets4 χρησιμοποιεί την έκδοση v4 του Sheets API v4 για να παρέχει στην R μια διεπαφή στο Google Sheets, εξ ου και το όνομα.\n\n20.3.2 Ξεκινώντας\nΗ κύρια συνάρτηση του πακέτου googlesheets4 είναι η read_sheet(), η οποία διαβάζει ένα φύλλο Google από μία διεύθυνση URL ή ένα αναγνωριστικό αρχείου. Αυτή η συνάρτηση έχει επίσης το όνομα range_read().\nΜπορείτε ακόμα να δημιουργήσετε ένα ολοκαίνουργιο φύλλο με την gs4_create() ή να γράψετε σε ένα υπάρχον φύλλο με την sheet_write() και τις σχετικές συναρτήσεις.\nΣε αυτήν την ενότητα θα εργαστούμε με τα ίδια σύνολα δεδομένων με αυτά που είδαμε στην ενότητα του Excel, ώστε να επισημάνουμε ομοιότητες και διαφορές μεταξύ των ροών εργασίας για την ανάγνωση δεδομένων από το Excel και το Google Sheets. Τα πακέτα readxl και googlesheets4 είναι σχεδιασμένα για να μιμούνται τη λειτουργικότητα του πακέτου readr, το οποίο παρέχει τη συνάρτηση read_csv() που έχετε δει στο Κεφάλαιο 7. Επομένως, πολλές εργασίες μπορούν να επιτευχθούν με μία απλή αντικατάσταση της read_excel() με την read_sheet(). Ωστόσο, θα δείτε ότι το Excel και το Google Sheets δεν συμπεριφέρονται με τον ίδιο ακριβώς τρόπο, επομένως κάποιες εργασίες ενδέχεται να απαιτούν επιπλέον αναβαθμίσεις στις κλήσεις των συναρτήσεων.\n\n20.3.3 Διαβάζοντας Google Sheets\nΤο Σχήμα 20.5 δείχνει πώς φαίνεται το υπολογιστικό φύλλο που πρόκειται να διαβάσουμε στην R στο Google Sheets. Αυτό είναι το ίδιο σύνολο δεδομένων όπως και στο Σχήμα 20.1, με τη διαφορά ότι είναι αποθηκευμένο σε ένα Google Sheet αντί για Excel.\n\n\n\n\n\n\n\nΣχήμα 20.5: Google Sheet called students in a browser window.\n\n\n\n\nΤο πρώτο όρισμα της read_sheet() είναι η διεύθυνση URL του αρχείου προς ανάγνωση και επιστρέφει ένα tibble: https://docs.google.com/spreadsheets/d/1V1nPp1tzOuutXFLb3G9Eyxi3qxeEhnOXUzL5_BcCQ0w. Το να δουλεύεις με διευθύνσεις URL δεν είναι ό,τι πιο ευχάριστο, επομένως συχνά θα θέλετε να προσδιορίσετε ένα φύλλο με το αναγνωριστικό του.\n\ngs4_deauth()\n\n\nstudents_sheet_id &lt;- \"1V1nPp1tzOuutXFLb3G9Eyxi3qxeEhnOXUzL5_BcCQ0w\"\nstudents &lt;- read_sheet(students_sheet_id)\n#&gt; ✔ Reading from students.\n#&gt; ✔ Range Sheet1.\nstudents\n#&gt; # A tibble: 6 × 5\n#&gt;   `Student ID` `Full Name`      favourite.food     mealPlan            AGE   \n#&gt;          &lt;dbl&gt; &lt;chr&gt;            &lt;chr&gt;              &lt;chr&gt;               &lt;list&gt;\n#&gt; 1            1 Sunil Huffmann   Strawberry yoghurt Lunch only          &lt;dbl&gt; \n#&gt; 2            2 Barclay Lynn     French fries       Lunch only          &lt;dbl&gt; \n#&gt; 3            3 Jayendra Lyne    N/A                Breakfast and lunch &lt;dbl&gt; \n#&gt; 4            4 Leon Rossini     Anchovies          Lunch only          &lt;NULL&gt;\n#&gt; 5            5 Chidiegwu Dunkel Pizza              Breakfast and lunch &lt;chr&gt; \n#&gt; 6            6 Güvenç Attila    Ice cream          Lunch only          &lt;dbl&gt;\n\nΑκριβώς όπως κάναμε με την read_excel(), μπορούμε να παρέχουμε ονόματα στηλών, συμβολοσειρές NA και τύπους στηλών στην read_sheet().\n\nstudents &lt;- read_sheet(\n  students_sheet_id,\n  col_names = c(\"student_id\", \"full_name\", \"favourite_food\", \"meal_plan\", \"age\"),\n  skip = 1,\n  na = c(\"\", \"N/A\"),\n  col_types = \"dcccc\"\n)\n#&gt; ✔ Reading from students.\n#&gt; ✔ Range 2:10000000.\n\nstudents\n#&gt; # A tibble: 6 × 5\n#&gt;   student_id full_name        favourite_food     meal_plan           age  \n#&gt;        &lt;dbl&gt; &lt;chr&gt;            &lt;chr&gt;              &lt;chr&gt;               &lt;chr&gt;\n#&gt; 1          1 Sunil Huffmann   Strawberry yoghurt Lunch only          4    \n#&gt; 2          2 Barclay Lynn     French fries       Lunch only          5    \n#&gt; 3          3 Jayendra Lyne    &lt;NA&gt;               Breakfast and lunch 7    \n#&gt; 4          4 Leon Rossini     Anchovies          Lunch only          &lt;NA&gt; \n#&gt; 5          5 Chidiegwu Dunkel Pizza              Breakfast and lunch five \n#&gt; 6          6 Güvenç Attila    Ice cream          Lunch only          6\n\nΣημειώστε ότι ορίσαμε τους τύπους των στηλών λίγο διαφορετικά εδώ, χρησιμοποιώντας σύντομους κωδικούς. Για παράδειγμα, το “dcccc” σημαίνει “double, character, character, character, character”.\nH ανάγνωση μεμονωμένων φύλλων από το Google Sheets είναι επίσης δυνατή. Ας διαβάσουμε το φύλλο “Torgersen Island” από το penguins Google Sheet:\n\npenguins_sheet_id &lt;- \"1aFu8lnD_g0yjF5O-K6SFgSEWiHPpgvFCF0NY9D6LXnY\"\nread_sheet(penguins_sheet_id, sheet = \"Torgersen Island\")\n#&gt; ✔ Reading from penguins.\n#&gt; ✔ Range ''Torgersen Island''.\n#&gt; # A tibble: 52 × 8\n#&gt;   species island    bill_length_mm bill_depth_mm flipper_length_mm\n#&gt;   &lt;chr&gt;   &lt;chr&gt;     &lt;list&gt;         &lt;list&gt;        &lt;list&gt;           \n#&gt; 1 Adelie  Torgersen &lt;dbl [1]&gt;      &lt;dbl [1]&gt;     &lt;dbl [1]&gt;        \n#&gt; 2 Adelie  Torgersen &lt;dbl [1]&gt;      &lt;dbl [1]&gt;     &lt;dbl [1]&gt;        \n#&gt; 3 Adelie  Torgersen &lt;dbl [1]&gt;      &lt;dbl [1]&gt;     &lt;dbl [1]&gt;        \n#&gt; 4 Adelie  Torgersen &lt;chr [1]&gt;      &lt;chr [1]&gt;     &lt;chr [1]&gt;        \n#&gt; 5 Adelie  Torgersen &lt;dbl [1]&gt;      &lt;dbl [1]&gt;     &lt;dbl [1]&gt;        \n#&gt; 6 Adelie  Torgersen &lt;dbl [1]&gt;      &lt;dbl [1]&gt;     &lt;dbl [1]&gt;        \n#&gt; # ℹ 46 more rows\n#&gt; # ℹ 3 more variables: body_mass_g &lt;list&gt;, sex &lt;chr&gt;, year &lt;dbl&gt;\n\nΜπορείτε να πάρετε μία λίστα με όλα τα φύλλα σε ένα Google Sheet με την sheet_names():\n\nsheet_names(penguins_sheet_id)\n#&gt; [1] \"Torgersen Island\" \"Biscoe Island\"    \"Dream Island\"\n\nΤέλος, όπως και με την read_excel(), μπορούμε να διαβάσουμε σε ένα τμήμα ενός Google Sheet ορίζοντας ένα εύρος (range) στην read_sheet(). Σημειώστε επίσης ότι χρησιμοποιούμε τη συνάρτηση gs4_example() παρακάτω για να εντοπίσουμε ένα παράδειγμα Google Sheet που συνοδεύει το πακέτο googlesheets4.\n\ndeaths_url &lt;- gs4_example(\"deaths\")\ndeaths &lt;- read_sheet(deaths_url, range = \"A5:F15\")\n#&gt; ✔ Reading from deaths.\n#&gt; ✔ Range A5:F15.\ndeaths\n#&gt; # A tibble: 10 × 6\n#&gt;   Name          Profession   Age `Has kids` `Date of birth`    \n#&gt;   &lt;chr&gt;         &lt;chr&gt;      &lt;dbl&gt; &lt;lgl&gt;      &lt;dttm&gt;             \n#&gt; 1 David Bowie   musician      69 TRUE       1947-01-08 00:00:00\n#&gt; 2 Carrie Fisher actor         60 TRUE       1956-10-21 00:00:00\n#&gt; 3 Chuck Berry   musician      90 TRUE       1926-10-18 00:00:00\n#&gt; 4 Bill Paxton   actor         61 TRUE       1955-05-17 00:00:00\n#&gt; 5 Prince        musician      57 TRUE       1958-06-07 00:00:00\n#&gt; 6 Alan Rickman  actor         69 FALSE      1946-02-21 00:00:00\n#&gt; # ℹ 4 more rows\n#&gt; # ℹ 1 more variable: `Date of death` &lt;dttm&gt;\n\n\n20.3.4 Γράφοντας σε Google Sheets\nΜπορείτε να γράψετε από την R σε Google Sheets με την write_sheet(). Το πρώτο όρισμα είναι το πλαίσιο δεδομένων που πρέπει να γραφτεί και το δεύτερο όρισμα είναι το όνομα (ή κάποιο άλλο αναγνωριστικό) του Google Sheet για εγγραφή:\n\nwrite_sheet(bake_sale, ss = \"bake-sale\")\n\nΕάν θέλετε να γράψετε τα δεδομένα σας σε ένα συγκεκριμένο φύλλο μέσα σε ένα Google Sheet, μπορείτε να το καθορίσετε και με το όρισμα sheet.\n\nwrite_sheet(bake_sale, ss = \"bake-sale\", sheet = \"Sales\")\n\n\n20.3.5 Έλεγχος ταυτότητας\nΕνώ μπορείτε να διαβάσετε από ένα δημόσιο Google Sheet χωρίς έλεγχο ταυτότητας με τον Google λογαριασμό σας και με την gs4_deauth(), η ανάγνωση ενός ιδιωτικού φύλλου ή η εγγραφή σε ένα φύλλο απαιτεί έλεγχο ταυτότητας, έτσι ώστε η googlesheets4 να μπορεί να προβάλλει και να διαχειρίζεστε τα δικά σας Google Sheets.\nΌταν επιχειρείτε να διαβάσετε ένα φύλλο που απαιτεί έλεγχο ταυτότητας, η googlesheets4 θα σας κατευθύνει σε ένα πρόγραμμα περιήγησης ιστού με ένα αντίστοιχο μήνυμα, για να συνδεθείτε στον Google λογαριασμό σας και να δώσετε άδεια λειτουργίας με το Google Sheets. Ωστόσο, εάν θέλετε να καθορίσετε έναν συγκεκριμένο λογαριασμό Google, εύρος ελέγχου ταυτότητας κ.λπ., μπορείτε να το κάνετε με την gs4_auth(), η οποία θα επιβάλει τη χρήση ενός διακριτικού που σχετίζεται με ένα συγκεκριμένο email. Για παράδειγμα: gs4_auth(email = \"mine@example.com\"). Για περισσότερες λεπτομέρειες ελέγχου ταυτότητας, συνιστούμε να διαβάσετε τις οδηγίες της googlesheets4 περί ελέγχου ταυτότητας: https://googlesheets4.tidyverse.org/articles/auth.html.\n\n20.3.6 Ασκήσεις\n\nΔιαβάστε το σύνολο δεδομένων students που συναντήσαμε νωρίτερα στο κεφάλαιο με το Excel, όπως και από Google Sheets, χωρίς να πρόσθετα ορίσματα στις συναρτήσεις read_excel() και read_sheet(). Είναι ακριβώς τα ίδια τα πλαίσια δεδομένων που προκύπτουν στην R;\nΑν όχι, σε τι διαφέρουν;\nΔιαβάστε το Google Sheet με όνομα survey από το https://pos.it/r4ds-survey, με την survey_id\" ως μεταβλητή χαρακτήρα και την n_pets ως αριθμητική μεταβλητή.\n\nΔιαβάστε το Google Sheet με όνομα roster από το https://pos.it/r4ds-roster. Το πλαίσιο δεδομένων που προκύπτει θα πρέπει να ονομάζεται roster και θα πρέπει να μοιάζει με το ακόλουθο.\n\n#&gt; # A tibble: 12 × 3\n#&gt;    group subgroup    id\n#&gt;    &lt;dbl&gt; &lt;chr&gt;    &lt;dbl&gt;\n#&gt;  1     1 A            1\n#&gt;  2     1 A            2\n#&gt;  3     1 A            3\n#&gt;  4     1 B            4\n#&gt;  5     1 B            5\n#&gt;  6     1 B            6\n#&gt;  7     1 B            7\n#&gt;  8     2 A            8\n#&gt;  9     2 A            9\n#&gt; 10     2 B           10\n#&gt; 11     2 B           11\n#&gt; 12     2 B           12",
    "crumbs": [
      "Εισαγωγή δεδομένων",
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>Υπολογιστικά φύλλα</span>"
    ]
  },
  {
    "objectID": "spreadsheets.html#σύνοψη",
    "href": "spreadsheets.html#σύνοψη",
    "title": "20  Υπολογιστικά φύλλα",
    "section": "\n20.4 Σύνοψη",
    "text": "20.4 Σύνοψη\nΤο Microsoft Excel και το Google Sheets είναι δύο από τα πιο δημοφιλή συστήματα υπολογιστικών φύλλων. Η δυνατότητα αλληλεπίδρασης με δεδομένα που είναι αποθηκευμένα σε αρχεία Excel και Google Sheets απευθείας από την R είναι μία υπερδύναμη! Σε αυτό το κεφάλαιο μάθατε πώς να διαβάζετε δεδομένα στην R από υπολογιστικά φύλλα από το Excel με την read_excel(), με το πακέτο readxl, και από Google Sheets, με την read_sheet() από το πακέτο googlesheets4. Αυτές οι συναρτήσεις λειτουργούν παρόμοια μεταξύ τους και έχουν παρόμοια ορίσματα για τον καθορισμό ονομάτων στηλών, συμβολοσειρών NA, γραμμών προς παράλειψη από την αρχή του αρχείου που διαβάζετε κ.λπ. Επιπλέον, και οι δύο λειτουργίες καθιστούν δυνατή την ανάγνωση ενός μόνο φύλλου από ένα υπολογιστικό φύλλο.\nΑπό την άλλη, η εγγραφή σε ένα αρχείο Excel απαιτεί διαφορετικό πακέτο και συνάρτηση (writexl::write_xlsx()), ενώ μπορείτε να γράψετε σε ένα Google Sheet με το πακέτο googlesheets4, χρησιμοποιώντας την write_sheet().\nΣτο επόμενο κεφάλαιο, θα μάθετε για μία διαφορετική πηγή δεδομένων και πως να διαβάζετε δεδομένα από αυτήν στην R: τις βάσεις δεδομένων.",
    "crumbs": [
      "Εισαγωγή δεδομένων",
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>Υπολογιστικά φύλλα</span>"
    ]
  },
  {
    "objectID": "databases.html",
    "href": "databases.html",
    "title": "21  Βάσεις Δεδομένων",
    "section": "",
    "text": "21.1 Εισαγωγή\nΈνας τεράστιος όγκος δεδομένων βρίσκετε σε βάσεις δεδομένων, επομένως είναι σημαντικό να γνωρίζετε με ποιο τρόπο μπορείτε να έχετε πρόσβαση σε αυτά. Μερικές φορές μπορεί να ζητήσετε από κάποιον να κατεβάσει για εσάς ένα .csv αρχείο, αλλά αυτό μπορεί να γίνει επώδυνο γρήγορα: κάθε φορά που χρειάζεται να κάνετε μία αλλαγή θα πρέπει να επικοινωνείτε με κάποιον άλλο. Αυτό που Θέλετε είναι να μπορείτε να μεταβείτε απευθείας στη βάση δεδομένων για να λάβετε τα δεδομένα που χρειάζεστε, όταν τα χρειάζεστε.\nΣε αυτό το κεφάλαιο, θα μάθετε πρώτα τα βασικά του πακέτου DBI: πώς να το χρησιμοποιήσετε για να συνδεθείτε σε μία βάση δεδομένων και στη συνέχεια να ανακτήσετε δεδομένα με ένα ερώτημα SQL1. Η SQL, συντομογραφία του structured query language, είναι η κοινή γλώσσα των βάσεων δεδομένων και είναι μία σημαντική γλώσσα για να μάθουν όλοι οι επιστήμονες δεδομένων. Δεν πρόκειται να ξεκινήσουμε με την SQL, αλλά αντ’ αυτού θα σας διδάξουμε το πακέτο dbplyr, το οποία μπορεί να μεταφράσει τον κώδικά σας, γραμμένο με dplyr, σε SQL. Θα την χρησιμοποιήσουμε ως τρόπο για να σας διδάξουμε μερικές από τις πιο σημαντικές δυνατότητες της SQL. Δεν θα γίνετε άριστοι στην SQL μέχρι το τέλος του κεφαλαίου, αλλά θα μπορείτε να είστε σε θέση να προσδιορίσετε τα πιο σημαντικά στοιχεία της και να κατανοήσετε τι κάνουν.",
    "crumbs": [
      "Εισαγωγή δεδομένων",
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>Βάσεις Δεδομένων</span>"
    ]
  },
  {
    "objectID": "databases.html#εισαγωγή",
    "href": "databases.html#εισαγωγή",
    "title": "21  Βάσεις Δεδομένων",
    "section": "",
    "text": "21.1.1 Προαπαιτούμενα\nΣε αυτό το κεφάλαιο, θα παρουσιάσουμε την DBI και το πακέτο dbplyr. Η DBI είναι μία διεπαφή χαμηλού επιπέδου που συνδέεται με βάσεις δεδομένων και εκτελεί SQL. Το dbplyr είναι μία διεπαφή υψηλού επιπέδου που μεταφράζει τον κώδικα dplyr σε ερωτήματα SQL και στη συνέχεια τα εκτελεί με την DBI.\n\nlibrary(DBI)\nlibrary(dbplyr)\nlibrary(tidyverse)",
    "crumbs": [
      "Εισαγωγή δεδομένων",
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>Βάσεις Δεδομένων</span>"
    ]
  },
  {
    "objectID": "databases.html#τα-βασικά-των-βάσεων-δεδομένων",
    "href": "databases.html#τα-βασικά-των-βάσεων-δεδομένων",
    "title": "21  Βάσεις Δεδομένων",
    "section": "\n21.2 Τα βασικά των βάσεων δεδομένων",
    "text": "21.2 Τα βασικά των βάσεων δεδομένων\nΣτο πιο απλό επίπεδο, μπορείτε να σκεφτείτε μία βάση δεδομένων ως μία συλλογή πλαισίων δεδομένων, που ονομάζονται, στην ορολογία των βάσεων δεδομένων, πίνακες. Όπως ένα πλαίσιο δεδομένων έτσι και ένας πίνακας βάσης δεδομένων είναι μία συλλογή από ονομασμένες στήλες, όπου κάθε τιμή στη στήλη είναι του ίδιου τύπου. Υπάρχουν τρεις διαφορές υψηλού επιπέδου μεταξύ των πλαισίων δεδομένων και των πινάκων βάσεων δεδομένων:\n\nΟι πίνακες βάσεων δεδομένων αποθηκεύονται στο δίσκο και μπορεί να είναι αυθαίρετα μεγάλοι. Τα πλαίσια δεδομένων αποθηκεύονται στη μνήμη και είναι θεμελιωδώς περιορισμένα (αν και αυτό το όριο εξακολουθεί να είναι αρκετά μεγάλο για πολλά προβλήματα).\nΟι πίνακες βάσεων δεδομένων έχουν σχεδόν πάντα ευρετήρια (indexes). Όπως το ευρετήριο ενός βιβλίου έτσι και ένα ευρετήριο βάσης δεδομένων καθιστά δυνατή τη γρήγορη εύρεση γραμμών ενδιαφέροντος χωρίς να χρειάζεται να κοιτάξετε κάθε μεμονωμένη γραμμή. Τα πλαίσια δεδομένων και τα tibbles δεν έχουν ευρετήρια, τα data.tables όμως έχουν και είναι ένας από τους λόγους που είναι τόσο γρήγορα.\nΟι περισσότερες κλασικές βάσεις δεδομένων είναι βελτιστοποιημένες για γρήγορη συλλογή δεδομένων και όχι για ανάλυση δεδομένων. Αυτές οι βάσεις δεδομένων ονομάζονται row-oriented επειδή τα δεδομένα αποθηκεύονται σειρά προς σειρά, αντί στήλη προς στήλη όπως στην R. Στις μέρες μας, υπάρχει μεγάλη ανάπτυξη column-oriented βάσεων δεδομένων που κάνουν την ανάλυση δεδομένων πολύ πιο γρήγορη.\n\nΟι βάσεις δεδομένων εκτελούνται από συστήματα διαχείρισης βάσεων δεδομένων (ΣΔΒΔ εν συντομία), τα οποία διατίθενται σε τρεις βασικές μορφές:\n\nΤα ΣΔΒΔ πελάτη-διακομιστή εκτελούνται σε έναν ισχυρό κεντρικό διακομιστή, στον οποίο συνδέετε από τον υπολογιστή σας (τον πελάτη). Είναι εξαιρετικά για την κοινή χρήση δεδομένων με πολλά άτομα μέσα σε μία ομάδα. Κάποια δημοφιλή ΣΔΒΔ πελάτη-διακομιστή είναι τα PostgreSQL, MariaDB, SQL Server και Oracle.\nΤα cloud ΣΔΒΔ, όπως το Snowflake, το RedShift της Amazon και το BigQuery της Google, είναι παρόμοια με τα ΣΔΒΔ πελάτη-διακομιστή, αλλά εκτελούνται στο cloud. Αυτό σημαίνει ότι μπορούν εύκολα να χειριστούν εξαιρετικά μεγάλα σύνολα δεδομένων και μπορούν να παρέχουν αυτόματα περισσότερους υπολογιστικούς πόρους, όποτε αυτοί απαιτούνται.\nΤα in-process ΣΔΒΔ, όπως το SQLite, ή το duckdb, εκτελούνται εξ ολοκλήρου στον υπολογιστή σας. Είναι ιδανικά για εργασία με μεγάλα σύνολα δεδομένων, όπου ο κύριος χρήστης είστε εσείς.",
    "crumbs": [
      "Εισαγωγή δεδομένων",
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>Βάσεις Δεδομένων</span>"
    ]
  },
  {
    "objectID": "databases.html#σύνδεση-σε-μία-βάση-δεδομένων",
    "href": "databases.html#σύνδεση-σε-μία-βάση-δεδομένων",
    "title": "21  Βάσεις Δεδομένων",
    "section": "\n21.3 Σύνδεση σε μία βάση δεδομένων",
    "text": "21.3 Σύνδεση σε μία βάση δεδομένων\nΓια να συνδεθείτε στη βάση δεδομένων από την R, θα χρησιμοποιήσετε δύο πακέτα:\n\nΘα χρησιμοποιείτε πάντα το DBI (database interface) επειδή παρέχει ένα σύνολο γενικών συναρτήσεων που συνδέονται με τη βάση δεδομένων, ανεβάζουν δεδομένα, εκτελούν ερωτήματα SQL κ.λπ.\nΘα χρησιμοποιήσετε επίσης ένα πακέτο προσαρμοσμένο για το ΣΔΒΔ στο οποίο συνδέεστε. Αυτό το πακέτο μεταφράζει τις γενικές DBI εντολές στις λεπτομέρειες που απαιτούνται για ένα συγκεκριμένο ΣΔΒΔ. Συνήθως υπάρχει ένα πακέτο για κάθε ΣΔΒΔ, π.χ. RPostgres για PostgreSQL και RMariaDB για MySQL.\n\nΕάν δεν μπορείτε να βρείτε ένα συγκεκριμένο πακέτο για το ΣΔΒΔ σας, μπορείτε συνήθως να χρησιμοποιήσετε το πακέτο odbc. Αυτό χρησιμοποιεί το πρωτόκολλο ODBC που υποστηρίζεται από αρκετά ΣΔΒΔ. Το odbc απαιτεί λίγο περισσότερο χρόνο στην εγκατάστασή του, γιατί θα χρειαστεί επίσης να εγκαταστήσετε ένα πρόγραμμα οδήγησης ODBC και να πείτε στο πακέτο odbc πού να το βρει.\nΣυγκεκριμένα, δημιουργείτε μία σύνδεση βάσης δεδομένων χρησιμοποιώντας την DBI::dbConnect(). Το πρώτο όρισμα επιλέγει το ΣΔΒΔ2 και, στη συνέχεια, το δεύτερο και τα επόμενα ορίσματα περιγράφουν τον τρόπο σύνδεσης σε αυτό (δηλαδή την τοποθεσία και τα διαπιστευτήρια που χρειάζεστε για την πρόσβαση σε αυτό). Ο παρακάτω κώδικας δείχνει μερικά παραδείγματα:\n\ncon &lt;- DBI::dbConnect(\n  RMariaDB::MariaDB(), \n  username = \"foo\"\n)\ncon &lt;- DBI::dbConnect(\n  RPostgres::Postgres(), \n  hostname = \"databases.mycompany.com\", \n  port = 1234\n)\n\nΟι ακριβείς λεπτομέρειες της σύνδεσης διαφέρουν πολύ από ΣΔΒΔ σε ΣΔΒΔ, οπότε δυστυχώς δεν μπορούμε να καλύψουμε όλες τις λεπτομέρειες εδώ. Αυτό σημαίνει ότι θα χρειαστεί να κάνετε λίγη έρευνα μόνοι σας. Συνήθως μπορείτε να ρωτήσετε άλλους επιστήμονες δεδομένων στην ομάδα σας ή να μιλήσετε με τον διαχειριστή της βάσης δεδομένων σας (database administrator, DBA). Η αρχική ρύθμιση θα χρειαστεί συχνά λίγο ψάξιμο (και ίσως λίγο γκουγκλάρισμα) για να γίνει σωστά, αλλά γενικά θα χρειαστεί να το κάνετε μόνο μία φορά.\n\n21.3.1 Σε αυτό το βιβλίο\nΗ εγκατάσταση ενός ΣΔΒΔ πελάτη-διακομιστή ή cloud θα ήταν οδυνηρή για αυτό το βιβλίο, επομένως θα χρησιμοποιήσουμε αντ ’αυτού ένα in-process ΣΔΒΔ που υπάρχει εξ ολοκλήρου σε ένα πακέτο της R: το duckdb. Χάρη στη μαγεία του DBI, η μόνη διαφορά μεταξύ της χρήσης του duckdb και οποιουδήποτε άλλου ΣΔΒΔ είναι ο τρόπος με τον οποίο θα συνδεθείτε στη βάση δεδομένων. Αυτό το καθιστά υπέροχο να διδαχτεί, καθώς και ο κώδικας είναι εύκολος ως προς την εκτέλεσή του, ενώ μπορείτε να πάρετε εύκολα ό,τι μαθαίνετε και να το εφαρμόσετε αλλού.\nΗ σύνδεση στο duckdb είναι ιδιαίτερα απλή, επειδή οι προεπιλογές δημιουργούν μία προσωρινή βάση δεδομένων που διαγράφεται όταν τερματίσετε την R. Αυτό είναι εξαιρετικό για εκμάθηση, επειδή εγγυάται ότι θα ξεκινάτε από κάτι καθαρό κάθε φορά που κάνετε επανεκκίνηση της R:\n\ncon &lt;- DBI::dbConnect(duckdb::duckdb())\n\nΤο duckdb είναι μία βάση δεδομένων υψηλής απόδοσης που έχει σχεδιαστεί για τις ανάγκες ενός επιστήμονα δεδομένων. Το χρησιμοποιούμε εδώ καθώς είναι πολύ εύκολο για να ξεκινήσετε, αλλά είναι επίσης ικανό να χειρίζεται gigabyte δεδομένων με μεγάλη ταχύτητα. Εάν θέλετε να χρησιμοποιήσετε το duckdb για ένα πραγματικό έργο ανάλυσης δεδομένων, θα χρειαστεί επίσης να δώσετε μία τιμή στο όρισμα dbdir για να δημιουργήσετε μία μόνιμη βάση δεδομένων και να πείτε στο duckdb πού να την αποθηκεύσει. Υποθέτοντας ότι χρησιμοποιείτε ένα project (Κεφάλαιο 6), είναι λογικό να το αποθηκεύσετε στον κατάλογο duckdb του αντίστοιχου project:\n\ncon &lt;- DBI::dbConnect(duckdb::duckdb(), dbdir = \"duckdb\")\n\n\n21.3.2 Φορτώστε μερικά δεδομένα\nΔεδομένου ότι πρόκειται για μία νέα βάση δεδομένων, πρέπει να ξεκινήσουμε προσθέτοντας κάποια δεδομένα. Εδώ θα προσθέσουμε τα σύνολα δεδομένων mpg και diamonds από το πακέτο ggplot2 χρησιμοποιώντας την DBI::dbWriteTable(). Η απλούστερη χρήση της dbWriteTable() χρειάζεται τρία ορίσματα: μία σύνδεση βάσης δεδομένων, το όνομα του πίνακα που θα δημιουργηθεί στη βάση δεδομένων και ένα πλαίσιο δεδομένων που περιέχει κάποια δεδομένα.\n\ndbWriteTable(con, \"mpg\", ggplot2::mpg)\ndbWriteTable(con, \"diamonds\", ggplot2::diamonds)\n\nΕάν χρησιμοποιείτε το duckdb σε πραγματικό project, συνιστούμε ανεπιφύλακτα να μάθετε για τις συναρτήσεις duckdb_read_csv() και duckdb_register_arrow(). Σας δίνουν ισχυρούς και αποδοτικούς τρόπους για να φορτώνετε γρήγορα δεδομένα απευθείας στο duckdb, χωρίς να χρειάζεται να τα φορτώσετε πρώτα στην R. Θα δείξουμε επίσης μία χρήσιμη τεχνική για τη φόρτωση πολλών αρχείων σε μία βάση δεδομένων στην Ενότητα 26.4.1.\n\n21.3.3 Βασικά στοιχεία DBI\nΜπορείτε να ελέγξετε ότι τα δεδομένα έχουν φορτωθεί σωστά χρησιμοποιώντας μερικές άλλες συναρτήσεις DBI: Η dbListTables() παραθέτει όλους τους πίνακες στη βάση δεδομένων3 και η dbReadTable() ανακτά τα περιεχόμενα ενός πίνακα.\n\ndbListTables(con)\n#&gt; [1] \"diamonds\" \"mpg\"\n\ncon |&gt; \n  dbReadTable(\"diamonds\") |&gt; \n  as_tibble()\n#&gt; # A tibble: 53,940 × 10\n#&gt;   carat cut       color clarity depth table price     x     y     z\n#&gt;   &lt;dbl&gt; &lt;fct&gt;     &lt;fct&gt; &lt;fct&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n#&gt; 1  0.23 Ideal     E     SI2      61.5    55   326  3.95  3.98  2.43\n#&gt; 2  0.21 Premium   E     SI1      59.8    61   326  3.89  3.84  2.31\n#&gt; 3  0.23 Good      E     VS1      56.9    65   327  4.05  4.07  2.31\n#&gt; 4  0.29 Premium   I     VS2      62.4    58   334  4.2   4.23  2.63\n#&gt; 5  0.31 Good      J     SI2      63.3    58   335  4.34  4.35  2.75\n#&gt; 6  0.24 Very Good J     VVS2     62.8    57   336  3.94  3.96  2.48\n#&gt; # ℹ 53,934 more rows\n\nΗ dbReadTable() επιστρέφει ένα data.frame επομένως χρησιμοποιούμε την as_tibble() για να το μετατρέψουμε σε tibble, έτσι ώστε να εκτυπώνεται όμορφα.\nΕάν γνωρίζετε ήδη SQL, μπορείτε να χρησιμοποιήσετε την dbGetQuery() για να λάβετε τα αποτελέσματα της εκτέλεσης ενός ερωτήματος στη βάση δεδομένων:\n\nsql &lt;- \"\n  SELECT carat, cut, clarity, color, price \n  FROM diamonds \n  WHERE price &gt; 15000\n\"\nas_tibble(dbGetQuery(con, sql))\n#&gt; # A tibble: 1,655 × 5\n#&gt;   carat cut       clarity color price\n#&gt;   &lt;dbl&gt; &lt;fct&gt;     &lt;fct&gt;   &lt;fct&gt; &lt;int&gt;\n#&gt; 1  1.54 Premium   VS2     E     15002\n#&gt; 2  1.19 Ideal     VVS1    F     15005\n#&gt; 3  2.1  Premium   SI1     I     15007\n#&gt; 4  1.69 Ideal     SI1     D     15011\n#&gt; 5  1.5  Very Good VVS2    G     15013\n#&gt; 6  1.73 Very Good VS1     G     15014\n#&gt; # ℹ 1,649 more rows\n\nΕάν δεν έχετε ξαναδεί SQL, μην ανησυχείτε! Θα μάθετε περισσότερα σύντομα. Αλλά αν διαβάσετε προσεκτικά, μπορεί να μαντέψετε ότι το παραπάνω ερώτημα επιλέγει πέντε στήλες του συνόλου δεδομένων diamonds και όλες τις γραμμές στις οποίες η price είναι μεγαλύτερη από 15.000.",
    "crumbs": [
      "Εισαγωγή δεδομένων",
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>Βάσεις Δεδομένων</span>"
    ]
  },
  {
    "objectID": "databases.html#βασικά-στοιχεία-του-πακέτου-dbplyr",
    "href": "databases.html#βασικά-στοιχεία-του-πακέτου-dbplyr",
    "title": "21  Βάσεις Δεδομένων",
    "section": "\n21.4 Βασικά στοιχεία του πακέτου dbplyr",
    "text": "21.4 Βασικά στοιχεία του πακέτου dbplyr\nΤώρα που συνδεθήκαμε σε μία βάση δεδομένων και φορτώσαμε μερικά δεδομένα, μπορούμε να αρχίσουμε να μαθαίνουμε για το πακέτο dbplyr. Το dbplyr είναι ένα σύστημα υποστήριξης της dplyr, που σημαίνει ότι συνεχίζετε να γράφετε κώδικα dplyr, αλλά το σύστημα υποστήριξης τον εκτελεί διαφορετικά. Σε αυτή την περίπτωση, το dbplyr μεταφράζεται σε SQL. Άλλα συστήματα υποστήριξης περιλαμβάνουν το πακέτο dtplyr που μεταφράζεται σε data.table και το multidplyr που εκτελεί τον κώδικά σας σε πολλαπλούς πυρήνες.\nΓια να χρησιμοποιήσετε το dbplyr, πρέπει πρώτα να χρησιμοποιήσετε την tbl() για να δημιουργήσετε ένα αντικείμενο που αντιπροσωπεύει έναν πίνακα βάσης δεδομένων:\n\ndiamonds_db &lt;- tbl(con, \"diamonds\")\ndiamonds_db\n#&gt; # Source:   table&lt;diamonds&gt; [?? x 10]\n#&gt; # Database: DuckDB v0.10.1 [unknown@Linux 6.5.0-1018-azure:R 4.3.3/:memory:]\n#&gt;   carat cut       color clarity depth table price     x     y     z\n#&gt;   &lt;dbl&gt; &lt;fct&gt;     &lt;fct&gt; &lt;fct&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n#&gt; 1  0.23 Ideal     E     SI2      61.5    55   326  3.95  3.98  2.43\n#&gt; 2  0.21 Premium   E     SI1      59.8    61   326  3.89  3.84  2.31\n#&gt; 3  0.23 Good      E     VS1      56.9    65   327  4.05  4.07  2.31\n#&gt; 4  0.29 Premium   I     VS2      62.4    58   334  4.2   4.23  2.63\n#&gt; 5  0.31 Good      J     SI2      63.3    58   335  4.34  4.35  2.75\n#&gt; 6  0.24 Very Good J     VVS2     62.8    57   336  3.94  3.96  2.48\n#&gt; # ℹ more rows\n\n\n\n\n\n\n\nΥπάρχουν δύο άλλοι συχνοί τρόποι αλληλεπίδρασης με μία βάση δεδομένων. Πρώτον, πολλές εταιρικές βάσεις δεδομένων είναι αρκετά μεγάλες, επομένως χρειάζεστε κάποια ιεραρχία για να κρατήσετε όλους τους πίνακες οργανωμένους. Σε αυτήν την περίπτωση, ίσως χρειαστεί να παρέχετε μία δομή ή έναν κατάλογο και μία δομή, για να επιλέξετε τον πίνακα που σας ενδιαφέρει:\n\ndiamonds_db &lt;- tbl(con, in_schema(\"sales\", \"diamonds\"))\ndiamonds_db &lt;- tbl(con, in_catalog(\"north_america\", \"sales\", \"diamonds\"))\n\nΆλλες φορές μπορεί να θέλετε να χρησιμοποιήσετε το δικό σας ερώτημα SQL ως σημείο εκκίνησης:\n\ndiamonds_db &lt;- tbl(con, sql(\"SELECT * FROM diamonds\"))\n\n\n\n\nΤο παραπάνω αντικείμενο είναι οκνηρό. Όταν χρησιμοποιείτε συναρτήσεις dplyr σε αυτό, το πακέτο dplyr δεν κάνει καμία εργασία: απλώς καταγράφει την ακολουθία πράξεων που θέλετε να εκτελέσετε και τις εκτελεί μόνο όταν χρειάζεται. Για παράδειγμα, πάρτε την ακόλουθη ροή:\n\nbig_diamonds_db &lt;- diamonds_db |&gt; \n  filter(price &gt; 15000) |&gt; \n  select(carat:clarity, price)\n\nbig_diamonds_db\n#&gt; # Source:   SQL [?? x 5]\n#&gt; # Database: DuckDB v0.10.1 [unknown@Linux 6.5.0-1018-azure:R 4.3.3/:memory:]\n#&gt;   carat cut       color clarity price\n#&gt;   &lt;dbl&gt; &lt;fct&gt;     &lt;fct&gt; &lt;fct&gt;   &lt;int&gt;\n#&gt; 1  1.54 Premium   E     VS2     15002\n#&gt; 2  1.19 Ideal     F     VVS1    15005\n#&gt; 3  2.1  Premium   I     SI1     15007\n#&gt; 4  1.69 Ideal     D     SI1     15011\n#&gt; 5  1.5  Very Good G     VVS2    15013\n#&gt; 6  1.73 Very Good G     VS1     15014\n#&gt; # ℹ more rows\n\nΜπορείτε να πείτε ότι αυτό το αντικείμενο αντιπροσωπεύει ένα ερώτημα βάσης δεδομένων, επειδή εκτυπώνει το όνομα του ΣΔΒΔ στο επάνω μέρος και ενώ σας λέει τον αριθμό των στηλών, συνήθως δεν γνωρίζει τον αριθμό των γραμμών. Αυτό συμβαίνει επειδή η εύρεση του συνολικού αριθμού γραμμών απαιτεί συνήθως την εκτέλεση του πλήρους ερωτήματος, κάτι που προσπαθούμε να αποφύγουμε.\nΜπορείτε να δείτε τον κώδικα SQL που δημιουργείται από τη συνάρτηση της dplyr show_query(). Το να γνωρίζετε πως να εφαρμόζετε συναρτήσεις της dplyr, είναι ένας πολύ καλός τρόπος για να μάθετε και SQL! Γράψτε λίγο κώδικα dplyr, πείτε στο dbplyr να τον μεταφράσει σε SQL και, στη συνέχεια, προσπαθήστε να καταλάβετε πώς ταιριάζουν οι δύο γλώσσες.\n\nbig_diamonds_db |&gt;\n  show_query()\n#&gt; &lt;SQL&gt;\n#&gt; SELECT carat, cut, color, clarity, price\n#&gt; FROM diamonds\n#&gt; WHERE (price &gt; 15000.0)\n\nΓια να επαναφέρετε όλα τα δεδομένα στην R, καλείτε την collect(). Στο παρασκήνιο, αυτό δημιουργεί την SQL, καλεί την dbGetQuery() για να πάρει τα δεδομένα και μετά μετατρέπει το αποτέλεσμα σε tibble:\n\nbig_diamonds &lt;- big_diamonds_db |&gt; \n  collect()\nbig_diamonds\n#&gt; # A tibble: 1,655 × 5\n#&gt;   carat cut       color clarity price\n#&gt;   &lt;dbl&gt; &lt;fct&gt;     &lt;fct&gt; &lt;fct&gt;   &lt;int&gt;\n#&gt; 1  1.54 Premium   E     VS2     15002\n#&gt; 2  1.19 Ideal     F     VVS1    15005\n#&gt; 3  2.1  Premium   I     SI1     15007\n#&gt; 4  1.69 Ideal     D     SI1     15011\n#&gt; 5  1.5  Very Good G     VVS2    15013\n#&gt; 6  1.73 Very Good G     VS1     15014\n#&gt; # ℹ 1,649 more rows\n\nΣυνήθως, θα χρησιμοποιήσετε το πακέτο dbplyr για να επιλέξετε τα δεδομένα που θέλετε από τη βάση δεδομένων, εκτελώντας κάποιο απλό φιλτράρισμα και κάποια σύνοψη χρησιμοποιώντας τις μεταφράσεις που περιγράφονται παρακάτω.",
    "crumbs": [
      "Εισαγωγή δεδομένων",
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>Βάσεις Δεδομένων</span>"
    ]
  },
  {
    "objectID": "databases.html#sql",
    "href": "databases.html#sql",
    "title": "21  Βάσεις Δεδομένων",
    "section": "\n21.5 SQL",
    "text": "21.5 SQL\nΤο υπόλοιπο κεφάλαιο θα σας διδάξει λίγη SQL μέσα από το φακό του dbplyr. Είναι μία μάλλον μη παραδοσιακή εισαγωγή στην SQL, αλλά ελπίζουμε ότι θα σας μεταφέρει τα βασικά γρήγορα. Ευτυχώς, αν καταλαβαίνετε το πακέτο dplyr, βρίσκεστε σε ένα εξαιρετικό μέρος για να καταλάβετε γρήγορα και την SQL, καθώς πολλές από τις έννοιες είναι ίδιες.\nΘα εξερευνήσουμε τη σχέση μεταξύ dplyr και SQL χρησιμοποιώντας μερικούς παλιούς φίλους από το πακέτο nycflights13: τα σύνολα δεδομένων flights και planes. Αυτά τα σύνολα δεδομένων είναι εύκολο να εισαχθούν στην δοκιμαστική βάση δεδομένων μας, καθώς το πακέτο dbplyr συνοδεύεται από μία συνάρτηση που αντιγράφει τους πίνακες από το nycflights13 στη βάση:\n\ndbplyr::copy_nycflights13(con)\n#&gt; Creating table: airlines\n#&gt; Creating table: airports\n#&gt; Creating table: flights\n#&gt; Creating table: planes\n#&gt; Creating table: weather\nflights &lt;- tbl(con, \"flights\")\nplanes &lt;- tbl(con, \"planes\")\n\n\n21.5.1 Βασικά στοιχεία SQL\nΤα στοιχεία ανώτατου επιπέδου της SQL ονομάζονται δηλώσεις. Οι κοινές δηλώσεις περιλαμβάνουν την CREATE για τον ορισμό νέων πινάκων, την INSERT για προσθήκη δεδομένων και την SELECT για ανάκτηση δεδομένων. Θα επικεντρωθούμε στις δηλώσεις SELECT που ονομάζονται επίσης ερωτήματα, καθώς είναι σχεδόν αποκλειστικά αυτό που θα χρησιμοποιήσετε ως επιστήμονας δεδομένων.\nΈνα ερώτημα αποτελείται από συνθήκες. Υπάρχουν πέντε σημαντικές συνθήκες: SELECT, FROM, WHERE, ORDER BY, και GROUP BY. Κάθε ερώτημα πρέπει να έχει τις SELECT4 και FROM5 και το απλούστερο ερώτημα είναι το SELECT * FROM table, το οποίο επιλέγει όλες τις στήλες από τον καθορισμένο πίνακα . Το αποτέλεσμα του dbplyr για έναν καθαρό πίνακα είναι :\n\nflights |&gt; show_query()\n#&gt; &lt;SQL&gt;\n#&gt; SELECT *\n#&gt; FROM flights\nplanes |&gt; show_query()\n#&gt; &lt;SQL&gt;\n#&gt; SELECT *\n#&gt; FROM planes\n\nΟι WHERE και ORDER BY ελέγχουν ποιες γραμμές θα περιέχονται στην έξοδο και πως αυτές θα είναι ταξινομημένες.\n\nflights |&gt; \n  filter(dest == \"IAH\") |&gt; \n  arrange(dep_delay) |&gt;\n  show_query()\n#&gt; &lt;SQL&gt;\n#&gt; SELECT flights.*\n#&gt; FROM flights\n#&gt; WHERE (dest = 'IAH')\n#&gt; ORDER BY dep_delay\n\nΗ GROUP BY μετατρέπει το ερώτημα σε μία σύνοψη, προκαλώντας μία συνάθροιση των δεδομένων:\n\nflights |&gt; \n  group_by(dest) |&gt; \n  summarize(dep_delay = mean(dep_delay, na.rm = TRUE)) |&gt; \n  show_query()\n#&gt; &lt;SQL&gt;\n#&gt; SELECT dest, AVG(dep_delay) AS dep_delay\n#&gt; FROM flights\n#&gt; GROUP BY dest\n\nΥπάρχουν δύο σημαντικές διαφορές μεταξύ των συναρτήσεων της dplyr και των συνθηκών SELECT:\n\nΣτην SQL, τα πεζά και κεφαλαία δεν έχουν σημασία: μπορείτε να γράψετε select, SELECT, ή ακόμα και SeLeCt. Σε αυτό το βιβλίο θα επιμείνουμε στη συχνή σύνταξη λέξεων-κλειδιών SQL με κεφαλαία για να τις ξεχωρίζουμε από τα ονόματα πινάκων ή μεταβλητών.\nΣτην SQL, η σειρά έχει σημασία: πρέπει πάντα να γράφετε τις συνθήκες με την εξής σειρά SELECT, FROM, WHERE, GROUP BY, ORDER BY. Η σειρά αυτή όμως δεν είναι ίδια με τον τρόπο όπου πραγματικά, οι συνθήκες, αξιολογούνται. Ξεκινά η FROM, μετά η WHERE, GROUP BY, SELECT και η ORDER BY.\n\nΟι ακόλουθες ενότητες εξερευνούν κάθε συνθήκη με περισσότερες λεπτομέρειες.\n\n\n\n\n\n\nΣημειώστε ότι ενώ η SQL είναι καθιερωμένη, είναι εξαιρετικά περίπλοκη και καμία βάση δεδομένων δεν την ακολουθεί ακριβώς. Ενώ τα κύρια στοιχεία στα οποία θα επικεντρωθούμε σε αυτό το βιβλίο είναι παρόμοια μεταξύ των ΣΔΒΔ, υπάρχουν πολλές μικρές παραλλαγές. Ευτυχώς, το πακέτο dbplyr έχει σχεδιαστεί για να χειρίζεται αυτό το πρόβλημα και δημιουργεί διαφορετικές μεταφράσεις για διαφορετικές βάσεις δεδομένων. Δεν είναι τέλεια, αλλά βελτιώνεται συνεχώς και στην περίπτωση που αντιμετωπίσετε κάποιο πρόβλημα, μπορείτε να το υποβάλετε στο GitHub για να μας βοηθήσετε να τα πάμε καλύτερα.\n\n\n\n\n21.5.2 SELECT\nΗ συνθήκη SELECT είναι “η μηχανή” των ερωτημάτων και εκτελεί την ίδια δουλειά με τις select(), mutate(), rename(), relocate() και, όπως θα μάθετε στην επόμενη ενότητα, την summarize().\nΟι select(), rename(), και relocate() έχουν αρκετά άμεσες μεταφράσεις στην SELECT καθώς απλώς επηρεάζουν το πού εμφανίζεται μία στήλη (αν εμφανίζεται καθόλου) μαζί με το όνομά της:\n\nplanes |&gt; \n  select(tailnum, type, manufacturer, model, year) |&gt; \n  show_query()\n#&gt; &lt;SQL&gt;\n#&gt; SELECT tailnum, \"type\", manufacturer, model, \"year\"\n#&gt; FROM planes\n\nplanes |&gt; \n  select(tailnum, type, manufacturer, model, year) |&gt; \n  rename(year_built = year) |&gt; \n  show_query()\n#&gt; &lt;SQL&gt;\n#&gt; SELECT tailnum, \"type\", manufacturer, model, \"year\" AS year_built\n#&gt; FROM planes\n\nplanes |&gt; \n  select(tailnum, type, manufacturer, model, year) |&gt; \n  relocate(manufacturer, model, .before = type) |&gt; \n  show_query()\n#&gt; &lt;SQL&gt;\n#&gt; SELECT tailnum, manufacturer, model, \"type\", \"year\"\n#&gt; FROM planes\n\nΑυτό το παράδειγμα δείχνει επίσης πώς η SQL αλλάζει ονόματα σε στήλες. Στην ορολογία της SQL η μετονομασία ονομάζεται aliasing και γίνεται με την AS. Σημειώστε ότι σε αντίθεση με την mutate(), το παλιό όνομα βρίσκεται στα αριστερά και το νέο όνομα βρίσκεται στα δεξιά.\n\n\n\n\n\n\nΣτα παραπάνω παραδείγματα σημειώστε ότι τα \"year\" και \"type\" είναι μέσα σε διπλά εισαγωγικά. Αυτό συμβαίνει επειδή πρόκειται για δεσμευμένες λέξεις στο duckdb, κι επομένως το πακέτο dbplyr τις παραθέτει για να αποφύγει οποιαδήποτε πιθανή σύγχυση μεταξύ των ονομάτων στηλών/πινάκων και των τελεστών SQL.\nΌταν εργάζεστε με άλλες βάσεις δεδομένων, είναι πιθανό να βλέπετε εισαγωγικά στα ονόματα κάθε μεταβλητής, επειδή μόνο λίγα πακέτα πελατών, όπως το duckdb, γνωρίζουν ποιες είναι όλες οι λέξεις που ανήκουν στο σύνολο των δεσμευμένων λέξεων τους, επομένως βάζουν σε εισαγωγικά τα πάντα για ασφάλεια.\nSELECT \"tailnum\", \"type\", \"manufacturer\", \"model\", \"year\"\nFROM \"planes\"\nΆλλα συστήματα βάσεων δεδομένων χρησιμοποιούν backticks αντί για εισαγωγικά:\nSELECT `tailnum`, `type`, `manufacturer`, `model`, `year`\nFROM `planes`\n\n\n\nΟι μεταφράσεις για την mutate() είναι εξίσου απλές: κάθε μεταβλητή γίνεται μία νέα έκφραση στην SELECT:\n\nflights |&gt; \n  mutate(\n    speed = distance / (air_time / 60)\n  ) |&gt; \n  show_query()\n#&gt; &lt;SQL&gt;\n#&gt; SELECT flights.*, distance / (air_time / 60.0) AS speed\n#&gt; FROM flights\n\nΘα επανέλθουμε στη μετάφραση μεμονωμένων στοιχείων (όπως το /) στην Ενότητα 21.6.\n\n21.5.3 FROM\nΗ συνθήκη FROM ορίζει την πηγή των δεδομένων. Δεν θα έχει πολύ ενδιαφέρον για λίγο, επειδή χρησιμοποιούμε απλά μεμονωμένους πίνακες. Θα δείτε όμως πιο περίπλοκα παραδείγματα μόλις δούμε τις συναρτήσεις ένωσης (join).\n\n21.5.4 GROUP BY\nH group_by() μεταφράζεται στην συνθήκη GROUP BY6 και η summarize() μεταφράζεται στην συνθήκη SELECT:\n\ndiamonds_db |&gt; \n  group_by(cut) |&gt; \n  summarize(\n    n = n(),\n    avg_price = mean(price, na.rm = TRUE)\n  ) |&gt; \n  show_query()\n#&gt; &lt;SQL&gt;\n#&gt; SELECT cut, COUNT(*) AS n, AVG(price) AS avg_price\n#&gt; FROM diamonds\n#&gt; GROUP BY cut\n\nΘα επανέλθουμε στο τι συμβαίνει με τη μετάφραση των n() και mean() στην Ενότητα 21.6.\n\n21.5.5 WHERE\nΗ filter()μεταφράζεται στη συνθήκη WHERE:\n\nflights |&gt; \n  filter(dest == \"IAH\" | dest == \"HOU\") |&gt; \n  show_query()\n#&gt; &lt;SQL&gt;\n#&gt; SELECT flights.*\n#&gt; FROM flights\n#&gt; WHERE (dest = 'IAH' OR dest = 'HOU')\n\nflights |&gt; \n  filter(arr_delay &gt; 0 & arr_delay &lt; 20) |&gt; \n  show_query()\n#&gt; &lt;SQL&gt;\n#&gt; SELECT flights.*\n#&gt; FROM flights\n#&gt; WHERE (arr_delay &gt; 0.0 AND arr_delay &lt; 20.0)\n\nΥπάρχουν μερικές σημαντικές λεπτομέρειες που πρέπει να σημειωθούν εδώ:\n\nΟ τελεστής | γίνεται OR και το & γίνεται AND.\nΗ SQL χρησιμοποιεί τον τελεστή = για σύγκριση, κι όχι τον ==. Η SQL δεν έχει ανάθεση, επομένως δεν υπάρχει πιθανότητα σύγχυσης εκεί.\nΗ SQL χρησιμοποιεί μόνο '' για συμβολοσειρές, όχι \"\". Ακόμη, στην SQL, το \"\" χρησιμοποιείται για τον προσδιορισμό μεταβλητών, όπως το `` της R.\n\nΈνας άλλος χρήσιμος τελεστής της SQL είναι ο IN, ο οποίος είναι πολύ κοντά στον %in% της R:\n\nflights |&gt; \n  filter(dest %in% c(\"IAH\", \"HOU\")) |&gt; \n  show_query()\n#&gt; &lt;SQL&gt;\n#&gt; SELECT flights.*\n#&gt; FROM flights\n#&gt; WHERE (dest IN ('IAH', 'HOU'))\n\nΗ SQL χρησιμοποιεί NULL αντί για NA. Τα NULL συμπεριφέρονται παρόμοια με τα NA. Η κύρια διαφορά είναι ότι, ενώ μπορούν να επηρεάσουν αποτελέσματα στις συγκρίσεις και στην αριθμητική, απορρίπτονται σιωπηλά κατά τη σύνοψη. Το πακέτο dbplyr θα σας υπενθυμίσει αυτήν τη συμπεριφορά την πρώτη φορά που θα τη συναντήσετε:\n\nflights |&gt; \n  group_by(dest) |&gt; \n  summarize(delay = mean(arr_delay))\n#&gt; Warning: Missing values are always removed in SQL aggregation functions.\n#&gt; Use `na.rm = TRUE` to silence this warning\n#&gt; This warning is displayed once every 8 hours.\n#&gt; # Source:   SQL [?? x 2]\n#&gt; # Database: DuckDB v0.10.1 [unknown@Linux 6.5.0-1018-azure:R 4.3.3/:memory:]\n#&gt;   dest  delay\n#&gt;   &lt;chr&gt; &lt;dbl&gt;\n#&gt; 1 ATL   11.3 \n#&gt; 2 CLT    7.36\n#&gt; 3 MCO    5.45\n#&gt; 4 MDW   12.4 \n#&gt; 5 HOU    7.18\n#&gt; 6 SDF   12.7 \n#&gt; # ℹ more rows\n\nΕάν θέλετε να μάθετε περισσότερα για το πώς λειτουργεί τοNULL, μπορεί να σας φανεί χρήσιμο το “Three valued logic” του Markus Winand.\nΣε γενικές γραμμές, μπορείτε να εργαστείτε με NULL τιμές χρησιμοποιώντας τις συναρτήσεις που θα χρησιμοποιούσατε για NA στην R:\n\nflights |&gt; \n  filter(!is.na(dep_delay)) |&gt; \n  show_query()\n#&gt; &lt;SQL&gt;\n#&gt; SELECT flights.*\n#&gt; FROM flights\n#&gt; WHERE (NOT((dep_delay IS NULL)))\n\nΑυτό το ερώτημα SQL απεικονίζει ένα από τα μειονεκτήματα του dbplyr: ενώ η SQL είναι σωστή, το ερώτημα δεν είναι τόσο απλό όσο θα μπορούσατε να το γράψετε χειροκίνητα. Σε αυτήν την περίπτωση, μπορείτε να αποφύγετε τις παρενθέσεις και να χρησιμοποιήσετε έναν ειδικό τελεστή που είναι πιο ευανάγνωστος:\nWHERE \"dep_delay\" IS NOT NULL\nΣημειώστε ότι εάν εφαρμόσετε την filter() σε μία μεταβλητή που δημιουργήσατε χρησιμοποιώντας μία σύνοψη, το dbplyr θα δημιουργήσει μία συνθήκη HAVING αντί για μία συνθήκη WHERE. Αυτή είναι μία από τις ιδιοσυγκρασίες της SQL: η WHERE αξιολογείται πριν από τη SELECT και τη GROUP BY. Επομένως η SQL χρειάζεται μία άλλη συνθήκη που θα αξιολογηθεί στη συνέχεια.\n\ndiamonds_db |&gt; \n  group_by(cut) |&gt; \n  summarize(n = n()) |&gt; \n  filter(n &gt; 100) |&gt; \n  show_query()\n#&gt; &lt;SQL&gt;\n#&gt; SELECT cut, COUNT(*) AS n\n#&gt; FROM diamonds\n#&gt; GROUP BY cut\n#&gt; HAVING (COUNT(*) &gt; 100.0)\n\n\n21.5.6 ORDER BY\nΗ ταξινόμηση γραμμών περιλαμβάνει μία απλή μετάφραση από την arrange() στην συνθήκη ORDER BY:\n\nflights |&gt; \n  arrange(year, month, day, desc(dep_delay)) |&gt; \n  show_query()\n#&gt; &lt;SQL&gt;\n#&gt; SELECT flights.*\n#&gt; FROM flights\n#&gt; ORDER BY \"year\", \"month\", \"day\", dep_delay DESC\n\nΠαρατηρήστε πώς η desc() μεταφράζεται στην DESC: αυτή είναι μία από τις πολλές συναρτήσεις της dplyr των οποίων το όνομα εμπνεύστηκαν από την SQL.\n\n21.5.7 Υποερωτήματα\nΜερικές φορές δεν είναι δυνατό να μεταφραστεί μία ροή με συναρτήσεις dplyr σε μία μεμονωμένη δήλωση SELECT και έτσι πρέπει να χρησιμοποιήσετε ένα υποερώτημα (ή εμφολευμένο ερώτημα). Ένα υποερώτημα είναι απλώς ένα ερώτημα που χρησιμοποιείται ως πηγή δεδομένων στην συνθήκη FROM, αντί για τον συνηθισμένο πίνακα.\nΤο dbplyr συνήθως χρησιμοποιεί υποερωτήματα για να αντιμετωπίσει τους περιορισμούς της SQL. Για παράδειγμα, οι εκφράσεις στην συνθήκη SELECT δεν μπορούν να αναφέρονται σε στήλες που μόλις δημιουργήθηκαν. Αυτό σημαίνει ότι η ακόλουθη (απλή) ροή συναρτήσεων dplyr πρέπει να συμβεί σε δύο βήματα: το πρώτο (εσωτερικό) ερώτημα υπολογίζει την year1 και στη συνέχεια το δεύτερο (εξωτερικό) ερώτημα μπορεί να υπολογίσει το year2.\n\nflights |&gt; \n  mutate(\n    year1 = year + 1,\n    year2 = year1 + 1\n  ) |&gt; \n  show_query()\n#&gt; &lt;SQL&gt;\n#&gt; SELECT q01.*, year1 + 1.0 AS year2\n#&gt; FROM (\n#&gt;   SELECT flights.*, \"year\" + 1.0 AS year1\n#&gt;   FROM flights\n#&gt; ) q01\n\nΑυτό θα το δείτε επίσης αν επιχειρήσετε να εφαρμόσετε την filter() σε μία μεταβλητή που μόλις δημιουργήσατε. Θυμηθείτε, παρόλο που η WHERE είναι γραμμένη μετά τη SELECT, αξιολογείται πριν από αυτή, επομένως χρειαζόμαστε ένα υποερώτημα σε αυτό το (απλό) παράδειγμα:\n\nflights |&gt; \n  mutate(year1 = year + 1) |&gt; \n  filter(year1 == 2014) |&gt; \n  show_query()\n#&gt; &lt;SQL&gt;\n#&gt; SELECT q01.*\n#&gt; FROM (\n#&gt;   SELECT flights.*, \"year\" + 1.0 AS year1\n#&gt;   FROM flights\n#&gt; ) q01\n#&gt; WHERE (year1 = 2014.0)\n\nΜερικές φορές το dbplyr θα δημιουργήσει ένα υποερώτημα που δεν χρειάζεται, επειδή δεν γνωρίζει ακόμη πώς να βελτιστοποιήσει αυτήν τη μετάφραση. Καθώς η dbplyr βελτιώνεται με την πάροδο του χρόνου, αυτές οι περιπτώσεις θα γίνονται πιο σπάνιες αλλά πιθανότατα δεν θα εξαφανιστούν ποτέ.\n\n21.5.8 Ενώσεις (Joins)\nΕάν είστε εξοικειωμένοι με τις ενώσεις της dplyr, οι ενώσεις της SQL είναι αρκετά παρόμοιες. Ορίστε ένα απλό παράδειγμα:\n\nflights |&gt; \n  left_join(planes |&gt; rename(year_built = year), by = \"tailnum\") |&gt; \n  show_query()\n#&gt; &lt;SQL&gt;\n#&gt; SELECT\n#&gt;   flights.*,\n#&gt;   planes.\"year\" AS year_built,\n#&gt;   \"type\",\n#&gt;   manufacturer,\n#&gt;   model,\n#&gt;   engines,\n#&gt;   seats,\n#&gt;   speed,\n#&gt;   engine\n#&gt; FROM flights\n#&gt; LEFT JOIN planes\n#&gt;   ON (flights.tailnum = planes.tailnum)\n\nΤο κύριο στοιχείο που πρέπει να προσέξετε εδώ είναι η σύνταξη: οι ενώσεις της SQL χρησιμοποιούν υποσυνθήκες της FROM για να επιστρέψουν πρόσθετους πίνακες, ενώ καθορίζουν το πώς σχετίζονται οι πίνακες με το ON.\nΤα ονόματα της dplyr για αυτές τις συναρτήσεις είναι τόσο στενά συνδεδεμένα με την SQL που μπορείτε εύκολα να μαντέψετε την αντιστοίχιση σε SQL για τις inner_join(), right_join() και full_join():\nSELECT flights.*, \"type\", manufacturer, model, engines, seats, speed\nFROM flights\nINNER JOIN planes ON (flights.tailnum = planes.tailnum)\n\nSELECT flights.*, \"type\", manufacturer, model, engines, seats, speed\nFROM flights\nRIGHT JOIN planes ON (flights.tailnum = planes.tailnum)\n\nSELECT flights.*, \"type\", manufacturer, model, engines, seats, speed\nFROM flights\nFULL JOIN planes ON (flights.tailnum = planes.tailnum)\nΕίναι πιθανό να χρειαστείτε πολλές ενώσεις όταν εργάζεστε με δεδομένα από μία βάση δεδομένων. Αυτό συμβαίνει επειδή οι πίνακες βάσεων δεδομένων αποθηκεύονται συχνά σε μία εξαιρετικά κανονικοποιημένη μορφή, όπου κάθε “γεγονός” αποθηκεύεται σε ένα μόνο μέρος, οπότε για να διατηρήσετε ένα πλήρες σύνολο δεδομένων για ανάλυση, πρέπει να πλοηγηθείτε σε ένα σύνθετο δίκτυο πινάκων που συνδέονται με πρωτεύοντα και ξένα κλειδιά. Αν συναντήσετε αυτό το σενάριο, το πακέτο dm, των Tobias Schieferdecker, Kirill Müller και Darko Bergant, θα κάνει τη ζωή σας λίγο πιο εύκολη. Μπορεί να καθορίσει αυτόματα τις συνδέσεις μεταξύ πινάκων χρησιμοποιώντας τους περιορισμούς που τα DBA συχνά παρέχουν, να οπτικοποιήσει τις συνδέσεις και να δημιουργήσει τις συνδέσεις που χρειάζεστε για να συνδέσετε έναν πίνακα με έναν άλλο.\n\n21.5.9 Λοιπές συναρτήσεις\nΤο dbplyr μεταφράζει επίσης και άλλες συναρτήσεις όπως οι distinct(), slice_*(), και intersect(), και μία ολοένα αυξανόμενη γκάμα από συναρτήσεις του πακέτου tidyr όπως οι pivot_longer() και pivot_wider(). Ο πιο εύκολος τρόπος για να δείτε το πλήρες σύνολο των διαθέσιμων, προς το παρόν, μεταφράσεων είναι να επισκεφτείτε τον ιστότοπο του dbplyr: https://dbplyr.tidyverse.org/reference/.\n\n21.5.10 Ασκήσεις\n\nΣε τι μεταφράζεται η distinct();\nΣε τι η head();\n\nΕξηγήστε τι κάνει καθένα από τα ακόλουθα ερωτήματα SQL και δοκιμάστε να τα δημιουργήσετε ξανά χρησιμοποιώντας το πακέτο dbplyr.\nSELECT * \nFROM flights\nWHERE dep_delay &lt; arr_delay\n\nSELECT *, distance / (air_time / 60) AS speed\nFROM flights",
    "crumbs": [
      "Εισαγωγή δεδομένων",
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>Βάσεις Δεδομένων</span>"
    ]
  },
  {
    "objectID": "databases.html#sec-sql-expressions",
    "href": "databases.html#sec-sql-expressions",
    "title": "21  Βάσεις Δεδομένων",
    "section": "\n21.6 Μεταφράσεις συναρτήσεων",
    "text": "21.6 Μεταφράσεις συναρτήσεων\nΜέχρι στιγμής έχουμε επικεντρωθεί στη μεγάλη εικόνα του πώς οι συναρτήσεις της dplyr μεταφράζονται στις συνθήκες ενός ερωτήματος. Τώρα θα εμβαθύνουμε λίγο και θα μιλήσουμε για τη μετάφραση των συναρτήσεων της R που λειτουργούν με μεμονωμένες στήλες, π.χ., τι συμβαίνει όταν χρησιμοποιείτε την mean(x) σε ένα summarize();\nΓια να δούμε τι συμβαίνει, θα χρησιμοποιήσουμε μερικές μικρές βοηθητικές συναρτήσεις που εκτελούν μία summarize() ή μία mutate() και εμφανίζουν το SQL ερώτημα που δημιουργήθηκε. Αυτό θα κάνει λίγο πιο εύκολο το να εξερευνήσετε μερικές παραλλαγές και να δείτε πως μπορεί να διαφέρουν οι συνόψεις και οι μετασχηματισμοί.\n\nsummarize_query &lt;- function(df, ...) {\n  df |&gt; \n    summarize(...) |&gt; \n    show_query()\n}\nmutate_query &lt;- function(df, ...) {\n  df |&gt; \n    mutate(..., .keep = \"none\") |&gt; \n    show_query()\n}\n\nΑς επικεντρωθούμε σε μερικές συνόψεις! Κοιτάζοντας τον παρακάτω κώδικα θα παρατηρήσετε ότι ορισμένες συναρτήσεις σύνοψης, όπως η mean(), έχουν σχετικά απλή μετάφραση ενώ άλλες, όπως η median(), είναι πολύ πιο περίπλοκες. Η πολυπλοκότητα είναι συνήθως μεγαλύτερη για συναρτήσεις που είναι συχνές στη στατιστική, αλλά λιγότερο συχνές σε βάσεις δεδομένων.\n\nflights |&gt; \n  group_by(year, month, day) |&gt;  \n  summarize_query(\n    mean = mean(arr_delay, na.rm = TRUE),\n    median = median(arr_delay, na.rm = TRUE)\n  )\n#&gt; `summarise()` has grouped output by \"year\" and \"month\". You can override\n#&gt; using the `.groups` argument.\n#&gt; &lt;SQL&gt;\n#&gt; SELECT\n#&gt;   \"year\",\n#&gt;   \"month\",\n#&gt;   \"day\",\n#&gt;   AVG(arr_delay) AS mean,\n#&gt;   PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY arr_delay) AS median\n#&gt; FROM flights\n#&gt; GROUP BY \"year\", \"month\", \"day\"\n\nΗ μετάφραση των συναρτήσεων σύνοψης γίνεται πιο περίπλοκη όταν χρησιμοποιούνται μέσα σε μία mutate(), επειδή πρέπει να μετατραπούν στις λεγόμενες συναρτήσεις window. Στην SQL, μετατρέπετε μία συνηθισμένη συνάρτηση συνάθροισης σε συνάρτηση window προσθέτοντας το OVER μετά από αυτήν:\n\nflights |&gt; \n  group_by(year, month, day) |&gt;  \n  mutate_query(\n    mean = mean(arr_delay, na.rm = TRUE),\n  )\n#&gt; &lt;SQL&gt;\n#&gt; SELECT\n#&gt;   \"year\",\n#&gt;   \"month\",\n#&gt;   \"day\",\n#&gt;   AVG(arr_delay) OVER (PARTITION BY \"year\", \"month\", \"day\") AS mean\n#&gt; FROM flights\n\nΣτην SQL, η έκφραση GROUP BY χρησιμοποιείται αποκλειστικά για συνόψεις, επομένως εδώ μπορείτε να δείτε ότι η ομαδοποίηση έχει μετακινηθεί από το όρισμα PARTITION BY στο OVER.\nΟι συναρτήσεις window περιλαμβάνουν όλες τις συναρτήσεις που κοιτάζουν προς τα εμπρός ή προς τα πίσω, όπως η lead() και η lag(), που κοιτάζουν την τιμή “πριν” ή “μετά” αντίστοιχα:\n\nflights |&gt; \n  group_by(dest) |&gt;  \n  arrange(time_hour) |&gt; \n  mutate_query(\n    lead = lead(arr_delay),\n    lag = lag(arr_delay)\n  )\n#&gt; &lt;SQL&gt;\n#&gt; SELECT\n#&gt;   dest,\n#&gt;   LEAD(arr_delay, 1, NULL) OVER (PARTITION BY dest ORDER BY time_hour) AS lead,\n#&gt;   LAG(arr_delay, 1, NULL) OVER (PARTITION BY dest ORDER BY time_hour) AS lag\n#&gt; FROM flights\n#&gt; ORDER BY time_hour\n\nΕδώ είναι σημαντικό να εφαρμόσετε την arrange() στα δεδομένα, επειδή οι πίνακες SQL δεν έχουν εγγενή σειρά. Στην πραγματικότητα, αν δεν χρησιμοποιήσετε την arrange(), μπορεί να πάρετε τις γραμμές με διαφορετική σειρά κάθε φορά! Σημειώστε ότι για τις συναρτήσεις window, οι πληροφορίες ταξινόμησης επαναλαμβάνονται: η συνθήκη ORDER BY του κύριου ερωτήματος δεν εφαρμόζεται αυτόματα στις συναρτήσεις window.\nΜία άλλη σημαντική συνάρτηση της SQL είναι η CASE WHEN. Χρησιμοποιείται ως μετάφραση των if_else() και case_when(), των συναρτήσεων του πακέτου dplyr που ενέπνευσε. Ακολουθούν μερικά απλά παραδείγματα:\n\nflights |&gt; \n  mutate_query(\n    description = if_else(arr_delay &gt; 0, \"delayed\", \"on-time\")\n  )\n#&gt; &lt;SQL&gt;\n#&gt; SELECT CASE WHEN (arr_delay &gt; 0.0) THEN 'delayed' WHEN NOT (arr_delay &gt; 0.0) THEN 'on-time' END AS description\n#&gt; FROM flights\nflights |&gt; \n  mutate_query(\n    description = \n      case_when(\n        arr_delay &lt; -5 ~ \"early\", \n        arr_delay &lt; 5 ~ \"on-time\",\n        arr_delay &gt;= 5 ~ \"late\"\n      )\n  )\n#&gt; &lt;SQL&gt;\n#&gt; SELECT CASE\n#&gt; WHEN (arr_delay &lt; -5.0) THEN 'early'\n#&gt; WHEN (arr_delay &lt; 5.0) THEN 'on-time'\n#&gt; WHEN (arr_delay &gt;= 5.0) THEN 'late'\n#&gt; END AS description\n#&gt; FROM flights\n\nΗ CASE WHEN χρησιμοποιείται επίσης για ορισμένες άλλες συναρτήσεις που δεν έχουν άμεση μετάφραση από την R στην SQL. Ένα καλό παράδειγμα αυτού είναι η cut():\n\nflights |&gt; \n  mutate_query(\n    description =  cut(\n      arr_delay, \n      breaks = c(-Inf, -5, 5, Inf), \n      labels = c(\"early\", \"on-time\", \"late\")\n    )\n  )\n#&gt; &lt;SQL&gt;\n#&gt; SELECT CASE\n#&gt; WHEN (arr_delay &lt;= -5.0) THEN 'early'\n#&gt; WHEN (arr_delay &lt;= 5.0) THEN 'on-time'\n#&gt; WHEN (arr_delay &gt; 5.0) THEN 'late'\n#&gt; END AS description\n#&gt; FROM flights\n\nΤο dbplyr μεταφράζει επίσης κοινές συναρτήσεις χειρισμού συμβολοσειράς και ημερομηνίας, για τις οποίες μπορείτε να μάθετε στο vignette(\"translation-function\", package = \"dbplyr\"). Οι μεταφράσεις του dbplyr σίγουρα δεν είναι τέλειες και υπάρχουν πολλές συναρτήσεις της R που δεν έχουν μεταφραστεί ακόμα, όμως το dbplyr κάνει εκπληκτικά καλή δουλειά καλύπτοντας τις λειτουργίες που θα χρησιμοποιείτε τις περισσότερες φορές.",
    "crumbs": [
      "Εισαγωγή δεδομένων",
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>Βάσεις Δεδομένων</span>"
    ]
  },
  {
    "objectID": "databases.html#σύνοψη",
    "href": "databases.html#σύνοψη",
    "title": "21  Βάσεις Δεδομένων",
    "section": "\n21.7 Σύνοψη",
    "text": "21.7 Σύνοψη\nΣε αυτό το κεφάλαιο μάθατε πώς να έχετε πρόσβαση σε δεδομένα από βάσεις δεδομένων. Εστιάσαμε στο dbplyr, ένα “σύστημα υποστήριξης” του dplyr που σας επιτρέπει να γράψετε κώδικα dplyr με τον οποίο είστε εξοικειωμένοι και να μεταφραστεί αυτόματα σε SQL. Χρησιμοποιήσαμε, ακόμα, αυτή τη μετάφραση για να σας μάθουμε λίγη SQL. Είναι σημαντικό να μάθετε κάποια κομμάτια της SQL καθώς είναι η πιο συχνά χρησιμοποιούμενη γλώσσα για εργασία με δεδομένα και η μερική γνώση θα σας διευκολύνει να επικοινωνείτε με άλλους ανθρώπους, σχετικούς με δεδομένα, που δεν χρησιμοποιούν R. Εάν έχετε ολοκληρώσει αυτό το κεφάλαιο και θέλετε να μάθετε περισσότερα για την SQL, έχουμε δύο συστάσεις:\n\nΤο SQL for Data Scientists από την Renée M. P. Teate είναι μία εισαγωγή στην SQL που έχει σχεδιαστεί ειδικά για τις ανάγκες των επιστημόνων δεδομένων και περιλαμβάνει παραδείγματα του είδους των δεδομένων που είναι πολύ πιθανό να συναντηθούν σε πραγματικές επιχειρήσεις.\nΤο Practical SQL από τον Anthony DeBarros είναι γραμμένο από την οπτική γωνία ενός δημοσιογράφου δεδομένων (ένας επιστήμονας δεδομένων που ειδικεύεται στην αφήγηση συναρπαστικών ιστοριών) και αναφέρεται σε περισσότερες λεπτομέρειες σχετικά με την εισαγωγή των δεδομένων σας μία βάση δεδομένων και την εγκατάσταση του δικού σας ΣΔΒΔ.\n\nΣτο επόμενο κεφάλαιο, θα μάθουμε για ένα άλλο σύστημα υποστήριξης της dplyr για εργασία με μεγάλα δεδομένα: το arrow. Το arrow έχει σχεδιαστεί για εργασία με μεγάλα αρχεία στον δίσκο και αποτελεί φυσικό συμπλήρωμα των βάσεων δεδομένων.",
    "crumbs": [
      "Εισαγωγή δεδομένων",
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>Βάσεις Δεδομένων</span>"
    ]
  },
  {
    "objectID": "databases.html#footnotes",
    "href": "databases.html#footnotes",
    "title": "21  Βάσεις Δεδομένων",
    "section": "",
    "text": "Η SQL προφέρεται είτε “s”-“q”-“l” είτε “sequel”.↩︎\nΣυνήθως, αυτή είναι η μόνη συνάρτηση που θα χρησιμοποιήσετε από το πακέτο πελάτη, επομένως συνιστούμε να χρησιμοποιήσετε τον τελεστή :: για να καλέστε αυτήν τη μία συνάρτηση, αντί να φορτώσετε ολόκληρο το πακέτο με το library() .↩︎\nΤουλάχιστον, όλοι οι πίνακες τους οποίους έχετε άδεια να δείτε.↩︎\nΑνάλογα με τη χρήση, η SELECT μπορεί να είναι είτε δήλωση είτε συνθήκη. Για να αποφευχθεί αυτή η σύγχυση, θα χρησιμοποιούμε το ερώτημα SELECT αντί για τη δήλωση SELECT.↩︎\nΤεχνικά, απαιτείται μόνο η SELECT, καθώς μπορείτε να γράψετε ερωτήματα όπως SELECT 1+1 για να εκτελέσετε βασικούς υπολογισμούς. Εαν θέλετε όμως να εργαστείτε με δεδομένα (όπως κάνετε πάντα!), θα χρειαστείτε επίσης μία συνθήκη FROM.↩︎\nΑυτό δεν είναι τυχαίο: το όνομα της συνάρτησης της dplyr εμπνεύστηκε από τον όρο της SQL.↩︎",
    "crumbs": [
      "Εισαγωγή δεδομένων",
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>Βάσεις Δεδομένων</span>"
    ]
  },
  {
    "objectID": "arrow.html",
    "href": "arrow.html",
    "title": "22  Arrow",
    "section": "",
    "text": "22.1 Εισαγωγή\nΤα αρχεία CSV έχουν σχεδιαστεί για να διαβάζονται εύκολα από τον άνθρωπο. Είναι μία καλή μορφή για ανταλλαγή πληροφορίας επειδή είναι πολύ απλά και μπορούν να διαβαστούν από κάθε εργαλείο. Τα αρχεία CSV όμως δεν είναι πολύ αποτελεσματικά: πρέπει να κάνετε αρκετή δουλειά για να διαβάσετε τα δεδομένα στην R. Σε αυτό το κεφάλαιο, θα μάθετε για μία ισχυρή εναλλακτική: τη μορφή parquet, μία μορφή που βασίζεται σε ανοιχτά πρότυπα και χρησιμοποιείται ευρέως από συστήματα διαχείρισης μεγάλων δεδομένων.\nΘα συνδυάσουμε αρχεία parquet με το Apache Arrow, μία εργαλειοθήκη πολλαπλών γλωσσών, σχεδιασμένη για αποτελεσματική ανάλυση και μεταφορά μεγάλων συνόλων δεδομένων. Θα χρησιμοποιήσουμε το Apache Arrow μέσω του πακέτου arrow, το οποίο παρέχει ένα σύστημα υποστήριξης της dplyr που σας επιτρέπει να αναλύετε σύνολα δεδομένων μεγαλύτερα από τη μνήμη, χρησιμοποιώντας την γνωστή σύνταξη από το πακέτο dplyr. Ως πρόσθετο πλεονέκτημα, το arrow είναι εξαιρετικά γρήγορο: θα δείτε μερικά παραδείγματα αργότερα στο κεφάλαιο.\nΤόσο το arrow όσο και το πακέτο dbplyr παρέχουν συστήματα υποστήριξης στο πακέτο dplyr, οπότε μπορεί να αναρωτιέστε πότε να χρησιμοποιήσετε το καθένα. Σε πολλές περιπτώσεις, αυτή η επιλογή έχει ήδη γίνει για εσάς, καθώς τα δεδομένα βρίσκονται ήδη σε μία βάση δεδομένων ή σε αρχεία parquet, οπότε θα θέλετε να εργαστείτε με αυτά ως έχουν. Εάν όμως ξεκινάτε με τα δικά σας δεδομένα (ίσως αρχεία CSV), μπορείτε είτε να τα φορτώσετε σε μία βάση δεδομένων είτε να τα μετατρέψετε σε parquet. Γενικά, είναι δύσκολο να γνωρίζουμε τι θα λειτουργήσει καλύτερα, επομένως στα πρώτα στάδια της ανάλυσής σας, θα σας ενθαρρύνουμε να δοκιμάσετε και τα δύο και να επιλέξετε αυτό που λειτουργεί καλύτερα για εσάς.\n(Ένα μεγάλο ευχαριστώ στη Danielle Navarro που συνέβαλε στην αρχική έκδοση αυτού του κεφαλαίου.)",
    "crumbs": [
      "Εισαγωγή δεδομένων",
      "<span class='chapter-number'>22</span>  <span class='chapter-title'>Arrow</span>"
    ]
  },
  {
    "objectID": "arrow.html#εισαγωγή",
    "href": "arrow.html#εισαγωγή",
    "title": "22  Arrow",
    "section": "",
    "text": "22.1.1 Προαπαιτούμενα\nΣε αυτό το κεφάλαιο, θα συνεχίσουμε να χρησιμοποιούμε το tidyverse, και ιδιαίτερα το πακέτο dplyr, αλλά θα το συνδυάσουμε με το πακέτο arrow που έχει σχεδιαστεί ειδικά για εργασία με μεγάλα δεδομένα.\n\nlibrary(tidyverse)\nlibrary(arrow)\n\nΑργότερα στο κεφάλαιο, θα δούμε επίσης κάποιες συνδέσεις μεταξύ arrow και duckdb, κι επομένως θα χρειαστούμε επίσης το πακέτο dbplyr και το duckdb.\n\nlibrary(dbplyr, warn.conflicts = FALSE)\nlibrary(duckdb)\n#&gt; Loading required package: DBI",
    "crumbs": [
      "Εισαγωγή δεδομένων",
      "<span class='chapter-number'>22</span>  <span class='chapter-title'>Arrow</span>"
    ]
  },
  {
    "objectID": "arrow.html#λήψη-δεδομένων",
    "href": "arrow.html#λήψη-δεδομένων",
    "title": "22  Arrow",
    "section": "\n22.2 Λήψη δεδομένων",
    "text": "22.2 Λήψη δεδομένων\nΞεκινάμε παίρνοντας ένα σύνολο δεδομένων αντάξιο αυτών των εργαλείων: ένα σύνολο δεδομένων από βιβλία που έχουν δανειστεί από τις δημόσιες βιβλιοθήκες του Σιάτλ. Είναι διαθέσιμο στο διαδίκτυο στη διεύθυνση data.seattle.gov/Community/Checkouts-by-Title/tmmm-ytt6. Αυτό το σύνολο δεδομένων περιέχει 41.389.465 γραμμές που σας λένε πόσες φορές κάθε βιβλίο έχει δανειστεί κάθε μήνα από τον Απρίλιο του 2005 έως τον Οκτώβριο του 2022.\nΟ παρακάτω κώδικας θα σας δώσει ένα αποθηκευμένο αντίγραφο των δεδομένων. Τα δεδομένα είναι ένα αρχείο CSV 9 GB, επομένως θα χρειαστεί λίγος χρόνος για τη λήψη του. Συνιστώ ανεπιφύλακτα να χρησιμοποιήσετε το curl::multi_download() για να κατεβάζετε πολύ μεγάλα αρχεία, καθώς έχει κατασκευαστεί γι’ αυτόν ακριβώς τον σκοπό: σας δίνει μία γραμμή προόδου και μπορεί να συνεχίσει τη λήψη εάν διακοπεί.\n\ndir.create(\"data\", showWarnings = FALSE)\n\ncurl::multi_download(\n  \"https://r4ds.s3.us-west-2.amazonaws.com/seattle-library-checkouts.csv\",\n  \"data/seattle-library-checkouts.csv\",\n  resume = TRUE\n)",
    "crumbs": [
      "Εισαγωγή δεδομένων",
      "<span class='chapter-number'>22</span>  <span class='chapter-title'>Arrow</span>"
    ]
  },
  {
    "objectID": "arrow.html#άνοιγμα-ενός-συνόλου-δεδομένων",
    "href": "arrow.html#άνοιγμα-ενός-συνόλου-δεδομένων",
    "title": "22  Arrow",
    "section": "\n22.3 Άνοιγμα ενός συνόλου δεδομένων",
    "text": "22.3 Άνοιγμα ενός συνόλου δεδομένων\nΑς ξεκινήσουμε ρίχνοντας μία ματιά στα δεδομένα. Με μέγεθος 9 GB, αυτό το αρχείο είναι αρκετά μεγάλο, οπότε πιθανώς να μην θέλουμε να το φορτώσουμε ολόκληρο στη μνήμη. Ένας καλός εμπειρικός κανόνας είναι ότι συνήθως θέλετε να έχετε τουλάχιστον διπλάσια μνήμη από το μέγεθος των δεδομένων, και πολλοί φορητοί υπολογιστές φτάνουν μέχρι τα 16 GB. Αυτό σημαίνει ότι θέλουμε να αποφύγουμε την read_csv() και προτιμάμε να χρησιμοποιήσουμε την arrow::open_dataset():\n\nseattle_csv &lt;- open_dataset(\n  sources = \"data/seattle-library-checkouts.csv\", \n  col_types = schema(ISBN = string()),\n  format = \"csv\"\n)\n\nΤι συμβαίνει όταν εκτελείται αυτός ο κώδικας;\nΗ open_dataset() θα σκανάρει μερικές χιλιάδες γραμμές για να καταλάβει τη δομή του συνόλου δεδομένων. Η στήλη ISBN περιέχει κενές τιμές για τις πρώτες 80.000 σειρές, επομένως πρέπει να καθορίσουμε τον τύπο στήλης για να βοηθήσουμε το arrow να επεξεργαστεί τη δομή των δεδομένων. Μόλις η open_dataset() σαρώσει τα δεδομένα, καταγράφει αυτό που βρέθηκε και σταματά. Θα διαβάζει περαιτέρω γραμμές μόνο όταν τις ζητάτε. Αυτά είναι τα μεταδεδομένα που βλέπουμε αν εκτυπώσουμε το seattle_csv:\n\nseattle_csv\n#&gt; FileSystemDataset with 1 csv file\n#&gt; UsageClass: string\n#&gt; CheckoutType: string\n#&gt; MaterialType: string\n#&gt; CheckoutYear: int64\n#&gt; CheckoutMonth: int64\n#&gt; Checkouts: int64\n#&gt; Title: string\n#&gt; ISBN: string\n#&gt; Creator: string\n#&gt; Subjects: string\n#&gt; Publisher: string\n#&gt; PublicationYear: string\n\nΗ πρώτη γραμμή στην έξοδο σας λέει ότι το seattle_csv αποθηκεύεται τοπικά στο δίσκο ως ένα μεμονωμένο αρχείο CSV. θα φορτωθεί στη μνήμη μόνο όταν απαιτείται. Το υπόλοιπο της εξόδου σας λέει τον τύπο στήλης που έχει υπολογίσει το arrow για κάθε στήλη.\nΜπορούμε να δούμε τι συμβαίνει στην πραγματικότητα με την glimpse(). Αυτό αποκαλύπτει ότι υπάρχουν ~41 εκατομμύρια γραμμές και 12 στήλες και, ακόμα, μας εμφανίζει και μερικές τιμές.\n\nseattle_csv |&gt; glimpse()\n#&gt; FileSystemDataset with 1 csv file\n#&gt; 41,389,465 rows x 12 columns\n#&gt; $ UsageClass      &lt;string&gt; \"Physical\", \"Physical\", \"Digital\", \"Physical\", \"Ph…\n#&gt; $ CheckoutType    &lt;string&gt; \"Horizon\", \"Horizon\", \"OverDrive\", \"Horizon\", \"Hor…\n#&gt; $ MaterialType    &lt;string&gt; \"BOOK\", \"BOOK\", \"EBOOK\", \"BOOK\", \"SOUNDDISC\", \"BOO…\n#&gt; $ CheckoutYear     &lt;int64&gt; 2016, 2016, 2016, 2016, 2016, 2016, 2016, 2016, 20…\n#&gt; $ CheckoutMonth    &lt;int64&gt; 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,…\n#&gt; $ Checkouts        &lt;int64&gt; 1, 1, 1, 1, 1, 1, 1, 1, 4, 1, 1, 2, 3, 2, 1, 3, 2,…\n#&gt; $ Title           &lt;string&gt; \"Super rich : a guide to having it all / Russell S…\n#&gt; $ ISBN            &lt;string&gt; \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\"…\n#&gt; $ Creator         &lt;string&gt; \"Simmons, Russell\", \"Barclay, James, 1965-\", \"Tim …\n#&gt; $ Subjects        &lt;string&gt; \"Self realization, Conduct of life, Attitude Psych…\n#&gt; $ Publisher       &lt;string&gt; \"Gotham Books,\", \"Pyr,\", \"Random House, Inc.\", \"Di…\n#&gt; $ PublicationYear &lt;string&gt; \"c2011.\", \"2010.\", \"2015\", \"2005.\", \"c2004.\", \"c20…\n\nΜπορούμε να αρχίσουμε να χρησιμοποιούμε αυτό το σύνολο δεδομένων με συναρτήσεις του πακέτου dplyr, χρησιμοποιώντας την collect() για να αναγκάσουμε το arrow να εκτελέσει τον υπολογισμό και να επιστρέψει κάποια δεδομένα. Για παράδειγμα, αυτός ο κωδικός μας λέει τον συνολικό αριθμό δανεισμών ανά έτος:\n\nseattle_csv |&gt; \n  group_by(CheckoutYear) |&gt; \n  summarise(Checkouts = sum(Checkouts)) |&gt; \n  arrange(CheckoutYear) |&gt; \n  collect()\n#&gt; # A tibble: 18 × 2\n#&gt;   CheckoutYear Checkouts\n#&gt;          &lt;int&gt;     &lt;int&gt;\n#&gt; 1         2005   3798685\n#&gt; 2         2006   6599318\n#&gt; 3         2007   7126627\n#&gt; 4         2008   8438486\n#&gt; 5         2009   9135167\n#&gt; 6         2010   8608966\n#&gt; # ℹ 12 more rows\n\nΧάρη στο arrow, αυτός ο κώδικας θα λειτουργεί ανεξάρτητα από το πόσο μεγάλο είναι το υποκείμενο σύνολο δεδομένων. Αλλά αυτή τη στιγμή είναι αρκετά αργός: στον υπολογιστή του Hadley, χρειάστηκαν ~10 δευτερόλεπτα για να τρέξει. Αυτό δεν είναι τρομερό δεδομένου του όγκου των δεδομένων που έχουμε, μπορούμε όμως να τα κάνουμε πολύ πιο γρήγορα μεταβαίνοντας σε μία καλύτερη μορφή.",
    "crumbs": [
      "Εισαγωγή δεδομένων",
      "<span class='chapter-number'>22</span>  <span class='chapter-title'>Arrow</span>"
    ]
  },
  {
    "objectID": "arrow.html#sec-parquet",
    "href": "arrow.html#sec-parquet",
    "title": "22  Arrow",
    "section": "\n22.4 Η μορφή parquet",
    "text": "22.4 Η μορφή parquet\nΓια να διευκολύνουμε την εργασία με αυτά τα δεδομένα, ας αλλάξουμε στη μορφή αρχείου parquet και ας τα χωρίσουμε σε πολλαπλά αρχεία. Οι παρακάτω ενότητες θα σας παρουσιάσουν πρώτα το parquet και την διαμέριση και, στη συνέχεια, θα εφαρμόσουν όσα μάθαμε στα δεδομένα της βιβλιοθήκης του Σιάτλ.\n\n22.4.1 Πλεονεκτήματα της parquet\nΌπως το CSV, έτσι και το parquet χρησιμοποιείται για δεδομένα σε μορφή πίνακα, αλλά αντί τα δεδομένα μας να είναι σε μία μορφή κειμένου που μπορείτε να διαβάσετε με οποιοδήποτε πρόγραμμα επεξεργασίας αρχείων, είναι μία προσαρμοσμένη δυαδική μορφή που έχει σχεδιαστεί ειδικά για τις ανάγκες των μεγάλων δεδομένων. Αυτό σημαίνει ότι:\n\nΤα αρχεία parquet είναι συνήθως μικρότερα από το αντίστοιχο αρχείο CSV. Το parquet βασίζεται σε αποδοτικές κωδικοποιήσεις για να διατηρεί το μέγεθος του αρχείου χαμηλό και να υποστηρίζει τη συμπίεση αρχείων. Αυτό βοηθά εργασίες που αφορούν αρχεία parquet να γίνουν πιο γρήγορες επειδή υπάρχουν λιγότερα δεδομένα για μετακίνηση από τον δίσκο προς τη μνήμη.\nΤα αρχεία parquet έχουν ένα σύστημα που επιτρέπει ευέλικτους τρόπους περιγραφής των τύπων δεδομένων. Όπως είπαμε στην Ενότητα 7.3, ένα αρχείο CSV δεν παρέχει πληροφορίες σχετικά με τους τύπους των στηλών του. Για παράδειγμα, ένα σύστημα αναγνώστης CSV πρέπει να μαντέψει εάν το “08-10-2022” πρέπει να αναλυθεί ως συμβολοσειρά ή ως ημερομηνία. Αντίθετα, τα αρχεία parquet αποθηκεύουν τα δεδομένα με τρόπο που καταγράφει και τον τύπο τους.\nΤα αρχεία parquet είναι “προσαρμοσμένα σε στήλες”. Αυτό σημαίνει ότι είναι οργανωμένα στήλη προς στήλη, όπως το πλαίσιο δεδομένων της R. Αυτό συνήθως οδηγεί σε καλύτερη απόδοση για εργασίες ανάλυσης δεδομένων σε σύγκριση με αρχεία CSV, τα οποία είναι οργανωμένα σε γραμμές.\nΤα αρχεία parquet είναι “σε κομμάτια”, γεγονός που καθιστά δυνατή την εργασία σε διαφορετικά μέρη του αρχείου ταυτόχρονα και, αν είστε τυχεροί, μπορείτε να παραλείψετε μερικά κομμάτια εντελώς.\n\nΥπάρχει ένα βασικό μειονέκτημα στα αρχεία parquet: δεν είναι πλέον “αναγνώσιμα από τον άνθρωπο”, δηλαδή εάν κοιτάξετε ένα αρχείο parquet χρησιμοποιώντας την readr::read_file(), θα δείτε απλώς μία δέσμη ασυναρτησιών.\n\n22.4.2 Διαμερισμός\nΚαθώς τα σύνολα δεδομένων γίνονται όλο και μεγαλύτερα, η αποθήκευση όλων των δεδομένων σε ένα μόνο αρχείο γίνεται όλο και πιο επίπονη, και είναι συχνά χρήσιμο μεγάλα σύνολα δεδομένων να χωρίζονται σε πολλαπλά αρχεία. Όταν αυτή η δόμηση γίνει έξυπνα, η στρατηγική αυτή μπορεί να οδηγήσει σε σημαντικές βελτιώσεις στην απόδοση, επειδή πολλές αναλύσεις θα απαιτούν μόνο ένα υποσύνολο των αρχείων.\nΔεν υπάρχουν συγκεκριμένοι και γρήγοροι κανόνες σχετικά με τον τρόπο διαχωρισμού των δεδομένων σας: τα αποτελέσματα θα εξαρτηθούν από τα δεδομένα σας, τα μοτίβα πρόσβασης και τα συστήματα που διαβάζουν τα δεδομένα. Είναι πιθανό να χρειαστεί να κάνετε κάποιους πειραματισμούς προτού βρείτε τον ιδανικό διαχωρισμό για την περίπτωσή σας. Ως γενικό οδηγό, το arrow προτείνει να αποφεύγετε αρχεία μικρότερα από 20 MB και μεγαλύτερα από 2 GB και να αποφεύγετε διαμερίσματα που παράγουν περισσότερα από 10.000 αρχεία. Θα πρέπει επίσης να προσπαθήσετε να χωρίσετε τα αρχεία σύμφωνα με τις μεταβλητές που φιλτράρετε. Όπως θα δείτε σύντομα, αυτό επιτρέπει στο arrow να παραλείψει αρκετούς υπολογισμούς διαβάζοντας μόνο τα σχετικά αρχεία.\n\n22.4.3 Ξαναγράφοντας τα δεδομένα της βιβλιοθήκης του Σιάτλ\nΑς εφαρμόσουμε αυτές τις ιδέες στα δεδομένα της βιβλιοθήκης του Σιάτλ για να δούμε πως λειτουργούν στην πράξη. Θα κάνουμε τον διαχωρισμό με βάση τη στήλη CheckoutYear, καθώς είναι πιθανό ορισμένες αναλύσεις να θέλουν να εξετάσουν μόνο τα πρόσφατα δεδομένα και ο διαχωρισμός ανά έτος επιστρέφει 18 κομμάτια λογικού μεγέθους.\nΓια να ξαναγράψουμε τα δεδομένα ορίζουμε το διαμέρισμα χρησιμοποιώντας την dplyr::group_by() και, στη συνέχεια, αποθηκεύουμε τα διαμερίσματα σε έναν κατάλογο με την arrow::write_dataset(). Η write_dataset() έχει δύο σημαντικά ορίσματα: έναν κατάλογο στον οποίο θα δημιουργήσουμε τα αρχεία και τη μορφή που θα χρησιμοποιήσουμε.\n\npq_path &lt;- \"data/seattle-library-checkouts\"\n\n\nseattle_csv |&gt;\n  group_by(CheckoutYear) |&gt;\n  write_dataset(path = pq_path, format = \"parquet\")\n\nΑυτό παίρνει περίπου ένα λεπτό για να τρέξει. Όπως θα δούμε σύντομα αυτή είναι μία αρχική επένδυση που αποδίδει καρπούς κάνοντας μελλοντικές εργασίες πολύ πολύ πιο γρήγορες.\nΑς ρίξουμε μία ματιά σε αυτό που μόλις δημιουργήσαμε:\n\ntibble(\n  files = list.files(pq_path, recursive = TRUE),\n  size_MB = file.size(file.path(pq_path, files)) / 1024^2\n)\n#&gt; # A tibble: 18 × 2\n#&gt;   files                            size_MB\n#&gt;   &lt;chr&gt;                              &lt;dbl&gt;\n#&gt; 1 CheckoutYear=2005/part-0.parquet    109.\n#&gt; 2 CheckoutYear=2006/part-0.parquet    164.\n#&gt; 3 CheckoutYear=2007/part-0.parquet    178.\n#&gt; 4 CheckoutYear=2008/part-0.parquet    195.\n#&gt; 5 CheckoutYear=2009/part-0.parquet    214.\n#&gt; 6 CheckoutYear=2010/part-0.parquet    222.\n#&gt; # ℹ 12 more rows\n\nΤο αρχείο CSV μας με τα 9 GB έχει ξαναγραφτεί σε 18 αρχεία parquet. Τα ονόματα αρχείων χρησιμοποιούν έναν κανόνα “αυτο-περιγραφής” που χρησιμοποιείται από το Apache Hive. Διαμερίσματα τύπου Hive ονομάζουν φακέλους με έναν κανόνα “key=value”, έτσι, όπως μπορείτε να μαντέψετε, ο κατάλογος CheckoutYear=2005 περιέχει όλα τα δεδομένα όπου η CheckoutYear είναι 2005. Κάθε αρχείο είναι μεταξύ 100 και 300 MB και το συνολικό μέγεθος είναι τώρα περίπου 4 GB, λίγο περισσότερο από το μισό μέγεθος του αρχικού αρχείου CSV. Αναμενόμενο, καθώς το parquet είναι μία πολύ πιο αποτελεσματική μορφή αρχείου.",
    "crumbs": [
      "Εισαγωγή δεδομένων",
      "<span class='chapter-number'>22</span>  <span class='chapter-title'>Arrow</span>"
    ]
  },
  {
    "objectID": "arrow.html#συνδυάζοντας-τα-πακέτα-dplyr-και-arrow",
    "href": "arrow.html#συνδυάζοντας-τα-πακέτα-dplyr-και-arrow",
    "title": "22  Arrow",
    "section": "\n22.5 Συνδυάζοντας τα πακέτα dplyr και arrow",
    "text": "22.5 Συνδυάζοντας τα πακέτα dplyr και arrow\nΑφού δημιουργήσαμε αυτά τα αρχεία parquet, τώρα θα πρέπει να τα διαβάσουμε ξανά. Χρησιμοποιούμε ξανά την open_dataset(), αλλά αυτή τη φορά της δίνουμε έναν κατάλογο:\n\nseattle_pq &lt;- open_dataset(pq_path)\n\nΤώρα μπορούμε να γράψουμε τη ροή με το πακέτο dplyr. Για παράδειγμα, θα μπορούσαμε να μετρήσουμε τον συνολικό αριθμό βιβλίων που είχαν δανειστεί κάθε μήνα για τα τελευταία πέντε χρόνια:\n\nquery &lt;- seattle_pq |&gt; \n  filter(CheckoutYear &gt;= 2018, MaterialType == \"BOOK\") |&gt;\n  group_by(CheckoutYear, CheckoutMonth) |&gt;\n  summarize(TotalCheckouts = sum(Checkouts)) |&gt;\n  arrange(CheckoutYear, CheckoutMonth)\n\nΗ σύνταξη κώδικα dplyr για δεδομένα arrow είναι εννοιολογικά παρόμοια με αυτή του πακέτου dbplyr, Κεφάλαιο 21: γράφετε κώδικα dplyr, ο οποίος μετατρέπεται αυτόματα σε ένα ερώτημα που κατανοεί η βιβλιοθήκη της Apache Arrow C++, και το οποίο ερώτημα στη συνέχεια εκτελείται όταν καλείτε την collect(). Εάν εκτυπώσουμε το αντικείμενο query, μπορούμε να δούμε μερικές πληροφορίες σχετικά με το τι περιμένουμε να επιστρέψει το Arrow όταν πραγματοποιηθεί η εκτέλεση:\n\nquery\n#&gt; FileSystemDataset (query)\n#&gt; CheckoutYear: int32\n#&gt; CheckoutMonth: int64\n#&gt; TotalCheckouts: int64\n#&gt; \n#&gt; * Grouped by CheckoutYear\n#&gt; * Sorted by CheckoutYear [asc], CheckoutMonth [asc]\n#&gt; See $.data for the source Arrow object\n\nΚαι μπορούμε να πάρουμε τα αποτελέσματα καλώντας την collect():\n\nquery |&gt; collect()\n#&gt; # A tibble: 58 × 3\n#&gt; # Groups:   CheckoutYear [5]\n#&gt;   CheckoutYear CheckoutMonth TotalCheckouts\n#&gt;          &lt;int&gt;         &lt;int&gt;          &lt;int&gt;\n#&gt; 1         2018             1         355101\n#&gt; 2         2018             2         309813\n#&gt; 3         2018             3         344487\n#&gt; 4         2018             4         330988\n#&gt; 5         2018             5         318049\n#&gt; 6         2018             6         341825\n#&gt; # ℹ 52 more rows\n\nΌπως και το dbplyr, έτσι και το arrow κατανοεί μόνο ορισμένες εκφράσεις της R, επομένως ενδέχεται να μην μπορείτε να γράψετε ακριβώς τον ίδιο κώδικα που θα γράφατε συνήθως. Ωστόσο, η λίστα των λειτουργιών που υποστηρίζονται είναι αρκετά εκτενής και συνεχίζει να αυξάνεται. Μπορείτε να βρείτε μία πλήρη λίστα με τις τρέχουσες υποστηριζόμενες συναρτήσεις στο ?acero.\n\n22.5.1 Απόδοση\nΑς ρίξουμε μία γρήγορη ματιά στο αντίκτυπο της απόδοσης που είχε η μετάβαση από CSV σε parquet. Αρχικά, ας ορίσουμε πόσο χρόνο χρειάζεται για να υπολογίσουμε τον αριθμό των βιβλίων που δανείζονται κάθε μήνα του 2021, όταν τα δεδομένα αποθηκεύονται ως ένα μεγάλο csv:\n\nseattle_csv |&gt; \n  filter(CheckoutYear == 2021, MaterialType == \"BOOK\") |&gt;\n  group_by(CheckoutMonth) |&gt;\n  summarize(TotalCheckouts = sum(Checkouts)) |&gt;\n  arrange(desc(CheckoutMonth)) |&gt;\n  collect() |&gt; \n  system.time()\n#&gt;    user  system elapsed \n#&gt;   8.932   0.775   8.580\n\nΤώρα ας χρησιμοποιήσουμε τη νέα μας έκδοση του συνόλου δεδομένων, στην οποία τα δεδομένα δανεισμού της βιβλιοθήκης του Σιάτλ έχουν χωριστεί σε 18 μικρότερα αρχεία parquet:\n\nseattle_pq |&gt; \n  filter(CheckoutYear == 2021, MaterialType == \"BOOK\") |&gt;\n  group_by(CheckoutMonth) |&gt;\n  summarize(TotalCheckouts = sum(Checkouts)) |&gt;\n  arrange(desc(CheckoutMonth)) |&gt;\n  collect() |&gt; \n  system.time()\n#&gt;    user  system elapsed \n#&gt;   0.196   0.050   0.045\n\nΗ ~100x επιτάχυνση στην απόδοση αποδίδεται σε δύο παράγοντες: την διαμέριση πολλαπλών αρχείων και τη μορφή των μεμονωμένων αρχείων:\n\nΗ διαμέριση βελτιώνει την απόδοση επειδή το ερώτημα χρησιμοποιεί το CheckoutYear == 2021 για να φιλτράρει τα δεδομένα και το arrow είναι αρκετά έξυπνη ώστε να αναγνωρίζει ότι χρειάζεται να διαβάσει μόνο 1 από τα 18 αρχεία parquet.\nΗ μορφή parquet βελτιώνει την απόδοση, αποθηκεύοντας τα δεδομένα σε δυαδική μορφή, η οποία μπορεί να διαβαστεί πιο άμεσα στη μνήμη. Η κατά στήλη μορφή και τα εμπλουτισμένα μεταδεδομένα σημαίνουν ότι η arrow χρειάζεται μόνο να διαβάσει τις τέσσερις στήλες που χρησιμοποιούνται πραγματικά στο ερώτημα (CheckoutYear, MaterialType, CheckoutMonth και Checkouts).\n\nΑυτή η τεράστια διαφορά στην απόδοση είναι η απάντηση στο γιατί συμφέρει να μετατρέψετε μεγάλα CSV σε parquet!\n\n22.5.2 Συνδυάζοντας τα πακέτα duckdb και arrow\nΥπάρχει ένα τελευταίο πλεονέκτημα του parquet και του arrow — είναι πολύ εύκολο να μετατρέψετε ένα σύνολο δεδομένων arrow σε βάση δεδομένων DuckDB (Κεφάλαιο 21) καλώντας την arrow::to_duckdb():\n\nseattle_pq |&gt; \n  to_duckdb() |&gt;\n  filter(CheckoutYear &gt;= 2018, MaterialType == \"BOOK\") |&gt;\n  group_by(CheckoutYear) |&gt;\n  summarize(TotalCheckouts = sum(Checkouts)) |&gt;\n  arrange(desc(CheckoutYear)) |&gt;\n  collect()\n#&gt; Warning: Missing values are always removed in SQL aggregation functions.\n#&gt; Use `na.rm = TRUE` to silence this warning\n#&gt; This warning is displayed once every 8 hours.\n#&gt; # A tibble: 5 × 2\n#&gt;   CheckoutYear TotalCheckouts\n#&gt;          &lt;int&gt;          &lt;dbl&gt;\n#&gt; 1         2022        2431502\n#&gt; 2         2021        2266438\n#&gt; 3         2020        1241999\n#&gt; 4         2019        3931688\n#&gt; 5         2018        3987569\n\nΤο καλό με την to_duckdb() είναι ότι η μεταφορά δεν περιλαμβάνει αντιγραφή στη μνήμη, πράγμα που είναι και στόχος του οικοσυστήματος του arrow: να επιτρέπει συνεχείς μεταβάσεις από το ένα υπολογιστικό περιβάλλον στο άλλο.\n\n22.5.3 Ασκήσεις\n\nΒρείτε το πιο δημοφιλές βιβλίο κάθε έτος.\nΠοιος συγγραφέας έχει τα περισσότερα βιβλία στο σύστημα της βιβλιοθήκης του Σιάτλ;\nΠώς έχουν αλλάξει οι δανεισμοί των βιβλίων έναντι των ηλεκτρονικών βιβλίων τα τελευταία 10 χρόνια;",
    "crumbs": [
      "Εισαγωγή δεδομένων",
      "<span class='chapter-number'>22</span>  <span class='chapter-title'>Arrow</span>"
    ]
  },
  {
    "objectID": "arrow.html#σύνοψη",
    "href": "arrow.html#σύνοψη",
    "title": "22  Arrow",
    "section": "\n22.6 Σύνοψη",
    "text": "22.6 Σύνοψη\nΣε αυτό το κεφάλαιο, σας δόθηκε μία γεύση από το πακέτο arrow, το οποίο παρέχει ένα σύστημα υποστήριξης της dplyr για εργασία με μεγάλα σύνολα δεδομένων, αποθηκευμένα στο δίσκο. Μπορεί να λειτουργήσει με αρχεία CSV και είναι πολύ πιο γρήγορο αν μετατρέψετε τα δεδομένα σας σε parquet. Η parquet είναι μία δυαδική μορφή δεδομένων που έχει σχεδιαστεί ειδικά για ανάλυση δεδομένων σε σύγχρονους υπολογιστές. Πολύ λιγότερα εργαλεία μπορούν να λειτουργήσουν με αρχεία parquet σε σύγκριση με τα CSV, αλλά η διαμερισμένη, συμπιεσμένη και στηλοειδής δομή τους τα καθιστά πολύ πιο αποτελεσματικά στην ανάλυση.\nΣτη συνέχεια θα μάθετε για την πρώτη σας πηγή δεδομένων που δεν είναι σε μορφή πίνακα, την οποία θα χειριστείτε χρησιμοποιώντας εργαλεία που παρέχονται από το πακέτο tidyr. Θα επικεντρωθούμε σε δεδομένα που προέρχονται από αρχεία JSON, οι γενικές αρχές όμως ισχύουν για δεδομένα που έχουν ιεραρχική (ή δενδροειδή) μορφή ανεξάρτητα από την προέλευσή τους.",
    "crumbs": [
      "Εισαγωγή δεδομένων",
      "<span class='chapter-number'>22</span>  <span class='chapter-title'>Arrow</span>"
    ]
  },
  {
    "objectID": "rectangling.html",
    "href": "rectangling.html",
    "title": "23  Ιεραρχικά δεδομένα",
    "section": "",
    "text": "23.1 Εισαγωγή\nΣε αυτό το κεφάλαιο, θα μάθετε την τέχνη της ορθογωνοποίησης των δεδομένων (μετατροπή σε μορφή πίνακα): παίρνοντας δηλαδή δεδομένα που είναι κατά βάση ιεραρχικά, ή σε μορφή δέντρου, και μετατρέποντάς τα σε ένα ορθογώνιο πλαίσιο δεδομένων που αποτελείται από γραμμές και στήλες (σαν πίνακας). Αυτό είναι σημαντικό επειδή τα ιεραρχικά δεδομένα συναντώνται αρκετά συχνά, ειδικά όταν εργάζεστε με δεδομένα που προέρχονται από το διαδίκτυο.\nΓια να μάθετε για την ορθογωνοποίηση, θα πρέπει πρώτα να μάθετε για τις λίστες, τη δομή δεδομένων που καθιστά δυνατή την ύπαρξη ιεραρχικών δεδομένων. Στη συνέχεια, θα μάθετε για δύο κρίσιμες συναρτήσεις του πακέτου tidyr: την tidyr::unnest_longer() και την tidyr::unnest_wider(). Στη συνέχεια, θα σας δείξουμε μερικές περιπτώσεις μελέτης, εφαρμόζοντας αυτές τις απλές συναρτήσεις ξανά και ξανά για την επίλυση πραγματικών προβλημάτων. Θα ολοκληρώσουμε μιλώντας για τα JSON, την πιο συχνή πηγή ιεραρχικών συνόλων δεδομένων και μία συχνή μορφή ανταλλαγής δεδομένων στο διαδίκτυο.",
    "crumbs": [
      "Εισαγωγή δεδομένων",
      "<span class='chapter-number'>23</span>  <span class='chapter-title'>Ιεραρχικά δεδομένα</span>"
    ]
  },
  {
    "objectID": "rectangling.html#εισαγωγή",
    "href": "rectangling.html#εισαγωγή",
    "title": "23  Ιεραρχικά δεδομένα",
    "section": "",
    "text": "23.1.1 Προαπαιτούμενα\nΣε αυτό το κεφάλαιο, θα χρησιμοποιήσουμε πολλές συναρτήσεις από το πακέτο tidyr, ένα βασικό μέλος του tidyverse. Θα χρησιμοποιήσουμε επίσης το πακέτο repurrrsive για να πάρουμε μερικά ενδιαφέροντα σύνολα δεδομένων για εξάσκηση στην ορθογωνοποίηση και θα ολοκληρώσουμε χρησιμοποιώντας το jsonlite για την ανάγνωση αρχείων JSON σε λίστες R.\n\nlibrary(tidyverse)\nlibrary(repurrrsive)\nlibrary(jsonlite)",
    "crumbs": [
      "Εισαγωγή δεδομένων",
      "<span class='chapter-number'>23</span>  <span class='chapter-title'>Ιεραρχικά δεδομένα</span>"
    ]
  },
  {
    "objectID": "rectangling.html#λίστες",
    "href": "rectangling.html#λίστες",
    "title": "23  Ιεραρχικά δεδομένα",
    "section": "\n23.2 Λίστες",
    "text": "23.2 Λίστες\nΜέχρι στιγμής έχετε εργαστεί με πλαίσια δεδομένων που περιέχουν απλά διανύσματα, όπως ακέραιους, γενικούς αριθμούς, χαρακτήρες, ημερομηνίες/ώρες και παράγοντες. Αυτά τα διανύσματα είναι απλά επειδή είναι ομοιογενή: κάθε στοιχείο είναι του ίδιου τύπου. Εάν θέλετε να αποθηκεύσετε στοιχεία διαφορετικών τύπων στο ίδιο διάνυσμα, θα χρειαστείτε μία λίστα, την οποία δημιουργείτε με την list():\n\nx1 &lt;- list(1:4, \"a\", TRUE)\nx1\n#&gt; [[1]]\n#&gt; [1] 1 2 3 4\n#&gt; \n#&gt; [[2]]\n#&gt; [1] \"a\"\n#&gt; \n#&gt; [[3]]\n#&gt; [1] TRUE\n\nΕίναι συχνά βολικό να ονομάσετε τα στοιχεία ή τα παιδιά μιας λίστας, κάτι που μπορείτε να κάνετε με τον ίδιο τρόπο όπως ονομάζετε τις στήλες ενός tibble:\n\nx2 &lt;- list(a = 1:2, b = 1:3, c = 1:4)\nx2\n#&gt; $a\n#&gt; [1] 1 2\n#&gt; \n#&gt; $b\n#&gt; [1] 1 2 3\n#&gt; \n#&gt; $c\n#&gt; [1] 1 2 3 4\n\nΑκόμη και για αυτές τις πολύ απλές λίστες, η εκτύπωση καταλαμβάνει αρκετό χώρο. Μία χρήσιμη εναλλακτική λύση είναι η str(), η οποίο δημιουργεί μία συμπαγή εμφάνιση της δομής (structure), χωρίς να δίνει έμφαση στα περιεχόμενα:\n\nstr(x1)\n#&gt; List of 3\n#&gt;  $ : int [1:4] 1 2 3 4\n#&gt;  $ : chr \"a\"\n#&gt;  $ : logi TRUE\nstr(x2)\n#&gt; List of 3\n#&gt;  $ a: int [1:2] 1 2\n#&gt;  $ b: int [1:3] 1 2 3\n#&gt;  $ c: int [1:4] 1 2 3 4\n\nΌπως μπορείτε να δείτε, η str() εμφανίζει κάθε παιδί της λίστας σε ξεχωριστή γραμμή. Εμφανίζει το όνομα, εάν υπάρχει, μετά μία συντομογραφία του τύπου των δεδομένων, και μετά τις λίγες τιμές από την αρχή.\n\n23.2.1 Ιεραρχία\nΟι λίστες μπορούν να περιέχουν οποιοδήποτε είδος αντικειμένου, συμπεριλαμβανομένων άλλων λιστών. Αυτό τις καθιστά κατάλληλες για την αναπαράσταση ιεραρχικών (δενδροειδών) δομών:\n\nx3 &lt;- list(list(1, 2), list(3, 4))\nstr(x3)\n#&gt; List of 2\n#&gt;  $ :List of 2\n#&gt;   ..$ : num 1\n#&gt;   ..$ : num 2\n#&gt;  $ :List of 2\n#&gt;   ..$ : num 3\n#&gt;   ..$ : num 4\n\nΤο παραπάνω διαφέρει σημαντικά από την c(), η οποίο δημιουργεί ένα επίπεδο διάνυσμα:\n\nc(c(1, 2), c(3, 4))\n#&gt; [1] 1 2 3 4\n\nx4 &lt;- c(list(1, 2), list(3, 4))\nstr(x4)\n#&gt; List of 4\n#&gt;  $ : num 1\n#&gt;  $ : num 2\n#&gt;  $ : num 3\n#&gt;  $ : num 4\n\nΚαθώς οι λίστες γίνονται πιο περίπλοκες, η str() γίνεται πιο χρήσιμη, καθώς σας επιτρέπει να δείτε την ιεραρχία περιληπτικά:\n\nx5 &lt;- list(1, list(2, list(3, list(4, list(5)))))\nstr(x5)\n#&gt; List of 2\n#&gt;  $ : num 1\n#&gt;  $ :List of 2\n#&gt;   ..$ : num 2\n#&gt;   ..$ :List of 2\n#&gt;   .. ..$ : num 3\n#&gt;   .. ..$ :List of 2\n#&gt;   .. .. ..$ : num 4\n#&gt;   .. .. ..$ :List of 1\n#&gt;   .. .. .. ..$ : num 5\n\nΚαθώς οι λίστες γίνονται ακόμη μεγαλύτερες και πιο περίπλοκες, η str() αρχίζει να αποτυγχάνει και θα πρέπει να μεταβείτε στην View()1. Το Σχήμα 23.1 δείχνει το αποτέλεσμα της κλήσης της View(x5). Η λειτουργία προβολής ξεκινά εμφανίζοντας μόνο το ανώτερο επίπεδο της λίστας, αλλά μπορείτε να επεκτείνετε διαδραστικά οποιοδήποτε από τα στοιχεία για να δείτε περισσότερα, όπως φαίνεται στο Σχήμα 23.2. Το RStudio θα σας δείξει επίσης τον κώδικα που χρειάζεστε για να αποκτήσετε πρόσβαση σε αυτό το στοιχείο, όπως στο Σχήμα 23.3. Θα επανέλθουμε στο πώς λειτουργεί αυτός ο κώδικας στην Ενότητα 27.3.\n\n\n\n\n\n\n\nΣχήμα 23.1: Η επιλογή προβολής του RStudio σας επιτρέπει να εξερευνήσετε διαδραστικά μία περίπλοκη λίστα. Το πρόγραμμα προβολής ανοίγει εμφανίζοντας μόνο το ανώτερο επίπεδο της λίστας.\n\n\n\n\n\n\n\n\n\n\n\nΣχήμα 23.2: Επιλέγοντας το δεξιόστροφο τρίγωνο, επεκτείνετε το αντίστοιχο στοιχείο της λίστας, ώστε να μπορείτε να δείτε και τα παιδιά του.\n\n\n\n\n\n\n\n\n\n\n\nΣχήμα 23.3: Μπορείτε να επαναλάβετε αυτήν την διαδικασία όσες φορές χρειάζεται για να φτάσετε στα δεδομένα που σας ενδιαφέρουν. Σημειώστε την κάτω αριστερή γωνία: εάν επιλέξετε ένα στοιχείο της λίστας, το RStudio θα σας δώσει τον κώδικα που απαιτείται για να ρο προσπελάσετε, σε αυτή η περίπτωση x5[[2]][[2]][[2]].\n\n\n\n\n\n23.2.2 Στήλες λίστας\nΛίστες μπορούν επίσης να υπάρχουν μέσα σε ένα tibble, όπου τις ονομάζουμε στήλες λίστας. Οι στήλες λίστας είναι χρήσιμες επειδή σας επιτρέπουν να τοποθετήσετε σε ένα tibble αντικείμενα που συνήθως δεν θα ανήκαν εκεί. Συγκεκριμένα, οι στήλες λίστας χρησιμοποιούνται πολύ στο οικοσύστημα των tidymodels, επειδή σας επιτρέπουν να αποθηκεύετε πράγματα, όπως αποτελέσματα μοντέλων ή επαναδειγματοληψίας, σε ένα πλαίσιο δεδομένων.\nΟρίστε ένα απλό παράδειγμα στήλης λίστας:\n\ndf &lt;- tibble(\n  x = 1:2, \n  y = c(\"a\", \"b\"),\n  z = list(list(1, 2), list(3, 4, 5))\n)\ndf\n#&gt; # A tibble: 2 × 3\n#&gt;       x y     z         \n#&gt;   &lt;int&gt; &lt;chr&gt; &lt;list&gt;    \n#&gt; 1     1 a     &lt;list [2]&gt;\n#&gt; 2     2 b     &lt;list [3]&gt;\n\nΔεν υπάρχει τίποτα ιδιαίτερο σχετικά με τις λίστες σε ένα tibble. Συμπεριφέρονται όπως κάθε άλλη στήλη:\n\ndf |&gt; \n  filter(x == 1)\n#&gt; # A tibble: 1 × 3\n#&gt;       x y     z         \n#&gt;   &lt;int&gt; &lt;chr&gt; &lt;list&gt;    \n#&gt; 1     1 a     &lt;list [2]&gt;\n\nΟ υπολογισμός με στήλες λίστας είναι πιο δύσκολος, αλλά αυτό συμβαίνει επειδή ο υπολογισμός με λίστες είναι γενικά πιο δύσκολος. Θα επανέλθουμε σε αυτό στο Κεφάλαιο 26. Σε αυτό το κεφάλαιο, θα επικεντρωθούμε στην αναδόμηση στηλών λίστας σε κανονικές μεταβλητές, ώστε να μπορείτε να χρησιμοποιήσετε σε αυτές τα υπάρχοντα εργαλεία σας.\nΗ προεπιλεγμένη μέθοδος εκτύπωσης εμφανίζει απλώς μία κατά προσέγγιση περίληψη των περιεχομένων. Η στήλη της λίστας μπορεί να είναι αυθαίρετα πολύπλοκη, επομένως δεν υπάρχει καλός τρόπος να την εκτυπώσετε. Εάν θέλετε να την δείτε, θα χρειαστεί να τραβήξετε μόνο τη μία στήλη λίστας και να εφαρμόσετε μία από τις τεχνικές που μάθατε παραπάνω, όπως df |&gt; pull(z) |&gt; str() ή df |&gt; pull(z) |&gt; View().\n\n\n\n\n\n\nΒασικό σύνολο λειτουργιών της R\n\n\n\nΤο να τοποθετήσετε μία λίστα σε μία στήλη ενός data.frame είναι εφικτό, αλλά είναι πολύ πιο περίπλοκο, καθώς το data.frame() αντιμετωπίζει μία λίστα ως μία λίστα με στήλες:\n\ndata.frame(x = list(1:3, 3:5))\n#&gt;   x.1.3 x.3.5\n#&gt; 1     1     3\n#&gt; 2     2     4\n#&gt; 3     3     5\n\nΜπορείτε να αναγκάσετε το data.frame() να αντιμετωπίζει μία λίστα ως μία λίστα γραμμών τυλίγοντας τη στη λίστα I(), το αποτέλεσμα όμως δεν εκτυπώνεται ιδιαίτερα καλά:\n\ndata.frame(\n  x = I(list(1:2, 3:5)), \n  y = c(\"1, 2\", \"3, 4, 5\")\n)\n#&gt;         x       y\n#&gt; 1    1, 2    1, 2\n#&gt; 2 3, 4, 5 3, 4, 5\n\nΕίναι πιο εύκολο να χρησιμοποιείτε στήλες λίστας με tibbles, επειδή το tibble() αντιμετωπίζει τις λίστες σαν διανύσματα αλλά και γιατί η μέθοδος εκτύπωσης έχει σχεδιαστεί με γνώμονα τις λίστες.",
    "crumbs": [
      "Εισαγωγή δεδομένων",
      "<span class='chapter-number'>23</span>  <span class='chapter-title'>Ιεραρχικά δεδομένα</span>"
    ]
  },
  {
    "objectID": "rectangling.html#αναδόμηση-unnest",
    "href": "rectangling.html#αναδόμηση-unnest",
    "title": "23  Ιεραρχικά δεδομένα",
    "section": "\n23.3 Αναδόμηση (Unnest)",
    "text": "23.3 Αναδόμηση (Unnest)\nΤώρα που μάθατε τα βασικά των λιστών και των στηλών λίστας, ας εξερευνήσουμε πώς μπορείτε να τις μετατρέψετε ξανά σε κανονικές γραμμές και στήλες. Εδώ θα χρησιμοποιήσουμε πολύ απλά δείγματα δεδομένων, ώστε να έχετε τη βασική ιδέα. Στην επόμενη ενότητα θα ασχοληθούμε με πραγματικά δεδομένα.\nΟι στήλες λίστας τείνουν να έρχονται σε δύο βασικές μορφές: με ονόματα και χωρίς ονόματα. Όταν τα παιδιά της λίστας ονομάζονται, τείνουν να έχουν τα ίδια ονόματα σε κάθε γραμμή. Για παράδειγμα, στο df1, κάθε στοιχείο της στήλης λίστας y έχει δύο στοιχεία που ονομάζονται a και b. Οι στήλες λίστας με ονόματα αναδομούνται σε στήλες: κάθε ονοματισμένο στοιχείο γίνεται μία νέα στήλη με όνομα.\n\ndf1 &lt;- tribble(\n  ~x, ~y,\n  1, list(a = 11, b = 12),\n  2, list(a = 21, b = 22),\n  3, list(a = 31, b = 32),\n)\n\nΌταν τα παιδιά είναι χωρίς όνομα, ο αριθμός των στοιχείων τείνει να διαφέρει από γραμμή σε γραμμή. Για παράδειγμα, στο df2, τα στοιχεία της στήλης λίστας y δεν έχουν όνομα και ποικίλλουν σε μήκος από ένα έως τρία. Οι στήλες λίστας χωρίς ονόματα αναδομούνται σε γραμμές: θα πάρετε μία γραμμή για κάθε παιδί της λίστας.\n\n\ndf2 &lt;- tribble(\n  ~x, ~y,\n  1, list(11, 12, 13),\n  2, list(21),\n  3, list(31, 32),\n)\n\nΤο πακέτο tidyr παρέχει δύο συναρτήσεις για αυτές τις δύο περιπτώσεις: την unnest_wider() και unnest_longer(). Οι ακόλουθες ενότητες εξηγούν πώς λειτουργούν.\n\n23.3.1 unnest_wider()\n\nΌταν κάθε γραμμή έχει τον ίδιο αριθμό στοιχείων με τα ίδια ονόματα, όπως στο df1, είναι λογικό κάθε στοιχείο να τοποθετείται στη δική του στήλη με την unnest_wider():\n\ndf1 |&gt; \n  unnest_wider(y)\n#&gt; # A tibble: 3 × 3\n#&gt;       x     a     b\n#&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n#&gt; 1     1    11    12\n#&gt; 2     2    21    22\n#&gt; 3     3    31    32\n\nΑπό προεπιλογή, τα ονόματα των νέων στηλών προέρχονται αποκλειστικά από τα ονόματα των στοιχείων της λίστας, μπορείτε όμως να χρησιμοποιήσετε το όρισμα names_sep για να συνδυάσετε το όνομα της στήλης και το όνομα του στοιχείου. Αυτό είναι χρήσιμο για την αποσαφήνιση επαναλαμβανόμενων ονομάτων.\n\ndf1 |&gt; \n  unnest_wider(y, names_sep = \"_\")\n#&gt; # A tibble: 3 × 3\n#&gt;       x   y_a   y_b\n#&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n#&gt; 1     1    11    12\n#&gt; 2     2    21    22\n#&gt; 3     3    31    32\n\n\n23.3.2 unnest_longer()\n\nΌταν κάθε γραμμή περιέχει μία λίστα χωρίς ονόματα, είναι πιο λογικό να τοποθετήσετε κάθε στοιχείο στη δική του γραμμή με την unnest_longer():\n\ndf2 |&gt; \n  unnest_longer(y)\n#&gt; # A tibble: 6 × 2\n#&gt;       x     y\n#&gt;   &lt;dbl&gt; &lt;dbl&gt;\n#&gt; 1     1    11\n#&gt; 2     1    12\n#&gt; 3     1    13\n#&gt; 4     2    21\n#&gt; 5     3    31\n#&gt; 6     3    32\n\nΣημειώστε πως η x αντιγράφεται για κάθε στοιχείο μέσα στην y: έτσι παίρνουμε μία γραμμή εξόδου για κάθε στοιχείο μέσα στη στήλη λίστα. Τι συμβαίνει όμως εάν ένα από τα στοιχεία είναι κενό, όπως στο παρακάτω παράδειγμα;\n\ndf6 &lt;- tribble(\n  ~x, ~y,\n  \"a\", list(1, 2),\n  \"b\", list(3),\n  \"c\", list()\n)\ndf6 |&gt; unnest_longer(y)\n#&gt; # A tibble: 3 × 2\n#&gt;   x         y\n#&gt;   &lt;chr&gt; &lt;dbl&gt;\n#&gt; 1 a         1\n#&gt; 2 a         2\n#&gt; 3 b         3\n\nΛαμβάνουμε μηδέν γραμμές στην έξοδο, οπότε ουσιαστικά η γραμμή εξαφανίζεται. Σε περίπτωση που θέλετε να κρατήσετε αυτήν τη γραμμή, προσθέτοντας NA στη y, ορίστε το keep_empty = TRUE.\n\n23.3.3 Αντιφατικοί τύποι δεδομένων\nΤι συμβαίνει εάν αφαιρέσετε μία στήλη λίστας που περιέχει διαφορετικούς τύπους διανυσμάτων;\nΓια παράδειγμα, πάρτε το ακόλουθο σύνολο δεδομένων όπου η στήλη λίστας y περιέχει δύο αριθμούς, έναν χαρακτήρα και μία τιμή λογικού τύπου, που κανονικά δεν μπορούν να συγχωνευθούν σε μία στήλη.\n\ndf4 &lt;- tribble(\n  ~x, ~y,\n  \"a\", list(1),\n  \"b\", list(\"a\", TRUE, 5)\n)\n\nΗ unnest_longer() διατηρεί πάντα το σύνολο των στηλών αμετάβλητο, ενώ αλλάζει τον αριθμό των γραμμών. Τι συμβαίνει λοιπόν;\nΠώς η unnest_longer() παράγει πέντε γραμμές ενώ διατηρεί τα πάντα στην y;\n\ndf4 |&gt; \n  unnest_longer(y)\n#&gt; # A tibble: 4 × 2\n#&gt;   x     y        \n#&gt;   &lt;chr&gt; &lt;list&gt;   \n#&gt; 1 a     &lt;dbl [1]&gt;\n#&gt; 2 b     &lt;chr [1]&gt;\n#&gt; 3 b     &lt;lgl [1]&gt;\n#&gt; 4 b     &lt;dbl [1]&gt;\n\nΌπως μπορείτε να δείτε, η έξοδος περιέχει μία στήλη λίστας, αλλά κάθε στοιχείο της στήλης λίστας περιέχει ένα μόνο στοιχείο. Επειδή η unnest_longer() δεν μπορεί να βρει έναν κοινό τύπο διανύσματος, διατηρεί τους αρχικούς τύπους σε μία στήλη λίστας. Ίσως αναρωτηθείτε αν αυτό παραβαίνει τον κανόνα ότι κάθε στοιχείο μιας στήλης πρέπει να είναι του ίδιου τύπου. Δεν την παραβαίνει: κάθε στοιχείο είναι μία λίστα, παρόλο που τα περιεχόμενα είναι διαφορετικών τύπων.\nΗ αντιμετώπιση αντιφατικών τύπων είναι μία πρόκληση και οι λεπτομέρειες εξαρτώνται από την ακριβή φύση του προβλήματος και τους στόχους σας. Πιθανότατα όμως θα χρειαστείτε εργαλεία που αναφέρονται στο Κεφάλαιο 26.\n\n23.3.4 Λοιπές συναρτήσεις\nΤο πακέτο tidyr έχει και μερικές άλλες χρήσιμες συναρτήσεις ορθογωνοποίησης που δεν θα καλύψουμε σε αυτό το βιβλίο:\n\nΗ unnest_auto() επιλέγει αυτόματα μεταξύ των unnest_longer() και unnest_wider() με βάση τη δομή της στήλης λίστας. Είναι εξαιρετική για γρήγορη εξερεύνηση των δεδομένων, τελικά όμως είναι κακή ιδέα γιατί δεν σας αναγκάζει να κατανοήσετε πώς είναι δομημένα τα δεδομένα σας, και κάνει τον κώδικά σας πιο δυσνόητο.\nΗ unnest() επεκτείνει και τις γραμμές και τις στήλες. Είναι χρήσιμη όταν έχετε μία στήλη λίστας που περιέχει μία δισδιάστατη δομή, όπως ένα πλαίσιο δεδομένων, δομή την οποία δεν συναντάτε σε αυτό το βιβλίο, αλλά μπορεί να συναντήσετε εάν χρησιμοποιήσετε το οικοσύστημα των tidymodels.\n\nΕίναι καλό να γνωρίζετε αυτές τις συναρτήσεις καθώς μπορεί να τις συναντήσετε όταν διαβάζετε τον κώδικα άλλων ή όταν αντιμετωπίζετε πιο σπάνιες προκλήσεις ορθογωνοποίησης.\n\n23.3.5 Ασκήσεις\n\nΤι συμβαίνει όταν χρησιμοποιείτε την unnest_wider() με στήλες λίστας χωρίς ονόματα, όπως στο df2;\nΠοιο όρισμα είναι τώρα απαραίτητο;\nΤι συμβαίνει με τις κενές τιμές;\nΤι συμβαίνει όταν χρησιμοποιείτε την unnest_longer() με στήλες λίστας με ονόματα, όπως στο df1;\nΠοιες πρόσθετες πληροφορίες λαμβάνετε στην έξοδο;\nΠώς μπορείτε να αποκρύψετε αυτή την επιπλέον λεπτομέρεια;\n\nΚατά καιρούς συναντάτε πλαίσια δεδομένων με πολλαπλές στήλες λίστας με ευθυγραμμισμένες τιμές. Για παράδειγμα, στο ακόλουθο πλαίσιο δεδομένων, οι τιμές των y και z είναι ευθυγραμμισμένες (δηλαδή, η y και η z θα έχουν πάντα το ίδιο μήκος σε μία γραμμή και η πρώτη τιμή της y αντιστοιχεί στη πρώτη τιμή της z). Τι συμβαίνει εάν εφαρμόσετε δύο φορές την unnest_longer() σε αυτό το πλαίσιο δεδομένων;\nΠώς μπορείτε να διατηρήσετε τη σχέση μεταξύ x και y;\n(Υπόδειξη: διαβάστε προσεκτικά τις αντίστοιχες οδηγίες).\n\ndf4 &lt;- tribble(\n  ~x, ~y, ~z,\n  \"a\", list(\"y-a-1\", \"y-a-2\"), list(\"z-a-1\", \"z-a-2\"),\n  \"b\", list(\"y-b-1\", \"y-b-2\", \"y-b-3\"), list(\"z-b-1\", \"z-b-2\", \"z-b-3\")\n)",
    "crumbs": [
      "Εισαγωγή δεδομένων",
      "<span class='chapter-number'>23</span>  <span class='chapter-title'>Ιεραρχικά δεδομένα</span>"
    ]
  },
  {
    "objectID": "rectangling.html#μελέτες-περίπτωσης",
    "href": "rectangling.html#μελέτες-περίπτωσης",
    "title": "23  Ιεραρχικά δεδομένα",
    "section": "\n23.4 Μελέτες περίπτωσης",
    "text": "23.4 Μελέτες περίπτωσης\nΗ κύρια διαφορά μεταξύ των απλών παραδειγμάτων που χρησιμοποιήσαμε παραπάνω και των πραγματικών δεδομένων είναι ότι τα πραγματικά δεδομένα περιέχουν συνήθως πολλαπλά επίπεδα ένθεσης, που απαιτούν πολλαπλές εφαρμογές της unnest_longer() και/ή της unnest_wider(). Για να το δείξουμε αυτό στην πράξη, η ενότητα αυτή λειτουργεί μέσω τριών πραγματικών προκλήσεων ορθογωνοποίησης χρησιμοποιώντας σύνολα δεδομένων από το πακέτο repurrrsive.\n\n23.4.1 Δεδομένα με μεγάλο πλάτος\nΘα ξεκινήσουμε με την gh_repos. Αυτή είναι μία λίστα που περιέχει δεδομένα σχετικά με μία συλλογή αποθετηρίων στο GitHub, τα οποία ανακτήθηκαν χρησιμοποιώντας το API του GitHub. Είναι μία εις βάθος ένθετη λίστα, κι επομένως είναι δύσκολο να δείξουμε τη δομή της σε αυτό το βιβλίο. Πριν συνεχίσουμε, συνιστούμε να την εξερευνήσετε λίγο μόνοι σας με την View(gh_repos).\nΗ gh_repos είναι μία λίστα, αλλά τα εργαλεία μας λειτουργούν με στήλες λίστας, οπότε θα ξεκινήσουμε βάζοντάς την σε ένα tibble. Ονομάζουμε αυτήν τη στήλη json για λόγους που θα δούμε αργότερα.\n\nrepos &lt;- tibble(json = gh_repos)\nrepos\n#&gt; # A tibble: 6 × 1\n#&gt;   json       \n#&gt;   &lt;list&gt;     \n#&gt; 1 &lt;list [30]&gt;\n#&gt; 2 &lt;list [30]&gt;\n#&gt; 3 &lt;list [30]&gt;\n#&gt; 4 &lt;list [26]&gt;\n#&gt; 5 &lt;list [30]&gt;\n#&gt; 6 &lt;list [30]&gt;\n\nΑυτό το tibble περιέχει 6 γραμμές, μία γραμμή για κάθε παιδί της gh_repos. Κάθε γραμμή περιέχει μία λίστα χωρίς ονόματα, με 26 ή 30 γραμμές. Δεδομένου ότι αυτά είναι χωρίς όνομα, θα ξεκινήσουμε με την unnest_longer() για να βάλουμε κάθε παιδί στη δική του γραμμή:\n\nrepos |&gt; \n  unnest_longer(json)\n#&gt; # A tibble: 176 × 1\n#&gt;   json             \n#&gt;   &lt;list&gt;           \n#&gt; 1 &lt;named list [68]&gt;\n#&gt; 2 &lt;named list [68]&gt;\n#&gt; 3 &lt;named list [68]&gt;\n#&gt; 4 &lt;named list [68]&gt;\n#&gt; 5 &lt;named list [68]&gt;\n#&gt; 6 &lt;named list [68]&gt;\n#&gt; # ℹ 170 more rows\n\nΜε μία πρώτη ματιά, μπορεί να φαίνεται ότι δεν έχουμε βελτιώσει την κατάσταση: ενώ έχουμε περισσότερες γραμμές (176 αντί για 6), κάθε στοιχείο της json εξακολουθεί να είναι μία λίστα. Ωστόσο, υπάρχει μία σημαντική διαφορά: τώρα κάθε στοιχείο είναι μία λίστα με ονόματα, ώστε να μπορούμε να χρησιμοποιήσουμε την unnest_wider() για να βάλουμε κάθε στοιχείο στη δική του στήλη:\n\nrepos |&gt; \n  unnest_longer(json) |&gt; \n  unnest_wider(json) \n#&gt; # A tibble: 176 × 68\n#&gt;         id name        full_name         owner        private html_url       \n#&gt;      &lt;int&gt; &lt;chr&gt;       &lt;chr&gt;             &lt;list&gt;       &lt;lgl&gt;   &lt;chr&gt;          \n#&gt; 1 61160198 after       gaborcsardi/after &lt;named list&gt; FALSE   https://github…\n#&gt; 2 40500181 argufy      gaborcsardi/argu… &lt;named list&gt; FALSE   https://github…\n#&gt; 3 36442442 ask         gaborcsardi/ask   &lt;named list&gt; FALSE   https://github…\n#&gt; 4 34924886 baseimports gaborcsardi/base… &lt;named list&gt; FALSE   https://github…\n#&gt; 5 61620661 citest      gaborcsardi/cite… &lt;named list&gt; FALSE   https://github…\n#&gt; 6 33907457 clisymbols  gaborcsardi/clis… &lt;named list&gt; FALSE   https://github…\n#&gt; # ℹ 170 more rows\n#&gt; # ℹ 62 more variables: description &lt;chr&gt;, fork &lt;lgl&gt;, url &lt;chr&gt;, …\n\nΑυτό λειτούργησε, αλλά το αποτέλεσμα δεν είναι με το μέρος μας: υπάρχουν τόσες πολλές στήλες που η tibble δεν τις εκτυπώνει όλες! Μπορούμε να τις δούμε με την names(). Εδώ βλέπουμε τις πρώτα 10:\n\nrepos |&gt; \n  unnest_longer(json) |&gt; \n  unnest_wider(json) |&gt; \n  names() |&gt; \n  head(10)\n#&gt;  [1] \"id\"          \"name\"        \"full_name\"   \"owner\"       \"private\"    \n#&gt;  [6] \"html_url\"    \"description\" \"fork\"        \"url\"         \"forks_url\"\n\nΑς κρατήσουμε μερικές στήλες που φαίνονται ενδιαφέρουσες:\n\nrepos |&gt; \n  unnest_longer(json) |&gt; \n  unnest_wider(json) |&gt; \n  select(id, full_name, owner, description)\n#&gt; # A tibble: 176 × 4\n#&gt;         id full_name               owner             description             \n#&gt;      &lt;int&gt; &lt;chr&gt;                   &lt;list&gt;            &lt;chr&gt;                   \n#&gt; 1 61160198 gaborcsardi/after       &lt;named list [17]&gt; Run Code in the Backgro…\n#&gt; 2 40500181 gaborcsardi/argufy      &lt;named list [17]&gt; Declarative function ar…\n#&gt; 3 36442442 gaborcsardi/ask         &lt;named list [17]&gt; Friendly CLI interactio…\n#&gt; 4 34924886 gaborcsardi/baseimports &lt;named list [17]&gt; Do we get warnings for …\n#&gt; 5 61620661 gaborcsardi/citest      &lt;named list [17]&gt; Test R package and repo…\n#&gt; 6 33907457 gaborcsardi/clisymbols  &lt;named list [17]&gt; Unicode symbols for CLI…\n#&gt; # ℹ 170 more rows\n\nΜπορείτε να χρησιμοποιήσετε το παραπάνω για να κατανοήσετε το πως δομήθηκε η gh_repos: κάθε παιδί ήταν και ένας χρήστης του GitHub στον οποίο αντιστοιχεί μία λίστα, η οποία περιέχει έως και 30 αποθετήρια που αυτός ο χρήστης δημιούργησε.\nΗ owner είναι μία άλλη στήλη λίστας και δεδομένου ότι περιέχει λίστες με ονόματα, μπορούμε να χρησιμοποιήσουμε την unnest_wider() για να φτάσουμε στις τιμές:\n\nrepos |&gt; \n  unnest_longer(json) |&gt; \n  unnest_wider(json) |&gt; \n  select(id, full_name, owner, description) |&gt; \n  unnest_wider(owner)\n#&gt; Error in `unnest_wider()`:\n#&gt; ! Can't duplicate names between the affected columns and the original\n#&gt;   data.\n#&gt; ✖ These names are duplicated:\n#&gt;   ℹ `id`, from `owner`.\n#&gt; ℹ Use `names_sep` to disambiguate using the column name.\n#&gt; ℹ Or use `names_repair` to specify a repair strategy.\n\nΩχ, αυτή η στήλη λίστας περιέχει επίσης μία στήλη id και δεν μπορούμε να έχουμε δύο στήλες με το όνομα id στο ίδιο πλαίσιο δεδομένων. Όπως προτείνεται, ας χρησιμοποιήσουμε την names_sep για να επιλύσουμε το πρόβλημα:\n\nrepos |&gt; \n  unnest_longer(json) |&gt; \n  unnest_wider(json) |&gt; \n  select(id, full_name, owner, description) |&gt; \n  unnest_wider(owner, names_sep = \"_\")\n#&gt; # A tibble: 176 × 20\n#&gt;         id full_name               owner_login owner_id owner_avatar_url     \n#&gt;      &lt;int&gt; &lt;chr&gt;                   &lt;chr&gt;          &lt;int&gt; &lt;chr&gt;                \n#&gt; 1 61160198 gaborcsardi/after       gaborcsardi   660288 https://avatars.gith…\n#&gt; 2 40500181 gaborcsardi/argufy      gaborcsardi   660288 https://avatars.gith…\n#&gt; 3 36442442 gaborcsardi/ask         gaborcsardi   660288 https://avatars.gith…\n#&gt; 4 34924886 gaborcsardi/baseimports gaborcsardi   660288 https://avatars.gith…\n#&gt; 5 61620661 gaborcsardi/citest      gaborcsardi   660288 https://avatars.gith…\n#&gt; 6 33907457 gaborcsardi/clisymbols  gaborcsardi   660288 https://avatars.gith…\n#&gt; # ℹ 170 more rows\n#&gt; # ℹ 15 more variables: owner_gravatar_id &lt;chr&gt;, owner_url &lt;chr&gt;, …\n\nΑυτό επιστρέφει ένα άλλο πλατύ σύνολο δεδομένων. Μπορείτε όμως να καταλάβετε ότι η στήλη owner φαίνεται να περιέχει πολλά πρόσθετα δεδομένα σχετικά με το άτομο που “κατέχει” το αποθετήριο.\n\n23.4.2 Σχεσιακά δεδομένα\nΤα ένθετα δεδομένα χρησιμοποιούνται μερικές φορές για την αναπαράσταση δεδομένων που συνήθως θα διανέμαμε σε πολλαπλά πλαίσια δεδομένων. Για παράδειγμα, πάρτε την got_chars που περιέχει δεδομένα σχετικά με χαρακτήρες που εμφανίζονται στα βιβλία και τις τηλεοπτικές σειρές του Game of Thrones. Όπως και η gh_repos, έτσι και αυτή είναι μία λίστα, οπότε ξεκινάμε μετατρέποντάς την σε στήλη λίστας ενός tibble:\n\nchars &lt;- tibble(json = got_chars)\nchars\n#&gt; # A tibble: 30 × 1\n#&gt;   json             \n#&gt;   &lt;list&gt;           \n#&gt; 1 &lt;named list [18]&gt;\n#&gt; 2 &lt;named list [18]&gt;\n#&gt; 3 &lt;named list [18]&gt;\n#&gt; 4 &lt;named list [18]&gt;\n#&gt; 5 &lt;named list [18]&gt;\n#&gt; 6 &lt;named list [18]&gt;\n#&gt; # ℹ 24 more rows\n\nΗ στήλη json περιέχει στοιχεία με ονόματα, επομένως θα ξεκινήσουμε διευρύνοντας την:\n\nchars |&gt; \n  unnest_wider(json)\n#&gt; # A tibble: 30 × 18\n#&gt;   url                    id name            gender culture    born           \n#&gt;   &lt;chr&gt;               &lt;int&gt; &lt;chr&gt;           &lt;chr&gt;  &lt;chr&gt;      &lt;chr&gt;          \n#&gt; 1 https://www.anapio…  1022 Theon Greyjoy   Male   \"Ironborn\" \"In 278 AC or …\n#&gt; 2 https://www.anapio…  1052 Tyrion Lannist… Male   \"\"         \"In 273 AC, at…\n#&gt; 3 https://www.anapio…  1074 Victarion Grey… Male   \"Ironborn\" \"In 268 AC or …\n#&gt; 4 https://www.anapio…  1109 Will            Male   \"\"         \"\"             \n#&gt; 5 https://www.anapio…  1166 Areo Hotah      Male   \"Norvoshi\" \"In 257 AC or …\n#&gt; 6 https://www.anapio…  1267 Chett           Male   \"\"         \"At Hag's Mire\"\n#&gt; # ℹ 24 more rows\n#&gt; # ℹ 12 more variables: died &lt;chr&gt;, alive &lt;lgl&gt;, titles &lt;list&gt;, …\n\nΚαι επιλέγοντας μερικές στήλες για πιο εύκολη ανάγνωση:\n\ncharacters &lt;- chars |&gt; \n  unnest_wider(json) |&gt; \n  select(id, name, gender, culture, born, died, alive)\ncharacters\n#&gt; # A tibble: 30 × 7\n#&gt;      id name              gender culture    born              died           \n#&gt;   &lt;int&gt; &lt;chr&gt;             &lt;chr&gt;  &lt;chr&gt;      &lt;chr&gt;             &lt;chr&gt;          \n#&gt; 1  1022 Theon Greyjoy     Male   \"Ironborn\" \"In 278 AC or 27… \"\"             \n#&gt; 2  1052 Tyrion Lannister  Male   \"\"         \"In 273 AC, at C… \"\"             \n#&gt; 3  1074 Victarion Greyjoy Male   \"Ironborn\" \"In 268 AC or be… \"\"             \n#&gt; 4  1109 Will              Male   \"\"         \"\"                \"In 297 AC, at…\n#&gt; 5  1166 Areo Hotah        Male   \"Norvoshi\" \"In 257 AC or be… \"\"             \n#&gt; 6  1267 Chett             Male   \"\"         \"At Hag's Mire\"   \"In 299 AC, at…\n#&gt; # ℹ 24 more rows\n#&gt; # ℹ 1 more variable: alive &lt;lgl&gt;\n\nΑυτό το σύνολο δεδομένων περιέχει επίσης πολλές στήλες λίστας:\n\nchars |&gt; \n  unnest_wider(json) |&gt; \n  select(id, where(is.list))\n#&gt; # A tibble: 30 × 8\n#&gt;      id titles    aliases    allegiances books     povBooks tvSeries playedBy\n#&gt;   &lt;int&gt; &lt;list&gt;    &lt;list&gt;     &lt;list&gt;      &lt;list&gt;    &lt;list&gt;   &lt;list&gt;   &lt;list&gt;  \n#&gt; 1  1022 &lt;chr [2]&gt; &lt;chr [4]&gt;  &lt;chr [1]&gt;   &lt;chr [3]&gt; &lt;chr&gt;    &lt;chr&gt;    &lt;chr&gt;   \n#&gt; 2  1052 &lt;chr [2]&gt; &lt;chr [11]&gt; &lt;chr [1]&gt;   &lt;chr [2]&gt; &lt;chr&gt;    &lt;chr&gt;    &lt;chr&gt;   \n#&gt; 3  1074 &lt;chr [2]&gt; &lt;chr [1]&gt;  &lt;chr [1]&gt;   &lt;chr [3]&gt; &lt;chr&gt;    &lt;chr&gt;    &lt;chr&gt;   \n#&gt; 4  1109 &lt;chr [1]&gt; &lt;chr [1]&gt;  &lt;NULL&gt;      &lt;chr [1]&gt; &lt;chr&gt;    &lt;chr&gt;    &lt;chr&gt;   \n#&gt; 5  1166 &lt;chr [1]&gt; &lt;chr [1]&gt;  &lt;chr [1]&gt;   &lt;chr [3]&gt; &lt;chr&gt;    &lt;chr&gt;    &lt;chr&gt;   \n#&gt; 6  1267 &lt;chr [1]&gt; &lt;chr [1]&gt;  &lt;NULL&gt;      &lt;chr [2]&gt; &lt;chr&gt;    &lt;chr&gt;    &lt;chr&gt;   \n#&gt; # ℹ 24 more rows\n\nΑς εξερευνήσουμε τη στήλη titles. Είναι μία στήλη λίστας χωρίς ονόματα, επομένως θα την αναδομήσουμε σε γραμμές:\n\nchars |&gt; \n  unnest_wider(json) |&gt; \n  select(id, titles) |&gt; \n  unnest_longer(titles)\n#&gt; # A tibble: 59 × 2\n#&gt;      id titles                                              \n#&gt;   &lt;int&gt; &lt;chr&gt;                                               \n#&gt; 1  1022 Prince of Winterfell                                \n#&gt; 2  1022 Lord of the Iron Islands (by law of the green lands)\n#&gt; 3  1052 Acting Hand of the King (former)                    \n#&gt; 4  1052 Master of Coin (former)                             \n#&gt; 5  1074 Lord Captain of the Iron Fleet                      \n#&gt; 6  1074 Master of the Iron Victory                          \n#&gt; # ℹ 53 more rows\n\nΊσως να περιμένατε να δείτε τα δεδομένα στον δικό τους, ξεχωριστό πίνακα, καθώς θα ήταν εύκολο να ενωθούν με τα δεδομένα χαρακτήρων όπως απαιτείται. Ας δοκιμάσουμε αυτή την επιλογή, μιας και απαιτεί πολύ λίγα βήματα καθαρισμού των δεδομένων: αφαιρούμε τις γραμμές που περιέχουν κενές συμβολοσειρές και μετονομάζουμε την στήλη titles σε title, καθώς κάθε γραμμή περιέχει πλέον μόνο έναν τίτλο.\n\ntitles &lt;- chars |&gt; \n  unnest_wider(json) |&gt; \n  select(id, titles) |&gt; \n  unnest_longer(titles) |&gt; \n  filter(titles != \"\") |&gt; \n  rename(title = titles)\ntitles\n#&gt; # A tibble: 52 × 2\n#&gt;      id title                                               \n#&gt;   &lt;int&gt; &lt;chr&gt;                                               \n#&gt; 1  1022 Prince of Winterfell                                \n#&gt; 2  1022 Lord of the Iron Islands (by law of the green lands)\n#&gt; 3  1052 Acting Hand of the King (former)                    \n#&gt; 4  1052 Master of Coin (former)                             \n#&gt; 5  1074 Lord Captain of the Iron Fleet                      \n#&gt; 6  1074 Master of the Iron Victory                          \n#&gt; # ℹ 46 more rows\n\nΘα μπορούσατε να φανταστείτε την δημιουργία ενός πίνακα σαν αυτόν για κάθε μία από τις στήλες λίστας και στη συνέχεια να χρησιμοποιήσετε συναρτήσεις ένωσης για να τις συνδυάσετε με τα δεδομένα χαρακτήρων με όποιον τρόπο τα χρειάζεστε.\n\n23.4.3 Πολυεπίπεδη ένθεση\nΘα ολοκληρώσουμε αυτές τις μελέτες περίπτωσης με μία στήλη λίστας με αρκετό βάθος ένθεσης που απαιτεί επαναλαμβανόμενους γύρους εφαρμογής της unnest_wider() και της unnest_longer() για να αναδομηθεί: την gmaps_cities. Βρίσκεται σε ένα tibble δύο στηλών που περιέχει πέντε ονόματα πόλεων και τα αποτελέσματα της χρήσης του geocoding API της Google για τον προσδιορισμό της τοποθεσίας τους:\n\ngmaps_cities\n#&gt; # A tibble: 5 × 2\n#&gt;   city       json            \n#&gt;   &lt;chr&gt;      &lt;list&gt;          \n#&gt; 1 Houston    &lt;named list [2]&gt;\n#&gt; 2 Washington &lt;named list [2]&gt;\n#&gt; 3 New York   &lt;named list [2]&gt;\n#&gt; 4 Chicago    &lt;named list [2]&gt;\n#&gt; 5 Arlington  &lt;named list [2]&gt;\n\nΗ json είναι μία στήλη λίστας με εσωτερικά ονόματα, οπότε ξεκινάμε με ένα unnest_wider():\n\ngmaps_cities |&gt; \n  unnest_wider(json)\n#&gt; # A tibble: 5 × 3\n#&gt;   city       results    status\n#&gt;   &lt;chr&gt;      &lt;list&gt;     &lt;chr&gt; \n#&gt; 1 Houston    &lt;list [1]&gt; OK    \n#&gt; 2 Washington &lt;list [2]&gt; OK    \n#&gt; 3 New York   &lt;list [1]&gt; OK    \n#&gt; 4 Chicago    &lt;list [1]&gt; OK    \n#&gt; 5 Arlington  &lt;list [2]&gt; OK\n\nΑυτό μας δίνει τις στήλες status και results. Θα απορρίψουμε τη στήλη status επειδή όλες οι τιμές της είναι ΟΚ. Σε μία πραγματική ανάλυση, θα θέλατε επίσης να καταγράψετε όλες τις γραμμές όπου status != \"OK και να καταλάβετε τι πήγε στραβά. Η results είναι μία λίστα χωρίς ονόματα, με ένα ή δύο στοιχεία (θα δούμε το γιατί σύντομα) οπότε θα την αναδομήσουμε σε γραμμές:\n\ngmaps_cities |&gt; \n  unnest_wider(json) |&gt; \n  select(-status) |&gt; \n  unnest_longer(results)\n#&gt; # A tibble: 7 × 2\n#&gt;   city       results         \n#&gt;   &lt;chr&gt;      &lt;list&gt;          \n#&gt; 1 Houston    &lt;named list [5]&gt;\n#&gt; 2 Washington &lt;named list [5]&gt;\n#&gt; 3 Washington &lt;named list [5]&gt;\n#&gt; 4 New York   &lt;named list [5]&gt;\n#&gt; 5 Chicago    &lt;named list [5]&gt;\n#&gt; 6 Arlington  &lt;named list [5]&gt;\n#&gt; # ℹ 1 more row\n\nΤώρα η results είναι μία λίστα με ονόματα, επομένως θα χρησιμοποιήσουμε την unnest_wider():\n\nlocations &lt;- gmaps_cities |&gt; \n  unnest_wider(json) |&gt; \n  select(-status) |&gt; \n  unnest_longer(results) |&gt; \n  unnest_wider(results)\nlocations\n#&gt; # A tibble: 7 × 6\n#&gt;   city       address_components formatted_address   geometry        \n#&gt;   &lt;chr&gt;      &lt;list&gt;             &lt;chr&gt;               &lt;list&gt;          \n#&gt; 1 Houston    &lt;list [4]&gt;         Houston, TX, USA    &lt;named list [4]&gt;\n#&gt; 2 Washington &lt;list [2]&gt;         Washington, USA     &lt;named list [4]&gt;\n#&gt; 3 Washington &lt;list [4]&gt;         Washington, DC, USA &lt;named list [4]&gt;\n#&gt; 4 New York   &lt;list [3]&gt;         New York, NY, USA   &lt;named list [4]&gt;\n#&gt; 5 Chicago    &lt;list [4]&gt;         Chicago, IL, USA    &lt;named list [4]&gt;\n#&gt; 6 Arlington  &lt;list [4]&gt;         Arlington, TX, USA  &lt;named list [4]&gt;\n#&gt; # ℹ 1 more row\n#&gt; # ℹ 2 more variables: place_id &lt;chr&gt;, types &lt;list&gt;\n\nΤώρα μπορούμε να δούμε γιατί δύο πόλεις έλαβαν δύο αποτελέσματα (δηλαδή δύο στοιχεία στη στήλη results): H τιμή “Washington” αντιστοιχήθηκε με το “state of Washington” και με το “Washington DC” ενώ η τιμή “Arlington” αντιστοιχήθηκε με το “Arlington, Virginia” και το “Arlington, Texas”.\nΥπάρχουν μερικές διαφορετικές κατευθύνσεις που θα μπορούσαμε να πάρουμε τώρα. Ίσως θέλουμε να προσδιορίσουμε την ακριβή τοποθεσία της αντιστοίχισης, η οποία είναι αποθηκευμένη στη στήλη λίστας geometry:\n\nlocations |&gt; \n  select(city, formatted_address, geometry) |&gt; \n  unnest_wider(geometry)\n#&gt; # A tibble: 7 × 6\n#&gt;   city       formatted_address   bounds           location     location_type\n#&gt;   &lt;chr&gt;      &lt;chr&gt;               &lt;list&gt;           &lt;list&gt;       &lt;chr&gt;        \n#&gt; 1 Houston    Houston, TX, USA    &lt;named list [2]&gt; &lt;named list&gt; APPROXIMATE  \n#&gt; 2 Washington Washington, USA     &lt;named list [2]&gt; &lt;named list&gt; APPROXIMATE  \n#&gt; 3 Washington Washington, DC, USA &lt;named list [2]&gt; &lt;named list&gt; APPROXIMATE  \n#&gt; 4 New York   New York, NY, USA   &lt;named list [2]&gt; &lt;named list&gt; APPROXIMATE  \n#&gt; 5 Chicago    Chicago, IL, USA    &lt;named list [2]&gt; &lt;named list&gt; APPROXIMATE  \n#&gt; 6 Arlington  Arlington, TX, USA  &lt;named list [2]&gt; &lt;named list&gt; APPROXIMATE  \n#&gt; # ℹ 1 more row\n#&gt; # ℹ 1 more variable: viewport &lt;list&gt;\n\nΤο παραπάνω μας δίνει τις νέες στήλες λίστας bounds (όρια) (μια ορθογώνια περιοχή) και location (θέση) (ένα σημείο). Μπορούμε να αναδομήσουμε την location για να δούμε το γεωγραφικό πλάτος (lat) και το γεωγραφικό μήκος (lng):\n\nlocations |&gt; \n  select(city, formatted_address, geometry) |&gt; \n  unnest_wider(geometry) |&gt; \n  unnest_wider(location)\n#&gt; # A tibble: 7 × 7\n#&gt;   city       formatted_address   bounds             lat    lng location_type\n#&gt;   &lt;chr&gt;      &lt;chr&gt;               &lt;list&gt;           &lt;dbl&gt;  &lt;dbl&gt; &lt;chr&gt;        \n#&gt; 1 Houston    Houston, TX, USA    &lt;named list [2]&gt;  29.8  -95.4 APPROXIMATE  \n#&gt; 2 Washington Washington, USA     &lt;named list [2]&gt;  47.8 -121.  APPROXIMATE  \n#&gt; 3 Washington Washington, DC, USA &lt;named list [2]&gt;  38.9  -77.0 APPROXIMATE  \n#&gt; 4 New York   New York, NY, USA   &lt;named list [2]&gt;  40.7  -74.0 APPROXIMATE  \n#&gt; 5 Chicago    Chicago, IL, USA    &lt;named list [2]&gt;  41.9  -87.6 APPROXIMATE  \n#&gt; 6 Arlington  Arlington, TX, USA  &lt;named list [2]&gt;  32.7  -97.1 APPROXIMATE  \n#&gt; # ℹ 1 more row\n#&gt; # ℹ 1 more variable: viewport &lt;list&gt;\n\nΗ αναδόμηση της bounds απαιτεί μερικά ακόμη βήματα:\n\nlocations |&gt; \n  select(city, formatted_address, geometry) |&gt; \n  unnest_wider(geometry) |&gt; \n  # εστιάστε στις μεταβλητές που μας ενδιαφέρουν\n  select(!location:viewport) |&gt;\n  unnest_wider(bounds)\n#&gt; # A tibble: 7 × 4\n#&gt;   city       formatted_address   northeast        southwest       \n#&gt;   &lt;chr&gt;      &lt;chr&gt;               &lt;list&gt;           &lt;list&gt;          \n#&gt; 1 Houston    Houston, TX, USA    &lt;named list [2]&gt; &lt;named list [2]&gt;\n#&gt; 2 Washington Washington, USA     &lt;named list [2]&gt; &lt;named list [2]&gt;\n#&gt; 3 Washington Washington, DC, USA &lt;named list [2]&gt; &lt;named list [2]&gt;\n#&gt; 4 New York   New York, NY, USA   &lt;named list [2]&gt; &lt;named list [2]&gt;\n#&gt; 5 Chicago    Chicago, IL, USA    &lt;named list [2]&gt; &lt;named list [2]&gt;\n#&gt; 6 Arlington  Arlington, TX, USA  &lt;named list [2]&gt; &lt;named list [2]&gt;\n#&gt; # ℹ 1 more row\n\nΣτη συνέχεια μετονομάζουμε τις southwest και northeast (τις γωνίες του ορθογωνίου) ώστε να μπορούμε να χρησιμοποιήσουμε το names_sep για να δημιουργήσουμε σύντομα αλλά εύκολα να θυμάστε ονόματα:\n\nlocations |&gt; \n  select(city, formatted_address, geometry) |&gt; \n  unnest_wider(geometry) |&gt; \n  select(!location:viewport) |&gt;\n  unnest_wider(bounds) |&gt; \n  rename(ne = northeast, sw = southwest) |&gt; \n  unnest_wider(c(ne, sw), names_sep = \"_\") \n#&gt; # A tibble: 7 × 6\n#&gt;   city       formatted_address   ne_lat ne_lng sw_lat sw_lng\n#&gt;   &lt;chr&gt;      &lt;chr&gt;                &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;\n#&gt; 1 Houston    Houston, TX, USA      30.1  -95.0   29.5  -95.8\n#&gt; 2 Washington Washington, USA       49.0 -117.    45.5 -125. \n#&gt; 3 Washington Washington, DC, USA   39.0  -76.9   38.8  -77.1\n#&gt; 4 New York   New York, NY, USA     40.9  -73.7   40.5  -74.3\n#&gt; 5 Chicago    Chicago, IL, USA      42.0  -87.5   41.6  -87.9\n#&gt; 6 Arlington  Arlington, TX, USA    32.8  -97.0   32.6  -97.2\n#&gt; # ℹ 1 more row\n\nΣημειώστε πώς αφαιρούμε δύο στήλες ταυτόχρονα, παρέχοντας ένα διάνυσμα ονομάτων μεταβλητών στην unnest_wider().\nΜόλις ανακαλύψετε τη διαδρομή για να φτάσετε στα στοιχεία που σας ενδιαφέρουν, μπορείτε να τα εξάγετε απευθείας χρησιμοποιώντας μία άλλη συνάρτηση του πακέτου tidyr, την hoist():\n\nlocations |&gt; \n  select(city, formatted_address, geometry) |&gt; \n  hoist(\n    geometry,\n    ne_lat = c(\"bounds\", \"northeast\", \"lat\"),\n    sw_lat = c(\"bounds\", \"southwest\", \"lat\"),\n    ne_lng = c(\"bounds\", \"northeast\", \"lng\"),\n    sw_lng = c(\"bounds\", \"southwest\", \"lng\"),\n  )\n\nΕάν αυτές οι μελέτες περίπτωσης σας έχουν ανοίξει την όρεξη για περισσότερες πραγματικές εφαρμογές της ορθογωνοποίησης, μπορείτε να δείτε μερικά ακόμη παραδείγματα εκτελώντας το vignette(\"rectangling\", package = \"tidyr\").\n\n23.4.4 Ασκήσεις\n\nΥπολογίστε κατά προσέγγιση πότε δημιουργήθηκε η gh_repos. Γιατί μπορείτε να υπολογίσετε μόνο κατά προσέγγιση την ημερομηνία;\nΗ στήλη owner του gh_repo περιέχει πολλές διπλότυπες πληροφορίες, επειδή κάθε κάτοχος (owner) μπορεί να έχει πολλαπλά αποθετήρια. Μπορείτε να δημιουργήσετε ένα πλαίσιο δεδομένων owners που περιέχει μία γραμμή για κάθε κάτοχο;\n(Συμβουλή: λειτουργεί η distinct() με στήλες λίστας;)\nΑκολουθήστε τα βήματα που χρησιμοποιήθηκαν για το titles για να δημιουργήσετε παρόμοιους πίνακες για τα ψευδώνυμα, τις υποθέσεις, τα βιβλία και τις τηλεοπτικές σειρές για τους χαρακτήρες του Game of Thrones.\n\nΕξηγήστε τον ακόλουθο κώδικα γραμμή προς γραμμή. Γιατί είναι ενδιαφέρον;\nΓιατί λειτουργεί για την got_chars, αλλά μπορεί να μην λειτουργεί γενικά;\n\ntibble(json = got_chars) |&gt; \n  unnest_wider(json) |&gt; \n  select(id, where(is.list)) |&gt; \n  pivot_longer(\n    where(is.list), \n    names_to = \"name\", \n    values_to = \"value\"\n  ) |&gt;  \n  unnest_longer(value)\n\n\nΣτο gmaps_cities, τι περιέχει η address_components;\nΓιατί το μήκος (length) ποικίλλει μεταξύ γραμμών;\nΑναδομήστε το κατάλληλα για να το καταλάβετε. (Συμβουλή: Η types φαίνεται να περιέχει πάντα δύο στοιχεία. Διευκολύνει η unnest_wider() την εργασία σας σε σχέση με την unnest_longer();).",
    "crumbs": [
      "Εισαγωγή δεδομένων",
      "<span class='chapter-number'>23</span>  <span class='chapter-title'>Ιεραρχικά δεδομένα</span>"
    ]
  },
  {
    "objectID": "rectangling.html#json",
    "href": "rectangling.html#json",
    "title": "23  Ιεραρχικά δεδομένα",
    "section": "\n23.5 JSON",
    "text": "23.5 JSON\nΌλες οι μελέτες περίπτωσης στην προηγούμενη ενότητα προέρχονται από αρχεία JSON που βρίσκονται εκεί έξω. Το JSON είναι συντομογραφία του javascript object notation και είναι ο τρόπος με τον οποίο τα περισσότερα API στο διαδίκτυο επιστρέφουν δεδομένα. Είναι σημαντικό να το κατανοήσουμε γιατί, ενώ οι τύποι δεδομένων ενός JSON και της R είναι αρκετά παρόμοιοι, δεν υπάρχει 1-προς-1 αντιστοίχιση, επομένως είναι καλό να τα κατανοήσουμε για περίπτωση όπου τα πράγματα πάνε στραβά.\n\n23.5.1 Τύποι δεδομένων\nΤο JSON είναι μία απλή μορφή δεδομένων που έχει σχεδιαστεί για να διαβάζεται και να γράφεται εύκολα από μηχανές και όχι από ανθρώπους. Διαθέτει έξι βασικούς τύπους δεδομένων. Τέσσερα από αυτά είναι βαθμωτά μεγέθη:\n\nΟ απλούστερος τύπος είναι το κενό (null) που παίζει τον ίδιο ρόλο με το NA στην R. Αντιπροσωπεύει την απουσία δεδομένων.\nΜία συμβολοσειρά μοιάζει πολύ με μία συμβολοσειρά στην R, αλλά πρέπει πάντα να χρησιμοποιείται με διπλά εισαγωγικά.\nΈνας αριθμός είναι παρόμοιος με τους αριθμούς της R: μπορούν να χρησιμοποιούν ακέραιο (π.χ. 123), δεκαδικό (π.χ. 123,45) ή επιστημονικό (π.χ. 1.23e3) συμβολισμό. Το JSON δεν υποστηρίζει τιμές Inf, -Inf ή NaN.\nΈνα λογικό διάνυσμα είναι παρόμοιο με τα TRUE και FALSE της R, αλλά χρησιμοποιεί πεζά true και false.\n\nΟι συμβολοσειρές, οι αριθμοί και τα λογικά διανύσματα των JSON μοιάζουν αρκετά με τους χαρακτήρες, τα αριθμητικά και τα λογικά διανύσματα του R. Η κύρια διαφορά είναι ότι οι βαθμίδες των JSON μπορούν να αντιπροσωπεύουν μόνο μία τιμή. Για να αναπαραστήσετε πολλαπλές τιμές πρέπει να χρησιμοποιήσετε έναν από τους δύο εναπομείναντες τύπους: πίνακες (arrays) και αντικείμενα.\nΤόσο οι πίνακες όσο και τα αντικείμενα είναι παρόμοια με τις λίστες στην R. Η διαφορά είναι στο εάν ονομάζονται ή όχι. Ένας πίνακας είναι σαν μία λίστα χωρίς ονόματα και γράφεται με []. Για παράδειγμα, το [1, 2, 3] είναι ένας πίνακας που περιέχει 3 αριθμούς και το [null, 1, \"string\", false] είναι ένας πίνακας που περιέχει ένα κενό, έναν αριθμό, μία συμβολοσειρά και ένα λογικό διάνυσμα. Ένα αντικείμενο είναι σαν μία λίστα με ονόματα και γράφεται με {}. Τα ονόματα (κλειδιά στην ορολογία των JSON) είναι συμβολοσειρές, επομένως πρέπει να περιβάλλονται από εισαγωγικά. Για παράδειγμα, το {\"x\": 1, \"y\": 2} είναι ένα αντικείμενο που αντιστοιχίζει το x στο 1 και το y στο 2.\nΣημειώστε ότι το JSON δεν διαθέτει εγγενή τρόπο αναπαράστασης ημερομηνιών ή ωρών, επομένως αποθηκεύονται συχνά ως συμβολοσειρές και θα χρειαστεί να χρησιμοποιήσετε την readr::parse_date() ή την readr::parse_datetime() για να τα μετατρέψετε στη σωστή δομή δεδομένων. Ομοίως, οι κανόνες των JSON για την αναπαράσταση αριθμών κινητής υποδιαστολής είναι λίγο ανακριβείς, επομένως μερικές φορές θα βρείτε αριθμούς αποθηκευμένους σε συμβολοσειρές. Εφαρμόστε την readr::parse_double() όπως απαιτείται για να λάβετε τον σωστό τύπο μεταβλητής.\n\n23.5.2 jsonlite\nΓια να μετατρέψετε ένα αρχείο JSON σε δομές δεδομένων της R, προτείνουμε το πακέτο jsonlite, του Jeroen Ooms. Θα χρησιμοποιήσουμε μόνο δύο συναρτήσεις του jsonlite: την read_json() και την parse_json(). Σε πραγματικές συνθήκες, θα χρησιμοποιήσετε την read_json() για να διαβάσετε ένα αρχείο JSON από το δίσκο. Για παράδειγμα, το πακέτο repurrsive παρέχει επίσης το gh_user ως αρχείο JSON και μπορείτε να το διαβάσετε με την read_json():\n\n# Ένα μονοπάτι προς ένα αρχείο json μέσα στο πακέτο: \ngh_users_json()\n#&gt; [1] \"/home/runner/work/_temp/Library/repurrrsive/extdata/gh_users.json\"\n\n# Διαβάστε το με την read_json()\ngh_users2 &lt;- read_json(gh_users_json())\n\n# Ελέγξτε ότι είναι ίδιο με τα δεδομένα που χρησιμοποιούσαμε προηγουμένως\nidentical(gh_users, gh_users2)\n#&gt; [1] TRUE\n\nΣε αυτό το βιβλίο, θα χρησιμοποιήσουμε επίσης την parse_json(), καθώς χρειάζεται ως είσοδο μία συμβολοσειρά που περιέχει το JSON, κάτι που το καθιστά κατάλληλο για τη δημιουργία απλών παραδειγμάτων. Για να ξεκινήσετε, ακολουθούν τρία απλά σύνολα δεδομένων JSON, ξεκινώντας με έναν αριθμό, τοποθετώντας μερικούς αριθμούς σε έναν πίνακα και στη συνέχεια τοποθετώντας αυτόν τον πίνακα σε ένα αντικείμενο:\n\nstr(parse_json('1'))\n#&gt;  int 1\nstr(parse_json('[1, 2, 3]'))\n#&gt; List of 3\n#&gt;  $ : int 1\n#&gt;  $ : int 2\n#&gt;  $ : int 3\nstr(parse_json('{\"x\": [1, 2, 3]}'))\n#&gt; List of 1\n#&gt;  $ x:List of 3\n#&gt;   ..$ : int 1\n#&gt;   ..$ : int 2\n#&gt;   ..$ : int 3\n\nΤο πακέτο jsonlite έχει μία άλλη σημαντική συνάρτηση που ονομάζεται fromJSON(). Δεν τη χρησιμοποιούμε εδώ επειδή εφαρμόζει αυτόματη απλοποίηση του αποτελέσματος (simplifyVector = TRUE). Αυτό λειτουργεί καλά σε αρκετές περιπτώσεις, ιδιαίτερα σε απλές, αλλά πιστεύουμε ότι είναι καλύτερα να κάνετε την ορθογωνοποίηση μόνοι σας, ώστε να γνωρίζετε ακριβώς τι συμβαίνει και να χειρίζεστε πιο εύκολα πιο περίπλοκες ένθετες δομές.\n\n23.5.3 Ξεκινώντας με την διαδικασία ορθογωνοποίησης\nΣτις περισσότερες περιπτώσεις, τα αρχεία JSON περιέχουν έναν μεμονωμένο πίνακα ανώτατου επιπέδου, επειδή έχουν σχεδιαστεί για να παρέχουν δεδομένα σχετικά με πολλά “πράγματα”, π.χ. πολλές σελίδες ή πολλές εγγραφές ή πολλά αποτελέσματα. Σε αυτήν την περίπτωση, θα ξεκινήσετε την ορθογωνοποίηση με την tibble(json), έτσι ώστε κάθε στοιχείο να γίνει μία γραμμή:\n\njson &lt;- '[\n  {\"name\": \"John\", \"age\": 34},\n  {\"name\": \"Susan\", \"age\": 27}\n]'\ndf &lt;- tibble(json = parse_json(json))\ndf\n#&gt; # A tibble: 2 × 1\n#&gt;   json            \n#&gt;   &lt;list&gt;          \n#&gt; 1 &lt;named list [2]&gt;\n#&gt; 2 &lt;named list [2]&gt;\n\ndf |&gt; \n  unnest_wider(json)\n#&gt; # A tibble: 2 × 2\n#&gt;   name    age\n#&gt;   &lt;chr&gt; &lt;int&gt;\n#&gt; 1 John     34\n#&gt; 2 Susan    27\n\nΣε πιο σπάνιες περιπτώσεις, το αρχείο JSON αποτελείται από ένα αντικείμενο JSON ανώτατου επιπέδου, που αντιπροσωπεύει ένα “πράγμα”. Σε αυτήν την περίπτωση, θα πρέπει να ξεκινήσετε τη διαδικασία της ορθογωνοποίησης βάζοντάς το αρχείο JSON πρώτα σε μία λίστα, προτού το βάλετε σε ένα tibble.\n\njson &lt;- '{\n  \"status\": \"OK\", \n  \"results\": [\n    {\"name\": \"John\", \"age\": 34},\n    {\"name\": \"Susan\", \"age\": 27}\n ]\n}\n'\ndf &lt;- tibble(json = list(parse_json(json)))\ndf\n#&gt; # A tibble: 1 × 1\n#&gt;   json            \n#&gt;   &lt;list&gt;          \n#&gt; 1 &lt;named list [2]&gt;\n\ndf |&gt; \n  unnest_wider(json) |&gt; \n  unnest_longer(results) |&gt; \n  unnest_wider(results)\n#&gt; # A tibble: 2 × 3\n#&gt;   status name    age\n#&gt;   &lt;chr&gt;  &lt;chr&gt; &lt;int&gt;\n#&gt; 1 OK     John     34\n#&gt; 2 OK     Susan    27\n\nΕναλλακτικά, μπορείτε να μπείτε μέσα στο αναγνωσμένο JSON και να ξεκινήσετε με το σημείο που πραγματικά σας ενδιαφέρει:\n\ndf &lt;- tibble(results = parse_json(json)$results)\ndf |&gt; \n  unnest_wider(results)\n#&gt; # A tibble: 2 × 2\n#&gt;   name    age\n#&gt;   &lt;chr&gt; &lt;int&gt;\n#&gt; 1 John     34\n#&gt; 2 Susan    27\n\n\n23.5.4 Ασκήσεις\n\n\nΟρθογωνοποιήστε τα df_col και df_row παρακάτω. Αντιπροσωπεύουν τους δύο τρόπους κωδικοποίησης ενός πλαισίου δεδομένων σε JSON.\n\njson_col &lt;- parse_json('\n  {\n    \"x\": [\"a\", \"x\", \"z\"],\n    \"y\": [10, null, 3]\n  }\n')\njson_row &lt;- parse_json('\n  [\n    {\"x\": \"a\", \"y\": 10},\n    {\"x\": \"x\", \"y\": null},\n    {\"x\": \"z\", \"y\": 3}\n  ]\n')\n\ndf_col &lt;- tibble(json = list(json_col)) \ndf_row &lt;- tibble(json = json_row)",
    "crumbs": [
      "Εισαγωγή δεδομένων",
      "<span class='chapter-number'>23</span>  <span class='chapter-title'>Ιεραρχικά δεδομένα</span>"
    ]
  },
  {
    "objectID": "rectangling.html#σύνοψη",
    "href": "rectangling.html#σύνοψη",
    "title": "23  Ιεραρχικά δεδομένα",
    "section": "\n23.6 Σύνοψη",
    "text": "23.6 Σύνοψη\nΣε αυτό το κεφάλαιο, μάθατε τι είναι οι λίστες, πώς μπορείτε να τις δημιουργήσετε από αρχεία JSON, και πώς να τις μετατρέψετε σε ορθογώνια πλαίσια δεδομένων. Παραδόξως χρειαζόμαστε μόνο δύο νέες συναρτήσεις: την unnest_longer() για να βάλουμε στοιχεία λίστας σε γραμμές, και την unnest_wider() για να τοποθετήσουμε στοιχεία λίστας σε στήλες. Δεν έχει σημασία το πόσο βαθιά ένθεση έχει η στήλη λίστας. Το μόνο που χρειάζεται να κάνετε είναι να καλείτε επανειλημμένα αυτές τις δύο συναρτήσεις.\nΤα JSON είναι η πιο κοινή μορφή δεδομένων που επιστρέφεται από API στο διαδίκτυο. Τι συμβαίνει εάν ο ιστότοπος δεν διαθέτει API, αλλά μπορείτε να δείτε τα δεδομένα που θέλετε στον ιστότοπο;\nΑυτό είναι το θέμα του επόμενου κεφαλαίου: η ιστοσυγκομιδή, η εξαγωγή δεδομένων, δηλαδή, από ιστοσελίδες HTML.",
    "crumbs": [
      "Εισαγωγή δεδομένων",
      "<span class='chapter-number'>23</span>  <span class='chapter-title'>Ιεραρχικά δεδομένα</span>"
    ]
  },
  {
    "objectID": "rectangling.html#footnotes",
    "href": "rectangling.html#footnotes",
    "title": "23  Ιεραρχικά δεδομένα",
    "section": "",
    "text": "Αυτή είναι μία δυνατότητα του RStudio.↩︎",
    "crumbs": [
      "Εισαγωγή δεδομένων",
      "<span class='chapter-number'>23</span>  <span class='chapter-title'>Ιεραρχικά δεδομένα</span>"
    ]
  },
  {
    "objectID": "webscraping.html",
    "href": "webscraping.html",
    "title": "24  Ιστοσυγκομιδή",
    "section": "",
    "text": "24.1 Εισαγωγή\nΑυτό το κεφάλαιο σας παρουσιάζει τα βασικά της ιστοσυγκομιδής (web scraping) με το πακέτο rvest. Η ιστοσυγκομιδή είναι ένα πολύ χρήσιμο εργαλείο για την εξαγωγή δεδομένων από ιστοσελίδες. Ορισμένοι ιστότοποι θα προσφέρουν την επιλογή ενός API, ένα σύνολο δομημένων αιτημάτων HTTP που επιστρέφουν δεδομένα ως JSON, τα οποία χειρίζεστε χρησιμοποιώντας τις τεχνικές από το Κεφάλαιο 23. Όπου είναι εφικτό, θα πρέπει να χρησιμοποιείτε το API1, γιατί συνήθως θα σας δώσει πιο αξιόπιστα δεδομένα. Δυστυχώς, όμως, ο προγραμματισμός με API είναι εκτός ύλης για αυτό το βιβλίο. Αντίθετα, διδάσκουμε την συγκομιδή (scraping), μία τεχνική που λειτουργεί είτε ένας ιστότοπος προσφέρει API είτε όχι.\nΣε αυτό το κεφάλαιο, θα συζητήσουμε πρώτα το ηθικό κομμάτι και τη νομιμότητα της συγκομιδής προτού πάμε στα βασικά της HTML. Στη συνέχεια, θα μάθετε τα βασικά των επιλογέων CSS για τον εντοπισμό συγκεκριμένων στοιχείων στη σελίδα και τον τρόπο χρήσης των συναρτήσεων του rvest για τη λήψη δεδομένων από κείμενο και γνωρίσματα HTML στην R. Στη συνέχεια, θα συζητήσουμε ορισμένες τεχνικές για να καταλάβουμε ποιος επιλογέας CSS χρειάζεται για τη σελίδα που συγκομίζετε, προτού ολοκληρώσουμε με μερικές μελέτες περίπτωσης και μία σύντομη συζήτηση περί δυναμικών ιστοτόπων.",
    "crumbs": [
      "Εισαγωγή δεδομένων",
      "<span class='chapter-number'>24</span>  <span class='chapter-title'>Ιστοσυγκομιδή</span>"
    ]
  },
  {
    "objectID": "webscraping.html#εισαγωγή",
    "href": "webscraping.html#εισαγωγή",
    "title": "24  Ιστοσυγκομιδή",
    "section": "",
    "text": "24.1.1 Προαπαιτούμενα\nΣε αυτό το κεφάλαιο, θα επικεντρωθούμε στα εργαλεία που παρέχει το πακέτο rvest. Το rvest είναι μέλος του tidyverse, αλλά δεν είναι βασικό της μέλος, επομένως θα χρειαστεί να την φορτώσετε ξεχωριστά. Θα φορτώσουμε επίσης ολόκληρο το tidyverse, καθώς θα δούμε ότι είναι γενικά χρήσιμο όταν δουλεύουμε με τα δεδομένα που έχουμε συλλέξει.\n\nlibrary(tidyverse)\nlibrary(rvest)",
    "crumbs": [
      "Εισαγωγή δεδομένων",
      "<span class='chapter-number'>24</span>  <span class='chapter-title'>Ιστοσυγκομιδή</span>"
    ]
  },
  {
    "objectID": "webscraping.html#περί-ηθικής-και-νομιμότητας-της-ιστοσυγκομιδής",
    "href": "webscraping.html#περί-ηθικής-και-νομιμότητας-της-ιστοσυγκομιδής",
    "title": "24  Ιστοσυγκομιδή",
    "section": "\n24.2 Περί ηθικής και νομιμότητας της ιστοσυγκομιδής",
    "text": "24.2 Περί ηθικής και νομιμότητας της ιστοσυγκομιδής\nΠριν ξεκινήσουμε να συζητάμε για τον κώδικα που θα χρειαστείτε για την ιστοσυγκομιδή, πρέπει να μιλήσουμε για το εάν είναι νόμιμο και ηθικό. Γενικά, η κατάσταση είναι περίπλοκη και για τα δύο.\nΗ νομιμότητα εξαρτάται αρκετά από το πού ζεις. Ωστόσο, ως γενική αρχή, εάν τα δεδομένα είναι δημοσίως διαθέσιμα, μη προσωπικά και πραγματολογικά, είναι πιθανό να είστε εντάξει2. Αυτοί οι τρεις παράγοντες είναι σημαντικοί επειδή συνδέονται με τους όρους και τις προϋποθέσεις, τις προσωπικές πληροφορίες και τα πνευματικά δικαιώματα του ιστότοπου, όπως θα συζητήσουμε παρακάτω.\nΕάν τα δεδομένα δεν είναι δημόσια, μη προσωπικά ή τεκμηριωμένα ή εάν τα συλλέγετε ειδικά για κέρδος, θα πρέπει να μιλήσετε με έναν δικηγόρο. Σε κάθε περίπτωση, θα πρέπει να σέβεστε τους πόρους του διακομιστή που φιλοξενεί τις σελίδες που επιλέγετε για ιστοσυγκομιδή. Κυρίως, αυτό σημαίνει ότι εάν συγκομίζετε πολλαπλές σελίδες, θα πρέπει να φροντίσετε να περιμένετε για λίγο μεταξύ κάθε αιτήματος. Ένας εύκολος τρόπος για να το κάνετε αυτό είναι να χρησιμοποιήσετε το πακέτο polite του Dmytro Perepolkin. Θα κάνει μία παύση αυτόματα μεταξύ των αιτημάτων και θα αποθηκεύσει προσωρινά τα αποτελέσματα, ώστε να μην ζητήσετε ποτέ την ίδια σελίδα δύο φορές.\n\n24.2.1 Όροι χρήσης\nΑν κοιτάξετε προσεκτικά, θα διαπιστώσετε ότι πολλοί ιστότοποι περιλαμβάνουν έναν σύνδεσμο “όροι και προϋποθέσεις” ή “όροι παροχής υπηρεσιών” κάπου στη σελίδα και αν τον διαβάσετε προσεκτικά, συχνά θα ανακαλύψετε ότι ο ιστότοπος απαγορεύει ρητά την ιστοσυγκομιδή. Αυτές οι σελίδες τείνουν να περιέχουν αρκετά ευρείς νομικούς ισχυρισμούς έτσι ώστε οι εταιρίες να μπορούν να είναι καλυμμένες σε μεγαλύτερο εύρος. Είναι ευγενικό να σέβεστε αυτούς τους όρους παροχής υπηρεσιών όπου είναι δυνατόν, αλλά μην τους θεωρήσετε δεδομένους.\nΤα δικαστήρια των ΗΠΑ έχουν γενικά διαπιστώσει ότι τοποθετώντας απλά τους όρους παροχής υπηρεσιών στο υποσέλιδο του ιστότοπου δεν αρκεί για να δεσμεύεστε από αυτούς, π.χ., HiQ Labs v. LinkedIn. Γενικά, για να δεσμευτείτε από τους όρους παροχής υπηρεσιών, πρέπει να έχετε κάνει κάποια ξεκάθαρη ενέργεια, όπως είναι η δημιουργία λογαριασμού ή η αποδοχή ενός πλαισίου με όρους. Αυτός είναι ο λόγος για τον οποίο έχει σημασία το εάν τα δεδομένα είναι δημόσια ή όχι. Εάν δεν χρειάζεστε λογαριασμό για να αποκτήσετε πρόσβαση σε αυτά, είναι απίθανο να δεσμεύεστε από τους όρους παροχής υπηρεσιών. Σημειώστε, ωστόσο, ότι η κατάσταση είναι μάλλον διαφορετική στην Ευρώπη, όπου τα δικαστήρια έχουν διαπιστώσει ότι οι όροι της υπηρεσίας ισχύουν ακόμη και αν δεν συμφωνείτε ρητά με αυτούς.\n\n24.2.2 Δεδομένα προσωπικού χαρακτήρα\nΑκόμα κι αν τα δεδομένα είναι δημόσια, θα πρέπει να είστε εξαιρετικά προσεκτικοί σχετικά με την συγκομιδή δεδομένων προσωπικού χαρακτήρα, όπως ονόματα, διευθύνσεις ηλεκτρονικού ταχυδρομείου, αριθμούς τηλεφώνου, ημερομηνίες γέννησης κ.λπ. Η Ευρώπη έχει ιδιαίτερα αυστηρούς νόμους σχετικά με τη συλλογή ή αποθήκευση τέτοιων δεδομένων (GDPR) και ανεξάρτητα από το πού ζείτε, είναι πιθανό να αντιμετωπίσετε ένα ηθικό αδιέξοδο. Για παράδειγμα, το 2016, μία ομάδα ερευνητών συγκόμισε πληροφορίες δημόσιων προφίλ χρήστη (π.χ. ονόματα χρήστη, ηλικία, φύλο, τοποθεσία κ.λπ.) περίπου 70.000 ατόμων από τον ιστότοπο γνωριμιών OkCupid και τα δημοσιοποίησαν χωρίς καμία προσπάθεια ανωνυμοποίησης. Ενώ οι ερευνητές θεώρησαν ότι δεν υπήρχε τίποτα λάθος με αυτό, καθώς τα δεδομένα ήταν ήδη δημόσια, αυτή η πράξη καταδικάστηκε ευρέως, λόγω ηθικών ανησυχιών σχετικά με την ταυτοποίηση των χρηστών των οποίων οι πληροφορίες δημοσιεύτηκαν στο σύνολο δεδομένων. Εάν η εργασία σας περιλαμβάνει συγκομιδή προσωπικών δεδομένων, συνιστούμε ανεπιφύλακτα να διαβάσετε για τη μελέτη της OkCupid3 καθώς και παρόμοιες μελέτες με αμφισβητήσιμη ερευνητική δεοντολογία, που αφορούν την απόκτηση και την δημοσιοποίηση δεδομένων προσωπικού χαρακτήρα.\n\n24.2.3 Πνευματικά δικαιώματα\nΤέλος, πρέπει επίσης να ανησυχείτε και για τη νομοθεσία περί πνευματικών δικαιωμάτων. Η νομοθεσία περί πνευματικών δικαιωμάτων είναι περίπλοκη, αλλά αξίζει να ρίξετε μία ματιά στον νόμο των ΗΠΑ που περιγράφει ακριβώς τι προστατεύεται: “[…] πρωτότυπα έργα παγιωμένα σε οποιοδήποτε απτό μέσο έκφρασης, […]”. Στη συνέχεια, περιγράφει συγκεκριμένες κατηγορίες που εφαρμόζεται, όπως λογοτεχνικά έργα, μουσικά έργα, κινηματογραφικές ταινίες και άλλα. Ιδιαίτερα, από την προστασία των πνευματικών δικαιωμάτων, απουσιάζουν τα δεδομένα. Αυτό σημαίνει ότι εφόσον περιορίζετε την συγκομιδή σας στα γεγονότα, δεν ισχύει η προστασία πνευματικών δικαιωμάτων. (Σημειώστε όμως ότι η Ευρώπη έχει ένα ξεχωριστό δικαίωμα “sui generis” που προστατεύει τις βάσεις δεδομένων.)\nΓια παράδειγμα, στις ΗΠΑ, οι συνταγές μαγειρικής δεν υπόκεινται σε πνευματικά δικαιώματα, επομένως τα πνευματικά δικαιώματα δεν μπορούν να χρησιμοποιηθούν για την προστασία τους. Αλλά αν αυτή η λίστα συνταγών συνοδεύεται από κάποιο σημαντικό καινοτόμο λογοτεχνικό περιεχόμενο, αυτό υπόκειται σε πνευματικά δικαιώματα. Αυτός είναι ο λόγος για τον οποίο όταν ψάχνετε για μία συνταγή στο διαδίκτυο, υπάρχει εκ των προτέρων πάντα τόσο πολύ περιεχόμενο.\nΕάν χρειάζεται να συγκομίσετε πρωτογενές περιεχόμενο (όπως κείμενο ή εικόνες), ενδέχεται να προστατεύεστε σύμφωνα με το δόγμα της ορθής χρήσης. Ο κανόνας της δίκαιης χρήσης δεν είναι αυστηρός, αλλά σταθμίζει μία σειρά αρκετών παραγόντων. Είναι πιο πιθανό να ισχύει εάν συλλέγετε δεδομένα για ερευνητικούς ή μη εμπορικούς σκοπούς και εάν περιορίσετε την χρήση αυτού που συλλέγετε σε αυτό που χρειάζεστε.",
    "crumbs": [
      "Εισαγωγή δεδομένων",
      "<span class='chapter-number'>24</span>  <span class='chapter-title'>Ιστοσυγκομιδή</span>"
    ]
  },
  {
    "objectID": "webscraping.html#τα-βασικά-της-html",
    "href": "webscraping.html#τα-βασικά-της-html",
    "title": "24  Ιστοσυγκομιδή",
    "section": "\n24.3 Τα βασικά της HTML",
    "text": "24.3 Τα βασικά της HTML\nΓια να συγκομίσετε ιστοσελίδες, πρέπει πρώτα να κατανοήσετε λίγα πράγματα για την HTML, τη γλώσσα που περιγράφει τις ιστοσελίδες. Τα αρχικά της HTML σημαίνουν HyperText Markup Language και η σύνταξη μοιάζει κάπως έτσι:\n&lt;html&gt;\n&lt;head&gt;\n  &lt;title&gt;Page title&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n  &lt;h1 id='first'&gt;A heading&lt;/h1&gt;\n  &lt;p&gt;Some text &amp; &lt;b&gt;some bold text.&lt;/b&gt;&lt;/p&gt;\n  &lt;img src='myimg.png' width='100' height='100'&gt;\n&lt;/body&gt;\nΗ HTML έχει μία ιεραρχική δομή που σχηματίζεται από στοιχεία τα οποία αποτελούνται από μία ετικέτα έναρξης (π.χ. &lt;tag&gt;), προαιρετικά χαρακτηριστικά (id='first'), μία ετικέτα λήξης4 (όπως &lt;/tag&gt;), και περιεχόμενα (οτιδήποτε μεταξύ της ετικέτας έναρξης και λήξης).\nΕφόσον τα &lt; και &gt; χρησιμοποιούνται για τις ετικέτες έναρξης και λήξης, δεν μπορείτε να τις γράψετε απευθείας. Πρέπει να χρησιμοποιήσετε τις ακολουθίες διαφυγής της HTML &gt; (μεγαλύτερο από) και &lt; (λιγότερο από). Και δεδομένου ότι αυτές οι ακολουθίες διαφυγής χρησιμοποιούν το &, εάν θέλετε ένα κυριολεκτικό συμπλεκτικό σύμβολο θα πρέπει να το διαφύγετε ως &amp;. Υπάρχει ένα ευρύ φάσμα πιθανών ακολουθιών διαφυγής στην HTML, αλλά δεν χρειάζεται να ανησυχείτε για αυτές καθώς το πακέτο rvest τις χειρίζεται αυτόματα για εσάς.\nΗ ιστοσυγκομιδή είναι εφικτή επειδή η δομή της πλειοψηφίας των σελίδων με δεδομένα που θέλετε να συγκομίσετε είναι συνεπής.\n\n24.3.1 Στοιχεία\nΥπάρχουν πάνω από 100 στοιχεία στην HTML. Μερικά από τα πιο σημαντικά είναι:\n\nΚάθε σελίδα HTML πρέπει να περιέχει ένα στοιχείο &lt;html&gt; και αυτό πρέπει να έχει δύο παιδιά: το &lt;head&gt;, που περιέχει μεταδεδομένα, όπως ο τίτλος της σελίδας, και το &lt;body&gt;, με το περιεχόμενο που βλέπετε στον browser.\nΕτικέτες στίξης όπως η &lt;h1&gt; (επικεφαλίδα 1), η &lt;section&gt; (ενότητα), η &lt;p&gt; (παράγραφος) και η &lt;ol&gt; (διατεταγμένη λίστα) αποτελούν τη συνολική δομή της σελίδας.\nΕτικέτες μορφοποίησης όπως η &lt;b&gt; (έντονη γραφή), η &lt;i&gt; (πλάγια γράμματα) και η &lt;a&gt; (σύνδεσμος) μορφοποιούν το κείμενο που υπάρχει μέσα σε ετικέτες στίξης.\n\nΑν συναντήσετε μία ετικέτα που δεν έχετε ξαναδεί, μπορείτε να μάθετε τι κάνει με λίγο γκουγκλάρισμα. Ένα άλλο καλό μέρος για να ξεκινήσετε είναι το MDN Web Docs, το οποίο περιγράφει σχεδόν κάθε πτυχή του προγραμματισμού ιστοσελίδων.\nΤα περισσότερα στοιχεία μπορούν να έχουν περιεχόμενο μεταξύ των ετικετών έναρξης και τέλους. Αυτό το περιεχόμενο μπορεί να είναι κείμενο ή περισσότερα στοιχεία. Για παράδειγμα, το ακόλουθο κομμάτι HTML περιέχει μία παράγραφο κειμένου, με μία λέξη με έντονη γραφή.\n&lt;p&gt;\n  Hi! My &lt;b&gt;name&lt;/b&gt; is Hadley.\n&lt;/p&gt;\nΤα παιδιά είναι τα στοιχεία που το στοιχείο &lt;html&gt; περιέχει, επομένως το στοιχείο &lt;p&gt; παραπάνω έχει ένα παιδί, το στοιχείο &lt;b&gt;. Το στοιχείο &lt;b&gt; δεν έχει παιδιά, αλλά έχει περιεχόμενα (το κείμενο “name”).\n\n24.3.2 Χαρακτηριστικά\nΟι ετικέτες μπορεί να έχουν ονοματισμένα χαρακτηριστικά που μοιάζουν ως name1='value1' name2='value2'. Δύο από τα πιο σημαντικά χαρακτηριστικά είναι το id και το class, που χρησιμοποιούνται σε συνδυασμό με την CSS (Cascading Style Sheets) για τον έλεγχο της οπτικής της σελίδας. Αυτά συνήθως είναι χρήσιμα κατά την συγκομιδή δεδομένων από μία σελίδα. Τα χαρακτηριστικά χρησιμοποιούνται επίσης για την καταγραφή του προορισμού των συνδέσμων (το χαρακτηριστικό href των στοιχείων &lt;a&gt;) και της πηγής των εικόνων (το χαρακτηριστικό src του στοιχείου &lt;img&gt;).",
    "crumbs": [
      "Εισαγωγή δεδομένων",
      "<span class='chapter-number'>24</span>  <span class='chapter-title'>Ιστοσυγκομιδή</span>"
    ]
  },
  {
    "objectID": "webscraping.html#εξάγοντας-δεδομένα",
    "href": "webscraping.html#εξάγοντας-δεδομένα",
    "title": "24  Ιστοσυγκομιδή",
    "section": "\n24.4 Εξάγοντας δεδομένα",
    "text": "24.4 Εξάγοντας δεδομένα\nΓια να ξεκινήσετε την συγκομιδή, θα χρειαστείτε τη διεύθυνση URL της σελίδας που θέλετε, την οποία μπορείτε συνήθως να αντιγράψετε από τον browser. Στη συνέχεια, θα χρειαστεί να διαβάσετε τον HTML κώδικα για αυτήν τη σελίδα στην R με την read_html(). Αυτό επιστρέφει ένα αντικείμενο xml_document5 το οποίο στη συνέχεια θα χειριστείτε χρησιμοποιώντας συναρτήσεις του rvest:\n\nhtml &lt;- read_html(\"http://rvest.tidyverse.org/\")\nhtml\n#&gt; {html_document}\n#&gt; &lt;html lang=\"en\"&gt;\n#&gt; [1] &lt;head&gt;\\n&lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=UT ...\n#&gt; [2] &lt;body&gt;\\n    &lt;a href=\"#container\" class=\"visually-hidden-focusable\"&gt;Ski ...\n\nΤο rvest περιλαμβάνει επίσης μία συνάρτηση που σας επιτρέπει να γράφετε HTML. Σε αυτό το κεφάλαιο, Θα χρησιμοποιήσουμε τη συνάρτηση αυτή όσο δείχνουμε πώς λειτουργούν οι διάφορες συναρτήσεις του rvest με απλά παραδείγματα.\n\nhtml &lt;- minimal_html(\"\n  &lt;p&gt;This is a paragraph&lt;/p&gt;\n  &lt;ul&gt;\n    &lt;li&gt;This is a bulleted list&lt;/li&gt;\n  &lt;/ul&gt;\n\")\nhtml\n#&gt; {html_document}\n#&gt; &lt;html&gt;\n#&gt; [1] &lt;head&gt;\\n&lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=UT ...\n#&gt; [2] &lt;body&gt;\\n&lt;p&gt;This is a paragraph&lt;/p&gt;\\n  &lt;ul&gt;\\n&lt;li&gt;This is a bulleted lis ...\n\nΤώρα που έχετε το HTML στην R, ήρθε η ώρα να εξάγετε τα δεδομένα που σας ενδιαφέρουν. Πρώτα θα μάθετε για τους επιλογείς CSS που σας επιτρέπουν να προσδιορίσετε τα στοιχεία που σας ενδιαφέρουν και τις συναρτήσεις του rvest που μπορείτε να χρησιμοποιήσετε για να εξάγετε δεδομένα από αυτά. Στη συνέχεια, θα καλύψουμε εν συντομία τους πίνακες στην HTML, οι οποίοι έχουν ορισμένα ειδικά εργαλεία.\n\n24.4.1 Εντοπίζοντας στοιχεία\nΤο όνομα CSS είναι συντομογραφία για το cascading style sheets, και είναι ένα εργαλείο για τον ορισμό του οπτικού στυλ των εγγράφων HTML. Η CSS περιλαμβάνει μία μικρογραφία γλώσσας (συντακτικού) για την επιλογή στοιχείων από μία σελίδα και ονομάζεται επιλογείς CSS. Οι επιλογείς CSS ορίζουν μοτίβα για τον εντοπισμό στοιχείων HTML και είναι χρήσιμοι για την ιστοσυγκομιδή, καθώς παρέχουν έναν συνοπτικό τρόπο περιγραφής των στοιχείων που θέλετε να εξάγετε.\nΘα επανέλθουμε στους επιλογείς CSS με περισσότερες λεπτομέρειες στην Ενότητα 24.5, αλλά ευτυχώς μπορείτε να καλύψετε αρκετό έδαφος μόνο με τρεις από αυτούς:\n\nΟ επιλογέας p επιλέγει όλα τα στοιχεία &lt;p&gt;.\nΟ .title επιλέγει όλα τα στοιχεία με class “title”.\nO #title επιλέγει το στοιχείο με το χαρακτηριστικό id που ισούται με “title”. Τα χαρακτηριστικά id πρέπει να είναι μοναδικά μέσα σε ένα έγγραφο, επομένως μόνο ένα στοιχείο θα επιλέγεται.\n\nΑς δοκιμάσουμε αυτούς τους επιλογείς με ένα απλό παράδειγμα:\n\nhtml &lt;- minimal_html(\"\n  &lt;h1&gt;This is a heading&lt;/h1&gt;\n  &lt;p id='first'&gt;This is a paragraph&lt;/p&gt;\n  &lt;p class='important'&gt;This is an important paragraph&lt;/p&gt;\n\")\n\nΧρησιμοποιήστε την html_elements() για να βρείτε όλα τα στοιχεία που ταιριάζουν με τον επιλογέα:\n\nhtml |&gt; html_elements(\"p\")\n#&gt; {xml_nodeset (2)}\n#&gt; [1] &lt;p id=\"first\"&gt;This is a paragraph&lt;/p&gt;\n#&gt; [2] &lt;p class=\"important\"&gt;This is an important paragraph&lt;/p&gt;\nhtml |&gt; html_elements(\".important\")\n#&gt; {xml_nodeset (1)}\n#&gt; [1] &lt;p class=\"important\"&gt;This is an important paragraph&lt;/p&gt;\nhtml |&gt; html_elements(\"#first\")\n#&gt; {xml_nodeset (1)}\n#&gt; [1] &lt;p id=\"first\"&gt;This is a paragraph&lt;/p&gt;\n\nΜία άλλη σημαντική συνάρτηση είναι η html_element(), η οποία επιστρέφει πάντα τον ίδιο αριθμό εξόδων με τις εισόδους. Εάν την εφαρμόσετε σε ολόκληρο το έγγραφο, θα σας δώσει την πρώτη, σε σειρά, αντιστοίχιση:\n\nhtml |&gt; html_element(\"p\")\n#&gt; {html_node}\n#&gt; &lt;p id=\"first\"&gt;\n\nΥπάρχει μία σημαντική διαφορά μεταξύ της html_element() και της html_elements() όταν χρησιμοποιείτε έναν επιλογέα που δεν ταιριάζει με κανένα στοιχείο. Η html_elements() επιστρέφει ένα διάνυσμα μήκους 0, ενώ η html_element() επιστρέφει μία κενή τιμή. Αυτό θα γίνει σύντομα σημαντικό.\n\nhtml |&gt; html_elements(\"b\")\n#&gt; {xml_nodeset (0)}\nhtml |&gt; html_element(\"b\")\n#&gt; {xml_missing}\n#&gt; &lt;NA&gt;\n\n\n24.4.2 Ένθετες επιλογές\nΣτις περισσότερες περιπτώσεις, θα χρησιμοποιήσετε τις html_elements() και html_element() μαζί, χρησιμοποιώντας αρχικά την html_elements(), για να προσδιορίσετε στοιχεία που θα γίνουν παρατηρήσεις και στη συνέχεια την html_element(), για να βρείτε στοιχεία που θα γίνουν μεταβλητές. Ας το δούμε στην πράξη χρησιμοποιώντας ένα απλό παράδειγμα. Εδώ έχουμε μία μη ταξινομημένη λίστα (&lt;ul&gt;) όπου κάθε στοιχείο της λίστας (&lt;li&gt;) περιέχει πληροφορίες σχετικά με τέσσερις χαρακτήρες του StarWars:\n\nhtml &lt;- minimal_html(\"\n  &lt;ul&gt;\n    &lt;li&gt;&lt;b&gt;C-3PO&lt;/b&gt; is a &lt;i&gt;droid&lt;/i&gt; that weighs &lt;span class='weight'&gt;167 kg&lt;/span&gt;&lt;/li&gt;\n    &lt;li&gt;&lt;b&gt;R4-P17&lt;/b&gt; is a &lt;i&gt;droid&lt;/i&gt;&lt;/li&gt;\n    &lt;li&gt;&lt;b&gt;R2-D2&lt;/b&gt; is a &lt;i&gt;droid&lt;/i&gt; that weighs &lt;span class='weight'&gt;96 kg&lt;/span&gt;&lt;/li&gt;\n    &lt;li&gt;&lt;b&gt;Yoda&lt;/b&gt; weighs &lt;span class='weight'&gt;66 kg&lt;/span&gt;&lt;/li&gt;\n  &lt;/ul&gt;\n  \")\n\nΜπορούμε να χρησιμοποιήσουμε την html_elements() για να δημιουργήσουμε ένα διάνυσμα, όπου κάθε στοιχείο αντιστοιχεί σε διαφορετικό χαρακτήρα:\n\ncharacters &lt;- html |&gt; html_elements(\"li\")\ncharacters\n#&gt; {xml_nodeset (4)}\n#&gt; [1] &lt;li&gt;\\n&lt;b&gt;C-3PO&lt;/b&gt; is a &lt;i&gt;droid&lt;/i&gt; that weighs &lt;span class=\"weight\"&gt; ...\n#&gt; [2] &lt;li&gt;\\n&lt;b&gt;R4-P17&lt;/b&gt; is a &lt;i&gt;droid&lt;/i&gt;\\n&lt;/li&gt;\n#&gt; [3] &lt;li&gt;\\n&lt;b&gt;R2-D2&lt;/b&gt; is a &lt;i&gt;droid&lt;/i&gt; that weighs &lt;span class=\"weight\"&gt; ...\n#&gt; [4] &lt;li&gt;\\n&lt;b&gt;Yoda&lt;/b&gt; weighs &lt;span class=\"weight\"&gt;66 kg&lt;/span&gt;\\n&lt;/li&gt;\n\nΓια να εξαγάγουμε το όνομα κάθε χαρακτήρα, χρησιμοποιούμε την html_element(), γιατί όταν εφαρμοστεί στην έξοδο της html_elements() είναι σίγουρο ότι θα επιστρέψει ένα αποτέλεσμα ανά στοιχείο:\n\ncharacters |&gt; html_element(\"b\")\n#&gt; {xml_nodeset (4)}\n#&gt; [1] &lt;b&gt;C-3PO&lt;/b&gt;\n#&gt; [2] &lt;b&gt;R4-P17&lt;/b&gt;\n#&gt; [3] &lt;b&gt;R2-D2&lt;/b&gt;\n#&gt; [4] &lt;b&gt;Yoda&lt;/b&gt;\n\nΗ διάκριση μεταξύ html_element() και html_elements() δεν είναι σημαντική για το όνομα, αλλά είναι σημαντική για το βάρος. Θέλουμε να πάρουμε ένα βάρος για κάθε χαρακτήρα, ακόμα κι αν δεν υπάρχει &lt;span&gt; βάρος (weight). Αυτό κάνει η html_element():\n\ncharacters |&gt; html_element(\".weight\")\n#&gt; {xml_nodeset (4)}\n#&gt; [1] &lt;span class=\"weight\"&gt;167 kg&lt;/span&gt;\n#&gt; [2] NA\n#&gt; [3] &lt;span class=\"weight\"&gt;96 kg&lt;/span&gt;\n#&gt; [4] &lt;span class=\"weight\"&gt;66 kg&lt;/span&gt;\n\nΗ html_elements() βρίσκει όλα τα &lt;span&gt; βάρους (weight) που είναι παιδιά του characters. Υπάρχουν μόνο τρία από αυτά, οπότε χάνουμε τη σύνδεση μεταξύ ονομάτων και βαρών:\n\ncharacters |&gt; html_elements(\".weight\")\n#&gt; {xml_nodeset (3)}\n#&gt; [1] &lt;span class=\"weight\"&gt;167 kg&lt;/span&gt;\n#&gt; [2] &lt;span class=\"weight\"&gt;96 kg&lt;/span&gt;\n#&gt; [3] &lt;span class=\"weight\"&gt;66 kg&lt;/span&gt;\n\nΤώρα που έχετε επιλέξει τα στοιχεία που σας ενδιαφέρουν, θα πρέπει να εξάγετε τα δεδομένα, είτε από τα περιεχόμενα του κειμένου είτε από ορισμένα χαρακτηριστικά.\n\n24.4.3 Κείμενο και χαρακτηριστικά\nΗ html_text2()6 εξάγει τα περιεχόμενα απλού κειμένου ενός στοιχείου HTML:\n\ncharacters |&gt; \n  html_element(\"b\") |&gt; \n  html_text2()\n#&gt; [1] \"C-3PO\"  \"R4-P17\" \"R2-D2\"  \"Yoda\"\n\ncharacters |&gt; \n  html_element(\".weight\") |&gt; \n  html_text2()\n#&gt; [1] \"167 kg\" NA       \"96 kg\"  \"66 kg\"\n\nΣημειώστε ότι τυχόν ακολουθίες διαφυγής θα αντιμετωπιστούν αυτόματα. θα δείτε ακολουθίες διαφυγής HTML μόνο στην πηγαίο κώδικα HTML, κι όχι στα δεδομένα που επιστρέφονται από το rvest.\nΗ html_attr() εξάγει δεδομένα από χαρακτηριστικά:\n\nhtml &lt;- minimal_html(\"\n  &lt;p&gt;&lt;a href='https://en.wikipedia.org/wiki/Cat'&gt;cats&lt;/a&gt;&lt;/p&gt;\n  &lt;p&gt;&lt;a href='https://en.wikipedia.org/wiki/Dog'&gt;dogs&lt;/a&gt;&lt;/p&gt;\n\")\n\nhtml |&gt; \n  html_elements(\"p\") |&gt; \n  html_element(\"a\") |&gt; \n  html_attr(\"href\")\n#&gt; [1] \"https://en.wikipedia.org/wiki/Cat\" \"https://en.wikipedia.org/wiki/Dog\"\n\nΗ html_attr() επιστρέφει πάντα μία συμβολοσειρά, επομένως εάν εξάγετε αριθμούς ή ημερομηνίες, θα πρέπει να εφαρμόσετε κάποια μετεπεξεργασία.\n\n24.4.4 Πίνακες\nΕάν είστε τυχεροί, τα δεδομένα σας θα είναι ήδη αποθηκευμένα σε έναν πίνακα HTML και θα πρέπει απλώς να τα διαβάσετε από αυτόν τον πίνακα. Συνήθως, είναι εύκολο να αναγνωρίσετε έναν πίνακα στον browser σας: θα έχει μία ορθογώνια δομή με γραμμές και στήλες και μπορείτε να τον αντιγράψετε και να τον επικολλήσετε σε ένα εργαλείο όπως το Excel.\nΟι πίνακες HTML δημιουργούνται από τέσσερα κύρια στοιχεία: &lt;table&gt;, &lt;tr&gt; (γραμμή πίνακα), &lt;th&gt; (επικεφαλίδα πίνακα) και &lt;td&gt; (δεδομένα πίνακα). Ακολουθεί ένας απλός πίνακας HTML με δύο στήλες και τρεις γραμμές:\n\nhtml &lt;- minimal_html(\"\n  &lt;table class='mytable'&gt;\n    &lt;tr&gt;&lt;th&gt;x&lt;/th&gt;   &lt;th&gt;y&lt;/th&gt;&lt;/tr&gt;\n    &lt;tr&gt;&lt;td&gt;1.5&lt;/td&gt; &lt;td&gt;2.7&lt;/td&gt;&lt;/tr&gt;\n    &lt;tr&gt;&lt;td&gt;4.9&lt;/td&gt; &lt;td&gt;1.3&lt;/td&gt;&lt;/tr&gt;\n    &lt;tr&gt;&lt;td&gt;7.2&lt;/td&gt; &lt;td&gt;8.1&lt;/td&gt;&lt;/tr&gt;\n  &lt;/table&gt;\n  \")\n\nΤο πακέτο rvest παρέχει μία συνάρτηση που ξέρει πώς να διαβάζει αυτού του είδους δεδομένων: την html_table(). Αυτή επιστρέφει μία λίστα που περιέχει ένα tibble για κάθε πίνακα που βρίσκεται στη σελίδα. Χρησιμοποιήστε την html_element() για να προσδιορίσετε τον πίνακα που θέλετε να εξάγετε:\n\nhtml |&gt; \n  html_element(\".mytable\") |&gt; \n  html_table()\n#&gt; # A tibble: 3 × 2\n#&gt;       x     y\n#&gt;   &lt;dbl&gt; &lt;dbl&gt;\n#&gt; 1   1.5   2.7\n#&gt; 2   4.9   1.3\n#&gt; 3   7.2   8.1\n\nΣημειώστε ότι τα x και y έχουν μετατραπεί αυτόματα σε αριθμούς. Αυτή η αυτόματη μετατροπή δεν λειτουργεί πάντα, επομένως σε πιο σύνθετα σενάρια μπορεί να θέλετε να την απενεργοποιήσετε με το convert = FALSE και στη συνέχεια να κάνετε τη δική σας μετατροπή.",
    "crumbs": [
      "Εισαγωγή δεδομένων",
      "<span class='chapter-number'>24</span>  <span class='chapter-title'>Ιστοσυγκομιδή</span>"
    ]
  },
  {
    "objectID": "webscraping.html#sec-css-selectors",
    "href": "webscraping.html#sec-css-selectors",
    "title": "24  Ιστοσυγκομιδή",
    "section": "\n24.5 Εύρεση των κατάλληλων επιλογέων",
    "text": "24.5 Εύρεση των κατάλληλων επιλογέων\nΤο να βρείτε τον επιλογέα που χρειάζεστε για τα δεδομένα σας είναι συνήθως το πιο δύσκολο μέρος του προβλήματος. Συχνά θα χρειαστεί να κάνετε κάποιους πειραματισμούς για να βρείτε έναν επιλογέα που είναι τόσο συγκεκριμένος (δηλαδή δεν επιλέγει πράγματα που δεν σας ενδιαφέρουν) όσο και ευαίσθητος (δηλαδή επιλέγει όλα όσα σας ενδιαφέρουν). Οι πολλαπλές δοκιμές είναι ένα φυσιολογικό κομμάτι της διαδικασίας! Υπάρχουν δύο βασικά εργαλεία που είναι διαθέσιμα για να σας βοηθήσουν με αυτήν τη διαδικασία: το SelectorGadget και τα εργαλεία προγραμματιστή του browser σας.\nΤο SelectorGadget είναι ένας σελιδοδείκτης javascript που δημιουργεί αυτόματα επιλογείς CSS με βάση τα θετικά και αρνητικά παραδείγματα που παρέχετε. Δεν λειτουργεί πάντα, αλλά όταν λειτουργεί, είναι μαγικό! Μπορείτε να μάθετε πώς να το εγκαταστήσετε και να το χρησιμοποιήσετε, είτε διαβάζοντας το https://rvest.tidyverse.org/articles/selectorgadget.html είτε παρακολουθώντας το βίντεο της Mine στη διεύθυνση https://www.youtube.com/watch?v=PetWV5g1Xsc.\nΚάθε σύγχρονος browser συνοδεύεται από κάποια εργαλειοθήκη για προγραμματιστές, συνιστούμε όμως το Chrome, ακόμα κι αν δεν είναι το κανονικό σας πρόγραμμα περιήγησης: τα εργαλεία προγραμματιστή του είναι μερικά από τα καλύτερα και είναι άμεσα διαθέσιμα. Κάντε δεξί κλικ σε ένα στοιχείο στη σελίδα και κάντε κλικ στην επιλογή «Επιθεώρηση». Αυτό θα ανοίξει μία επεκτάσιμη προβολή της πλήρους σελίδας HTML, με κέντρο το στοιχείο στο οποίο μόλις κάνατε κλικ. Μπορείτε να το χρησιμοποιήσετε για να εξερευνήσετε τη σελίδα και να πάρετε μία ιδέα του ποιοι επιλογείς μπορεί να δουλέψουν. Δώστε ιδιαίτερη προσοχή στα χαρακτηριστικά κλάσης (class) και αναγνωριστικού (id), καθώς αυτά χρησιμοποιούνται συχνά για να σχηματίσουν την οπτική δομή της σελίδας, και ως εκ τούτου αποτελούν καλά εργαλεία για την εξαγωγή των δεδομένων που αναζητάτε.\nΜέσα στην καρτέλα Στοιχεία, μπορείτε επίσης να κάνετε δεξί κλικ σε ένα στοιχείο και να επιλέξετε Αντιγραφή ως Eπιλογέα για να δημιουργήσετε έναν επιλογέα που θα προσδιορίζει μοναδικά το στοιχείο που σας ενδιαφέρει.\nΕάν είτε το SelectorGadget είτε το Chrome DevTools έχουν δημιουργήσει έναν επιλογέα CSS που δεν καταλαβαίνετε, δοκιμάστε να δείτε το Selectors Explained που μεταφράζει τους επιλογείς CSS σε απλά αγγλικά. Εάν παρατηρείτε ότι το κάνετε αυτό συχνά, ίσως να θέλετε να μάθετε περισσότερα σχετικά με τους επιλογείς CSS γενικά. Συνιστούμε να ξεκινήσετε με το διασκεδαστικό εκπαιδευτικό υλικό CSS dinner, και στη συνέχεια να ανατρέξετε στο MDN web docs.",
    "crumbs": [
      "Εισαγωγή δεδομένων",
      "<span class='chapter-number'>24</span>  <span class='chapter-title'>Ιστοσυγκομιδή</span>"
    ]
  },
  {
    "objectID": "webscraping.html#βάζοντάς-τα-όλα-μαζί",
    "href": "webscraping.html#βάζοντάς-τα-όλα-μαζί",
    "title": "24  Ιστοσυγκομιδή",
    "section": "\n24.6 Βάζοντάς τα όλα μαζί",
    "text": "24.6 Βάζοντάς τα όλα μαζί\nΑς τα συγκεντρώσουμε όλα αυτά μαζί για να συγκομίσουμε μερικούς ιστοτόπους. Υπάρχει ο κίνδυνος ότι αυτά τα παραδείγματα δεν θα λειτουργούν πλέον όταν τα εκτελέσετε — αυτή είναι η κύρια πρόκληση της ιστοσυγκομιδής. Εάν αλλάξει η δομή του ιστότοπου, τότε θα πρέπει να αλλάξετε και τον κώδικα.\n\n24.6.1 StarWars\nΤο rvest περιλαμβάνει ένα πολύ απλό παράδειγμα στο vignette(\"starwars\"). Αυτή είναι μία απλή σελίδα με ελάχιστη HTML, επομένως είναι ένα καλό μέρος για να ξεκινήσετε. Θα σας συνιστούσα να πλοηγηθείτε σε αυτήν τη σελίδα τώρα και να χρησιμοποιήσετε την “Επιθεώρηση στοιχείου” για να επιθεωρήσετε έναν από τους τίτλους που αναφέρεται σε μία ταινία Star Wars. Χρησιμοποιήστε το πληκτρολόγιο ή το ποντίκι για να εξερευνήσετε την ιεραρχία της HTML και να δείτε εάν μπορείτε να αποκτήσετε μία αίσθηση της κοινής δομής που χρησιμοποιείται από κάθε ταινία.\nΘα πρέπει να μπορείτε να δείτε ότι κάθε ταινία έχει μία κοινή δομή που μοιάζει με αυτή:\n&lt;section&gt;\n  &lt;h2 data-id=\"1\"&gt;The Phantom Menace&lt;/h2&gt;\n  &lt;p&gt;Released: 1999-05-19&lt;/p&gt;\n  &lt;p&gt;Director: &lt;span class=\"director\"&gt;George Lucas&lt;/span&gt;&lt;/p&gt;\n  \n  &lt;div class=\"crawl\"&gt;\n    &lt;p&gt;...&lt;/p&gt;\n    &lt;p&gt;...&lt;/p&gt;\n    &lt;p&gt;...&lt;/p&gt;\n  &lt;/div&gt;\n&lt;/section&gt;\nΣτόχος μας είναι να μετατρέψουμε αυτά τα δεδομένα σε ένα πλαίσιο δεδομένων 7 γραμμών με μεταβλητές title, year, director, και intro. Θα ξεκινήσουμε διαβάζοντας το HTML αρχείο και εξάγοντας όλα τα στοιχεία &lt;section&gt;:\n\nurl &lt;- \"https://rvest.tidyverse.org/articles/starwars.html\"\nhtml &lt;- read_html(url)\n\nsection &lt;- html |&gt; html_elements(\"section\")\nsection\n#&gt; {xml_nodeset (7)}\n#&gt; [1] &lt;section&gt;&lt;h2 data-id=\"1\"&gt;\\nThe Phantom Menace\\n&lt;/h2&gt;\\n&lt;p&gt;\\nReleased: 1 ...\n#&gt; [2] &lt;section&gt;&lt;h2 data-id=\"2\"&gt;\\nAttack of the Clones\\n&lt;/h2&gt;\\n&lt;p&gt;\\nReleased: ...\n#&gt; [3] &lt;section&gt;&lt;h2 data-id=\"3\"&gt;\\nRevenge of the Sith\\n&lt;/h2&gt;\\n&lt;p&gt;\\nReleased:  ...\n#&gt; [4] &lt;section&gt;&lt;h2 data-id=\"4\"&gt;\\nA New Hope\\n&lt;/h2&gt;\\n&lt;p&gt;\\nReleased: 1977-05-2 ...\n#&gt; [5] &lt;section&gt;&lt;h2 data-id=\"5\"&gt;\\nThe Empire Strikes Back\\n&lt;/h2&gt;\\n&lt;p&gt;\\nReleas ...\n#&gt; [6] &lt;section&gt;&lt;h2 data-id=\"6\"&gt;\\nReturn of the Jedi\\n&lt;/h2&gt;\\n&lt;p&gt;\\nReleased: 1 ...\n#&gt; [7] &lt;section&gt;&lt;h2 data-id=\"7\"&gt;\\nThe Force Awakens\\n&lt;/h2&gt;\\n&lt;p&gt;\\nReleased: 20 ...\n\nΑυτό ανακτά επτά στοιχεία που ταιριάζουν με τις επτά ταινίες που βρέθηκαν σε αυτήν τη σελίδα, υποδηλώνοντας ότι η χρήση του section ως επιλογέα είναι καλή. Η εξαγωγή των επιμέρους στοιχείων είναι απλή, καθώς τα δεδομένα βρίσκονται πάντα στο κείμενο. Το μόνο που χρειάζεται είναι να βρούμε τον κατάλληλο επιλογέα:\n\nsection |&gt; html_element(\"h2\") |&gt; html_text2()\n#&gt; [1] \"The Phantom Menace\"      \"Attack of the Clones\"   \n#&gt; [3] \"Revenge of the Sith\"     \"A New Hope\"             \n#&gt; [5] \"The Empire Strikes Back\" \"Return of the Jedi\"     \n#&gt; [7] \"The Force Awakens\"\n\nsection |&gt; html_element(\".director\") |&gt; html_text2()\n#&gt; [1] \"George Lucas\"     \"George Lucas\"     \"George Lucas\"    \n#&gt; [4] \"George Lucas\"     \"Irvin Kershner\"   \"Richard Marquand\"\n#&gt; [7] \"J. J. Abrams\"\n\nΑφού το κάνουμε αυτό για κάθε στοιχείο, μπορούμε να βάλουμε όλα τα αποτελέσματα σε ένα tibble:\n\ntibble(\n  title = section |&gt; \n    html_element(\"h2\") |&gt; \n    html_text2(),\n  released = section |&gt; \n    html_element(\"p\") |&gt; \n    html_text2() |&gt; \n    str_remove(\"Released: \") |&gt; \n    parse_date(),\n  director = section |&gt; \n    html_element(\".director\") |&gt; \n    html_text2(),\n  intro = section |&gt; \n    html_element(\".crawl\") |&gt; \n    html_text2()\n)\n#&gt; # A tibble: 7 × 4\n#&gt;   title                   released   director         intro                  \n#&gt;   &lt;chr&gt;                   &lt;date&gt;     &lt;chr&gt;            &lt;chr&gt;                  \n#&gt; 1 The Phantom Menace      1999-05-19 George Lucas     \"Turmoil has engulfed …\n#&gt; 2 Attack of the Clones    2002-05-16 George Lucas     \"There is unrest in th…\n#&gt; 3 Revenge of the Sith     2005-05-19 George Lucas     \"War! The Republic is …\n#&gt; 4 A New Hope              1977-05-25 George Lucas     \"It is a period of civ…\n#&gt; 5 The Empire Strikes Back 1980-05-17 Irvin Kershner   \"It is a dark time for…\n#&gt; 6 Return of the Jedi      1983-05-25 Richard Marquand \"Luke Skywalker has re…\n#&gt; # ℹ 1 more row\n\nΕπεξεργαστήκαμε λίγο περισσότερο την released για να λάβουμε μία μεταβλητή που θα είναι εύκολη στη χρήση αργότερα για την ανάλυσή μας.\n\n24.6.2 Κορυφαίες ταινίες στο IMDB\nΓια την επόμενη εργασία μας θα αντιμετωπίσουμε κάτι λίγο πιο δύσκολο, θα εξάγουμε τις κορυφαίες 250 ταινίες από το IMDb (Internet Movie Database). Την περίοδο που γράφτηκε η δεύτερη αγγλική έκδοση αυτού του κεφαλαίου, η σελίδα έμοιαζε έτσι Σχήμα 24.1.\n\n\n\n\n\n\n\nΣχήμα 24.1: Στιγμιότυπο των κορυφαίων ταινιών του IMDb στις 05/12/2022.\n\n\n\n\nΤα δεδομένα αυτά έχουν μία σαφή δομή πίνακα, επομένως αξίζει να ξεκινήσετε με την html_table():\n\nurl &lt;- \"https://web.archive.org/web/20220201012049/https://www.imdb.com/chart/top/\"\nhtml &lt;- read_html(url)\n\ntable &lt;- html |&gt; \n  html_element(\"table\") |&gt; \n  html_table()\ntable\n#&gt; # A tibble: 250 × 5\n#&gt;   ``    `Rank & Title`                    `IMDb Rating` `Your Rating`   ``   \n#&gt;   &lt;lgl&gt; &lt;chr&gt;                                     &lt;dbl&gt; &lt;chr&gt;           &lt;lgl&gt;\n#&gt; 1 NA    \"1.\\n      The Shawshank Redempt…           9.2 \"12345678910\\n… NA   \n#&gt; 2 NA    \"2.\\n      The Godfather\\n      …           9.1 \"12345678910\\n… NA   \n#&gt; 3 NA    \"3.\\n      The Godfather: Part I…           9   \"12345678910\\n… NA   \n#&gt; 4 NA    \"4.\\n      The Dark Knight\\n    …           9   \"12345678910\\n… NA   \n#&gt; 5 NA    \"5.\\n      12 Angry Men\\n       …           8.9 \"12345678910\\n… NA   \n#&gt; 6 NA    \"6.\\n      Schindler's List\\n   …           8.9 \"12345678910\\n… NA   \n#&gt; # ℹ 244 more rows\n\nΤο παραπάνω περιλαμβάνει μερικές κενές στήλες, αλλά γενικά κάνει καλή δουλειά στην καταγραφή της πληροφορίας από τον πίνακα. Ωστόσο, πρέπει να το επεξεργαστούμε λίγο περισσότερο για να το κάνουμε πιο εύκολο στη χρήση. Αρχικά, θα μετονομάσουμε τις στήλες και θα αφαιρέσουμε το περιττό κενό διάστημα στην κατάταξη και τον τίτλο. Αυτό Θα το κάνουμε με την select() (αντί για την rename()), για να κάνουμε τη μετονομασία και την επιλογή μόνο αυτών των δύο στηλών σε ένα βήμα. Στη συνέχεια, θα αφαιρέσουμε τις νέες γραμμές και τα επιπλέον κενά και, στη συνέχεια, θα εφαρμόσουμε την separate_wider_regex() (από την Ενότητα 15.3.4) για να μεταφέρουμε τον τίτλο, το έτος και την κατάταξη στις δικές τους, ξεχωριστές μεταβλητές.\n\nratings &lt;- table |&gt;\n  select(\n    rank_title_year = `Rank & Title`,\n    rating = `IMDb Rating`\n  ) |&gt; \n  mutate(\n    rank_title_year = str_replace_all(rank_title_year, \"\\n +\", \" \")\n  ) |&gt; \n  separate_wider_regex(\n    rank_title_year,\n    patterns = c(\n      rank = \"\\\\d+\", \"\\\\. \",\n      title = \".+\", \" +\\\\(\",\n      year = \"\\\\d+\", \"\\\\)\"\n    )\n  )\nratings\n#&gt; # A tibble: 250 × 4\n#&gt;   rank  title                    year  rating\n#&gt;   &lt;chr&gt; &lt;chr&gt;                    &lt;chr&gt;  &lt;dbl&gt;\n#&gt; 1 1     The Shawshank Redemption 1994     9.2\n#&gt; 2 2     The Godfather            1972     9.1\n#&gt; 3 3     The Godfather: Part II   1974     9  \n#&gt; 4 4     The Dark Knight          2008     9  \n#&gt; 5 5     12 Angry Men             1957     8.9\n#&gt; 6 6     Schindler's List         1993     8.9\n#&gt; # ℹ 244 more rows\n\nΑκόμη και σε αυτήν την περίπτωση, όπου τα περισσότερα δεδομένα προέρχονται από κελιά πίνακα, αξίζει να κοιτάξετε τον ακατέργαστο κώδικα HTML. Εάν το κάνετε, θα ανακαλύψετε ότι μπορούμε να προσθέσουμε λίγα επιπλέον δεδομένα χρησιμοποιώντας ένα από τα χαρακτηριστικά. Αυτός είναι ένας από τους λόγους για τους οποίους αξίζει να αφιερώσετε λίγο χρόνο για να εξετάσετε την πηγαίο κώδικα της σελίδας. Μπορεί να βρείτε επιπλέον δεδομένα ή μία διαφορετική οδό για να πάρετε τα δεδομένα, η οποία να είναι ελαφρώς πιο εύκολη.\n\nhtml |&gt; \n  html_elements(\"td strong\") |&gt; \n  head() |&gt; \n  html_attr(\"title\")\n#&gt; [1] \"9.2 based on 2,536,415 user ratings\"\n#&gt; [2] \"9.1 based on 1,745,675 user ratings\"\n#&gt; [3] \"9.0 based on 1,211,032 user ratings\"\n#&gt; [4] \"9.0 based on 2,486,931 user ratings\"\n#&gt; [5] \"8.9 based on 749,563 user ratings\"  \n#&gt; [6] \"8.9 based on 1,295,705 user ratings\"\n\nΑυτό, μπορούμε να το συνδυάσουμε με τα δεδομένα του πίνακα και να εφαρμόσουμε ξανά την separate_wider_regex() για να εξαγάγουμε το μέρος της πληροφορίας που μας ενδιαφέρει:\n\nratings |&gt;\n  mutate(\n    rating_n = html |&gt; html_elements(\"td strong\") |&gt; html_attr(\"title\")\n  ) |&gt; \n  separate_wider_regex(\n    rating_n,\n    patterns = c(\n      \"[0-9.]+ based on \",\n      number = \"[0-9,]+\",\n      \" user ratings\"\n    )\n  ) |&gt; \n  mutate(\n    number = parse_number(number)\n  )\n#&gt; # A tibble: 250 × 5\n#&gt;   rank  title                    year  rating  number\n#&gt;   &lt;chr&gt; &lt;chr&gt;                    &lt;chr&gt;  &lt;dbl&gt;   &lt;dbl&gt;\n#&gt; 1 1     The Shawshank Redemption 1994     9.2 2536415\n#&gt; 2 2     The Godfather            1972     9.1 1745675\n#&gt; 3 3     The Godfather: Part II   1974     9   1211032\n#&gt; 4 4     The Dark Knight          2008     9   2486931\n#&gt; 5 5     12 Angry Men             1957     8.9  749563\n#&gt; 6 6     Schindler's List         1993     8.9 1295705\n#&gt; # ℹ 244 more rows",
    "crumbs": [
      "Εισαγωγή δεδομένων",
      "<span class='chapter-number'>24</span>  <span class='chapter-title'>Ιστοσυγκομιδή</span>"
    ]
  },
  {
    "objectID": "webscraping.html#δυναμικές-σελίδες",
    "href": "webscraping.html#δυναμικές-σελίδες",
    "title": "24  Ιστοσυγκομιδή",
    "section": "\n24.7 Δυναμικές σελίδες",
    "text": "24.7 Δυναμικές σελίδες\nΜέχρι στιγμής έχουμε επικεντρωθεί σε ιστοτόπους όπου η html_elements() επιστρέφει ό,τι βλέπετε στον browser και συζητήσαμε πώς να τα αναλύσετε και πώς να τα οργανώσετε σε τακτοποιημένα πλαίσια δεδομένων. Κατά καιρούς, ωστόσο, θα βρείτε έναν ιστότοπο όπου η html_elements() και παρόμοιες συναρτήσεις δεν επιστρέφουν τίποτα σαν αυτό που βλέπετε στο πρόγραμμα περιήγησης. Σε πολλές περιπτώσεις, αυτό συμβαίνει επειδή προσπαθείτε να συγκομίσετε έναν ιστότοπο που δημιουργεί δυναμικά το περιεχόμενο της σελίδας με javascript. Αυτό δεν λειτουργεί προς το παρόν με το rvest, επειδή το πακέτο rvest κατεβάζει τον ακατέργαστο κώδικα HTML και δεν εκτελεί καθόλου javascript.\nΕίναι ακόμα εφικτό να συγκομίσετε αυτούς τους τύπους σελίδων, αλλά το πακέτο rvest πρέπει να χρησιμοποιήσει μία πιο δαπανηρή διαδικασία: την πλήρη προσομοίωση του browser, συμπεριλαμβανομένης της εκτέλεσης όλων των στοιχείων javascript. Η λειτουργία αυτή δεν ήταν διαθέσιμη τη στιγμή της σύνταξης αυτού του κειμένου, αλλά είναι κάτι πάνω στο οποίο εργαζόμαστε ενεργά και μπορεί να είναι διαθέσιμη κατά την περίοδο που θα διαβάζετε αυτό το βιβλίο. Χρησιμοποιεί το πακέτο chromote το οποίο εκτελεί στην πραγματικότητα τον browser Chrome στο παρασκήνιο και σας παρέχει πρόσθετα εργαλεία για να αλληλεπιδράσετε με τον ιστότοπο, όπως η πληκτρολόγηση κειμένου και το κλικ σε κουμπιά. Ρίξτε μία ματιά στον ιστότοπο του rvest για περισσότερες λεπτομέρειες.",
    "crumbs": [
      "Εισαγωγή δεδομένων",
      "<span class='chapter-number'>24</span>  <span class='chapter-title'>Ιστοσυγκομιδή</span>"
    ]
  },
  {
    "objectID": "webscraping.html#σύνοψη",
    "href": "webscraping.html#σύνοψη",
    "title": "24  Ιστοσυγκομιδή",
    "section": "\n24.8 Σύνοψη",
    "text": "24.8 Σύνοψη\nΣε αυτό το κεφάλαιο, μάθατε το γιατί, το γιατί όχι, και το πώς της συγκομιδής δεδομένων από ιστοσελίδες. Πρώτα, μάθατε για τα βασικά της HTML και τη χρήση επιλογέων CSS για αναφορά σε συγκεκριμένα στοιχεία και μετά μάθατε να χρησιμοποιείτε το πακέτο rvest για να μεταφέρετε δεδομένα από την HTML στην R. Στη συνέχεια, παρουσιάσαμε την ιστοσυγκομιδή με δύο μελέτες περίπτωσης: ένα πιο απλό σενάριο για την συγκομιδή δεδομένων σχετικών με τις ταινίες StarWars από τον ιστότοπο του πακέτου rvest, και ένα πιο περίπλοκο σενάριο για την συγκομιδή των κορυφαίων 250 ταινιών από την IMDB.\nΟι τεχνικές λεπτομέρειες της συγκομιδής δεδομένων από τον ιστό μπορεί να είναι περίπλοκες, ιδιαίτερα όταν ασχολούμαστε με ιστοτόπους, ωστόσο οι νομικές και ηθικές οπτικές μπορεί να είναι ακόμη πιο περίπλοκες. Είναι σημαντικό για εσάς να ενημερωθείτε και για τα δύο αυτά προτού ξεκινήσετε τη συγκομιδή δεδομένων.\nΑυτό μας φέρνει στο τέλος της ενότητας του βιβλίου σχετικά με την εισαγωγή δεδομένων όπου έχετε μάθει τεχνικές για να λαμβάνετε δεδομένα από τον τόπο αποθήκευσής τους (υπολογιστικά φύλλα, βάσεις δεδομένων, αρχεία JSON και ιστοτόπους) σε μία τακτοποιημένη μορφή στην R. Τώρα ήρθε η ώρα να στρέψουμε το βλέμμα μας σε ένα νέο θέμα: πως να αξιοποιήσουμε στο έπακρο την R ως γλώσσα προγραμματισμού.",
    "crumbs": [
      "Εισαγωγή δεδομένων",
      "<span class='chapter-number'>24</span>  <span class='chapter-title'>Ιστοσυγκομιδή</span>"
    ]
  },
  {
    "objectID": "webscraping.html#footnotes",
    "href": "webscraping.html#footnotes",
    "title": "24  Ιστοσυγκομιδή",
    "section": "",
    "text": "Πολλά δημοφιλή API έχουν ήδη αντίστοιχα πακέτα στο CRAN που τα ενθυλακώνουν, οπότε ξεκινήστε πρώτα με λίγη έρευνα!↩︎\nΠροφανώς δεν είμαστε δικηγόροι και αυτό δεν είναι νομική συμβουλή. Αυτή όμως είναι η καλύτερη περίληψη που μπορούμε να δώσουμε έχοντας διαβάσει αρκετά για αυτό το θέμα.↩︎\nΈνα παράδειγμα άρθρου σχετικά με τη μελέτη της OkCupid δημοσιεύτηκε από το Wired, https://www.wired.com/2016/05/okcupid-study-reveals-perils-big-data-science .↩︎\nΑυτή η κλάση προέρχεται από το πακέτο xml2. Το xml2 είναι ένα πακέτο χαμηλού επιπέδου στο οποίο το πακέτο rvest στηρίζεται.↩︎\nΑυτή η κλάση προέρχεται από το πακέτο xml2. Το xml2 είναι ένα πακέτο χαμηλού επιπέδου στο οποίο το πακέτο rvest στηρίζεται.↩︎\nΗ rvest παρέχει επίσης την html_text(), αλλά θα πρέπει σχεδόν πάντα να χρησιμοποιείτε την html_text2(), καθώς κάνει καλύτερη δουλειά στη μετατροπή του ένθετου HTML κώδικα σε κείμενο.↩︎",
    "crumbs": [
      "Εισαγωγή δεδομένων",
      "<span class='chapter-number'>24</span>  <span class='chapter-title'>Ιστοσυγκομιδή</span>"
    ]
  },
  {
    "objectID": "program.html",
    "href": "program.html",
    "title": "Προγραμματισμός",
    "section": "",
    "text": "Σε αυτό το μέρος του βιβλίου, θα βελτιώσετε τις προγραμματιστικές σας δεξιότητες. Ο προγραμματισμός είναι μια οριζόντια δεξιότητα που απαιτείται για όλες τις σχετικές εργασίες της επιστήμης των δεδομένων: πρέπει να χρησιμοποιήσετε υπολογιστή για να εφαρμόσετε την επιστήμη των δεδομένων. Δεν μπορεί να γίνει στη σκέψη, ούτε με μολύβι και χαρτί.\n\n\n\n\n\n\n\nΣχήμα 1: Ο προγραμματισμός είναι το νερό στο οποίο κολυμπούν όλα τα άλλα στοιχεία.\n\n\n\n\nΟ προγραμματισμός παράγει κώδικα και ο κώδικας είναι ένα εργαλείο επικοινωνίας. Προφανώς, ο κώδικας λέει στον υπολογιστή τι θέλετε να κάνει. Επικοινωνεί, όμως, και το σχετικό νόημα σε άλλους ανθρώπους. Το να σκέφτεστε τον κώδικα ως μέσο επικοινωνίας είναι σημαντικό γιατί κάθε έργο που κάνετε είναι ουσιαστικά συνεργατικό. Ακόμα κι αν δεν εργάζεστε με άλλους, σίγουρα θα συνεργαστείτε με τον μελλοντικό εαυτό σας! Η σύνταξη ξεκάθαρου κώδικα είναι σημαντική ώστε οι άλλοι (όπως οι μελλοντικοί εαυτοί σας) να καταλάβουν γιατί αντιμετωπίσατε μια ανάλυση με τον τρόπο που την αντιμετωπίσατε. Αυτό σημαίνει ότι το να γίνετε καλύτεροι στον προγραμματισμό συνεπάγεται επίσης με την βελτίωση στην επικοινωνία. Με την πάροδο του χρόνου, θέλετε ο κώδικάς σας να γίνεται όχι μόνο ευκολότερος στην συγγραφή, αλλά και ευκολότερος στην ανάγνωση από άλλους.\nΣτα ακόλουθα τρία κεφάλαια, θα μάθετε δεξιότητες για τη βελτίωση του τρόπου με τον οποίο προγραμματίζετε:\n\nΗ αντιγραφή και επικόλληση είναι ένα ισχυρό εργαλείο, αλλά θα πρέπει να αποφύγετε να την εφαρμόζετε περισσότερες από δύο φορές. Η επανάληψη του κώδικά σας είναι επικίνδυνη γιατί μπορεί εύκολα να οδηγήσει σε σφάλματα και ασυνέπειες. Έτσι, στο 25  Συναρτήσεις, θα μάθετε πώς να γράφετε συναρτήσεις που σας επιτρέπουν να εξάγετε επαναλαμβανόμενο κώδικα tidyverse, ώστε να μπορεί να επαναχρησιμοποιηθεί εύκολα.\nΟι συναρτήσεις εξάγουν επαναλαμβανόμενο κώδικα, αλλά συχνά χρειάζεται να επαναλάβετε τις ίδιες ενέργειες για διαφορετικές εισόδους. Χρειάζεστε εργαλεία για επανάληψη που σας επιτρέπουν να κάνετε παρόμοια πράγματα ξανά και ξανά. Αυτά τα εργαλεία περιλαμβάνουν βρόγχους και συναρτησιακό προγραμματισμό, για τα οποία θα μάθετε στο 26  Επανάληψη.\nΚαθώς διαβάζετε περισσότερο κώδικα που γράφτηκε από άλλους, θα δείτε περισσότερο κώδικα που δεν χρησιμοποιεί το tidyverse. Στο 27  Ένας οδηγός για το βασικό σύνολο λειτουργιών της R, θα μάθετε μερικές από τις πιο σημαντικές συναρτήσεις του βασικού πακέτου λειτουργιών της R που μπορεί να δείτε εκεί έξω.\n\nΣτόχος αυτών των κεφαλαίων είναι να σας διδάξουν τα ελάχιστα σχετικά με τον προγραμματισμό που χρειάζεστε για την επιστήμη των δεδομένων. Αφού κατανοήσετε το υλικό εδώ, σας συνιστούμε ανεπιφύλακτα να συνεχίσετε να επενδύετε στις προγραμματιστικές σας δεξιότητες. Έχουμε γράψει δύο βιβλία που μπορεί να σας φανούν χρήσιμα. Το Hands on Programming with R, από τον Garrett Grolemund, είναι μια εισαγωγή στην R ως γλώσσα προγραμματισμού και είναι ένα εξαιρετικό μέρος για να ξεκινήσετε εάν η R είναι η πρώτη γλώσσα προγραμματισμού σας. Το Advanced R του Hadley Wickham βουτά στις λεπτομέρειες της γλώσσας προγραμματισμού R. Είναι εξαιρετικό μέρος για να ξεκινήσετε εάν έχετε υπάρχουσα εμπειρία προγραμματισμού και υπέροχο επόμενο βήμα αφού έχετε μάθει καλά τις ιδέες σε αυτά τα κεφάλαια.",
    "crumbs": [
      "Προγραμματισμός"
    ]
  },
  {
    "objectID": "functions.html",
    "href": "functions.html",
    "title": "25  Συναρτήσεις",
    "section": "",
    "text": "25.1 Εισαγωγή\nΈνας από τους καλύτερους τρόπους για να βελτιώσετε τις ικανότητές σας ως επιστήμονας δεδομένων είναι γράφοντας συναρτήσεις. Οι συναρτήσεις σας επιτρέπουν να αυτοματοποιείτε συχνές εργασίες με έναν πιο ισχυρό και γενικευμένο τρόπο από την αντιγραφή και επικόλληση. Η σύνταξη μιας συνάρτησης έχει τέσσερα μεγάλα πλεονεκτήματα σε σχέση με τη χρήση της αντιγραφής και επικόλλησης:\nΈνας καλός εμπειρικός κανόνας είναι να εξετάζετε το ενδεχόμενο να γράψετε μία συνάρτηση κάθε φορά που έχετε αντιγράψει και επικολλήσει ένα κομμάτι κώδικα περισσότερες από δύο φορές (δηλαδή έχετε τρία αντίγραφα του ίδιου κώδικα). Σε αυτό το κεφάλαιο, θα μάθετε για τρεις χρήσιμους τύπους συναρτήσεων:\nΚάθε μία από αυτές τις ενότητες περιλαμβάνει αρκετά παραδείγματα που θα σας βοηθήσουν να γενικεύσετε μοτίβα που βλέπετε. Αυτά τα παραδείγματα δεν θα ήταν διαθέσιμα χωρίς τη βοήθεια των φίλων μας στο twitter και σας προτείνουμε να ακολουθήσετε τους συνδέσμους στο σχόλιο για να δείτε τις αρχικές ιδέες. Μπορεί επίσης να θέλετε να διαβάσετε τα αρχικά tweets για τις γενικές λειτουργίες και συναρτήσεις διαγραμμάτων για να δείτε ακόμα περισσότερες συναρτήσεις.",
    "crumbs": [
      "Προγραμματισμός",
      "<span class='chapter-number'>25</span>  <span class='chapter-title'>Συναρτήσεις</span>"
    ]
  },
  {
    "objectID": "functions.html#εισαγωγή",
    "href": "functions.html#εισαγωγή",
    "title": "25  Συναρτήσεις",
    "section": "",
    "text": "Μπορείτε να δώσετε σε μία συνάρτηση ένα όνομα που να θυμάστε και που κάνει τον κώδικά σας πιο κατανοητό.\nΚαθώς οι απαιτήσεις αλλάζουν, χρειάζεται μόνο να αλλάξετε τον κώδικά σας σε ένα σημείο, αντί για πολλά.\nΕξαλείφετε την πιθανότητα να αναπαράγετε λάθη που θα κάνατε χρησιμοποιώντας την αντιγραφή και επικόλληση (δηλαδή ενημερώνοντας ένα όνομα μεταβλητής σε ένα μέρος, αλλά όχι σε άλλο).\nΔιευκολύνει την επαναχρησιμοποίηση του κώδικά σας από project σε project, αυξάνοντας την παραγωγικότητά σας με την πάροδο του χρόνου.\n\n\n\nΟι διανυσματικές συναρτήσεις λαμβάνουν ένα ή περισσότερα διανύσματα ως είσοδο και επιστρέφουν ένα διάνυσμα ως έξοδο.\nΟι συναρτήσεις που εφαρμόζονται σε πλαίσια δεδομένων λαμβάνουν ένα πλαίσιο δεδομένων ως είσοδο και επιστρέφουν ένα πλαίσιο δεδομένων ως έξοδο.\nΣυναρτήσεις διαγραμμάτων που λαμβάνουν ένα πλαίσιο δεδομένων ως είσοδο και επιστρέφουν ένα διάγραμμα ως έξοδο.\n\n\n\n25.1.1 Προαπαιτούμενα\nΘα συνοψίσουμε μία ποικιλία συναρτήσεων από όλο το tidyverse. Θα χρησιμοποιήσουμε επίσης το σύνολο δεδομένων nycflights13 για να εφαρμόσουμε τις συναρτήσεις μας.\n\nlibrary(tidyverse)\nlibrary(nycflights13)",
    "crumbs": [
      "Προγραμματισμός",
      "<span class='chapter-number'>25</span>  <span class='chapter-title'>Συναρτήσεις</span>"
    ]
  },
  {
    "objectID": "functions.html#διανυσματικές-συναρτήσεις",
    "href": "functions.html#διανυσματικές-συναρτήσεις",
    "title": "25  Συναρτήσεις",
    "section": "\n25.2 Διανυσματικές συναρτήσεις",
    "text": "25.2 Διανυσματικές συναρτήσεις\nΘα ξεκινήσουμε με τις διανυσματικές συναρτήσεις: συναρτήσεις που παίρνουν ένα ή περισσότερα διανύσματα ως είσοδο και επιστρέφουν ένα διάνυσμα ως αποτέλεσμα. Για παράδειγμα, ρίξτε μία ματιά σε αυτόν τον κώδικα. Τι κάνει;\n\ndf &lt;- tibble(\n  a = rnorm(5),\n  b = rnorm(5),\n  c = rnorm(5),\n  d = rnorm(5),\n)\n\ndf |&gt; mutate(\n  a = (a - min(a, na.rm = TRUE)) / \n    (max(a, na.rm = TRUE) - min(a, na.rm = TRUE)),\n  b = (b - min(b, na.rm = TRUE)) / \n    (max(b, na.rm = TRUE) - min(a, na.rm = TRUE)),\n  c = (c - min(c, na.rm = TRUE)) / \n    (max(c, na.rm = TRUE) - min(c, na.rm = TRUE)),\n  d = (d - min(d, na.rm = TRUE)) / \n    (max(d, na.rm = TRUE) - min(d, na.rm = TRUE)),\n)\n#&gt; # A tibble: 5 × 4\n#&gt;       a     b     c     d\n#&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n#&gt; 1 0.339  2.59 0.291 0    \n#&gt; 2 0.880  0    0.611 0.557\n#&gt; 3 0      1.37 1     0.752\n#&gt; 4 0.795  1.37 0     1    \n#&gt; 5 1      1.34 0.580 0.394\n\nΊσως μπορείτε να καταλάβετε ότι ο κώδικας αλλάζει τη κλίμακα κάθε στήλης έτσι ώστε κάθε μία να έχει εύρος από 0 έως 1. Βρήκατε όμως το λάθος; Όταν ο Hadley έγραψε αυτόν τον κώδικα, έκανε ένα λάθος κατά την αντιγραφή και επικόλληση και ξέχασε να αλλάξει το a σε b. Η αποτροπή αυτού του τύπου λάθους είναι ένας πολύ καλός λόγος για να μάθετε πώς να γράφετε συναρτήσεις.\n\n25.2.1 Σύνταξη μιας συνάρτησης\nΓια να γράψετε μία συνάρτηση, πρέπει πρώτα να αναλύσετε τον κώδικα που επαναλαμβάνετε για να υπολογίσετε ποια μέρη του είναι σταθερά και ποια μέρη του μπορούν να αλλάζουν. Αν πάρουμε τον παραπάνω κώδικα και τον βγάλουμε έξω από τη mutate(), είναι λίγο πιο εύκολο να δούμε το μοτίβο γιατί κάθε επανάληψη είναι πλέον μία γραμμή:\n\n(a - min(a, na.rm = TRUE)) / (max(a, na.rm = TRUE) - min(a, na.rm = TRUE))\n(b - min(b, na.rm = TRUE)) / (max(b, na.rm = TRUE) - min(b, na.rm = TRUE))\n(c - min(c, na.rm = TRUE)) / (max(c, na.rm = TRUE) - min(c, na.rm = TRUE))\n(d - min(d, na.rm = TRUE)) / (max(d, na.rm = TRUE) - min(d, na.rm = TRUE))  \n\nΓια να το κάνουμε λίγο πιο σαφές, μπορούμε να αντικαταστήσουμε το κομμάτι που αλλάζει με █:\n\n(█ - min(█, na.rm = TRUE)) / (max(█, na.rm = TRUE) - min(█, na.rm = TRUE))\n\nΓια να το μετατρέψετε σε συνάρτηση χρειάζεστε τρία πράγματα:\n\nΈνα όνομα. Εδώ θα χρησιμοποιήσουμε το rescale01 επειδή αυτή η συνάρτηση αλλάζει την κλίμακα ενός διανύσματος ώστε να βρίσκεται μεταξύ 0 και 1.\nΤα ορίσματα. Τα ορίσματα είναι πράγματα που μπορεί να διαφέρουν από εκτέλεση σε εκτέλεση και η ανάλυσή μας παραπάνω μας λέει ότι έχουμε μόνο ένα. Θα το ονομάσουμε x καθώς έτσι συνηθίζεται για ένα αριθμητικό διάνυσμα.\nΤο σώμα. Το σώμα είναι ο κώδικας που επαναλαμβάνεται σε όλες τις εκτελέσεις.\n\nΣτη συνέχεια, δημιουργείτε μία συνάρτηση ακολουθώντας το παρακάτω πρότυπο:\n\nname &lt;- function(arguments) {\n  body\n}\n\nΣτην συγκεκριμένη περίπτωση έχουμε:\n\nrescale01 &lt;- function(x) {\n  (x - min(x, na.rm = TRUE)) / (max(x, na.rm = TRUE) - min(x, na.rm = TRUE))\n}\n\nΣε αυτό το σημείο, μπορείτε να δοκιμάσετε μερικές απλές τιμές για να βεβαιωθείτε ότι έχετε αποτυπώσει σωστά τη λογική:\n\nrescale01(c(-10, 0, 10))\n#&gt; [1] 0.0 0.5 1.0\nrescale01(c(1, 2, 3, NA, 5))\n#&gt; [1] 0.00 0.25 0.50   NA 1.00\n\nΣτη συνέχεια, μπορείτε να μεταφέρετε τη συνάρτηση στη mutate() ως:\n\ndf |&gt; mutate(\n  a = rescale01(a),\n  b = rescale01(b),\n  c = rescale01(c),\n  d = rescale01(d),\n)\n#&gt; # A tibble: 5 × 4\n#&gt;       a     b     c     d\n#&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n#&gt; 1 0.339 1     0.291 0    \n#&gt; 2 0.880 0     0.611 0.557\n#&gt; 3 0     0.530 1     0.752\n#&gt; 4 0.795 0.531 0     1    \n#&gt; 5 1     0.518 0.580 0.394\n\n(Στο Κεφάλαιο 26, θα μάθετε πώς να χρησιμοποιείτε την across() για να μειώσετε ακόμη περισσότερο την επανάληψη έτσι ώστε το μόνο που θα χρειαστείτε θα είναι df |&gt; mutate(across(a:d, rescale01))).\n\n25.2.2 Βελτιώνοντας τη συνάρτησή μας\nΜπορεί να παρατηρήσετε ότι η συνάρτηση rescale01() κάνει κάποια περιττά βήματα — αντί να υπολογίσουμε τη min() δύο φορές και τη max() μία φορά θα μπορούσαμε να υπολογίσουμε την ελάχιστη και τη μέγιστη τιμή σε ένα βήμα με τη range():\n\nrescale01 &lt;- function(x) {\n  rng &lt;- range(x, na.rm = TRUE)\n  (x - rng[1]) / (rng[2] - rng[1])\n}\n\nΉ θα μπορούσατε να δοκιμάσετε αυτή τη συνάρτηση σε ένα διάνυσμα που περιέχει μία τιμή απείρου:\n\nx &lt;- c(1:10, Inf)\nrescale01(x)\n#&gt;  [1]   0   0   0   0   0   0   0   0   0   0 NaN\n\nΤο αποτέλεσμα δεν είναι πολύ βοηθητικό, οπότε θα μπορούσαμε να ζητήσουμε από τη range() να παραβλέπει τιμές απείρου:\n\nrescale01 &lt;- function(x) {\n  rng &lt;- range(x, na.rm = TRUE, finite = TRUE)\n  (x - rng[1]) / (rng[2] - rng[1])\n}\n\nrescale01(x)\n#&gt;  [1] 0.0000000 0.1111111 0.2222222 0.3333333 0.4444444 0.5555556 0.6666667\n#&gt;  [8] 0.7777778 0.8888889 1.0000000       Inf\n\nΟι αλλαγές αυτές απεικονίζουν ένα σημαντικό πλεονέκτημα των συναρτήσεων: επειδή έχουμε μετακινήσει τον επαναλαμβανόμενο κώδικα σε μία συνάρτηση, οι αλλαγές μπορούν να γίνουν μόνο σε ένα μέρος.\n\n25.2.3 Συναρτήσεις mutate\nΜιας και έχετε πλέον τη βασική ιδέα των συναρτήσεων, ας ρίξουμε μία ματιά και σε μερικά παραδείγματα. Θα ξεκινήσουμε εξετάζοντας τις συναρτήσεις “mutate”, δηλαδή συναρτήσεις που λειτουργούν καλά στο εσωτερικό των mutate() και filter() επειδή επιστρέφουν μία έξοδο ίδιου μεγέθους με την είσοδο.\nΑς ξεκινήσουμε με μία απλή παραλλαγή της rescale01(). Ίσως θέλετε να κάνετε έναν Z-score υπολογισμό, αλλάζοντας τη κλίμακα ενός διανύσματος ώστε να έχει μέσο όρο μηδέν και τυπική απόκλιση ίση με ένα:\n\nz_score &lt;- function(x) {\n  (x - mean(x, na.rm = TRUE)) / sd(x, na.rm = TRUE)\n}\n\nΉ ίσως θέλετε να βάλετε την case_when() μέσα σε μία νέα συνάρτηση και να της δώσετε ένα χρήσιμο όνομα. Για παράδειγμα, η παρακάτω συνάρτηση clamp() διασφαλίζει ότι όλες οι τιμές ενός διανύσματος βρίσκονται μεταξύ ενός ελάχιστου ή ενός μέγιστου:\n\nclamp &lt;- function(x, min, max) {\n  case_when(\n    x &lt; min ~ min,\n    x &gt; max ~ max,\n    .default = x\n  )\n}\n\nclamp(1:10, min = 3, max = 7)\n#&gt;  [1] 3 3 3 4 5 6 7 7 7 7\n\nΦυσικά οι συναρτήσεις δεν χρειάζεται να λειτουργούν μόνο με αριθμητικές μεταβλητές. Ίσως θέλετε να κάνετε μερικούς επαναλαμβανόμενους χειρισμούς σε κείμενο. Ίσως χρειαστεί να κάνετε τον πρώτο χαρακτήρα κεφαλαίο:\n\nfirst_upper &lt;- function(x) {\n  str_sub(x, 1, 1) &lt;- str_to_upper(str_sub(x, 1, 1))\n  x\n}\n\nfirst_upper(\"hello\")\n#&gt; [1] \"Hello\"\n\nΉ ίσως θέλετε να αφαιρέσετε τα σύμβολα ποσοστού, τα κόμματα και τα σύμβολα του δολαρίου από ένα κείμενο πριν το μετατρέψετε σε αριθμό:\n\n# https://twitter.com/NVlabormarket/status/1571939851922198530\nclean_number &lt;- function(x) {\n  is_pct &lt;- str_detect(x, \"%\")\n  num &lt;- x |&gt; \n    str_remove_all(\"%\") |&gt; \n    str_remove_all(\",\") |&gt; \n    str_remove_all(fixed(\"$\")) |&gt; \n    as.numeric()\n  if_else(is_pct, num / 100, num)\n}\n\nclean_number(\"$12,300\")\n#&gt; [1] 12300\nclean_number(\"45%\")\n#&gt; [1] 0.45\n\nΜερικές φορές οι συναρτήσεις σας θα είναι εξαιρετικά εξειδικευμένες ως προς ένα βήμα μιας ανάλυσης δεδομένων. Για παράδειγμα, εάν έχετε έναν αριθμό μεταβλητών που χρησιμοποιούν κωδικούς για να αναδείξουν κενές τιμές σαν τους 997, 998 ή 999, ίσως θελήσετε να γράψετε μία συνάρτηση για να τις αντικαταστήσετε με NA:\n\nfix_na &lt;- function(x) {\n  if_else(x %in% c(997, 998, 999), NA, x)\n}\n\nΈχουμε επικεντρωθεί σε παραδείγματα που λαμβάνουν ένα μόνο διάνυσμα επειδή πιστεύουμε ότι είναι τα πιο κοινά. Δεν υπάρχει κανένας λόγος όμως η συνάρτησή σας να μην μπορεί να λάβει ως είσοδο πολλαπλά διανύσματα.\n\n25.2.4 Συναρτήσεις σύνοψης\nΜία άλλη σημαντική οικογένεια συναρτήσεων με διανύσματα ως είσοδο είναι οι συναρτήσεις σύνοψης. Συναρτήσεις, δηλαδή, που επιστρέφουν μία μόνο τιμή για χρήση στη summarize(). Κάποιες φορές μπορεί να είναι απλώς θέμα ορισμού ενός ή δύο προεπιλεγμένων ορισμάτων:\n\ncommas &lt;- function(x) {\n  str_flatten(x, collapse = \", \", last = \" and \")\n}\n\ncommas(c(\"cat\", \"dog\", \"pigeon\"))\n#&gt; [1] \"cat, dog and pigeon\"\n\nΉ μπορείτε να “καλύψετε” μέσα σε μία συνάρτηση έναν απλό υπολογισμό, όπως αυτόν για του συντελεστή διακύμανσης, ο οποίος διαιρεί την τυπική απόκλιση με τον μέσο όρο:\n\ncv &lt;- function(x, na.rm = FALSE) {\n  sd(x, na.rm = na.rm) / mean(x, na.rm = na.rm)\n}\n\ncv(runif(100, min = 0, max = 50))\n#&gt; [1] 0.5196276\ncv(runif(100, min = 0, max = 500))\n#&gt; [1] 0.5652554\n\nΉ ίσως θέλετε απλά να κάνετε ένα κοινό μοτίβο πιο εύκολο να θυμάστε δίνοντάς του ένα αξέχαστο όνομα:\n\n# https://twitter.com/gbganalyst/status/1571619641390252033\nn_missing &lt;- function(x) {\n  sum(is.na(x))\n} \n\nΜπορείτε επίσης να γράψετε συναρτήσεις με πολλαπλές εισόδους. Για παράδειγμα, ίσως θέλετε να υπολογίσετε το μέσο απόλυτο ποσοστιαίο σφάλμα για να σας βοηθήσει να συγκρίνετε τις προβλέψεις ενός μοντέλου με τις πραγματικές τιμές:\n\n# https://twitter.com/neilgcurrie/status/1571607727255834625\nmape &lt;- function(actual, predicted) {\n  sum(abs((actual - predicted) / actual)) / length(actual)\n}\n\n\n\n\n\n\n\nRStudio\n\n\n\nΜόλις ξεκινήσετε να γράφετε συναρτήσεις, υπάρχουν δύο εξαιρετικά χρήσιμες συντομεύσεις στο RStudio:\n\nΓια να βρείτε τον ορισμό μιας συνάρτησης που έχετε γράψει, τοποθετήστε τον κέρσορα στο όνομα της συνάρτησης και πατήστε F2.\nΓια να μεταβείτε γρήγορα σε μία συνάρτηση, πατήστε Ctrl + . για να ανοίξετε τη λειτουργία εύρεσης αρχείων και συναρτήσεων και πληκτρολογήστε τα πρώτα γράμματα του ονόματος της συνάρτησής σας. Μπορείτε επίσης να πλοηγηθείτε σε αρχεία, ενότητες Quarto και πολλά άλλα, καθιστώντας το ένα πολύ εύχρηστο εργαλείο πλοήγησης.\n\n\n\n\n25.2.5 Ασκήσεις\n\n\nΕξασκηθείτε στη μετατροπή των παρακάτω αποσπασμάτων κώδικα σε συναρτήσεις. Σκεφτείτε τι κάνει κάθε συνάρτηση. Πώς θα τις λέγατε; Πόσα ορίσματα χρειάζονται;\n\nmean(is.na(x))\nmean(is.na(y))\nmean(is.na(z))\n\nx / sum(x, na.rm = TRUE)\ny / sum(y, na.rm = TRUE)\nz / sum(z, na.rm = TRUE)\n\nround(x / sum(x, na.rm = TRUE) * 100, 1)\nround(y / sum(y, na.rm = TRUE) * 100, 1)\nround(z / sum(z, na.rm = TRUE) * 100, 1)\n\n\nΣτη δεύτερη παραλλαγή της rescale01(), τιμές απείρου παραμένουν αμετάβλητες. Μπορείτε να ξαναγράψετε τη rescale01() έτσι ώστε το -Inf να αντιστοιχιστεί στο 0 και το Inf να αντιστοιχιστεί στο 1;\nΔεδομένου ενός διανύσματος ημερομηνιών γέννησης, γράψτε μία συνάρτηση για να υπολογίσετε την ηλικία σε έτη.\nΓράψτε τις δικές σας συναρτήσεις για να υπολογίσετε τη διακύμανση και τη λοξότητα ενός αριθμητικού διανύσματος. Μπορείτε να αναζητήσετε τους ορισμούς στη Wikipedia ή οπουδήποτε αλλού.\nΓράψτε τη both_na(), μία συνάρτηση σύνοψης που παίρνει ως είσοδο δύο διανύσματα του ίδιου μεγέθους και επιστρέφει τον αριθμό των θέσεων που έχουν NA και στα δύο διανύσματα.\n\nΔιαβάστε τα αντίστοιχα εγχειρίδια για να καταλάβετε τι κάνουν οι παρακάτω συναρτήσεις. Γιατί είναι χρήσιμες, παρόλο που είναι τόσο μικρές;\n\nis_directory &lt;- function(x) {\n  file.info(x)$isdir\n}\nis_readable &lt;- function(x) {\n  file.access(x, 4) == 0\n}",
    "crumbs": [
      "Προγραμματισμός",
      "<span class='chapter-number'>25</span>  <span class='chapter-title'>Συναρτήσεις</span>"
    ]
  },
  {
    "objectID": "functions.html#συναρτήσεις-πλαισίου-δεδομένων",
    "href": "functions.html#συναρτήσεις-πλαισίου-δεδομένων",
    "title": "25  Συναρτήσεις",
    "section": "\n25.3 Συναρτήσεις πλαισίου δεδομένων",
    "text": "25.3 Συναρτήσεις πλαισίου δεδομένων\nΟι συναρτήσεις διανυσμάτων είναι χρήσιμες για την εξαγωγή κώδικα που επαναλαμβάνεται μέσα σε μία συνάρτηση της dplyr. Ωστόσο, συχνά θα επαναλαμβάνετε και τις ίδιες τις συναρτήσεις της dplyr, ιδιαίτερα μέσα σε ένα μεγάλο πλαίσιο εργασίας. Όταν παρατηρήσετε ότι κάνετε πολλές φορές αντιγραφή και επικόλληση τις ίδιες συναρτήσεις, θα μπορούσατε να σκεφτείτε να γράψετε μία συνάρτηση πλαισίου δεδομένων. Οι συναρτήσεις πλαισίου δεδομένων λειτουργούν όπως οι συναρτήσεις της dplyr: λαμβάνουν ένα πλαίσιο δεδομένων ως το πρώτο όρισμα, μερικά επιπλέον ορίσματα σχετικά με το τι πρέπει να γίνει με αυτό και επιστρέφουν ένα πλαίσιο δεδομένων ή ένα διάνυσμα.\nΓια να σας αφήσουμε να γράψετε μία συνάρτηση που χρησιμοποιεί συναρτήσεις από το πακέτο dplyr, θα σας παρουσιάσουμε πρώτα την πρόκληση της έμμεσης αναφοράς και πώς μπορείτε να την ξεπεράσετε με τον εγκλεισμό, { }. Έχοντας κατανοήσει αυτή τη θεωρία, θα σας δείξουμε στη συνέχεια αρκετά παραδείγματα για να δείξουμε τι μπορείτε να κάνετε με αυτή.\n\n25.3.1 Έμμεση αναφορά και tidy αξιολόγηση\nΌταν ξεκινάτε να γράφετε συναρτήσεις που χρησιμοποιούν συναρτήσεις της dplyr, έρχεστε γρήγορα αντιμέτωποι με το πρόβλημα της έμμεσης αναφοράς. Ας παρουσιάσουμε το πρόβλημα με μία πολύ απλή συνάρτηση: την grouped_mean(). Ο στόχος αυτής της συνάρτησης είναι να υπολογίσει τη μέση τιμή της mean_var ανά group_var:\n\ngrouped_mean &lt;- function(df, group_var, mean_var) {\n  df |&gt; \n    group_by(group_var) |&gt; \n    summarize(mean(mean_var))\n}\n\nΑν προσπαθήσουμε να τη χρησιμοποιήσουμε, παίρνουμε ένα σφάλμα:\n\ndiamonds |&gt; grouped_mean(cut, carat)\n#&gt; Error in `group_by()`:\n#&gt; ! Must group by variables found in `.data`.\n#&gt; ✖ Column `group_var` is not found.\n\nΓια να κάνουμε το πρόβλημα λίγο πιο κατανοητό, μπορούμε να χρησιμοποιήσουμε ένα συνθετικό πλαίσιο δεδομένων:\n\ndf &lt;- tibble(\n  mean_var = 1,\n  group_var = \"g\",\n  group = 1,\n  x = 10,\n  y = 100\n)\n\ndf |&gt; grouped_mean(group, x)\n#&gt; # A tibble: 1 × 2\n#&gt;   group_var `mean(mean_var)`\n#&gt;   &lt;chr&gt;                &lt;dbl&gt;\n#&gt; 1 g                        1\ndf |&gt; grouped_mean(group, y)\n#&gt; # A tibble: 1 × 2\n#&gt;   group_var `mean(mean_var)`\n#&gt;   &lt;chr&gt;                &lt;dbl&gt;\n#&gt; 1 g                        1\n\nΑνεξάρτητα από το πώς ονομάζουμε την grouped_mean() αυτό που εκτελεί πάντα είναι df |&gt; group_by(group_var) |&gt; summary(mean(mean_var)), αντί για df |&gt; group_by(group) |&gt; summarize(mean(x)) ή df |&gt; group_by(group) |&gt; summarize(mean(y)). Αυτό είναι ένα πρόβλημα έμμεσης ανάθεσης και προκύπτει επειδή το πακέτο dplyr χρησιμοποιεί tidy αξιολόγηση για να σας επιτρέψει να αναφερθείτε στα ονόματα των μεταβλητών μέσα στο πλαίσιο δεδομένων σας χωρίς καμία ειδική μεταχείριση.\nΗ tidy αξιολόγηση είναι ιδανική για το το 95% των περιπτώσεων, επειδή κάνει τις αναλύσεις των δεδομένων σας πολύ συνοπτικές, καθώς δεν χρειάζεται ποτέ να πείτε από ποιο πλαίσιο δεδομένων προέρχεται μία μεταβλητή. Είναι προφανές από τα συμφραζόμενα. Το μειονέκτημα της tidy αξιολόγησης έρχεται όταν θέλουμε να βάλουμε επαναλαμβανόμενο κώδικα από το tidyverse σε μία συνάρτηση. Εδώ χρειαζόμαστε κάποιον τρόπο για να πούμε στη group_by() και στη summarize() να μην αντιμετωπίζουν πλέον τα group_var και mean_var ως ονόματα μεταβλητών, αλλά να ψάξουμε μέσα σε αυτά για τη μεταβλητή που θέλουμε πραγματικά να χρησιμοποιήσουμε.\nΗ tidy αξιολόγηση περιλαμβάνει επίσης μία λύση στο πρόβλημα που ονομάζεται ενθυλάκωση 🤗. Το να ενθυλακώσετε μία μεταβλητή σημαίνει να την τυλίξετε σε άγκιστρα έτσι ώστε, για παράδειγμα, η var να γίνει { var }. Η ενθυλάκωση μιας μεταβλητής λέει στο πακέτο dplyr να χρησιμοποιήσει την τιμή που είναι αποθηκευμένη μέσα στο όρισμα, όχι το όρισμα ως το κυριολεκτικό όνομα της μεταβλητής. Ένας τρόπος για να θυμάστε τι συμβαίνει κάθε φορά είναι να σκεφτείτε το { } σαν να κοιτάτε μέσα σε ένα τούνελ — Το { var } θα κάνει μία συνάρτηση της dplyr να διαβάσει μέσα στη var αντί να αναζητά μία μεταβλητή που ονομάζεται var.\nΕπομένως, για να λειτουργήσει η grouped_mean(), πρέπει να περιστοιχίσουμε τη group_var και τη mean_var με το { }:\n\ngrouped_mean &lt;- function(df, group_var, mean_var) {\n  df |&gt; \n    group_by({{ group_var }}) |&gt; \n    summarize(mean({{ mean_var }}))\n}\n\ndf |&gt; grouped_mean(group, x)\n#&gt; # A tibble: 1 × 2\n#&gt;   group `mean(x)`\n#&gt;   &lt;dbl&gt;     &lt;dbl&gt;\n#&gt; 1     1        10\n\nΕπιτυχία!\n\n25.3.2 Πότε να ενθυλακώσετε;\nΕπομένως, η βασική πρόκληση για τη σύνταξη συναρτήσεων πλαισίου δεδομένων είναι να καταλάβουμε ποια ορίσματα πρέπει να ενθυκαλωθούν. Ευτυχώς, αυτό είναι εύκολο γιατί μπορείτε να το αναζητήσετε από τις οδηγίες 😄. Υπάρχουν δύο όροι που πρέπει να αναζητήσετε στις οδηγίες και αντιστοιχούν στις δύο πιο συνηθισμένες υποκατηγορίες αξιολόγησης tidy:\n\nΑπόκρυψη δεδομένων: χρησιμοποιείται σε συναρτήσεις όπως οι arrange(), filter() και summarize() που δουλεύουν με μεταβλητές.\nTidy-selection: χρησιμοποιείται για συναρτήσεις όπως οι select(), relocate() και rename() που επιλέγουν μεταβλητές.\n\nΗ αντίληψή σας για το ποια ορίσματα χρησιμοποιούν αξιολόγηση tidy θα πρέπει να είναι καλή για πολλές κοινώς χρησιμοποιούμενες συναρτήσεις — απλώς σκεφτείτε αν μπορείτε να υπολογίσετε (π.χ. x + 1) ή να επιλέξετε (π.χ. a:x).\nΣτις επόμενες ενότητες, θα εξερευνήσουμε τα είδη των εύχρηστων συναρτήσεων που μπορείτε να γράψετε μόλις καταλάβετε την ενθυλάκωση.\n\n25.3.3 Συνηθισμένες εφαρμογές\nΕάν εκτελείτε το ίδιο σύνολο περιλήψεων συχνά κατά την αρχική σας εξερεύνηση δεδομένων, μπορείτε να εξετάσετε το ενδεχόμενο να τις βάλετε σε μία βοηθητική συνάρτηση:\n\nsummary6 &lt;- function(data, var) {\n  data |&gt; summarize(\n    min = min({{ var }}, na.rm = TRUE),\n    mean = mean({{ var }}, na.rm = TRUE),\n    median = median({{ var }}, na.rm = TRUE),\n    max = max({{ var }}, na.rm = TRUE),\n    n = n(),\n    n_miss = sum(is.na({{ var }})),\n    .groups = \"drop\"\n  )\n}\n\ndiamonds |&gt; summary6(carat)\n#&gt; # A tibble: 1 × 6\n#&gt;     min  mean median   max     n n_miss\n#&gt;   &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt;  &lt;int&gt;\n#&gt; 1   0.2 0.798    0.7  5.01 53940      0\n\n(Όποτε βάζετε την summarize() σε μία βοηθητική συνάρτηση, πιστεύουμε ότι είναι καλή πρακτική να ορίζετε .groups = \"drop\" για να αποφύγετε το σχετικό μήνυμα και να αφήσετε τα δεδομένα σας σε μη ομαδοποιημένη κατάσταση μετά την επεξεργασία τους.)\nΤο καλό με αυτή τη συνάρτηση είναι ότι επειδή περιέχει την summarize(), μπορείτε να τη χρησιμοποιήσετε σε ομαδοποιημένα δεδομένα:\n\ndiamonds |&gt; \n  group_by(cut) |&gt; \n  summary6(carat)\n#&gt; # A tibble: 5 × 7\n#&gt;   cut         min  mean median   max     n n_miss\n#&gt;   &lt;ord&gt;     &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt;  &lt;int&gt;\n#&gt; 1 Fair       0.22 1.05    1     5.01  1610      0\n#&gt; 2 Good       0.23 0.849   0.82  3.01  4906      0\n#&gt; 3 Very Good  0.2  0.806   0.71  4    12082      0\n#&gt; 4 Premium    0.2  0.892   0.86  4.01 13791      0\n#&gt; 5 Ideal      0.2  0.703   0.54  3.5  21551      0\n\nΕπιπλέον, δεδομένου ότι τα ορίσματα που πρέπει να συνοψιστούν είναι μιας μορφής απόκρυψης δεδομένων σημαίνει ότι και το όρισμα var στη summary6() είναι επίσης απόκρυψη δεδομένων. Αυτό σημαίνει ότι μπορείτε επίσης να συνοψίσετε ήδη υπολογισμένες μεταβλητές:\n\ndiamonds |&gt; \n  group_by(cut) |&gt; \n  summary6(log10(carat))\n#&gt; # A tibble: 5 × 7\n#&gt;   cut          min    mean  median   max     n n_miss\n#&gt;   &lt;ord&gt;      &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt;  &lt;int&gt;\n#&gt; 1 Fair      -0.658 -0.0273  0      0.700  1610      0\n#&gt; 2 Good      -0.638 -0.133  -0.0862 0.479  4906      0\n#&gt; 3 Very Good -0.699 -0.164  -0.149  0.602 12082      0\n#&gt; 4 Premium   -0.699 -0.125  -0.0655 0.603 13791      0\n#&gt; 5 Ideal     -0.699 -0.225  -0.268  0.544 21551      0\n\nΓια να συνοψίσετε πολλαπλές μεταβλητές, θα χρειαστεί να περιμένετε μέχρι την Ενότητα 26.2, όπου θα μάθετε πώς να χρησιμοποιείτε την across().\nΜία άλλη δημοφιλής βοηθητική συνάρτηση τύπου summarize() είναι μία έκδοση της count() που υπολογίζει επίσης αναλογίες:\n\n# https://twitter.com/Diabb6/status/1571635146658402309\ncount_prop &lt;- function(df, var, sort = FALSE) {\n  df |&gt;\n    count({{ var }}, sort = sort) |&gt;\n    mutate(prop = n / sum(n))\n}\n\ndiamonds |&gt; count_prop(clarity)\n#&gt; # A tibble: 8 × 3\n#&gt;   clarity     n   prop\n#&gt;   &lt;ord&gt;   &lt;int&gt;  &lt;dbl&gt;\n#&gt; 1 I1        741 0.0137\n#&gt; 2 SI2      9194 0.170 \n#&gt; 3 SI1     13065 0.242 \n#&gt; 4 VS2     12258 0.227 \n#&gt; 5 VS1      8171 0.151 \n#&gt; 6 VVS2     5066 0.0939\n#&gt; # ℹ 2 more rows\n\nΑυτή η συνάρτηση έχει τρία ορίσματα: df, var και sort, και μόνο η var πρέπει να ενθυλακωθεί επειδή περνάει στη count() που χρησιμοποιεί απόκρυψη δεδομένων για όλες τις μεταβλητές. Σημειώστε ότι χρησιμοποιούμε μία προεπιλεγμένη τιμή για την sort, έτσι ώστε εάν ο χρήστης δεν δώσει τη δική του τιμή, θα χρησιμοποιήσει τη προεπιλεγμένη FALSE.\nΉ ίσως θέλετε να βρείτε τις ταξινομημένες μοναδικές τιμές μιας μεταβλητής για ένα υποσύνολο δεδομένων. Αντί να δώσουμε μία μεταβλητή και μία τιμή για να κάνουμε το φιλτράρισμα, θα επιτρέψουμε στον χρήστη να δώσει μία συνθήκη:\n\nunique_where &lt;- function(df, condition, var) {\n  df |&gt; \n    filter({{ condition }}) |&gt; \n    distinct({{ var }}) |&gt; \n    arrange({{ var }})\n}\n\n# Βρείτε όλους τους προορισμούς τον Δεκέμβριο\nflights |&gt; unique_where(month == 12, dest)\n#&gt; # A tibble: 96 × 1\n#&gt;   dest \n#&gt;   &lt;chr&gt;\n#&gt; 1 ABQ  \n#&gt; 2 ALB  \n#&gt; 3 ATL  \n#&gt; 4 AUS  \n#&gt; 5 AVL  \n#&gt; 6 BDL  \n#&gt; # ℹ 90 more rows\n\nΕδώ, ενθυλακώνουμε την condition επειδή έχει περάσει στην filter() και την var επειδή έχει περάσει στις distinct() και arrange().\nΈχουμε δημιουργήσει όλα αυτά τα παραδείγματα για να λάβουμε ένα πλαίσιο δεδομένων ως πρώτο όρισμα, αλλά αν εργάζεστε συχνά με τα ίδια δεδομένα, μπορεί να είναι λογικό να τα ενσωματώσετε στον κώδικα ως έχουν, έτσι ώστε να ισχύουν πάντα. Για παράδειγμα, η ακόλουθη συνάρτηση λειτουργεί πάντα με το σύνολο δεδομένων flights και επιλέγει πάντα τις μεταβλητές time_hour, carrier και flight, καθώς αποτελούν το σύνθετο πρωτεύον κλειδί που σας επιτρέπει να προσδιορίσετε μία γραμμή.\n\nsubset_flights &lt;- function(rows, cols) {\n  flights |&gt; \n    filter({{ rows }}) |&gt; \n    select(time_hour, carrier, flight, {{ cols }})\n}\n\n\n25.3.4 Απόκρυψη δεδομένων εναντίον tidy-selection\nΜερικές φορές θέλετε να επιλέξετε μεταβλητές μέσα σε μία συνάρτηση που χρησιμοποιεί απόκρυψη δεδομένων. Για παράδειγμα, φανταστείτε ότι θέλετε να γράψετε μία συνάρτηση count_missing() που μετράει τον αριθμό των παρατηρήσεων που λείπουν σε γραμμές. Μπορείτε να δοκιμάσετε να γράψετε κάτι σαν:\n\ncount_missing &lt;- function(df, group_vars, x_var) {\n  df |&gt; \n    group_by({{ group_vars }}) |&gt; \n    summarize(\n      n_miss = sum(is.na({{ x_var }})),\n      .groups = \"drop\"\n    )\n}\n\nflights |&gt; \n  count_missing(c(year, month, day), dep_time)\n#&gt; Error in `group_by()`:\n#&gt; ℹ In argument: `c(year, month, day)`.\n#&gt; Caused by error:\n#&gt; ! `c(year, month, day)` must be size 336776 or 1, not 1010328.\n\nΑυτό δεν λειτουργεί επειδή η group_by() χρησιμοποιεί απόκρυψη δεδομένων και όχι tidy-selection. Μπορούμε να επιλύσουμε αυτό το πρόβλημα χρησιμοποιώντας τη συνάρτηση pick(), η οποία σας επιτρέπει να χρησιμοποιείτε tidy-selection μέσα στις συναρτήσεις απόκρυψης δεδομένων:\n\ncount_missing &lt;- function(df, group_vars, x_var) {\n  df |&gt; \n    group_by(pick({{ group_vars }})) |&gt; \n    summarize(\n      n_miss = sum(is.na({{ x_var }})),\n      .groups = \"drop\"\n  )\n}\n\nflights |&gt; \n  count_missing(c(year, month, day), dep_time)\n#&gt; # A tibble: 365 × 4\n#&gt;    year month   day n_miss\n#&gt;   &lt;int&gt; &lt;int&gt; &lt;int&gt;  &lt;int&gt;\n#&gt; 1  2013     1     1      4\n#&gt; 2  2013     1     2      8\n#&gt; 3  2013     1     3     10\n#&gt; 4  2013     1     4      6\n#&gt; 5  2013     1     5      3\n#&gt; 6  2013     1     6      1\n#&gt; # ℹ 359 more rows\n\nΜία άλλη βολική χρήση της pick() είναι η δημιουργία ενός δισδιάστατου πίνακα μετρήσεων. Εδώ μετράμε χρησιμοποιώντας όλες τις μεταβλητές στις γραμμές (rows) και στις στήλες (cols) και, στη συνέχεια, χρησιμοποιούμε τη pivot_wider() για να αναδιατάξουμε τις μετρήσεις σε ένα πλέγμα:\n\n# https://twitter.com/pollicipes/status/1571606508944719876\ncount_wide &lt;- function(data, rows, cols) {\n  data |&gt; \n    count(pick(c({{ rows }}, {{ cols }}))) |&gt; \n    pivot_wider(\n      names_from = {{ cols }}, \n      values_from = n,\n      names_sort = TRUE,\n      values_fill = 0\n    )\n}\n\ndiamonds |&gt; count_wide(c(clarity, color), cut)\n#&gt; # A tibble: 56 × 7\n#&gt;   clarity color  Fair  Good `Very Good` Premium Ideal\n#&gt;   &lt;ord&gt;   &lt;ord&gt; &lt;int&gt; &lt;int&gt;       &lt;int&gt;   &lt;int&gt; &lt;int&gt;\n#&gt; 1 I1      D         4     8           5      12    13\n#&gt; 2 I1      E         9    23          22      30    18\n#&gt; 3 I1      F        35    19          13      34    42\n#&gt; 4 I1      G        53    19          16      46    16\n#&gt; 5 I1      H        52    14          12      46    38\n#&gt; 6 I1      I        34     9           8      24    17\n#&gt; # ℹ 50 more rows\n\nΕνώ τα παραδείγματά μας έχουν επικεντρωθεί ως επί το πλείστον στο πακέτο dplyr, η αξιολόγηση tidy ενισχύει επίσης το πακέτο tidyr και αν κοιτάξετε τις οδηγίες της pivot_wider(), μπορείτε να δείτε ότι το όρισμα names_from χρησιμοποιεί tidy-selection.\n\n25.3.5 Ασκήσεις\n\n\nΧρησιμοποιώντας τα σύνολα δεδομένων από το nycflights13, γράψτε μία συνάρτηση που:\n\n\nΒρίσκει όλες τις πτήσεις που ακυρώθηκαν (δηλαδή is.na(arr_time)) ή καθυστέρησαν περισσότερο από μία ώρα.\n\nflights |&gt; filter_severe()\n\n\n\nΜετρά τον αριθμό των ακυρωμένων πτήσεων και τον αριθμό των πτήσεων που καθυστέρησαν περισσότερο από μία ώρα.\n\nflights |&gt; group_by(dest) |&gt; summarize_severe()\n\n\n\nΒρίσκει όλες τις πτήσεις που ακυρώθηκαν ή καθυστέρησαν για περισσότερες από έναν αριθμό ωρών που παρείχε ο χρήστης:\n\nflights |&gt; filter_severe (hours = 2)\n\n\n\nΣυνοψίζει τον καιρό (weather) για να υπολογίσει το ελάχιστο, το μέσο και το μέγιστο μιας μεταβλητής που παρέχεται από τον χρήστη:\n\nweather |&gt; summarize_weather(temp)\n\n\n\nΜετατρέπει τη μεταβλητή που παρέχεται από τον χρήστη η οποία χρησιμοποιεί ώρες (π.χ. dep_time, arr_time, κ.λπ.) σε δεκαδικό χρόνο (δηλαδή ώρες + (λεπτά / 60)).\n\nflights |&gt; standardize_time(sched_dep_time)\n\n\n\n\nΓια καθεμία από τις παρακάτω συναρτήσεις, παραθέστε όλα τα ορίσματα που χρησιμοποιούν αξιολόγηση tidy και περιγράψτε εάν χρησιμοποιούν απόκρυψη δεδομένων ή tidy-selection: distinct(), count(), group_by(), rename_with(), slice_min(), slice_sample().\n\nΓενικεύστε την ακόλουθη συνάρτηση ώστε να μπορείτε να δώσετε οποιονδήποτε αριθμό μεταβλητών προς μέτρηση.\n\ncount_prop &lt;- function(df, var, sort = FALSE) {\n  df |&gt;\n    count({{ var }}, sort = sort) |&gt;\n    mutate(prop = n / sum(n))\n}",
    "crumbs": [
      "Προγραμματισμός",
      "<span class='chapter-number'>25</span>  <span class='chapter-title'>Συναρτήσεις</span>"
    ]
  },
  {
    "objectID": "functions.html#συναρτήσεις-διαγραμμάτων",
    "href": "functions.html#συναρτήσεις-διαγραμμάτων",
    "title": "25  Συναρτήσεις",
    "section": "\n25.4 Συναρτήσεις διαγραμμάτων",
    "text": "25.4 Συναρτήσεις διαγραμμάτων\nΑντί να επιστρέψετε ένα πλαίσιο δεδομένων, ίσως θέλετε να επιστρέψετε ένα διάγραμμα. Ευτυχώς, μπορείτε να χρησιμοποιήσετε τις ίδιες τεχνικές με το πακέτο ggplot2, επειδή η aes() είναι μία συνάρτηση απόκρυψης δεδομένων. Για παράδειγμα, φανταστείτε ότι δημιουργείτε πολλά ιστογράμματα:\n\ndiamonds |&gt; \n  ggplot(aes(x = carat)) +\n  geom_histogram(binwidth = 0.1)\n\ndiamonds |&gt; \n  ggplot(aes(x = carat)) +\n  geom_histogram(binwidth = 0.05)\n\nΔεν θα ήταν ωραίο αν μπορούσατε να τα βάλετε σε μία συνάρτηση ιστογράμματος; Είναι αρκετά εύκολο μόλις μάθετε ότι η aes() είναι μία συνάρτηση απόκρυψης δεδομένων και πρέπει να την ενθυλακώσετε:\n\nhistogram &lt;- function(df, var, binwidth = NULL) {\n  df |&gt; \n    ggplot(aes(x = {{ var }})) + \n    geom_histogram(binwidth = binwidth)\n}\n\ndiamonds |&gt; histogram(carat, 0.1)\n\n\n\n\n\n\n\nΣημειώστε ότι η histogram() επιστρέφει ένα διάγραμμα ggplot2, που σημαίνει ότι, έαν θέλετε, μπορείτε ακόμα και να προσθέσετε επιπλέον στοιχεία. Απλώς θυμηθείτε να αλλάξετε το |&gt; σε +:\n\ndiamonds |&gt; \n  histogram(carat, 0.1) +\n  labs(x = \"Size (in carats)\", y = \"Number of diamonds\")\n\n\n25.4.1 Περισσότερες μεταβλητές\nΕίναι εύκολο να προσθέσετε περισσότερες μεταβλητές. Για παράδειγμα, ίσως θέλετε έναν εύκολο τρόπο για να δείτε εύκολα με το μάτι εάν ένα σύνολο δεδομένων είναι γραμμικό ή όχι, αντιπαραθέτοντας μία ομαλοποιημένη γραμμή και μία ευθεία γραμμή:\n\n# https://twitter.com/tyler_js_smith/status/1574377116988104704\nlinearity_check &lt;- function(df, x, y) {\n  df |&gt;\n    ggplot(aes(x = {{ x }}, y = {{ y }})) +\n    geom_point() +\n    geom_smooth(method = \"loess\", formula = y ~ x, color = \"red\", se = FALSE) +\n    geom_smooth(method = \"lm\", formula = y ~ x, color = \"blue\", se = FALSE) \n}\n\nstarwars |&gt; \n  filter(mass &lt; 1000) |&gt; \n  linearity_check(mass, height)\n\n\n\n\n\n\n\nΉ ίσως θέλετε μία εναλλακτική λύση για τα έγχρωμα διαγράμματα διασποράς πάνω σε πολύ μεγάλα σύνολα δεδομένων όπου η αναπαράσταση πολλών σημείων δημιουργεί πρόβλημα:\n\n# https://twitter.com/ppaxisa/status/1574398423175921665\nhex_plot &lt;- function(df, x, y, z, bins = 20, fun = \"mean\") {\n  df |&gt; \n    ggplot(aes(x = {{ x }}, y = {{ y }}, z = {{ z }})) + \n    stat_summary_hex(\n      aes(color = after_scale(fill)), # κάντε τα όρια του διαγράμματος το ίδιο χρώμα με το γέμισμα\n      bins = bins, \n      fun = fun,\n    )\n}\n\ndiamonds |&gt; hex_plot(carat, price, depth)\n\n\n\n\n\n\n\n\n25.4.2 Συνδυασμοί με άλλα πακέτα από το tidyverse\nΜερικές από τις πιο χρήσιμες βοηθητικές συναρτήσεις συνδυάζουν τον χειρισμό δεδομένων με το πακέτο ggplot2. Για παράδειγμα, σε περίπτωση που θέλετε να κάνετε ένα γράφημα κατακόρυφων ράβδων, όπου ταξινομείτε αυτόματα τις ράβδους ανά συχνότητα χρησιμοποιώντας τη fct_infreq(). Δεδομένου ότι το γράφημα ράβδων είναι κατακόρυφο, πρέπει επίσης να αντιστρέψουμε τη συνήθη σειρά για να λάβουμε τις μεγαλύτερες τιμές στην κορυφή:\n\nsorted_bars &lt;- function(df, var) {\n  df |&gt; \n    mutate({{ var }} := fct_rev(fct_infreq({{ var }})))  |&gt;\n    ggplot(aes(y = {{ var }})) +\n    geom_bar()\n}\n\ndiamonds |&gt; sorted_bars(clarity)\n\n\n\n\n\n\n\nΠρέπει να χρησιμοποιήσουμε έναν νέο τελεστή εδώ, τον := (γνωστός ως τελεστής walrus), επειδή δημιουργούμε το όνομα της μεταβλητής με βάση τα δεδομένα που παρέχονται από τον χρήστη. Τα ονόματα των μεταβλητών εμφανίζονται στην αριστερή πλευρά του =, αλλά η σύνταξη της R δεν επιτρέπει τίποτα στα αριστερά του = εκτός από ένα μόνο κυριολεκτικό όνομα. Για να επιλύσουμε αυτό το πρόβλημα, χρησιμοποιούμε τον ειδικό τελεστή :=, τον οποίο η αξιολόγηση tidy αντιμετωπίζει ακριβώς με τον ίδιο τρόπο όπως το =.\nΉ ίσως θέλετε να διευκολύνετε τη δημιουργία ενός ραβδογράμματος μόνο για ένα υποσύνολο των δεδομένων:\n\nconditional_bars &lt;- function(df, condition, var) {\n  df |&gt; \n    filter({{ condition }}) |&gt; \n    ggplot(aes(x = {{ var }})) + \n    geom_bar()\n}\n\ndiamonds |&gt; conditional_bars(cut == \"Good\", clarity)\n\n\n\n\n\n\n\nΜπορείτε επίσης να χρησιμοποιήσετε τη φαντασία σας και να εμφανίσετε περιλήψεις δεδομένων με άλλους τρόπους. Μπορείτε να βρείτε μία ενδιαφέρουσα εφαρμογή στη διεύθυνση https://gist.github.com/GShotwell/b19ef520b6d56f61a830fabb3454965b. Χρησιμοποιεί τις ετικέτες των αξόνων για να εμφανίσει την υψηλότερη τιμή. Καθώς μαθαίνετε περισσότερα για το πακέτο ggplot2, οι ικανότητες των συναρτήσεων σας θα συνεχίσουν να αυξάνονται.\nΘα ολοκληρώσουμε με μία πιο περίπλοκη περίπτωση: την τοποθέτηση ετικετών στα διαγράμματα που δημιουργείτε.\n\n25.4.3 Προσθήκη ετικετών\nΘυμάστε τη συνάρτηση ιστογράμματος που σας δείξαμε νωρίτερα;\n\nhistogram &lt;- function(df, var, binwidth = NULL) {\n  df |&gt; \n    ggplot(aes(x = {{ var }})) + \n    geom_histogram(binwidth = binwidth)\n}\n\nΔεν θα ήταν ωραίο αν μπορούσαμε να θέσουμε με μία ετικέτα το αποτέλεσμα χρησιμοποιώντας τη μεταβλητή και το εύρος της κατηγορίας που χρησιμοποιήθηκε; Για να γίνει αυτό, θα πρέπει να ρίξουμε μία ματιά κάτω από το καπό της αξιολόγησης tidy και να χρησιμοποιήσουμε μία συνάρτηση από ένα πακέτο για το οποίο δεν έχουμε μιλήσει ακόμα, το rlang. Το rlang είναι ένα πακέτο χαμηλού επιπέδου που χρησιμοποιείται σχεδόν από κάθε άλλο πακέτο στο tidyverse επειδή εφαρμόζει αξιολόγηση tidy (καθώς και πολλά άλλα χρήσιμα εργαλεία).\nΓια να λύσουμε το πρόβλημα σχετικά με τις ετικέτες μπορούμε να χρησιμοποιήσουμε την rlang::englue(). Αυτό λειτουργεί παρόμοια με την str_glue(), επομένως οποιαδήποτε τιμή είναι τυλιγμένη με { } θα εισαχθεί στη συμβολοσειρά. Αλλά κατανοεί επίσης το { }, το οποίο εισάγει αυτόματα το κατάλληλο όνομα μεταβλητής:\n\n\nhistogram &lt;- function(df, var, binwidth) {\n  label &lt;- rlang::englue(\"A histogram of {{var}} with binwidth {binwidth}\")\n  \n  df |&gt; \n    ggplot(aes(x = {{ var }})) + \n    geom_histogram(binwidth = binwidth) + \n    labs(title = label)\n}\n\ndiamonds |&gt; histogram(carat, 0.1)\n\n\n\n\n\n\n\nΜπορείτε να χρησιμοποιήσετε την ίδια προσέγγιση σε οποιοδήποτε άλλο σημείο που θέλετε να βάλετε κάποιο κείμενο σε ένα διάγραμμα ggplot2.\n\n25.4.4 Ασκήσεις\nΔημιουργήστε μία συνάρτηση διαγράμματος εφαρμόζοντας σταδιακά τα παρακάτω βήματα:\n\nΣχεδιάστε ένα διάγραμμα διασποράς χρησιμοποιώντας ένα σύνολο δεδομένων dataset και μεταβλητών x και y.\nΠροσθέστε τη γραμμή της εξίσωσης της καλύτερης προσαρμογής (δηλαδή ένα γραμμικό μοντέλο χωρίς τα τυπικά σφάλματα).\nΠροσθέστε έναν τίτλο.",
    "crumbs": [
      "Προγραμματισμός",
      "<span class='chapter-number'>25</span>  <span class='chapter-title'>Συναρτήσεις</span>"
    ]
  },
  {
    "objectID": "functions.html#στυλ",
    "href": "functions.html#στυλ",
    "title": "25  Συναρτήσεις",
    "section": "\n25.5 Στυλ",
    "text": "25.5 Στυλ\nΗ R δεν ενδιαφέρεται για το πώς ονομάζονται η συνάρτηση ή τα ορίσματά σας, αλλά για τους ανθρώπους τα ονόματα κάνουν μεγάλη διαφορά. Ιδανικά, το όνομα της συνάρτησής σας θα είναι σύντομο, αλλά θα υπονοεί ξεκάθαρα τι κάνει η συνάρτηση. Αυτό είναι δύσκολο! Αλλά είναι καλύτερο να είμαστε σαφείς παρά σύντομοι, καθώς η αυτόματη συμπλήρωση του RStudio διευκολύνει την πληκτρολόγηση μεγάλων ονομάτων.\nΓενικά, τα ονόματα των συναρτήσεων πρέπει να είναι ρήματα και τα ορίσματα πρέπει να είναι ουσιαστικά. Υπάρχουν μερικές εξαιρέσεις: τα ουσιαστικά είναι εντάξει εάν η συνάρτηση υπολογίζει ένα πολύ γνωστό ουσιαστικό (δηλαδή η mean() είναι καλύτερο όνομα από τη compute_mean()), ή η πρόσβαση σε κάποια ιδιότητα ενός αντικειμένου (δηλαδή το coef() είναι καλύτερο όνομα από το get_coefficients()). Χρησιμοποιήστε την κρίση σας και μην φοβάστε να μετονομάσετε μία συνάρτηση εάν βρείτε ένα καλύτερο όνομα αργότερα.\n\n# Πολύ μικρό όνομα\nf()\n\n# Δεν είναι ρήμα ούτε περιγραφικό\nmy_awesome_function()\n\n# Μακρύ, αλλά ξεκάθαρο\nimpute_missing()\ncollapse_years()\n\nΗ R επίσης δεν ενδιαφέρεται για το πώς χρησιμοποιείτε το κενό στις συναρτήσεις σας, αλλά οι αναγνώστες του κώδικά σας στο μέλλον θα το κάνουν. Συνεχίστε να ακολουθείτε τους κανόνες από το Κεφάλαιο 4. Επιπλέον, η function() πρέπει πάντα να ακολουθείται από αγκύλες ({}) και τα περιεχόμενα θα πρέπει να έχουν εσοχές με δύο επιπλέον κενά. Αυτό κάνει πιο εύκολη την προβολή της ιεραρχίας του κώδικά σας, αφαιρώντας το αριστερό περιθώριο.\n\n# Λείπουν δύο επιπλέον κενά\ndensity &lt;- function(color, facets, binwidth = 0.1) {\ndiamonds |&gt; \n  ggplot(aes(x = carat, y = after_stat(density), color = {{ color }})) +\n  geom_freqpoly(binwidth = binwidth) +\n  facet_wrap(vars({{ facets }}))\n}\n\n# Το pipe έχει τοποθετηθεί λάθος\ndensity &lt;- function(color, facets, binwidth = 0.1) {\n  diamonds |&gt; \n  ggplot(aes(x = carat, y = after_stat(density), color = {{ color }})) +\n  geom_freqpoly(binwidth = binwidth) +\n  facet_wrap(vars({{ facets }}))\n}\n\nΌπως μπορείτε να δείτε, συνιστούμε να τοποθετήσετε επιπλέον κενά μέσα στο { }. Αυτό κάνει αρκετά προφανές ότι κάτι ασυνήθιστο συμβαίνει.\n\n25.5.1 Ασκήσεις\n\n\nΔιαβάστε τον πηγαίο κώδικα για καθεμία από τις ακόλουθες δύο συναρτήσεις, βρείτε τι κάνουν και, στη συνέχεια, σκεφτείτε καλύτερα ονόματα.\n\nf1 &lt;- function(string, prefix) {\n  str_sub(string, 1, str_length(prefix)) == prefix\n}\n\nf3 &lt;- function(x, y) {\n  rep(y, length.out = length(x))\n}\n\n\nΠάρτε μία συνάρτηση που έχετε γράψει πρόσφατα και αφιερώστε 5 λεπτά στο να σκεφτείτε ένα καλύτερο όνομα για αυτήν και τα ορίσματά της.\nΥποστηρίξτε γιατί τα ονόματα norm_r(), norm_d() κ.λπ. θα ήταν καλύτερα από τα rnorm(), dnorm(). Υποστηρίξτε το αντίθετο. Πώς θα μπορούσατε να κάνετε τα ονόματα ακόμα πιο ξεκάθαρα;",
    "crumbs": [
      "Προγραμματισμός",
      "<span class='chapter-number'>25</span>  <span class='chapter-title'>Συναρτήσεις</span>"
    ]
  },
  {
    "objectID": "functions.html#σύνοψη",
    "href": "functions.html#σύνοψη",
    "title": "25  Συναρτήσεις",
    "section": "\n25.6 Σύνοψη",
    "text": "25.6 Σύνοψη\nΣε αυτό το κεφάλαιο, μάθατε πώς να γράφετε συναρτήσεις για τρία χρήσιμα σενάρια: δημιουργία ενός διανύσματος, δημιουργία ενός πλαισίου δεδομένων ή δημιουργία ενός διαγράμματος. Στην πορεία είδατε πολλά παραδείγματα, τα οποία ελπίζουμε ότι άρχισαν να σας εμπνέουν και να σας έδωσαν μερικές ιδέες για το πού οι συναρτήσεις θα μπορούσαν να βοηθήσουν στον κώδικα της ανάλυσής σας.\nΣας δείξαμε μόνο τη βάση για να ξεκινήσετε με τις συναρτήσεις αλλά υπάρχουν πολλά περισσότερα να μάθετε. Μερικά μέρη για να μάθετε περισσότερα:\n\nΓια να μάθετε περισσότερα σχετικά με τον προγραμματισμό με αξιολόγηση tidy, δείτε χρήσιμα παραδείγματα και στο programming with dplyr και programming with tidyr ενώ περισσότερα για τα θεωρητικά στοιχειά δείτε το What is data-masking and why do I need {{?.\nΓια να μάθετε περισσότερα σχετικά με τη μείωση του διπλασιασμού στον κώδικα ggplot2, διαβάστε το κεφάλαιο Programming with ggplot2 του βιβλίου ggplot2.\nΓια περισσότερες συμβουλές σχετικά με τη συνάρτηση style, ανατρέξτε στο tidyverse style guide.\n\nΣτο επόμενο κεφάλαιο, θα ασχοληθούμε με την επανάληψη, η οποία σας παρέχει περαιτέρω εργαλεία για να μειώσετε τη διπλοτυπία στον κώδικά σας.",
    "crumbs": [
      "Προγραμματισμός",
      "<span class='chapter-number'>25</span>  <span class='chapter-title'>Συναρτήσεις</span>"
    ]
  },
  {
    "objectID": "iteration.html",
    "href": "iteration.html",
    "title": "26  Επανάληψη",
    "section": "",
    "text": "26.1 Εισαγωγή\nΣε αυτό το κεφάλαιο, θα μάθετε εργαλεία σχετικά με την επανάληψη, εκτελώντας επανειλημμένα την ίδια ενέργεια σε διαφορετικά αντικείμενα. Γενικά, η επανάληψη στην R φαίνεται διαφορετική από άλλες γλώσσες προγραμματισμού, επειδή μεγάλο μέρος της εκτελείται έμμεσα οπότε, κάθε φορά το έχουμε έτοιμο. Για παράδειγμα, εάν θέλετε να διπλασιάσετε ένα αριθμητικό διάνυσμα x στην R, μπορείτε απλώς να γράψετε 2 * x. Στην πλειοψηφία των άλλων γλωσσών, θα χρειαστεί να γράψετε και το κομμάτι του κώδικα για να διπλασιάσετε κάθε στοιχείο του x χρησιμοποιώντας κάποιου είδους βρόγχο for.\nΤο βιβλίο αυτό σας έχει ήδη δώσει έναν μικρό αλλά ισχυρό αριθμό εργαλείων που εκτελούν την ίδια ενέργεια για πολλά “πράγματα”:\nΤώρα, ήρθε η ώρα να μάθετε μερικά πιο γενικά εργαλεία που συχνά ονομάζονται εργαλεία συναρτησιακού προγραμματισμού επειδή είναι χτισμένα γύρω από συναρτήσεις που λαμβάνουν ως είσοδο άλλες συναρτήσεις. Η εκμάθηση συναρτησιακού προγραμματισμού μπορεί εύκολα να εκτραπεί σε γενικές και ασαφής έννοιες, αλλά σε αυτό το κεφάλαιο θα διατηρήσουμε μία συγκεκριμένη κατεύθυνση εστιάζοντας σε τρεις κοινές εργασίες: τροποποίηση πολλαπλών στηλών, ανάγνωση πολλαπλών αρχείων και αποθήκευση πολλαπλών αντικειμένων.",
    "crumbs": [
      "Προγραμματισμός",
      "<span class='chapter-number'>26</span>  <span class='chapter-title'>Επανάληψη</span>"
    ]
  },
  {
    "objectID": "iteration.html#εισαγωγή",
    "href": "iteration.html#εισαγωγή",
    "title": "26  Επανάληψη",
    "section": "",
    "text": "Την facet_wrap() και την facet_grid() που σχεδιάζουν ένα διάγραμμα για κάθε υποσύνολο.\nΤην group_by() μαζί με την summarize() που υπολογίζουν συνοπτικά στατιστικά στοιχεία για κάθε υποσύνολο.\nΤην unnest_wider() και την unnest_longer() που δημιουργούν νέες γραμμές και στήλες για κάθε στοιχείο μιας στήλης ή λίστας.\n\n\n\n26.1.1 Προαπαιτούμενα\nΣε αυτό το κεφάλαιο, θα επικεντρωθούμε στα εργαλεία που παρέχονται από το πακέτο dplyr και το πακέτο purrr, δύο βασικά μέλη του tidyverse. Έχετε δει το πακέτο dplyr στο παρελθόν, αλλά όχι το purrr. Θα χρησιμοποιήσουμε απλώς μερικές συναρτήσεις του purrr σε αυτό το κεφάλαιο, αλλά γενικά είναι ένα εξαιρετικό πακέτο για να εξερευνήσετε καθώς βελτιώνετε τις προγραμματιστικές σας ικανότητες.\n\nlibrary(tidyverse)",
    "crumbs": [
      "Προγραμματισμός",
      "<span class='chapter-number'>26</span>  <span class='chapter-title'>Επανάληψη</span>"
    ]
  },
  {
    "objectID": "iteration.html#sec-across",
    "href": "iteration.html#sec-across",
    "title": "26  Επανάληψη",
    "section": "\n26.2 Τροποποίηση πολλαπλών στηλών",
    "text": "26.2 Τροποποίηση πολλαπλών στηλών\nΦανταστείτε ότι έχετε αυτό το απλό tibble και θέλετε να μετρήσετε τον αριθμό των παρατηρήσεων και να υπολογίσετε τη διάμεσο κάθε στήλης.\n\ndf &lt;- tibble(\n  a = rnorm(10),\n  b = rnorm(10),\n  c = rnorm(10),\n  d = rnorm(10)\n)\n\nΘα μπορούσατε να το κάνετε με αντιγραφή-επικόλληση:\n\ndf |&gt; summarize(\n  n = n(),\n  a = median(a),\n  b = median(b),\n  c = median(c),\n  d = median(d),\n)\n#&gt; # A tibble: 1 × 5\n#&gt;       n      a      b       c     d\n#&gt;   &lt;int&gt;  &lt;dbl&gt;  &lt;dbl&gt;   &lt;dbl&gt; &lt;dbl&gt;\n#&gt; 1    10 -0.246 -0.287 -0.0567 0.144\n\nΑυτό παραβιάζει τον εμπειρικό μας κανόνα που λέει να μην εφαρμόζεται αντιγραφή και επικόλληση περισσότερες από δύο φορές. Μπορείτε, ακόμα, να φανταστείτε ότι αυτό γίνεται πολύ κουραστικό αν έχετε δεκάδες ή και εκατοντάδες στήλες. Αντίθετα, μπορείτε να χρησιμοποιήσετε την across():\n\ndf |&gt; summarize(\n  n = n(),\n  across(a:d, median),\n)\n#&gt; # A tibble: 1 × 5\n#&gt;       n      a      b       c     d\n#&gt;   &lt;int&gt;  &lt;dbl&gt;  &lt;dbl&gt;   &lt;dbl&gt; &lt;dbl&gt;\n#&gt; 1    10 -0.246 -0.287 -0.0567 0.144\n\nΗ across() έχει τρία ιδιαίτερα σημαντικά ορίσματα τα οποία θα συζητήσουμε λεπτομερώς στις επόμενες ενότητες. Θα χρησιμοποιείτε τα δύο πρώτα κάθε φορά που χρησιμοποιείτε την across(): το πρώτο όρισμα, .cols, καθορίζει ποιες στήλες θέλετε να επαναλάβετε και το δεύτερο όρισμα, .fns, καθορίζει το τι θα εφαρμόσετε σε κάθε στήλη. Μπορείτε να χρησιμοποιήσετε το όρισμα .names όταν χρειάζεστε έναν επιπλέον έλεγχο στα ονόματα των στηλών εξόδου, κάτι που είναι ιδιαίτερα σημαντικό όταν χρησιμοποιείτε την across() με την mutate(). Θα συζητήσουμε επίσης δύο σημαντικές παραλλαγές, τις if_any() και if_all(), οι οποίες λειτουργούν μέσα στη filter().\n\n26.2.1 Επιλογή στηλών με .cols\n\nΤο πρώτο όρισμα στην across(), το .cols, επιλέγει τις στήλες προς επεξεργασία. Χρησιμοποιεί τις ίδιες προδιαγραφές με την select(), Ενότητα 3.3.2, ώστε να μπορείτε να χρησιμοποιήσετε συναρτήσεις όπως την starts_with() και την ends_with() για να επιλέξετε στήλες με βάση το όνομά τους.\nΥπάρχουν δύο πρόσθετες τεχνικές επιλογής που είναι ιδιαίτερα χρήσιμες για την across(): οι everything() και where(). Η everything() είναι απλή: επιλέγει κάθε στήλη (που δεν χρησιμοποιείται για ομαδοποίηση):\n\ndf &lt;- tibble(\n  grp = sample(2, 10, replace = TRUE),\n  a = rnorm(10),\n  b = rnorm(10),\n  c = rnorm(10),\n  d = rnorm(10)\n)\n\ndf |&gt; \n  group_by(grp) |&gt; \n  summarize(across(everything(), median))\n#&gt; # A tibble: 2 × 5\n#&gt;     grp       a       b     c     d\n#&gt;   &lt;int&gt;   &lt;dbl&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n#&gt; 1     1 -0.0935 -0.0163 0.363 0.364\n#&gt; 2     2  0.312  -0.0576 0.208 0.565\n\nΠαρατηρήστε ότι οι στήλες που χρησιμοποιούνται για ομαδοποίηση (εδώ, η grp) δεν περιλαμβάνονται στην across() επειδή διατηρούνται αυτόματα από την summarize().\nΗ where() σας επιτρέπει να επιλέξετε στήλες με βάση τον τύπο τους:\n\nΗ where(is.numeric) επιλέγει όλες τις αριθμητικές στήλες.\nΗ where(is.character) επιλέγει όλες τις στήλες συμβολοσειρών.\nΗ where(is.Date) επιλέγει όλες τις στήλες ημερομηνίας.\nΗ where(is.POSIXct) επιλέγει όλες τις στήλες ημερομηνίας-ώρας.\nΗ where(is.logical) επιλέγει όλες τις λογικές στήλες.\n\nΌπως και σε άλλες συναρτήσεις επιλογής στηλών, μπορείτε να συνδυάσετε τα παραπάνω με άλγεβρα Boole. Για παράδειγμα, η !where(is.numeric) επιλέγει όλες τις μη αριθμητικές στήλες και ο συνδυασμός starts_with(\"a\") & where(is.logical) επιλέγει όλες τις λογικές στήλες των οποίων το όνομα αρχίζει με “a”.\n\n26.2.2 Κλήση μιας μεμονωμένης συνάρτησης\nΤο δεύτερο όρισμα της across() ορίζει πώς θα μετασχηματιστεί κάθε στήλη. Σε απλές περιπτώσεις, όπως παραπάνω, το όρισμα θα είναι μία υπάρχουσα συνάρτηση. Αυτό αποκαλύπτει ένα ιδιαίτερο χαρακτηριστικό της R: μπορούμε να τοποθετήσουμε μία συνάρτηση (median, mean, str_flatten, …) μέσα σε μία άλλη συνάρτηση (across). Λειτουργίες σαν και αυτή καθιστούν την R μια συναρτησιακή γλώσσα προγραμματισμού.\nΕίναι σημαντικό να σημειωθεί ότι τοποθετούμε τη συνάρτηση ως όρισμα στην across(), έτσι ώστε η across() να μπορεί να την καλέσει. Δεν την καλούμε εμείς. Αυτό σημαίνει ότι το όνομα της συνάρτησης δεν πρέπει ποτέ να ακολουθείται από (). Εάν ξεχαστείτε, θα λάβετε ένα σφάλμα:\n\ndf |&gt; \n  group_by(grp) |&gt; \n  summarize(across(everything(), median()))\n#&gt; Error in `summarize()`:\n#&gt; ℹ In argument: `across(everything(), median())`.\n#&gt; Caused by error in `median.default()`:\n#&gt; ! argument \"x\" is missing, with no default\n\nΑυτό το σφάλμα προκύπτει επειδή καλείτε τη συνάρτηση χωρίς κάποιο όρισμα ως είσοδο, π.χ.\n\nmedian()\n#&gt; Error in median.default(): argument \"x\" is missing, with no default\n\n\n26.2.3 Κλήση πολλαπλών συναρτήσεων\nΣε πιο περίπλοκες περιπτώσεις, μπορεί να θέλετε να προσθέσετε ορίσματα ή να εφαρμόσετε πολλαπλούς μετασχηματισμούς. Ας εξηγήσουμε το παρασκήνιο αυτού του προβλήματος με ένα απλό παράδειγμα: τι θα συμβεί εάν λείπουν κάποιες τιμές στα δεδομένα μας; Η median() επηρεάζεται από τις κενές τιμές, δίνοντάς μας ένα όχι και τόσο καλό αποτέλεσμα:\n\nrnorm_na &lt;- function(n, n_na, mean = 0, sd = 1) {\n  sample(c(rnorm(n - n_na, mean = mean, sd = sd), rep(NA, n_na)))\n}\n\ndf_miss &lt;- tibble(\n  a = rnorm_na(5, 1),\n  b = rnorm_na(5, 1),\n  c = rnorm_na(5, 2),\n  d = rnorm(5)\n)\ndf_miss |&gt; \n  summarize(\n    across(a:d, median),\n    n = n()\n  )\n#&gt; # A tibble: 1 × 5\n#&gt;       a     b     c     d     n\n#&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt;\n#&gt; 1    NA    NA    NA  1.15     5\n\nΘα ήταν ωραίο εάν μπορούσαμε να προσθέσουμε το όρισμα na.rm = TRUE στη median() για να αφαιρέσουμε τις κενές τιμές. Για να το κάνουμε, αντί να καλέσουμε απευθείας τη median(), πρέπει να δημιουργήσουμε μία νέα συνάρτηση που καλεί τη median() με τα ορίσματα που θέλουμε:\n\ndf_miss |&gt; \n  summarize(\n    across(a:d, function(x) median(x, na.rm = TRUE)),\n    n = n()\n  )\n#&gt; # A tibble: 1 × 5\n#&gt;       a     b      c     d     n\n#&gt;   &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt;\n#&gt; 1 0.139 -1.11 -0.387  1.15     5\n\nΟ νέος τρόπος παραπάνω είναι κάπως μακροσκελής και για αυτό η R περιέχει μία εύχρηστη συντόμευση: σε περιπτώσεις κώδικα με εικονικές, ή ανώνυμες συναρτήσεις1, μπορείτε να αντικαταστήσετε το κομμάτι function με το \\2:\n\ndf_miss |&gt; \n  summarize(\n    across(a:d, \\(x) median(x, na.rm = TRUE)),\n    n = n()\n  )\n\nΣε κάθε περίπτωση, η across() αναπτύσσεται αποτελεσματικά στον ακόλουθο κώδικα:\n\ndf_miss |&gt; \n  summarize(\n    a = median(a, na.rm = TRUE),\n    b = median(b, na.rm = TRUE),\n    c = median(c, na.rm = TRUE),\n    d = median(d, na.rm = TRUE),\n    n = n()\n  )\n\nΌταν αφαιρούμε τις κενές τιμές από τη median(), θα ήταν ωραίο να γνωρίζουμε και πόσες τιμές αφαιρέθηκαν. Μπορούμε να το ανακαλύψουμε παρέχοντας δύο συναρτήσεις στην across(): μία για τον υπολογισμό της διάμεσης τιμής και άλλη μία για την καταμέτρηση των κενών τιμών. H παροχή πολλαπλών συναρτήσεων γίνεται χρησιμοποιώντας μία λίστα με ονόματα στα στοιχεία της στο όρισμα .fns:\n\ndf_miss |&gt; \n  summarize(\n    across(a:d, list(\n      median = \\(x) median(x, na.rm = TRUE),\n      n_miss = \\(x) sum(is.na(x))\n    )),\n    n = n()\n  )\n#&gt; # A tibble: 1 × 9\n#&gt;   a_median a_n_miss b_median b_n_miss c_median c_n_miss d_median d_n_miss\n#&gt;      &lt;dbl&gt;    &lt;int&gt;    &lt;dbl&gt;    &lt;int&gt;    &lt;dbl&gt;    &lt;int&gt;    &lt;dbl&gt;    &lt;int&gt;\n#&gt; 1    0.139        1    -1.11        1   -0.387        2     1.15        0\n#&gt; # ℹ 1 more variable: n &lt;int&gt;\n\nΑν παρατηρήσετε προσεκτικά, ίσως καταλάβετε ότι οι στήλες ονομάζονται χρησιμοποιώντας μία προδιαγραφή ένωσης (Ενότητα 14.3.2) όπως η {.col}_{.fn}. Όπου .col είναι το όνομα της αρχικής στήλης και . fn είναι το όνομα της συνάρτησης. Δεν είναι τυχαίο! Όπως θα μάθετε στην επόμενη ενότητα, μπορείτε να χρησιμοποιήσετε το όρισμα .names για να παρέχετε μία ένωση με βάση τις δικές σας προδιαγραφές.\n\n26.2.4 Ονόματα στηλών\nΤο αποτέλεσμα της across() ονομάζεται σύμφωνα με τις προδιαγραφές που παρέχονται στο όρισμα .names. Θα μπορούσαμε να καθορίσουμε το δικό μας, αν θέλαμε το όνομα της συνάρτησης να εμφανίζεται πρώτο3:\n\ndf_miss |&gt; \n  summarize(\n    across(\n      a:d,\n      list(\n        median = \\(x) median(x, na.rm = TRUE),\n        n_miss = \\(x) sum(is.na(x))\n      ),\n      .names = \"{.fn}_{.col}\"\n    ),\n    n = n(),\n  )\n#&gt; # A tibble: 1 × 9\n#&gt;   median_a n_miss_a median_b n_miss_b median_c n_miss_c median_d n_miss_d\n#&gt;      &lt;dbl&gt;    &lt;int&gt;    &lt;dbl&gt;    &lt;int&gt;    &lt;dbl&gt;    &lt;int&gt;    &lt;dbl&gt;    &lt;int&gt;\n#&gt; 1    0.139        1    -1.11        1   -0.387        2     1.15        0\n#&gt; # ℹ 1 more variable: n &lt;int&gt;\n\nΤο όρισμα .names είναι ιδιαίτερα σημαντικό όταν χρησιμοποιείτε την across() με την mutate(). Από προεπιλογή, η έξοδος της across() έχει τα ίδια ονόματα με τις εισόδους. Αυτό σημαίνει ότι η across() μέσα στη mutate() θα αντικαταστήσει τις υπάρχουσες στήλες. Για παράδειγμα, εδώ χρησιμοποιούμε την coalesce() για να αντικαταστήσουμε τα NA με 0:\n\ndf_miss |&gt; \n  mutate(\n    across(a:d, \\(x) coalesce(x, 0))\n  )\n#&gt; # A tibble: 5 × 4\n#&gt;        a      b      c     d\n#&gt;    &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt;\n#&gt; 1  0.434 -1.25   0     1.60 \n#&gt; 2  0     -1.43  -0.297 0.776\n#&gt; 3 -0.156 -0.980  0     1.15 \n#&gt; 4 -2.61  -0.683 -0.785 2.13 \n#&gt; 5  1.11   0     -0.387 0.704\n\nΣε περίπτωση που θέλετε να δημιουργήσετε νέες στήλες, μπορείτε να χρησιμοποιήσετε το όρισμα .names για να δώσετε στην έξοδο νέα ονόματα:\n\ndf_miss |&gt; \n  mutate(\n    across(a:d, \\(x) coalesce(x, 0), .names = \"{.col}_na_zero\")\n  )\n#&gt; # A tibble: 5 × 8\n#&gt;        a      b      c     d a_na_zero b_na_zero c_na_zero d_na_zero\n#&gt;    &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;\n#&gt; 1  0.434 -1.25  NA     1.60      0.434    -1.25      0         1.60 \n#&gt; 2 NA     -1.43  -0.297 0.776     0        -1.43     -0.297     0.776\n#&gt; 3 -0.156 -0.980 NA     1.15     -0.156    -0.980     0         1.15 \n#&gt; 4 -2.61  -0.683 -0.785 2.13     -2.61     -0.683    -0.785     2.13 \n#&gt; 5  1.11  NA     -0.387 0.704     1.11      0        -0.387     0.704\n\n\n26.2.5 Φιλτράρισμα\nΗ across() ταιριάζει αρκετά μέσα στην summarize() και στην mutate(). Η χρήση της όμως με την filter() είναι πιο άβολη, επειδή συνήθως πρέπει να συνδυάσετε πολλαπλές συνθήκες με τους τελεστές | και &. Είναι σαφές ότι η across() μπορεί να βοηθήσει στη δημιουργία πολλαπλών στηλών λογικού τύπου, αλλά μετά τι; Για αυτό, το πακέτο dplyr προσφέρει δύο παραλλαγές της across() που ονομάζονται if_any() και if_all():\n\n# ίδιο με το df_miss |&gt; filter(is.na(a) | is.na(b) | is.na(c) | is.na(d))\ndf_miss |&gt; filter(if_any(a:d, is.na))\n#&gt; # A tibble: 4 × 4\n#&gt;        a      b      c     d\n#&gt;    &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt;\n#&gt; 1  0.434 -1.25  NA     1.60 \n#&gt; 2 NA     -1.43  -0.297 0.776\n#&gt; 3 -0.156 -0.980 NA     1.15 \n#&gt; 4  1.11  NA     -0.387 0.704\n\n# ίδιο με το df_miss |&gt; filter(is.na(a) & is.na(b) & is.na(c) & is.na(d))\ndf_miss |&gt; filter(if_all(a:d, is.na))\n#&gt; # A tibble: 0 × 4\n#&gt; # ℹ 4 variables: a &lt;dbl&gt;, b &lt;dbl&gt;, c &lt;dbl&gt;, d &lt;dbl&gt;\n\n\n26.2.6 Η across() σε συναρτήσεις\nΗ across() είναι ιδιαίτερα χρήσιμη γιατί σας επιτρέπει να λειτουργείτε σε πολλαπλές στήλες. Για παράδειγμα, ο Jacob Scott χρησιμοποιεί τη μικρή βοηθητική συνάρτηση η οποία περιλαμβάνει μία ομάδα συναρτήσεων του πακέτου lubridate για να επεκτείνει όλες τις στήλες ημερομηνίας σε ξεχωριστές στήλες έτους, μήνα και ημέρας:\n\nexpand_dates &lt;- function(df) {\n  df |&gt; \n    mutate(\n      across(where(is.Date), list(year = year, month = month, day = mday))\n    )\n}\n\ndf_date &lt;- tibble(\n  name = c(\"Amy\", \"Bob\"),\n  date = ymd(c(\"2009-08-03\", \"2010-01-16\"))\n)\n\ndf_date |&gt; \n  expand_dates()\n#&gt; # A tibble: 2 × 5\n#&gt;   name  date       date_year date_month date_day\n#&gt;   &lt;chr&gt; &lt;date&gt;         &lt;dbl&gt;      &lt;dbl&gt;    &lt;int&gt;\n#&gt; 1 Amy   2009-08-03      2009          8        3\n#&gt; 2 Bob   2010-01-16      2010          1       16\n\nΗ across() διευκολύνει επίσης την παροχή πολλών στηλών σε ένα μόνο όρισμα επειδή το πρώτο όρισμα χρησιμοποιεί tidy-select. Απλά πρέπει να θυμάστε να ενθυλακώσετε αυτό το όρισμα, όπως συζητήσαμε στην Ενότητα 25.3.2. Για παράδειγμα, αυτή η συνάρτηση θα υπολογίσει τους μέσους όρους των αριθμητικών στηλών από προεπιλογή. Ωστόσο, παρέχοντας το δεύτερο όρισμα, μπορείτε να επιλέξετε να συνοψίσετε μόνο στήλες που θα επιλέξετε:\n\nsummarize_means &lt;- function(df, summary_vars = where(is.numeric)) {\n  df |&gt; \n    summarize(\n      across({{ summary_vars }}, \\(x) mean(x, na.rm = TRUE)),\n      n = n(),\n      .groups = \"drop\"\n    )\n}\ndiamonds |&gt; \n  group_by(cut) |&gt; \n  summarize_means()\n#&gt; # A tibble: 5 × 9\n#&gt;   cut       carat depth table price     x     y     z     n\n#&gt;   &lt;ord&gt;     &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt;\n#&gt; 1 Fair      1.05   64.0  59.1 4359.  6.25  6.18  3.98  1610\n#&gt; 2 Good      0.849  62.4  58.7 3929.  5.84  5.85  3.64  4906\n#&gt; 3 Very Good 0.806  61.8  58.0 3982.  5.74  5.77  3.56 12082\n#&gt; 4 Premium   0.892  61.3  58.7 4584.  5.97  5.94  3.65 13791\n#&gt; 5 Ideal     0.703  61.7  56.0 3458.  5.51  5.52  3.40 21551\n\ndiamonds |&gt; \n  group_by(cut) |&gt; \n  summarize_means(c(carat, x:z))\n#&gt; # A tibble: 5 × 6\n#&gt;   cut       carat     x     y     z     n\n#&gt;   &lt;ord&gt;     &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt;\n#&gt; 1 Fair      1.05   6.25  6.18  3.98  1610\n#&gt; 2 Good      0.849  5.84  5.85  3.64  4906\n#&gt; 3 Very Good 0.806  5.74  5.77  3.56 12082\n#&gt; 4 Premium   0.892  5.97  5.94  3.65 13791\n#&gt; 5 Ideal     0.703  5.51  5.52  3.40 21551\n\n\n26.2.7 Περί pivot_longer()\n\nΠριν συνεχίσουμε, αξίζει να επισημάνουμε μία ενδιαφέρουσα σύνδεση μεταξύ της across() και της pivot_longer() (Ενότητα 5.3). Σε πολλές περιπτώσεις, εκτελείτε τους ίδιους υπολογισμούς συγκεντρώνοντας πρώτα τα δεδομένα και στη συνέχεια εκτελώντας τους υπολογισμούς ανά ομάδα και όχι ανά στήλη. Για παράδειγμα, δείτε αυτήν τη σύνοψη ως αποτέλεσμα πολλαπλών συναρτήσεων:\n\ndf |&gt; \n  summarize(across(a:d, list(median = median, mean = mean)))\n#&gt; # A tibble: 1 × 8\n#&gt;   a_median a_mean b_median b_mean c_median c_mean d_median d_mean\n#&gt;      &lt;dbl&gt;  &lt;dbl&gt;    &lt;dbl&gt;  &lt;dbl&gt;    &lt;dbl&gt;  &lt;dbl&gt;    &lt;dbl&gt;  &lt;dbl&gt;\n#&gt; 1   0.0380  0.205  -0.0163 0.0910    0.260 0.0716    0.540  0.508\n\nΘα μπορούσαμε να υπολογίσουμε τις ίδιες τιμές συγκεντρώνοντας τα δεδομένα σε ύψος (pivot longer) και στη συνέχεια να συνοψίσουμε:\n\nlong &lt;- df |&gt; \n  pivot_longer(a:d) |&gt; \n  group_by(name) |&gt; \n  summarize(\n    median = median(value),\n    mean = mean(value)\n  )\nlong\n#&gt; # A tibble: 4 × 3\n#&gt;   name   median   mean\n#&gt;   &lt;chr&gt;   &lt;dbl&gt;  &lt;dbl&gt;\n#&gt; 1 a      0.0380 0.205 \n#&gt; 2 b     -0.0163 0.0910\n#&gt; 3 c      0.260  0.0716\n#&gt; 4 d      0.540  0.508\n\nΚαι αν θέλατε την ίδια δομή με την across(), θα μπορούσατε να συγκεντρώσετε ξανά σε πλάτος:\n\nlong |&gt; \n  pivot_wider(\n    names_from = name,\n    values_from = c(median, mean),\n    names_vary = \"slowest\",\n    names_glue = \"{name}_{.value}\"\n  )\n#&gt; # A tibble: 1 × 8\n#&gt;   a_median a_mean b_median b_mean c_median c_mean d_median d_mean\n#&gt;      &lt;dbl&gt;  &lt;dbl&gt;    &lt;dbl&gt;  &lt;dbl&gt;    &lt;dbl&gt;  &lt;dbl&gt;    &lt;dbl&gt;  &lt;dbl&gt;\n#&gt; 1   0.0380  0.205  -0.0163 0.0910    0.260 0.0716    0.540  0.508\n\nΕίναι καλό να γνωρίζετε την παραπάνω τεχνική καθώς μερικές φορές μπορεί να αντιμετωπίσετε ένα πρόβλημα το οποίο δεν μπορεί, για την ώρα, να λυθεί χρησιμοποιώντας την across(): όταν έχετε ομάδες στηλών τις οποίες θέλετε να χρησιμοποιήσετε ταυτόχρονα σε υπολογισμούς. Για παράδειγμα, φανταστείτε ότι το πλαίσιο δεδομένων μας περιέχει και τιμές και βάρη και θέλουμε να υπολογίσουμε έναν σταθμισμένο μέσο όρο:\n\ndf_paired &lt;- tibble(\n  a_val = rnorm(10),\n  a_wts = runif(10),\n  b_val = rnorm(10),\n  b_wts = runif(10),\n  c_val = rnorm(10),\n  c_wts = runif(10),\n  d_val = rnorm(10),\n  d_wts = runif(10)\n)\n\nΔεν υπάρχει τρόπος, προς το παρόν, αυτό να γίνει με την across()4, είναι όμως σχετικά απλό με την pivot_longer():\n\ndf_long &lt;- df_paired |&gt; \n  pivot_longer(\n    everything(), \n    names_to = c(\"group\", \".value\"), \n    names_sep = \"_\"\n  )\ndf_long\n#&gt; # A tibble: 40 × 3\n#&gt;   group    val   wts\n#&gt;   &lt;chr&gt;  &lt;dbl&gt; &lt;dbl&gt;\n#&gt; 1 a      0.715 0.518\n#&gt; 2 b     -0.709 0.691\n#&gt; 3 c      0.718 0.216\n#&gt; 4 d     -0.217 0.733\n#&gt; 5 a     -1.09  0.979\n#&gt; 6 b     -0.209 0.675\n#&gt; # ℹ 34 more rows\n\ndf_long |&gt; \n  group_by(group) |&gt; \n  summarize(mean = weighted.mean(val, wts))\n#&gt; # A tibble: 4 × 2\n#&gt;   group    mean\n#&gt;   &lt;chr&gt;   &lt;dbl&gt;\n#&gt; 1 a      0.126 \n#&gt; 2 b     -0.0704\n#&gt; 3 c     -0.360 \n#&gt; 4 d     -0.248\n\nΕάν χρειαστεί, μπορείτε να χρησιμοποιήσετε την pivot_wider() για να επιστρέψετε στην αρχική μορφή των δεδομένων.\n\n26.2.8 Ασκήσεις\n\n\nΕξασκήστε τις δεξιότητές σας στην across():\n\nΥπολογίζοντας του αριθμού των μοναδικών τιμών σε κάθε στήλη του συνόλου δεδομένων palmerpenguins::penguins.\nΥπολογίζοντας τον μέσο όρο κάθε στήλης στο σύνολο δεδομένων mtcars.\nΟμαδοποιώντας, στο σύνολο δεδομένων diamonds, ανά cut, clarity, και color και στη συνέχεια μετρώντας τον αριθμό των παρατηρήσεων και υπολογίζοντας τον μέσο όρο κάθε αριθμητικής στήλης.\n\n\nΤι συμβαίνει εάν χρησιμοποιήσετε μία λίστα συναρτήσεων στην across(), αλλά δεν τις ονομάσετε; Τι όνομα εμφανίζεται στην έξοδο;\nΠροσαρμόστε την expand_dates() για να αφαιρέσετε αυτόματα τις στήλες ημερομηνίας μετά την επέκτασή τους. Χρειάζεται να ενθυλακώσετε κάποια επιχειρήματα;\n\nΕξηγήστε τι κάνει κάθε βήμα σε αυτή τη συνάρτηση. Ποιο ιδιαίτερο χαρακτηριστικό της where() εκμεταλλευόμαστε εδώ;\n\nshow_missing &lt;- function(df, group_vars, summary_vars = everything()) {\n  df |&gt; \n    group_by(pick({{ group_vars }})) |&gt; \n    summarize(\n      across({{ summary_vars }}, \\(x) sum(is.na(x))),\n      .groups = \"drop\"\n    ) |&gt;\n    select(where(\\(x) any(x &gt; 0)))\n}\nnycflights13::flights |&gt; show_missing(c(year, month, day))",
    "crumbs": [
      "Προγραμματισμός",
      "<span class='chapter-number'>26</span>  <span class='chapter-title'>Επανάληψη</span>"
    ]
  },
  {
    "objectID": "iteration.html#ανάγνωση-πολλαπλών-αρχείων",
    "href": "iteration.html#ανάγνωση-πολλαπλών-αρχείων",
    "title": "26  Επανάληψη",
    "section": "\n26.3 Ανάγνωση πολλαπλών αρχείων",
    "text": "26.3 Ανάγνωση πολλαπλών αρχείων\nΣτην προηγούμενη ενότητα μάθατε πώς να χρησιμοποιείτε την dplyr::across() για να επαναλάβετε έναν μετασχηματισμό σε πολλαπλές στήλες. Σε αυτήν την ενότητα θα μάθετε πώς να χρησιμοποιείτε την purrr::map() για να εφαρμόσετε οτιδήποτε σε κάθε αρχείο ενός καταλόγου. Ας ξεκινήσουμε με ένα παράδειγμα: φανταστείτε ότι έχετε έναν φάκελο γεμάτο αρχεία excel5 που θέλετε να διαβάσετε. Μπορείτε να το κάνετε με αντιγραφή και επικόλληση για κάθε ένα αρχείο:\n\ndata2019 &lt;- readxl::read_excel(\"data/y2019.xlsx\")\ndata2020 &lt;- readxl::read_excel(\"data/y2020.xlsx\")\ndata2021 &lt;- readxl::read_excel(\"data/y2021.xlsx\")\ndata2022 &lt;- readxl::read_excel(\"data/y2022.xlsx\")\n\nΚαι μετά να χρησιμοποιήσετε την dplyr::bind_rows() για να τα συνδυάσετε όλα μαζί:\n\ndata &lt;- bind_rows(data2019, data2020, data2021, data2022)\n\nΜπορείτε να φανταστείτε ότι αυτό θα γινόταν κουραστικό αρκετά γρήγορα, ειδικά αν είχατε εκατοντάδες αρχεία, όχι μόνο τέσσερα. Οι επόμενες ενότητες σας δείχνουν πώς να αυτοματοποιήσετε αυτού του είδους την εργασία. Υπάρχουν τρία βασικά βήματα: χρησιμοποιήστε την list.files() για να απαριθμήσετε όλα τα αρχεία σε έναν κατάλογο, στη συνέχεια χρησιμοποιήστε την purrr::map() για να διαβάσετε το καθένα από αυτά σε μία λίστα, και στη συνέχεια χρησιμοποιήστε την purrr::list_rbind() για να τα συνδυάσετε σε ένα ενιαίο πλαίσιο δεδομένων. Θα συζητήσουμε στη συνέχεια πώς μπορείτε να χειριστείτε καταστάσεις όπου η ετερογένεια αυξάνεται, όπου δεν μπορείτε να κάνετε ακριβώς το ίδιο πράγμα σε κάθε αρχείο.\n\n26.3.1 Καταγραφή αρχείων σε έναν κατάλογο\nΌπως προτείνει και το όνομα, η list.files() καταγράφει (lists) τα αρχεία σε έναν κατάλογο. Σχεδόν πάντα θα χρησιμοποιείτε τρία ορίσματα:\n\nΤο πρώτο όρισμα, path, είναι ο κατάλογος που θα αναζητήσετε τα αρχεία.\nΤο pattern είναι μία κανονική έκφραση που χρησιμοποιείται για να φιλτράρει τα ονόματα των αρχείων. Το πιο κοινό μοτίβο είναι κάτι σαν [.]xlsx$ ή [.]csv$ για να βρείτε όλα τα αρχεία με μία συγκεκριμένη κατάληξη.\nΤο full.names καθορίζει εάν το όνομα του καταλόγου πρέπει να συμπεριληφθεί στην έξοδο ή όχι. Σχεδόν πάντα θέλετε να είναι TRUE.\n\nΓια να κάνουμε το παράδειγμά μας συγκεκριμένο, αυτό το βιβλίο περιέχει έναν φάκελο με 12 αρχεία Excel που περιέχουν δεδομένα από το πακέτο gapminder. Κάθε αρχείο περιέχει δεδομένα ενός έτους για 142 χώρες. Μπορούμε να τα καταγράψουμε όλα με την κατάλληλη κλήση στην list.files():\n\npaths &lt;- list.files(\"data/gapminder\", pattern = \"[.]xlsx$\", full.names = TRUE)\npaths\n#&gt;  [1] \"data/gapminder/1952.xlsx\" \"data/gapminder/1957.xlsx\"\n#&gt;  [3] \"data/gapminder/1962.xlsx\" \"data/gapminder/1967.xlsx\"\n#&gt;  [5] \"data/gapminder/1972.xlsx\" \"data/gapminder/1977.xlsx\"\n#&gt;  [7] \"data/gapminder/1982.xlsx\" \"data/gapminder/1987.xlsx\"\n#&gt;  [9] \"data/gapminder/1992.xlsx\" \"data/gapminder/1997.xlsx\"\n#&gt; [11] \"data/gapminder/2002.xlsx\" \"data/gapminder/2007.xlsx\"\n\n\n26.3.2 Λίστες\nΤώρα που έχουμε αυτές τα 12 μονοπάτια, θα μπορούσαμε να καλέσουμε τη read_excel() 12 φορές για να λάβουμε 12 πλαίσια δεδομένων:\n\ngapminder_1952 &lt;- readxl::read_excel(\"data/gapminder/1952.xlsx\")\ngapminder_1957 &lt;- readxl::read_excel(\"data/gapminder/1957.xlsx\")\ngapminder_1962 &lt;- readxl::read_excel(\"data/gapminder/1962.xlsx\")\n ...,\ngapminder_2007 &lt;- readxl::read_excel(\"data/gapminder/2007.xlsx\")\n\nΗ τοποθέτηση κάθε αρχείου Excel στη δική του μεταβλητή θα κάνει τη διαχείρισή τους δύσκολη σε λίγα βήματα πιο κάτω. Αντίθετα, θα είναι πιο εύκολο εάν τα τοποθετήσουμε σε ένα μόνο αντικείμενο. Μία λίστα είναι το τέλειο εργαλείο για αυτή τη δουλειά:\n\nfiles &lt;- list(\n  readxl::read_excel(\"data/gapminder/1952.xlsx\"),\n  readxl::read_excel(\"data/gapminder/1957.xlsx\"),\n  readxl::read_excel(\"data/gapminder/1962.xlsx\"),\n  ...,\n  readxl::read_excel(\"data/gapminder/2007.xlsx\")\n)\n\nΤώρα που έχετε αυτά τα πλαίσια δεδομένων σε μία λίστα, πώς μπορείτε να βγάλετε ένα από αυτή; Μπορείτε να χρησιμοποιήσετε την files[[i]] για να εξάγετε το iοστο στοιχείο:\n\nfiles[[3]]\n#&gt; # A tibble: 142 × 5\n#&gt;   country     continent lifeExp      pop gdpPercap\n#&gt;   &lt;chr&gt;       &lt;chr&gt;       &lt;dbl&gt;    &lt;dbl&gt;     &lt;dbl&gt;\n#&gt; 1 Afghanistan Asia         32.0 10267083      853.\n#&gt; 2 Albania     Europe       64.8  1728137     2313.\n#&gt; 3 Algeria     Africa       48.3 11000948     2551.\n#&gt; 4 Angola      Africa       34    4826015     4269.\n#&gt; 5 Argentina   Americas     65.1 21283783     7133.\n#&gt; 6 Australia   Oceania      70.9 10794968    12217.\n#&gt; # ℹ 136 more rows\n\nΘα επανέλθουμε στο [[ με περισσότερες λεπτομέρειες στην Ενότητα 27.3.\n\n26.3.3 purrr::map() και list_rbind()\n\nΟ κώδικας για να συλλέξετε αυτά τα πλαίσια δεδομένων σε μία λίστα “με το χέρι” είναι εξίσου κουραστικός στην πληκτρολόγηση όσο με τον κώδικα που διαβάζει τα αρχεία ένα ένα. Ευτυχώς, μπορούμε να χρησιμοποιήσουμε τη purrr::map() για να χρησιμοποιήσουμε με ακόμα καλύτερο τρόπο το διάνυσμα paths. Η map() είναι παρόμοια με την across(), αλλά αντί να εφαρμόζει κάτι σε κάθε στήλη μέσα σε ένα πλαίσιο δεδομένων, εφαρμόζει κάτι σε κάθε στοιχείο ενός διανύσματος. Η map(x, f) είναι συντομογραφία για:\n\nlist(\n  f(x[[1]]),\n  f(x[[2]]),\n  ...,\n  f(x[[n]])\n)\n\nΜπορούμε λοιπόν να χρησιμοποιήσουμε τη map() για να πάρουμε μία λίστα με 12 πλαίσια δεδομένων:\n\nfiles &lt;- map(paths, readxl::read_excel)\nlength(files)\n#&gt; [1] 12\n\nfiles[[1]]\n#&gt; # A tibble: 142 × 5\n#&gt;   country     continent lifeExp      pop gdpPercap\n#&gt;   &lt;chr&gt;       &lt;chr&gt;       &lt;dbl&gt;    &lt;dbl&gt;     &lt;dbl&gt;\n#&gt; 1 Afghanistan Asia         28.8  8425333      779.\n#&gt; 2 Albania     Europe       55.2  1282697     1601.\n#&gt; 3 Algeria     Africa       43.1  9279525     2449.\n#&gt; 4 Angola      Africa       30.0  4232095     3521.\n#&gt; 5 Argentina   Americas     62.5 17876956     5911.\n#&gt; 6 Australia   Oceania      69.1  8691212    10040.\n#&gt; # ℹ 136 more rows\n\n(Αυτή είναι μία άλλη δομή δεδομένων που δεν εμφανίζεται ιδιαίτερα συμπαγής χρησιμοποιώντας την str(), επομένως ίσως θέλετε να τη φορτώσετε στο RStudio και να την επιθεωρήσετε με την View()).\nΤώρα μπορούμε να χρησιμοποιήσουμε την purrr::list_rbind() για να συνδυάσουμε αυτήν τη λίστα πλαισίων δεδομένων σε ένα ενιαίο πλαίσιο δεδομένων:\n\nlist_rbind(files)\n#&gt; # A tibble: 1,704 × 5\n#&gt;   country     continent lifeExp      pop gdpPercap\n#&gt;   &lt;chr&gt;       &lt;chr&gt;       &lt;dbl&gt;    &lt;dbl&gt;     &lt;dbl&gt;\n#&gt; 1 Afghanistan Asia         28.8  8425333      779.\n#&gt; 2 Albania     Europe       55.2  1282697     1601.\n#&gt; 3 Algeria     Africa       43.1  9279525     2449.\n#&gt; 4 Angola      Africa       30.0  4232095     3521.\n#&gt; 5 Argentina   Americas     62.5 17876956     5911.\n#&gt; 6 Australia   Oceania      69.1  8691212    10040.\n#&gt; # ℹ 1,698 more rows\n\nΉ θα μπορούσαμε να κάνουμε και τα δύο βήματα ταυτόχρονα σε μία διαδικασία με τον τελεστή pipe:\n\npaths |&gt; \n  map(readxl::read_excel) |&gt; \n  list_rbind()\n\nΤι γίνεται αν θέλουμε να προσθέσουμε ορίσματα στη read_excel(); Χρησιμοποιούμε την ίδια τεχνική που χρησιμοποιήσαμε με την across(). Για παράδειγμα, είναι συχνά χρήσιμο να βλέπουμε τις πρώτες γραμμές των δεδομένων με το όρισμα n_max = 1:\n\npaths |&gt; \n  map(\\(path) readxl::read_excel(path, n_max = 1)) |&gt; \n  list_rbind()\n#&gt; # A tibble: 12 × 5\n#&gt;   country     continent lifeExp      pop gdpPercap\n#&gt;   &lt;chr&gt;       &lt;chr&gt;       &lt;dbl&gt;    &lt;dbl&gt;     &lt;dbl&gt;\n#&gt; 1 Afghanistan Asia         28.8  8425333      779.\n#&gt; 2 Afghanistan Asia         30.3  9240934      821.\n#&gt; 3 Afghanistan Asia         32.0 10267083      853.\n#&gt; 4 Afghanistan Asia         34.0 11537966      836.\n#&gt; 5 Afghanistan Asia         36.1 13079460      740.\n#&gt; 6 Afghanistan Asia         38.4 14880372      786.\n#&gt; # ℹ 6 more rows\n\nΑυτό καθιστά σαφές ότι κάτι λείπει: δεν υπάρχει στήλη year, επειδή αυτή η τιμή καταγράφεται στο μονοπάτι και όχι στα μεμονωμένα αρχεία. Θα αντιμετωπίσουμε αυτό το πρόβλημα στη συνέχεια.\n\n26.3.4 Δεδομένα στο μονοπάτι\nΜερικές φορές το όνομα του αρχείου περιέχει και αυτό πληροφορία. Σε αυτό το παράδειγμα, το όνομα αρχείου περιέχει το έτος, το οποίο δεν καταγράφεται με άλλον τρόπο στα ξεχωριστά αρχεία. Για να μπει αυτή η στήλη στο τελικό πλαίσιο δεδομένων, πρέπει να κάνουμε δύο πράγματα:\nΑρχικά, δίνουμε ένα όνομα στο διάνυσμα των μονοπατιών. Ο πιο εύκολος τρόπος για να γίνει αυτό είναι με τη συνάρτηση set_names(), η οποία μπορεί να λάβει μία συνάρτηση. Εδώ χρησιμοποιούμε τη basename() για να εξαγάγουμε μόνο το όνομα του αρχείου από το πλήρες μονοπάτι:\n\npaths |&gt; set_names(basename) \n#&gt;                  1952.xlsx                  1957.xlsx \n#&gt; \"data/gapminder/1952.xlsx\" \"data/gapminder/1957.xlsx\" \n#&gt;                  1962.xlsx                  1967.xlsx \n#&gt; \"data/gapminder/1962.xlsx\" \"data/gapminder/1967.xlsx\" \n#&gt;                  1972.xlsx                  1977.xlsx \n#&gt; \"data/gapminder/1972.xlsx\" \"data/gapminder/1977.xlsx\" \n#&gt;                  1982.xlsx                  1987.xlsx \n#&gt; \"data/gapminder/1982.xlsx\" \"data/gapminder/1987.xlsx\" \n#&gt;                  1992.xlsx                  1997.xlsx \n#&gt; \"data/gapminder/1992.xlsx\" \"data/gapminder/1997.xlsx\" \n#&gt;                  2002.xlsx                  2007.xlsx \n#&gt; \"data/gapminder/2002.xlsx\" \"data/gapminder/2007.xlsx\"\n\nΑυτά τα ονόματα μεταφέρονται αυτόματα από όλες τις λειτουργίες της map, επομένως η λίστα των πλαισίων δεδομένων θα έχει τα ίδια ονόματα:\n\nfiles &lt;- paths |&gt; \n  set_names(basename) |&gt; \n  map(readxl::read_excel)\n\nΟ παραπάνω κώδικας με τη κλήση της map(), είναι συντομογραφία για:\n\nfiles &lt;- list(\n  \"1952.xlsx\" = readxl::read_excel(\"data/gapminder/1952.xlsx\"),\n  \"1957.xlsx\" = readxl::read_excel(\"data/gapminder/1957.xlsx\"),\n  \"1962.xlsx\" = readxl::read_excel(\"data/gapminder/1962.xlsx\"),\n  ...,\n  \"2007.xlsx\" = readxl::read_excel(\"data/gapminder/2007.xlsx\")\n)\n\nΜπορείτε επίσης να χρησιμοποιήσετε το [[ για να εξάγετε στοιχεία ανά όνομα:\n\nfiles[[\"1962.xlsx\"]]\n#&gt; # A tibble: 142 × 5\n#&gt;   country     continent lifeExp      pop gdpPercap\n#&gt;   &lt;chr&gt;       &lt;chr&gt;       &lt;dbl&gt;    &lt;dbl&gt;     &lt;dbl&gt;\n#&gt; 1 Afghanistan Asia         32.0 10267083      853.\n#&gt; 2 Albania     Europe       64.8  1728137     2313.\n#&gt; 3 Algeria     Africa       48.3 11000948     2551.\n#&gt; 4 Angola      Africa       34    4826015     4269.\n#&gt; 5 Argentina   Americas     65.1 21283783     7133.\n#&gt; 6 Australia   Oceania      70.9 10794968    12217.\n#&gt; # ℹ 136 more rows\n\nΣτη συνέχεια, χρησιμοποιούμε το όρισμα names_to στη list_rbind() για να της πούμε να αποθηκεύσει τα ονόματα σε μία νέα στήλη που ονομάζεται year και στη συνέχεια χρησιμοποιούμε τη readr::parse_number() για να εξαγάγουμε τον αριθμό από το κείμενο.\n\npaths |&gt; \n  set_names(basename) |&gt; \n  map(readxl::read_excel) |&gt; \n  list_rbind(names_to = \"year\") |&gt; \n  mutate(year = parse_number(year))\n#&gt; # A tibble: 1,704 × 6\n#&gt;    year country     continent lifeExp      pop gdpPercap\n#&gt;   &lt;dbl&gt; &lt;chr&gt;       &lt;chr&gt;       &lt;dbl&gt;    &lt;dbl&gt;     &lt;dbl&gt;\n#&gt; 1  1952 Afghanistan Asia         28.8  8425333      779.\n#&gt; 2  1952 Albania     Europe       55.2  1282697     1601.\n#&gt; 3  1952 Algeria     Africa       43.1  9279525     2449.\n#&gt; 4  1952 Angola      Africa       30.0  4232095     3521.\n#&gt; 5  1952 Argentina   Americas     62.5 17876956     5911.\n#&gt; 6  1952 Australia   Oceania      69.1  8691212    10040.\n#&gt; # ℹ 1,698 more rows\n\nΣε πιο περίπλοκες περιπτώσεις, μπορεί να υπάρχουν άλλες ήδη αποθηκευμένες μεταβλητές στο όνομα του καταλόγου ή ίσως το όνομα του αρχείου να περιέχει πολλά bit δεδομένων. Σε αυτήν την περίπτωση, χρησιμοποιήστε τη set_names() (χωρίς ορίσματα) για να καταγράψετε το πλήρες μονοπάτι και, στη συνέχεια, χρησιμοποιήστε τη tidyr::separate_wider_delim() και την αντίστοιχη οικογένεια συναρτήσεων για να τα μετατρέψετε σε χρήσιμες στήλες.\n\npaths |&gt; \n  set_names() |&gt; \n  map(readxl::read_excel) |&gt; \n  list_rbind(names_to = \"year\") |&gt; \n  separate_wider_delim(year, delim = \"/\", names = c(NA, \"dir\", \"file\")) |&gt; \n  separate_wider_delim(file, delim = \".\", names = c(\"file\", \"ext\"))\n#&gt; # A tibble: 1,704 × 8\n#&gt;   dir       file  ext   country     continent lifeExp      pop gdpPercap\n#&gt;   &lt;chr&gt;     &lt;chr&gt; &lt;chr&gt; &lt;chr&gt;       &lt;chr&gt;       &lt;dbl&gt;    &lt;dbl&gt;     &lt;dbl&gt;\n#&gt; 1 gapminder 1952  xlsx  Afghanistan Asia         28.8  8425333      779.\n#&gt; 2 gapminder 1952  xlsx  Albania     Europe       55.2  1282697     1601.\n#&gt; 3 gapminder 1952  xlsx  Algeria     Africa       43.1  9279525     2449.\n#&gt; 4 gapminder 1952  xlsx  Angola      Africa       30.0  4232095     3521.\n#&gt; 5 gapminder 1952  xlsx  Argentina   Americas     62.5 17876956     5911.\n#&gt; 6 gapminder 1952  xlsx  Australia   Oceania      69.1  8691212    10040.\n#&gt; # ℹ 1,698 more rows\n\n\n26.3.5 Αποθηκεύστε την δουλειά σας\nΤώρα που έχετε κάνει όλη αυτή τη σκληρή δουλειά για να φτάσετε σε ένα ωραίο τακτοποιημένο πλαίσιο δεδομένων, είναι η κατάλληλη στιγμή να την αποθηκεύσετε:\n\ngapminder &lt;- paths |&gt; \n  set_names(basename) |&gt; \n  map(readxl::read_excel) |&gt; \n  list_rbind(names_to = \"year\") |&gt; \n  mutate(year = parse_number(year))\n\nwrite_csv(gapminder, \"gapminder.csv\")\n\nΌταν επανέλθετε σε αυτό το πρόβλημα στο μέλλον, μπορείτε να διαβάσετε μόνο ένα αρχείο csv. Για μεγάλα και πιο περιεκτικά σύνολα δεδομένων, η χρήση αρχείων parquet μπορεί να είναι καλύτερη επιλογή από τα .csv, όπως συζητήθηκε στην Ενότητα 22.4.\nΕάν εργάζεστε σε ένα project, προτείνουμε να ονομάσετε το αρχείο που κάνει αυτού του είδους προετοιμασίας δεδομένων κάτι παρόμοιο με το 0-cleanup.R. Το 0 στο όνομα του αρχείου υποδηλώνει ότι πρέπει να εκτελεστεί πριν από οτιδήποτε άλλο.\nΕάν τα αρχεία δεδομένων εισόδου σας αλλάξουν με την πάροδο του χρόνου, μπορεί να θελήσετε να μάθετε ένα εργαλείο όπως το targets για να ρυθμίσετε τον αντίστοιχο κώδικα καθαρισμού δεδομένων έτσι ώστε να εκτελείται αυτόματα κάθε φορά που ένα από τα αρχεία εισόδου τροποποιείται.\n\n26.3.6 Πολλαπλές απλές επαναλήψεις\nΕδώ μόλις φορτώσαμε τα δεδομένα απευθείας από το δίσκο και ήμασταν τυχεροί με το να έχουμε πλέον ένα τακτοποιημένο σύνολο δεδομένων. Στις περισσότερες περιπτώσεις, θα χρειαστεί να κάνετε κάποια επιπλέον τακτοποίηση. Έχετε δύο βασικές επιλογές: μπορείτε να κάνετε έναν γύρο επανάληψης με μία σύνθετη συνάρτηση ή να κάνετε πολλαπλούς γύρους επανάληψης με απλές συναρτήσεις. Σύμφωνα με την εμπειρία μας, οι περισσότεροι προσεγγίζουν πρώτα μία σύνθετη επανάληψη, αλλά συχνά είστε καλύτερα κάνοντας πολλές απλές επαναλήψεις.\nΓια παράδειγμα, φανταστείτε ότι θέλετε να διαβάσετε σε μία ομάδα αρχείων, να φιλτράρετε τις κενές τιμές, να συγκεντρώσετε πληροφορία και στη συνέχεια να τη συνδυάσετε. Ένας τρόπος για να προσεγγίσετε το πρόβλημα είναι να γράψετε μία συνάρτηση που παίρνει ένα αρχείο ως είσοδο και κάνει όλα τα βήματα και στη συνέχεια να καλέσετε την map() μία φορά:\n\nprocess_file &lt;- function(path) {\n  df &lt;- read_csv(path)\n  \n  df |&gt; \n    filter(!is.na(id)) |&gt; \n    mutate(id = tolower(id)) |&gt; \n    pivot_longer(jan:dec, names_to = \"month\")\n}\n\npaths |&gt; \n  map(process_file) |&gt; \n  list_rbind()\n\nΕναλλακτικά, θα μπορούσατε να εκτελέσετε κάθε βήμα της process_file() σε κάθε αρχείο:\n\npaths |&gt; \n  map(read_csv) |&gt; \n  map(\\(df) df |&gt; filter(!is.na(id))) |&gt; \n  map(\\(df) df |&gt; mutate(id = tolower(id))) |&gt; \n  map(\\(df) df |&gt; pivot_longer(jan:dec, names_to = \"month\")) |&gt; \n  list_rbind()\n\nΣυνιστούμε αυτήν την προσέγγιση επειδή σας εμποδίζει από το να εστιάζετε στο να λαμβάνετε το πρώτο αρχείο αμέσως πριν προχωρήσετε στα υπόλοιπα. Λαμβάνοντας υπόψη όλα τα δεδομένα όταν κάνετε τακτοποίηση και καθαρισμό, είναι πιο πιθανό να σκεφτείτε ολιστικά και να καταλήξετε σε ένα αποτέλεσμα καλύτερης ποιότητας.\nΣε αυτό το συγκεκριμένο παράδειγμα, υπάρχει άλλη μία βελτιστοποίηση που θα μπορούσατε να κάνετε με το να συνδέσετε όλα τα πλαίσια δεδομένων μαζί σε κάποιο πρότερο βήμα. Στη συνέχεια, μπορείτε να βασιστείτε στην κανονική συμπεριφορά της dplyr:\n\npaths |&gt; \n  map(read_csv) |&gt; \n  list_rbind() |&gt; \n  filter(!is.na(id)) |&gt; \n  mutate(id = tolower(id)) |&gt; \n  pivot_longer(jan:dec, names_to = \"month\")\n\n\n26.3.7 Ετερογενή δεδομένα\nΔυστυχώς, μερικές φορές δεν είναι δυνατό να μεταβείτε απευθείας από τη map() στη list_rbind() επειδή τα πλαίσια δεδομένων είναι τόσο ετερογενή που η list_rbind() είτε αποτυγχάνει είτε παράγει ένα πλαίσιο δεδομένων που δεν είναι χρήσιμο. Σε αυτήν την περίπτωση, εξακολουθεί να είναι χρήσιμο να ξεκινήσετε με τη φόρτωση όλων των αρχείων:\n\nfiles &lt;- paths |&gt; \n  map(readxl::read_excel) \n\nΣτη συνέχεια, μία πολύ χρήσιμη στρατηγική είναι να αποθηκεύσετε τη δομή των πλαισίων δεδομένων, ώστε να μπορείτε να την εξερευνήσετε χρησιμοποιώντας τις δεξιότητές σας στην επιστήμη δεδομένων. Ένας τρόπος για να το κάνετε αυτό είναι με τη εύχρηστη συνάρτηση df_types6 που επιστρέφει ένα tibble με μία σειρά για κάθε στήλη:\n\ndf_types &lt;- function(df) {\n  tibble(\n    col_name = names(df), \n    col_type = map_chr(df, vctrs::vec_ptype_full),\n    n_miss = map_int(df, \\(x) sum(is.na(x)))\n  )\n}\n\ndf_types(gapminder)\n#&gt; # A tibble: 6 × 3\n#&gt;   col_name  col_type  n_miss\n#&gt;   &lt;chr&gt;     &lt;chr&gt;      &lt;int&gt;\n#&gt; 1 year      double         0\n#&gt; 2 country   character      0\n#&gt; 3 continent character      0\n#&gt; 4 lifeExp   double         0\n#&gt; 5 pop       double         0\n#&gt; 6 gdpPercap double         0\n\nΣτη συνέχεια, μπορείτε να εφαρμόσετε αυτήν τη συνάρτηση σε όλα τα αρχεία και ίσως με τη χρήση κάποιον συγκεντρωτικών πινάκων οι διαφορές να γίνουν πιο εύκολα αντιληπτές. Για παράδειγμα, αυτό διευκολύνει την επαλήθευση ότι τα υπολογιστικά φύλλα του gapminder με τα οποία έχουμε εργαστεί είναι όλα αρκετά ομοιογενή:\n\nfiles |&gt; \n  map(df_types) |&gt; \n  list_rbind(names_to = \"file_name\") |&gt; \n  select(-n_miss) |&gt; \n  pivot_wider(names_from = col_name, values_from = col_type)\n#&gt; # A tibble: 12 × 6\n#&gt;   file_name country   continent lifeExp pop    gdpPercap\n#&gt;   &lt;chr&gt;     &lt;chr&gt;     &lt;chr&gt;     &lt;chr&gt;   &lt;chr&gt;  &lt;chr&gt;    \n#&gt; 1 1952.xlsx character character double  double double   \n#&gt; 2 1957.xlsx character character double  double double   \n#&gt; 3 1962.xlsx character character double  double double   \n#&gt; 4 1967.xlsx character character double  double double   \n#&gt; 5 1972.xlsx character character double  double double   \n#&gt; 6 1977.xlsx character character double  double double   \n#&gt; # ℹ 6 more rows\n\nΕάν τα αρχεία έχουν ετερογενείς δομές, ίσως χρειαστεί να τα επεξεργαστείτε περισσότερο για να μπορέσετε να τα ενώσετε με επιτυχία. Δυστυχώς, θα σας αφήσουμε να ανακαλύψετε το πως μόνοι σας, ίσως όμως θέλετε να διαβάσετε περισσότερα για την map_if() και την map_at(). Η map_if() σας επιτρέπει να τροποποιείτε επιλεκτικά στοιχεία μιας λίστας βάσει των τιμών τους. Η map_at() σας επιτρέπει να τροποποιείτε επιλεκτικά στοιχεία βάσει των ονομάτων τους.\n\n26.3.8 Διαχείριση αποτυχιών\nΜερικές φορές η δομή των δεδομένων σας μπορεί να είναι αρκετά δυσανάγνωστη με αποτέλεσμα να μην μπορείτε να διαβάσετε όλα τα αρχεία με μία μόνο εντολή. Και τότε θα συναντήσετε ένα από τα μειονεκτήματα της map(): πετυχαίνει ή αποτυγχάνει συνολικά. Η map() είτε θα διαβάσει με επιτυχία όλα τα αρχεία σε έναν κατάλογο, είτε θα αποτύχει με ένα σφάλμα, διαβάζοντας μηδέν αρχεία. Αυτό είναι ενοχλητικό: γιατί μία αποτυχία σας εμποδίζει να αποκτήσετε πρόσβαση σε όλες τις άλλες επιτυχίες;\nΕυτυχώς, το πακέτο purrr συνοδεύεται από μία βοηθητική συνάρτηση για την αντιμετώπιση αυτού του προβλήματος: possibly(). Η possibly() είναι αυτό που είναι γνωστό ως τελεστής συνάρτησης: δέχεται ως είσοδο μία συνάρτηση και επιστρέφει μία συνάρτηση με τροποποιημένη συμπεριφορά. Συγκεκριμένα, η possibly() αλλάζει μία συνάρτηση από το να επιστρέψει κάποιο σφάλμα στην επιστροφή μιας τιμής που εσείς καθορίζετε:\n\nfiles &lt;- paths |&gt; \n  map(possibly(\\(path) readxl::read_excel(path), NULL))\n\ndata &lt;- files |&gt; list_rbind()\n\nΑυτό λειτουργεί ιδιαίτερα καλά εδώ επειδή η list_rbind(), όπως πολλές συναρτήσεις του tidyverse, αγνοεί αυτόματα τις NULL τιμές.\nΈχετε πλέον όλα τα δεδομένα που μπορούν να διαβαστούν εύκολα και ήρθε η ώρα να αντιμετωπίσετε το δύσκολο κομμάτι του να καταλάβετε γιατί απέτυχε η φόρτωση ορισμένων αρχείων και τι να κάνετε για αυτό. Ξεκινήστε βρίσκοντας τα μονοπάτια που απέτυχαν:\n\nfailed &lt;- map_vec(files, is.null)\npaths[failed]\n#&gt; character(0)\n\nΣτη συνέχεια, καλέστε ξανά τη συνάρτηση εισαγωγής για κάθε αποτυχία και ανακαλύψτε τι πήγε στραβά.",
    "crumbs": [
      "Προγραμματισμός",
      "<span class='chapter-number'>26</span>  <span class='chapter-title'>Επανάληψη</span>"
    ]
  },
  {
    "objectID": "iteration.html#αποθήκευση-πολλαπλών-εξόδων",
    "href": "iteration.html#αποθήκευση-πολλαπλών-εξόδων",
    "title": "26  Επανάληψη",
    "section": "\n26.4 Αποθήκευση πολλαπλών εξόδων",
    "text": "26.4 Αποθήκευση πολλαπλών εξόδων\nΣτην τελευταία ενότητα, μάθατε για την map(), η οποία είναι χρήσιμη για την ανάγνωση πολλαπλών αρχείων σε ένα ενιαίο αντικείμενο. Σε αυτή την ενότητα, θα εξερευνήσουμε το αντίθετο πρόβλημα: πώς μπορείτε να πάρετε ένα ή περισσότερα αντικείμενα της R και να τα αποθηκεύσετε σε ένα ή περισσότερα αρχεία; Θα εξερευνήσουμε αυτή την πρόκληση χρησιμοποιώντας τρία παραδείγματα:\n\nΑποθήκευση πολλαπλών πλαισίων δεδομένων σε μία βάση δεδομένων.\nΑποθήκευση πολλαπλών πλαισίων δεδομένων σε πολλαπλά αρχεία .csv.\nΑποθήκευση πολλαπλών διαγραμμάτων σε πολλαπλά αρχεία .png.\n\n\n26.4.1 Εγγραφή σε βάση δεδομένων\nΜερικές φορές, όταν εργάζεστε με πολλά αρχεία ταυτόχρονα, δεν είναι δυνατό να χωρέσετε όλα τα δεδομένα σας στη μνήμη ταυτόχρονα, και δεν μπορείτε να τρέξετε την map(files, read_csv). Μία προσέγγιση για να αντιμετωπίσετε αυτό το πρόβλημα είναι να φορτώσετε τα δεδομένα σας σε μία βάση δεδομένων, ώστε να μπορείτε να αποκτήσετε πρόσβαση μόνο στα τμήματα που χρειάζεστε με την dbplyr.\nΑν είστε τυχεροί, το πακέτο βάσης δεδομένων που χρησιμοποιείτε θα παρέχει μία εύκολη στη χρήση συνάρτηση που λαμβάνει ένα διάνυσμα μονοπατιών και φορτώνει όλα τα δεδομένα στη βάση δεδομένων. Αυτό συμβαίνει με τη συνάρτηση duckdb_read_csv() της duckdb:\n\ncon &lt;- DBI::dbConnect(duckdb::duckdb())\nduckdb::duckdb_read_csv(con, \"gapminder\", paths)\n\nΑυτό θα λειτουργούσε καλά εδώ, αλλά δεν έχουμε αρχεία csv, αντίθετα έχουμε αρχεία Excel. Έτσι, θα πρέπει να το κάνουμε “με το χέρι”. Το να μάθετε να το κάνετε με το χέρι θα σας βοηθήσει επίσης σε περιπτώσεις που έχετε μία σειρά από αρχεία csv και ταυτόχρονα η βάση δεδομένων με την οποία εργάζεστε δεν έχει κάποια λειτουργία για να τα φορτώσει όλα.\nΠρέπει να ξεκινήσουμε δημιουργώντας έναν πίνακα που θα γεμίσουμε με δεδομένα. Ο πιο εύκολος τρόπος για να το κάνουμε αυτό είναι δημιουργώντας το αντικείμενο template, ένα εικονικό πλαίσιο δεδομένων που περιέχει όλες τις στήλες που θέλουμε, αλλά μόνο ένα δείγμα των δεδομένων. Για τα δεδομένα από την gapminder, μπορούμε να δημιουργήσουμε το template διαβάζοντας ένα μόνο αρχείο και προσθέτοντας το έτος (year) σε αυτό:\n\ntemplate &lt;- readxl::read_excel(paths[[1]])\ntemplate$year &lt;- 1952\ntemplate\n#&gt; # A tibble: 142 × 6\n#&gt;   country     continent lifeExp      pop gdpPercap  year\n#&gt;   &lt;chr&gt;       &lt;chr&gt;       &lt;dbl&gt;    &lt;dbl&gt;     &lt;dbl&gt; &lt;dbl&gt;\n#&gt; 1 Afghanistan Asia         28.8  8425333      779.  1952\n#&gt; 2 Albania     Europe       55.2  1282697     1601.  1952\n#&gt; 3 Algeria     Africa       43.1  9279525     2449.  1952\n#&gt; 4 Angola      Africa       30.0  4232095     3521.  1952\n#&gt; 5 Argentina   Americas     62.5 17876956     5911.  1952\n#&gt; 6 Australia   Oceania      69.1  8691212    10040.  1952\n#&gt; # ℹ 136 more rows\n\nΤώρα μπορούμε να συνδεθούμε στη βάση δεδομένων και να χρησιμοποιήσουμε την DBI::dbCreateTable() για να μετατρέψουμε το πρότυπό μας σε έναν πίνακα βάσης δεδομένων:\n\ncon &lt;- DBI::dbConnect(duckdb::duckdb())\nDBI::dbCreateTable(con, \"gapminder\", template)\n\nΗ dbCreateTable() δεν χρησιμοποιεί τα δεδομένα του template, μόνο τα ονόματα και τους τύπους μεταβλητών. Έτσι, αν ελέγξουμε τον πίνακα gapminder θα δείτε ότι είναι κενός αλλά έχει τις μεταβλητές που χρειαζόμαστε με τους τύπους που αναμένουμε:\n\ncon |&gt; tbl(\"gapminder\")\n#&gt; # Source:   table&lt;gapminder&gt; [0 x 6]\n#&gt; # Database: DuckDB v0.10.1 [unknown@Linux 6.5.0-1018-azure:R 4.3.3/:memory:]\n#&gt; # ℹ 6 variables: country &lt;chr&gt;, continent &lt;chr&gt;, lifeExp &lt;dbl&gt;, pop &lt;dbl&gt;,\n#&gt; #   gdpPercap &lt;dbl&gt;, year &lt;dbl&gt;\n\nΣτη συνέχεια, χρειαζόμαστε μία συνάρτηση που παίρνει ως είσοδο ένα μονοπάτι αρχείου, το διαβάζει στην R και προσθέτει το αποτέλεσμα στον πίνακα gapminder. Μπορούμε να το κάνουμε συνδυάζοντας την read_excel() με την DBI::dbAppendTable():\n\nappend_file &lt;- function(path) {\n  df &lt;- readxl::read_excel(path)\n  df$year &lt;- parse_number(basename(path))\n  \n  DBI::dbAppendTable(con, \"gapminder\", df)\n}\n\nΤώρα πρέπει να καλέσουμε την append_file() μία φορά για κάθε στοιχείο του path. Αυτό μπορεί να γίνει σίγουρα με την map():\n\npaths |&gt; map(append_file)\n\nΔεν μας ενδιαφέρει η έξοδος της append_file(), επομένως αντί για την map() είναι λίγο πιο ωραίο να χρησιμοποιείτε την walk(). Η walk() κάνει ακριβώς το ίδιο με την map(), αλλά χωρίς να δίνει έξοδο:\n\npaths |&gt; walk(append_file)\n\nΤώρα μπορούμε να ελέγξουμε αν έχουμε όλα τα δεδομένα στον πίνακά μας:\n\ncon |&gt; \n  tbl(\"gapminder\") |&gt; \n  count(year)\n#&gt; # Source:   SQL [?? x 2]\n#&gt; # Database: DuckDB v0.10.1 [unknown@Linux 6.5.0-1018-azure:R 4.3.3/:memory:]\n#&gt;    year     n\n#&gt;   &lt;dbl&gt; &lt;dbl&gt;\n#&gt; 1  1967   142\n#&gt; 2  1977   142\n#&gt; 3  1987   142\n#&gt; 4  2007   142\n#&gt; 5  1952   142\n#&gt; 6  1957   142\n#&gt; # ℹ more rows\n\n\n26.4.2 Εγγραφή αρχείων csv\nΗ ίδια βασική αρχή ισχύει αν θέλουμε να γράψουμε πολλαπλά αρχεία csv, ένα για κάθε ομάδα. Ας φανταστούμε ότι θέλουμε να πάρουμε το σύνολο δεδομένων ggplot2::diamonds και να αποθηκεύσουμε ένα αρχείο csv για κάθε τιμής της στήλης clarity. Πρώτα πρέπει να δημιουργήσουμε τα ξεχωριστά σύνολα δεδομένων. Υπάρχουν πολλοί τρόποι που θα μπορούσατε να το κάνετε αυτό, αλλά υπάρχει ένας τρόπος που μας αρέσει ιδιαίτερα: η group_nest().\n\nby_clarity &lt;- diamonds |&gt; \n  group_nest(clarity)\n\nby_clarity\n#&gt; # A tibble: 8 × 2\n#&gt;   clarity               data\n#&gt;   &lt;ord&gt;   &lt;list&lt;tibble[,9]&gt;&gt;\n#&gt; 1 I1               [741 × 9]\n#&gt; 2 SI2            [9,194 × 9]\n#&gt; 3 SI1           [13,065 × 9]\n#&gt; 4 VS2           [12,258 × 9]\n#&gt; 5 VS1            [8,171 × 9]\n#&gt; 6 VVS2           [5,066 × 9]\n#&gt; # ℹ 2 more rows\n\nΑυτό μας δίνει ένα νέο tibble με οκτώ γραμμές και δύο στήλες. H clarity είναι η μεταβλητή ομαδοποίησης μας και η data είναι μία λίστα/στήλη που περιέχει ένα tibble για κάθε μοναδική τιμή της clarity:\n\nby_clarity$data[[1]]\n#&gt; # A tibble: 741 × 9\n#&gt;   carat cut       color depth table price     x     y     z\n#&gt;   &lt;dbl&gt; &lt;ord&gt;     &lt;ord&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n#&gt; 1  0.32 Premium   E      60.9    58   345  4.38  4.42  2.68\n#&gt; 2  1.17 Very Good J      60.2    61  2774  6.83  6.9   4.13\n#&gt; 3  1.01 Premium   F      61.8    60  2781  6.39  6.36  3.94\n#&gt; 4  1.01 Fair      E      64.5    58  2788  6.29  6.21  4.03\n#&gt; 5  0.96 Ideal     F      60.7    55  2801  6.37  6.41  3.88\n#&gt; 6  1.04 Premium   G      62.2    58  2801  6.46  6.41  4   \n#&gt; # ℹ 735 more rows\n\nΌσο είμαστε σε αυτό το στάδιο, ας δημιουργήσουμε μία στήλη που δίνει το όνομα του αρχείου εξόδου, χρησιμοποιώντας την mutate() και την str_glue():\n\nby_clarity &lt;- by_clarity |&gt; \n  mutate(path = str_glue(\"diamonds-{clarity}.csv\"))\n\nby_clarity\n#&gt; # A tibble: 8 × 3\n#&gt;   clarity               data path             \n#&gt;   &lt;ord&gt;   &lt;list&lt;tibble[,9]&gt;&gt; &lt;glue&gt;           \n#&gt; 1 I1               [741 × 9] diamonds-I1.csv  \n#&gt; 2 SI2            [9,194 × 9] diamonds-SI2.csv \n#&gt; 3 SI1           [13,065 × 9] diamonds-SI1.csv \n#&gt; 4 VS2           [12,258 × 9] diamonds-VS2.csv \n#&gt; 5 VS1            [8,171 × 9] diamonds-VS1.csv \n#&gt; 6 VVS2           [5,066 × 9] diamonds-VVS2.csv\n#&gt; # ℹ 2 more rows\n\nΈτσι, εάν επρόκειτο να αποθηκεύσουμε αυτά τα πλαίσια δεδομένων με το χέρι, θα μπορούσαμε να γράψουμε κάτι σαν:\n\nwrite_csv(by_clarity$data[[1]], by_clarity$path[[1]])\nwrite_csv(by_clarity$data[[2]], by_clarity$path[[2]])\nwrite_csv(by_clarity$data[[3]], by_clarity$path[[3]])\n...\nwrite_csv(by_clarity$by_clarity[[8]], by_clarity$path[[8]])\n\nΑυτό είναι λίγο διαφορετικό από τις προηγούμενες χρήσεις της map(), επειδή υπάρχουν δύο ορίσματα που αλλάζουν, όχι μόνο ένα. Αυτό σημαίνει ότι χρειαζόμαστε μία νέα συνάρτηση: την map2(), η οποία διαφοροποιεί και το πρώτο και το δεύτερο όρισμα. Και επειδή και πάλι δεν μας ενδιαφέρει η έξοδος, θέλουμε την walk2() αντί για την map2(). Αυτό μας δίνει:\n\nwalk2(by_clarity$data, by_clarity$path, write_csv)\n\n\n26.4.3 Αποθήκευση διαγραμμάτων\nΜπορούμε να ακολουθήσουμε την ίδια βασική προσέγγιση για να δημιουργήσουμε πολλαπλά διαγράμματα. Ας φτιάξουμε πρώτα μία συνάρτηση που σχεδιάζει το διάγραμμα που θέλουμε:\n\ncarat_histogram &lt;- function(df) {\n  ggplot(df, aes(x = carat)) + geom_histogram(binwidth = 0.1)  \n}\n\ncarat_histogram(by_clarity$data[[1]])\n\n\n\n\n\n\n\nΤώρα μπορούμε να χρησιμοποιήσουμε την map() για να δημιουργήσουμε μία λίστα από πολλαπλά διαγράμματα7 και τα τελικά μονοπάτια τους:\n\nby_clarity &lt;- by_clarity |&gt; \n  mutate(\n    plot = map(data, carat_histogram),\n    path = str_glue(\"clarity-{clarity}.png\")\n  )\n\nΣτη συνέχεια, χρησιμοποιήστε την walk2() με την ggsave() για να αποθηκεύσετε κάθε διάγραμμα:\n\nwalk2(\n  by_clarity$path,\n  by_clarity$plot,\n  \\(path, plot) ggsave(path, plot, width = 6, height = 6)\n)\n\nΟ παραπάνω κώδικας είναι συντομογραφία για:\n\nggsave(by_clarity$path[[1]], by_clarity$plot[[1]], width = 6, height = 6)\nggsave(by_clarity$path[[2]], by_clarity$plot[[2]], width = 6, height = 6)\nggsave(by_clarity$path[[3]], by_clarity$plot[[3]], width = 6, height = 6)\n...\nggsave(by_clarity$path[[8]], by_clarity$plot[[8]], width = 6, height = 6)",
    "crumbs": [
      "Προγραμματισμός",
      "<span class='chapter-number'>26</span>  <span class='chapter-title'>Επανάληψη</span>"
    ]
  },
  {
    "objectID": "iteration.html#σύνοψη",
    "href": "iteration.html#σύνοψη",
    "title": "26  Επανάληψη",
    "section": "\n26.5 Σύνοψη",
    "text": "26.5 Σύνοψη\nΣε αυτό το κεφάλαιο, είδατε πώς να χρησιμοποιείτε επανάληψη για να λύσετε τρία συνηθισμένα προβλήματα που εμφανίζονται συχνά όταν ασχολείστε με την επιστήμη δεδομένων: την διαχείριση πολλαπλών στηλών, την ανάγνωση πολλαπλών αρχείων και την αποθήκευση πολλαπλών εξόδων. Γενικά όμως, η επανάληψη είναι μία υπερδύναμη: αν γνωρίζετε τη σωστή τεχνική επανάληψης, μπορείτε εύκολα να περάσετε από το να διορθώσετε ένα πρόβλημα στο να διορθώσετε όλα τα προβλήματα. Αφού εξοικειωθείτε με τις τεχνικές σε αυτό το κεφάλαιο, σας προτείνουμε να μάθετε περισσότερα διαβάζοντας το κεφάλαιο Functionals του βιβλίου Advanced R και να συμβουλευτείτε την ιστοσελίδα purrr.\nΑν γνωρίζετε ήδη αρκετά για την επανάληψη σε άλλες γλώσσες, μπορεί να εκπλαγείτε που δεν συζητήσαμε τον βρόγχο for. Αυτό οφείλεται στο ότι η προσανατολισμένη προς την ανάλυση δεδομένων φύση της R αλλάζει τον τρόπο που επαναλαμβάνουμε: στις περισσότερες περιπτώσεις μπορείτε να βασιστείτε σε ένα ιδίωμα για να κάνετε κάτι σε κάθε στήλη ή σε κάθε ομάδα. Και όταν δεν μπορείτε, συχνά μπορείτε να χρησιμοποιήσετε ένα εργαλείο λειτουργικού προγραμματισμού όπως η map() που εφαρμόζει κάτι σε κάθε στοιχείο μιας λίστας. Ωστόσο, θα δείτε βρόγχους for σε κώδικες που θα συναντήσετε εκεί έξω, έτσι θα μάθετε για αυτούς στο επόμενο κεφάλαιο, όπου θα συζητήσουμε κάποια σημαντικά εργαλεία της βασικής έκδοσης της R.",
    "crumbs": [
      "Προγραμματισμός",
      "<span class='chapter-number'>26</span>  <span class='chapter-title'>Επανάληψη</span>"
    ]
  },
  {
    "objectID": "iteration.html#footnotes",
    "href": "iteration.html#footnotes",
    "title": "26  Επανάληψη",
    "section": "",
    "text": "Ανώνυμες, γιατί ποτέ δεν ορίσαμε ρητά το όνομα με τον τελεστή &lt;-. Ένας άλλος όρος που χρησιμοποιούν οι προγραμματιστές σε αυτή τη περίπτωση είναι “συνάρτηση λάμδα (lambda)”.↩︎\nΣε κάποια παλαιότερη έκδοση κώδικα μπορεί να δείτε σύνταξη παρόμοια με ~ .x + 1. Αυτός είναι ένας άλλος τρόπος για να γράψετε ανώνυμες συναρτήσεις, αλλά λειτουργεί μόνο μέσα σε συναρτήσεις του tidyverse και χρησιμοποιεί πάντα το όνομα της μεταβλητής .x. Τώρα, συνιστούμε τη σύνταξη όπως αυτή ορίζεται στη βασική έκδοση της R, \\(x) x + 1.↩︎\nΠρος το παρόν, δεν μπορείτε να αλλάξετε τη σειρά των στηλών, αλλά θα μπορούσατε να τις αναδιατάξετε εκ των υστέρων χρησιμοποιώντας την relocate() ή κάτι παρόμοιο.↩︎\nΊσως μπορέσει να γίνει κάποια μέρα, αλλά αυτή τη στιγμή δεν βλέπουμε το πως.↩︎\nΔεν θα εξηγήσουμε πώς λειτουργεί, αλλά αν κοιτάξετε τις οδηγίες για τις συναρτήσεις που χρησιμοποιούνται, θα πρέπει να μπορείτε να το ξεκαθαρίσετε.↩︎\nΔεν θα εξηγήσουμε πώς λειτουργεί, αλλά αν κοιτάξετε τις οδηγίες για τις συναρτήσεις που χρησιμοποιούνται, θα πρέπει να μπορείτε να το ξεκαθαρίσετε.↩︎\nΜπορείτε να εκτυπώσετε το by_clarity$plot για να λάβετε μία πρόχειρη απεικόνηση — θα πάρετε ένα διάγραμμα για κάθε στοιχείο του plots. ΣΗΜΕΙΩΣΗ: αυτό δεν συνέβη σε εμένα.↩︎",
    "crumbs": [
      "Προγραμματισμός",
      "<span class='chapter-number'>26</span>  <span class='chapter-title'>Επανάληψη</span>"
    ]
  },
  {
    "objectID": "base-R.html",
    "href": "base-R.html",
    "title": "27  Ένας οδηγός για το βασικό σύνολο λειτουργιών της R",
    "section": "",
    "text": "27.1 Εισαγωγή\nΩς επίλογο της ενότητας του προγραμματισμού, θα σας δώσουμε μία ιδέα για τις πιο σημαντικές βασικές συναρτήσεις της R που διαφορετικά δεν θα συζητούσαμε σε αυτό το βιβλίο. Τα εργαλεία αυτά είναι αρκετά χρήσιμα όσο προγραμματίζετε περισσότερο και θα σας βοηθήσουν στο να διαβάζετε κώδικα που κυκλοφορεί εκεί έξω.\nΣε αυτό το σημείο είναι καλό να σας υπενθυμίσουμε ότι το tidyverse δεν υπάρχει μόνο για να αντιμετωπίζει προβλήματα της επιστήμης δεδομένων. Δείχνουμε το tidyverse σε αυτό το βιβλίο επειδή τα αντίστοιχα πακέτα του μοιράζονται μία κοινή φιλοσοφία, αυξάνοντας τη συνοχή μεταξύ των συναρτήσεων και καθιστώντας κάθε νέα συνάρτηση ή πακέτο λίγο πιο εύκολα στην εκμάθηση και χρήση. Δεν είναι δυνατό να χρησιμοποιήσετε το tidyverse χωρίς τη χρήση των βασικών συναρτήσεων της R. Σας έχουμε ήδη μάθει πολλές βασικές συναρτήσεις R: από την library() για την φόρτωση πακέτων, τη sum() και τη mean() για αριθμητικές περιλήψεις, για τους τύπους δεδομένων με παράγοντες (factors), ημερομηνίες και POSIXct και φυσικά όλους τους βασικούς τελεστές όπως +, -, /, *, |, &, και !. Αυτό στο οποίο δεν έχουμε επικεντρωθεί μέχρι στιγμής είναι οι βασικές ροές εργασίας της R, επομένως θα επισημάνουμε μερικές από αυτές σε αυτό το κεφάλαιο.\nΑφού διαβάσετε αυτό το βιβλίο, θα μάθετε και άλλες προσεγγίσεις πάνω στα ίδια προβλήματα χρησιμοποιώντας το βασικό σύνολο λειτουργιών της R, το data.table και άλλα πακέτα. Θα συναντήσετε αυτές τις άλλες προσεγγίσεις χωρίς αμφιβολία όταν αρχίσετε να διαβάζετε κώδικα R που γράφτηκε από άλλους, ιδιαίτερα εάν χρησιμοποιείτε το StackOverflow. Είναι 100% εντάξει να γράφετε κώδικα που χρησιμοποιεί έναν συνδυασμό προσεγγίσεων και μην αφήνετε κανέναν να σας πει το αντίθετο!\nΣε αυτό το κεφάλαιο, θα εστιάσουμε σε τέσσερις μεγάλες θεματολογίες: δημιουργία υποσυνόλων με [, δημιουργία υποσυνόλων με τα [[ και $, την οικογένεια συναρτήσεων apply και βρόγχους for. Τέλος, θα συζητήσουμε εν συντομία δύο συναρτήσεις δημιουργίας διαγραμμάτων.",
    "crumbs": [
      "Προγραμματισμός",
      "<span class='chapter-number'>27</span>  <span class='chapter-title'>Ένας οδηγός για το βασικό σύνολο λειτουργιών της R</span>"
    ]
  },
  {
    "objectID": "base-R.html#εισαγωγή",
    "href": "base-R.html#εισαγωγή",
    "title": "27  Ένας οδηγός για το βασικό σύνολο λειτουργιών της R",
    "section": "",
    "text": "27.1.1 Προαπαιτούμενα\nΤο πακέτο αυτό εστιάζει στις βασικές λειτουργίες της R, επομένως δεν έχει πραγματικά προαπαιτούμενα, αλλά θα φορτώσουμε το tidyverse για να εξηγήσουμε μερικές διαφορές.\n\nlibrary(tidyverse)",
    "crumbs": [
      "Προγραμματισμός",
      "<span class='chapter-number'>27</span>  <span class='chapter-title'>Ένας οδηγός για το βασικό σύνολο λειτουργιών της R</span>"
    ]
  },
  {
    "objectID": "base-R.html#sec-subset-many",
    "href": "base-R.html#sec-subset-many",
    "title": "27  Ένας οδηγός για το βασικό σύνολο λειτουργιών της R",
    "section": "\n27.2 Επιλογή πολλαπλών στοιχείων με [\n",
    "text": "27.2 Επιλογή πολλαπλών στοιχείων με [\n\nΤο [ χρησιμοποιείται για την εξαγωγή υποσυνόλων από διανύσματα και πλαίσια δεδομένων και καλείται ως x[i] ή x[i, j]. Σε αυτήν την ενότητα, θα σας παρουσιάσουμε τις ικανότητες του [, δείχνοντάς σας πρώτα πώς μπορείτε να το χρησιμοποιήσετε με διανύσματα και στη συνέχεια πως οι ίδιες αρχές επεκτείνονται με απλό τρόπο στις δύο διαστάσεις όπως στα πλαίσια δεδομένων. Στη συνέχεια, θα σας βοηθήσουμε να το εμπεδώσετε δείχνοντας πώς διάφορες συναρτήσεις της dplyr είναι ειδικές περιπτώσεις του [.\n\n27.2.1 Υποσύνολα από διανύσματα\nΥπάρχουν πέντε κύριοι τύποι κατηγοριών με τις οποίες μπορείτε να εξάγετε ένα υποσύνολο από ένα διάνυσμα, δηλαδή πέντε διαφορετικές κατηγορίες που αντιστοιχούν στο i από το x[i]:\n\n\nΔιάνυσμα με θετικούς ακέραιους αριθμούς. Η δημιουργία υποσυνόλων με θετικούς ακέραιους αριθμούς επιστρέφει τα στοιχεία των αντίστοιχων θέσεων:\n\nx &lt;- c(\"one\", \"two\", \"three\", \"four\", \"five\")\nx[c(3, 2, 5)]\n#&gt; [1] \"three\" \"two\"   \"five\"\n\nΕπαναλαμβάνοντας μία θέση μπορείτε να δημιουργήσετε μία μεγαλύτερη έξοδο, κάνοντας τον όρο “υποσύνολο” ελαφρώς λανθασμένο.\n\nx[c(1, 1, 5, 5, 5, 2)]\n#&gt; [1] \"one\"  \"one\"  \"five\" \"five\" \"five\" \"two\"\n\n\n\nΔιάνυσμα με αρνητικούς ακέραιους αριθμούς. Αρνητικές τιμές αφαιρούν τα στοιχεία στις αντίστοιχες θέσεις:\n\nx[c(-1, -3, -5)]\n#&gt; [1] \"two\"  \"four\"\n\n\n\nΛογικό διάνυσμα. Δημιουργώντας ένα υποσύνολο χρησιμοποιώντας λογικές τιμές επιστρέφει όλες τις τιμές όπου είναι TRUE. Συχνά, αυτό είναι πιο χρήσιμο σε συνδυασμό με συναρτήσεις σύγκρισης.\n\nx &lt;- c(10, 3, NA, 5, 8, 1, NA)\n\n# Όλες οι μη κενές τιμές του x\nx[!is.na(x)]\n#&gt; [1] 10  3  5  8  1\n\n# Όλες οι ζυγές (ή κενές!) τιμές του x\nx[x %% 2 == 0]\n#&gt; [1] 10 NA  8 NA\n\nΣε αντίθεση με την filter(), οι θέσεις που περιέχουν NA θα συμπεριληφθούν στην έξοδο ως NA.\n\n\nΔιάνυσμα χαρακτήρα. Εάν έχετε ένα διάνυσμα με ονόματα για κάθε στοιχείο του, μπορείτε να δημιουργήσετε ένα υποσύνολο με ένα διάνυσμα χαρακτήρα:\n\nx &lt;- c(abc = 1, def = 2, xyz = 5)\nx[c(\"xyz\", \"def\")]\n#&gt; xyz def \n#&gt;   5   2\n\nΌπως και με τα υποσύνολα από θετικούς ακέραιους αριθμούς, μπορείτε να χρησιμοποιήσετε ένα διάνυσμα χαρακτήρων για να επαναλάβετε μεμονωμένες εγγραφές.\n\nΚενό. Ο τελευταίος τύπος δημιουργίας υποσύνολου είναι το κενό, x[], το οποίο επιστρέφει ολόκληρο το x. Δεν είναι χρήσιμο όμως για υποσύνολα διανυσμάτων, αλλά όπως θα δούμε σύντομα, είναι χρήσιμο για υποσύνολα δισδιάστατων δομών, όπως τα tibbles.\n\n27.2.2 Υποσύνολα πλαισίων δεδομένων\nΥπάρχουν αρκετοί διαφορετικοί τρόποι1 με τους οποίους μπορείτε να χρησιμοποιήσετε το [ με ένα πλαίσιο δεδομένων, αλλά ο πιο σημαντικός είναι να επιλέξετε γραμμές και στήλες ξεχωριστά χρησιμοποιώντας το df[γραμμές, στήλες]. Εδώ οι γραμμές και οι στήλες είναι διανύσματα όπως περιγράφονται παραπάνω. Για παράδειγμα, τα df[γραμμές, ] και df[, στήλες] επιλέγουν μόνο γραμμές ή μόνο στήλες, χρησιμοποιώντας το κενό υποσύνολο για να διατηρήσουν την άλλη διάσταση.\nΜερικά παραδείγματα:\n\ndf &lt;- tibble(\n  x = 1:3, \n  y = c(\"a\", \"e\", \"f\"), \n  z = runif(3)\n)\n\n# Επιλέξτε την πρώτη γραμμή και τη δεύτερη στήλη\ndf[1, 2]\n#&gt; # A tibble: 1 × 1\n#&gt;   y    \n#&gt;   &lt;chr&gt;\n#&gt; 1 a\n\n# Επιλέξτε όλες τις γραμμές και τις στήλες x και y\ndf[, c(\"x\" , \"y\")]\n#&gt; # A tibble: 3 × 2\n#&gt;       x y    \n#&gt;   &lt;int&gt; &lt;chr&gt;\n#&gt; 1     1 a    \n#&gt; 2     2 e    \n#&gt; 3     3 f\n\n# Επιλέξτε γραμμλες όπου το `x` είναι μεγαλύτερο από 1 και όλες οι στήλες\ndf[df$x &gt; 1, ]\n#&gt; # A tibble: 2 × 3\n#&gt;       x y         z\n#&gt;   &lt;int&gt; &lt;chr&gt; &lt;dbl&gt;\n#&gt; 1     2 e     0.834\n#&gt; 2     3 f     0.601\n\nΘα επανέλθουμε σύντομα στο $, θα πρέπει όμως να μπορείτε να μαντέψετε ήδη τι κάνει το df$x από τα συμφραζόμενα: εξάγει τη μεταβλητή x από το df. Εδώ, πρέπει να το χρησιμοποιήσουμε επειδή το [ δεν χρησιμοποιεί αξιολόγηση tidy, επομένως πρέπει να είστε ξεκάθαροι σχετικά με την πηγή της μεταβλητής x.\nΥπάρχει μία σημαντική διαφορά μεταξύ των tibbles και των πλαισίων δεδομένων όσον αφορά το [. Σε αυτό το βιβλίο, χρησιμοποιήσαμε κυρίως τα tibbles, τα οποία είναι πλαίσια δεδομένων, αλλά τροποποιούν ορισμένες συμπεριφορές για να κάνουν τη ζωή σας λίγο πιο εύκολη. Στα περισσότερα σημεία, μπορείτε να χρησιμοποιήσετε είτε το “tibble” είτε το “data frame” (πλαίσιο δεδομένων), οπότε όταν θέλουμε να δώσουμε έμφαση στο ενσωματωμένο πλαίσιο δεδομένων της R, θα γράφουμε data.frame. Εάν το df είναι ένα data.frame, τότε το df[, cols] θα επιστρέψει ένα διάνυσμα εάν το col επιλέγει μία στήλη, και ένα πλαίσιο δεδομένων εάν επιλέγει περισσότερες από μία στήλες. Εάν το df είναι tibble, τότε η χρήση του [ θα επιστρέφει πάντα ένα tibble.\n\ndf1 &lt;- data.frame(x = 1:3)\ndf1[, \"x\"]\n#&gt; [1] 1 2 3\n\ndf2 &lt;- tibble(x = 1:3)\ndf2[, \"x\"]\n#&gt; # A tibble: 3 × 1\n#&gt;       x\n#&gt;   &lt;int&gt;\n#&gt; 1     1\n#&gt; 2     2\n#&gt; 3     3\n\nΈνας τρόπος για να αποφύγετε αυτή την ασάφεια με τα data.frame είναι να θέτετε το όρισμα drop = FALSE:\n\ndf1[, \"x\" , drop = FALSE]\n#&gt;   x\n#&gt; 1 1\n#&gt; 2 2\n#&gt; 3 3\n\n\n27.2.3 Ισοδύναμα της dplyr\nΑρκετές συναρτήσεις της dplyr είναι ειδικές περιπτώσεις του [:\n\n\nΗ filter() ισοδυναμεί με το να δημιουργείτε υποσύνολα γραμμών χρησιμοποιώντας ένα λογικό διάνυσμα ενώ ταυτόχρονα εξαιρείτε τις κενές τιμές:\n\ndf &lt;- tibble(\n  x = c(2, 3, 1, 1, NA), \n  y = letters[1:5], \n  z = runif(5)\n)\ndf |&gt; filter(x &gt; 1)\n\n# ίδιο με το\ndf[!is.na(df$x) & df$x &gt; 1, ]\n\nΜία άλλη γνωστή τεχνική είναι η χρήση της which(), εξαιτίας της ιδιότητάς της να εξαιρεί κενές τιμές: df[which(df$x &gt; 1), ].\n\n\nΗ arrange() ισοδυναμεί με την αναδιοργάνωση των γραμμών χρησιμοποιώντας ένα διάνυσμα ακέραιου αριθμού. Συνήθως γίνεται με την order():\n\ndf |&gt; arrange(x, y)\n\n# ίδιο με το\ndf[order(df$x, df$y), ]\n\nΜπορείτε να χρησιμοποιήσετε το order(decreasing = TRUE) για να ταξινομήσετε όλες τις στήλες με φθίνουσα σειρά ή το -rank(col) για να ταξινομήσετε τις στήλες με φθίνουσα μία προς μία.\n\n\nΤόσο η select() όσο και η relocate() είναι παρόμοιες με το να δημιουργείτε υποσύνολα στηλών χρησιμοποιώντας ένα διάνυσμα χαρακτήρων:\n\ndf |&gt; select(x, z)\n\n# ίδιο με το\ndf[, c(\"x\", \"z\")]\n\n\n\nΤο βασικό σύνολο της R προσφέρει μία συνάρτηση η οποία συνδυάζει τα χαρακτηριστικά της filter() και της select()2 και ονομάζεται subset():\n\ndf |&gt; \n  filter(x &gt; 1) |&gt; \n  select(y, z)\n#&gt; # A tibble: 2 × 2\n#&gt;   y           z\n#&gt;   &lt;chr&gt;   &lt;dbl&gt;\n#&gt; 1 a     0.157  \n#&gt; 2 b     0.00740\n\n\n# ίδιο με το\ndf |&gt; subset(x &gt; 1, c(y, z))\n\nΗ συνάρτηση αυτή ήταν η έμπνευση για ένα αρκετά μεγάλο μέρος του συντακτικού της dplyr.\n\n27.2.4 Ασκήσεις\n\n\nΔημιουργήστε συναρτήσεις οι οποίες παίρνουν ως είσοδο ένα διάνυσμα και επιστρέφουν:\nα.  Τα στοιχεία που βρίσκονται σε ζυγές θέσεις.\nβ.  Όλα τα στοιχεία εκτός του τελευταίου.\nγ.  Μόνο ζυγές τιμές (και όχι κενές τιμές).\n\nΓιατί το x[-which(x &gt; 0)] δεν είναι το ίδιο με το x[x &lt;= 0]; Διαβάστε τις οδηγίες για την which() και πειραματιστείτε για να το βρείτε.",
    "crumbs": [
      "Προγραμματισμός",
      "<span class='chapter-number'>27</span>  <span class='chapter-title'>Ένας οδηγός για το βασικό σύνολο λειτουργιών της R</span>"
    ]
  },
  {
    "objectID": "base-R.html#sec-subset-one",
    "href": "base-R.html#sec-subset-one",
    "title": "27  Ένας οδηγός για το βασικό σύνολο λειτουργιών της R",
    "section": "\n27.3 Επιλέγοντας μόνο ένα στοιχείο με το $ και το [[\n",
    "text": "27.3 Επιλέγοντας μόνο ένα στοιχείο με το $ και το [[\n\nΤο [, το οποίο επιλέγει πολλαπλά στοιχεία, συνδυάζεται με τα [[ και $, τα οποία εξάγουν ένα μεμονωμένο στοιχείο. Σε αυτήν την ενότητα, θα σας δείξουμε πώς να χρησιμοποιείτε τα [[ και $ για να εξάγετε στήλες από τα πλαίσια δεδομένων, θα συζητήσουμε μερικές ακόμη διαφορές μεταξύ των data.frame και των tibbles και θα τονίσουμε μερικές σημαντικές διαφορές μεταξύ του [ και του [[ όταν χρησιμοποιούνται με λίστες.\n\n27.3.1 Πλαίσια δεδομένων\nΤα [[ και $ μπορούν να χρησιμοποιηθούν για την εξαγωγή στηλών από ένα πλαίσιο δεδομένων. Το [[ μπορεί να έχει πρόσβαση σε δομές δεδομένων με βάση τη θέση ή το όνομα, και το $ είναι ειδικά για πρόσβαση με βάση το όνομα:\n\ntb &lt;- tibble(\n  x = 1:4,\n  y = c(10, 4, 1, 21)\n)\n\n# ανά θέση\ntb[[1]]\n#&gt; [1] 1 2 3 4\n\n# ανά όνομα\ntb[[\"x\"]]\n#&gt; [1] 1 2 3 4\ntb$x\n#&gt; [1] 1 2 3 4\n\nΜπορούν να χρησιμοποιηθούν και για τη δημιουργία νέων στηλών. Το αντίστοιχο της mutate() στο βασικό σύνολο της R είναι:\n\ntb$z &lt;- tb$x + tb$y\ntb\n#&gt; # A tibble: 4 × 3\n#&gt;       x     y     z\n#&gt;   &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt;\n#&gt; 1     1    10    11\n#&gt; 2     2     4     6\n#&gt; 3     3     1     4\n#&gt; 4     4    21    25\n\nΥπάρχουν πολλές άλλες προσεγγίσεις του βασικού συνόλου της R για τη δημιουργία νέων στηλών, συμπεριλαμβανομένων των transform(), with() και within(). Ο Hadley συγκέντρωσε μερικά παραδείγματα στη διεύθυνση https://gist.github.com/hadley/1986a273e384fb2d4d752c18ed71bedf.\nΗ απευθείας χρήση του $ είναι βολική για την κατασκευή γρήγορων περιλήψεων. Για παράδειγμα, εάν θέλετε απλώς να βρείτε το μέγεθος του μεγαλύτερου διαμαντιού ή τις πιθανές τιμές της cut, δεν χρειάζεται να χρησιμοποιήσετε την summarize():\n\nmax(diamonds$carat)\n#&gt; [1] 5.01\n\nlevels(diamonds$cut)\n#&gt; [1] \"Fair\"      \"Good\"      \"Very Good\" \"Premium\"   \"Ideal\"\n\nΗ dplyr παρέχει επίσης ένα ισοδύναμο με το [[/$ που δεν αναφέραμε στο Κεφάλαιο 3: την pull(). Η pull() παίρνει είτε ένα όνομα μεταβλητής είτε μία θέση μεταβλητής και επιστρέφει ακριβώς αυτήν τη στήλη. Αυτό σημαίνει ότι θα μπορούσαμε να ξαναγράψουμε τον παραπάνω κώδικα για να χρησιμοποιήσουμε το pipe:\n\ndiamonds |&gt; pull(carat) |&gt; max()\n#&gt; [1] 5.01\n\ndiamonds |&gt; pull(cut) |&gt; levels()\n#&gt; [1] \"Fair\"      \"Good\"      \"Very Good\" \"Premium\"   \"Ideal\"\n\n\n27.3.2 Tibbles\nΥπάρχουν μερικές σημαντικές διαφορές μεταξύ των tibbles και του βασικού data.frame όσον αφορά το $. Στα πλαίσια δεδομένων αρκεί να ταιριάξει το πρόθεμα οποιουδήποτε ονόματος μεταβλητής (η λεγόμενη μερική αντιστοίχιση) και δεν παραπονιέται εάν η στήλη δεν υπάρχει:\n\ndf &lt;- data.frame(x1 = 1)\ndf$x\n#&gt; [1] 1\ndf$z\n#&gt; NULL\n\nΤα tibbles είναι πιο αυστηρά: τα ονόματα των μεταβλητών πρέπει να ταιριάζουν ακριβώς και θα επιστρέψουν μία προειδοποίηση εάν η στήλη στην οποία προσπαθείτε να αποκτήσετε πρόσβαση δεν υπάρχει:\n\ntb &lt;- tibble(x1 = 1)\n\ntb$x\n#&gt; Warning: Unknown or uninitialised column: `x`.\n#&gt; NULL\ntb$z\n#&gt; Warning: Unknown or uninitialised column: `z`.\n#&gt; NULL\n\nΓια αυτόν τον λόγο, μερικές φορές αστειευόμαστε ότι τα tibbles είναι τεμπέλικα και κακόκεφα: κάνουν λίγα και παραπονιούνται περισσότερο.\n\n27.3.3 Λίστες\nΤα [[ και $ είναι επίσης πολύ σημαντικά για εργασίες με λίστες και είναι σημαντικό να κατανοήσουμε πώς διαφέρουν από το [. Ας δείξουμε τις διαφορές με μία λίστα με όνομα l:\n\nl &lt;- list(\n  a = 1:3, \n  b = \"a string\", \n  c = pi, \n  d = list(-1, -5)\n)\n\n\n\nΤο [ εξάγει μία υπο-λίστα. Δεν έχει σημασία πόσα στοιχεία θα εξάγετε, το αποτέλεσμα θα είναι πάντα λίστα.\n\nstr(l[1:2])\n#&gt; List of 2\n#&gt;  $ a: int [1:3] 1 2 3\n#&gt;  $ b: chr \"a string\"\n\nstr(l[1])\n#&gt; List of 1\n#&gt;  $ a: int [1:3] 1 2 3\n\nstr(l[4])\n#&gt; List of 1\n#&gt;  $ d:List of 2\n#&gt;   ..$ : num -1\n#&gt;   ..$ : num -5\n\nΌπως και με τα διανύσματα, μπορείτε να δημιουργήσετε υποσύνολα χρησιμοποιώντας διανύσματα λογικών τιμών, ακέραιων αριθμών ή χαρακτήρων.\n\n\nΤα [[ και $ εξάγουν ένα μόνο στοιχείο από μία λίστα. Αφαιρούν ένα επίπεδο από τη λίστα.\n\nstr(l[[1]])\n#&gt;  int [1:3] 1 2 3\n\nstr(l[[4]])\n#&gt; List of 2\n#&gt;  $ : num -1\n#&gt;  $ : num -5\n\nstr(l$a)\n#&gt;  int [1:3] 1 2 3\n\n\n\nΗ διαφορά μεταξύ [ και [[ είναι ιδιαίτερα σημαντική για τις λίστες, επειδή το [[ εμβαθύνει στη λίστα ενώ το [ επιστρέφει μία νέα, μικρότερη λίστα. Για να σας βοηθήσουμε να θυμάστε τη διαφορά, ρίξτε μία ματιά στην ασυνήθιστη πιπεριέρα στο Σχήμα 27.1. Εάν η πιπεριέρα είναι η λίστα σας με όνομα pepper, τότε, το pepper[1] είναι μία πιπεριέρα που περιέχει ένα μόνο φακελάκι πιπεριού. Το pepper[2] θα ήταν το ίδιο, αλλά θα περιέχει το δεύτερο φακελάκι. Το pepper[1:2] θα ήταν μία πιπεριέρα με δύο φακελάκια πιπεριού. Το pepper[[1]] θα εξάγει το ίδιο το φακελάκι πιπεριού.\n\n\n\n\n\n\n\nΣχήμα 27.1: (Αριστερά) Μία πιπεριέρα που βρήκε κάποτε ο Χάντλεϊ στο δωμάτιο του ξενοδοχείου του. (Μέση) pepper[1]. (Δεξιά) pepper[[1]]\n\n\n\n\nΗ ίδια αρχή ισχύει όταν χρησιμοποιείτε το μονοδιάστατο [ σε ένα πλαίσιο δεδομένων: το df[\"x\"] επιστρέφει ένα πλαίσιο δεδομένων μίας στήλης και το df[[\"x\"]] επιστρέφει ένα διάνυσμα.\n\n27.3.4 Ασκήσεις\n\nΤι συμβαίνει όταν χρησιμοποιείτε το [[ με έναν θετικό ακέραιο που είναι μεγαλύτερος από το μήκος του διανύσματος; Τι συμβαίνει όταν δημιουργείτε ένα υποσυνόλου χρησιμοποιώντας ένα όνομα που δεν υπάρχει;\nΤι θα μπορούσε να είναι το pepper[[1]][1]; Το pepper[[1]][[1]];",
    "crumbs": [
      "Προγραμματισμός",
      "<span class='chapter-number'>27</span>  <span class='chapter-title'>Ένας οδηγός για το βασικό σύνολο λειτουργιών της R</span>"
    ]
  },
  {
    "objectID": "base-R.html#οικογένεια-συναρτήσεων-apply",
    "href": "base-R.html#οικογένεια-συναρτήσεων-apply",
    "title": "27  Ένας οδηγός για το βασικό σύνολο λειτουργιών της R",
    "section": "\n27.4 Οικογένεια συναρτήσεων apply",
    "text": "27.4 Οικογένεια συναρτήσεων apply\nΣτο Κεφάλαιο 26, μάθατε τεχνικές σχετικές με το tidyverse για επανάληψη, όπως την dplyr::across() και την οικογένεια συναρτήσεων map. Σε αυτήν την ενότητα, θα μάθετε για τα βασικά τους ισοδύναμα, την οικογένεια συναρτήσεων apply. Σε αυτό το πλαίσιο, η apply και η map είναι συνώνυμες επειδή ένας άλλος τρόπος να πούμε “αντιστοίχιση (map) μιας συνάρτησης σε κάθε στοιχείο ενός διανύσματος” είναι “εφαρμογή (apply) μιας συνάρτησης σε κάθε στοιχείο ενός διανύσματος”. Εδώ θα σας δώσουμε μία γρήγορη επισκόπηση αυτής της οικογένειας συναρτήσεων, ώστε να μπορείτε να την αναγνωρίσετε εκεί έξω.\nΤο πιο σημαντικό μέλος αυτής της οικογένειας είναι η lapply(), η οποία μοιάζει πολύ με τη purrr::map()3. Στην πραγματικότητα, επειδή δεν έχουμε χρησιμοποιήσει καμία από τις πιο προχωρημένες δυνατότητες της map(), μπορείτε να αντικαταστήσετε κάθε κλήση της map() στο Κεφάλαιο 26 με την lapply().\nΔεν υπάρχει ακριβής αντιστοίχιση του βασικού συνόλου λειτουργιών της R με την across(), αλλά μπορείτε να έρθετε αρκετά κοντά χρησιμοποιώντας το [ με την lapply(). Αυτό λειτουργεί επειδή στο παρασκήνιο, τα πλαίσια δεδομένων είναι λίστες στηλών, επομένως η κλήση της lapply() σε ένα πλαίσιο δεδομένων εφαρμόζει τη συνάρτηση σε κάθε στήλη.\n\ndf &lt;- tibble(a = 1, b = 2, c = \"a\", d = \"b\", e = 4)\n\n# Πρώτα βρείτε τις αριθμητικές στήλες\nnum_cols &lt;- sapply(df, is.numeric)\nnum_cols\n#&gt;     a     b     c     d     e \n#&gt;  TRUE  TRUE FALSE FALSE  TRUE\n\n# Στη συνέχεια, αλλάξτε κάθε στήλη με την lapply() και αντικαταστήστε τις αρχικές τιμές\ndf[, num_cols] &lt;- lapply(df[, num_cols, drop = FALSE], \\(x) x * 2)\ndf\n#&gt; # A tibble: 1 × 5\n#&gt;       a     b c     d         e\n#&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt;\n#&gt; 1     2     4 a     b         8\n\nΟ παραπάνω κώδικας χρησιμοποιεί μία νέα συνάρτηση, την sapply(). Είναι παρόμοια με την lapply(), αλλά προσπαθεί πάντα να απλοποιήσει το αποτέλεσμα, εξ ου και το s στο όνομά της. Εδώ παράγει ένα λογικό διάνυσμα αντί για μία λίστα. Δεν συνιστούμε να τη χρησιμοποιήσετε για τη δημιουργία προγραμμάτων, επειδή η απλοποίηση μπορεί να αποτύχει και να σας δώσει έναν απροσδόκητο τύπο δεδομένων. Συνήθως όμως είναι καλή για διαδραστική χρήση. Η purrr έχει μία παρόμοια συνάρτηση που ονομάζεται map_vec() που δεν αναφέραμε στο Κεφάλαιο 26.\nΤο βασικό σύνολο της R παρέχει μία πιο αυστηρή έκδοση της sapply() που ονομάζεται vapply(), συντομογραφία για το vector apply. Παίρνει ένα πρόσθετο όρισμα που καθορίζει τον αναμενόμενο τύπο, διασφαλίζοντας ότι η απλοποίηση γίνεται με τον ίδιο τρόπο ανεξάρτητα από την είσοδο. Για παράδειγμα, θα μπορούσαμε να αντικαταστήσουμε την κλήση της sapply() παραπάνω με αυτήν της vapply() όπου προσδιορίζουμε ότι αναμένουμε από την is.numeric() να επιστρέψει ένα λογικό διάνυσμα μήκους 1:\n\nvapply(df, is.numeric, logical(1))\n#&gt;     a     b     c     d     e \n#&gt;  TRUE  TRUE FALSE FALSE  TRUE\n\nΗ διαφορά μεταξύ των sapply() και vapply() είναι πολύ σημαντική όταν βρίσκονται μέσα σε μία συνάρτηση (καθώς επηρεάζεται η ανθεκτικότητα της συνάρτησης σε ασυνήθιστες εισόδους), αλλά συνήθως δεν έχει σημασία στην ανάλυση δεδομένων.\nΈνα άλλο σημαντικό μέλος της οικογένειας συναρτήσεων apply είναι η tapply() η οποία υπολογίζει μία ενιαία ομαδοποιημένη σύνοψη:\n\ndiamonds |&gt; \n  group_by(cut) |&gt; \n  summarize(price = mean(price))\n#&gt; # A tibble: 5 × 2\n#&gt;   cut       price\n#&gt;   &lt;ord&gt;     &lt;dbl&gt;\n#&gt; 1 Fair      4359.\n#&gt; 2 Good      3929.\n#&gt; 3 Very Good 3982.\n#&gt; 4 Premium   4584.\n#&gt; 5 Ideal     3458.\n\ntapply(diamonds$price, diamonds$cut, mean)\n#&gt;      Fair      Good Very Good   Premium     Ideal \n#&gt;  4358.758  3928.864  3981.760  4584.258  3457.542\n\nΔυστυχώς, η tapply() επιστρέφει τα αποτελέσματά της σε ένα διάνυσμα με όνομα και απαιτεί κάποια προσπάθεια εάν θέλετε να συλλέξετε πολλές περιλήψεις και μεταβλητές ομαδοποίησης σε ένα πλαίσιο δεδομένων (είναι σίγουρα εφικτό το να μην το κάνετε αυτό και απλώς να εργαστείτε με ξεχωριστά διανύσματα, αλλά κατά την εμπειρία μας αυτό απλώς καθυστερεί την δουλειά που πρέπει να γίνει). Αν θέλετε να δείτε πώς μπορείτε να χρησιμοποιήσετε την tapply() ή άλλες βασικές τεχνικές για να εκτελέσετε άλλες ομαδοποιημένες περιλήψεις, ο Hadley έχει συγκεντρώσει μερικές τεχνικές σε ένα gist.\nΤο τελευταίο μέλος της οικογένειας apply είναι η apply(), η οποία λειτουργεί με μητρώα και arrays. Πιο αναλυτικά, προσέξτε την apply(df, 2, something), που είναι ένας αργός και δυνητικά επικίνδυνος τρόπος για να εφαρμόσετε την lapply(df, something). Αυτό σπάνια εμφανίζεται στην επιστήμη δεδομένων επειδή συνήθως εργαζόμαστε με πλαίσια δεδομένων και όχι με μητρώα.",
    "crumbs": [
      "Προγραμματισμός",
      "<span class='chapter-number'>27</span>  <span class='chapter-title'>Ένας οδηγός για το βασικό σύνολο λειτουργιών της R</span>"
    ]
  },
  {
    "objectID": "base-R.html#βρόγχοι-for",
    "href": "base-R.html#βρόγχοι-for",
    "title": "27  Ένας οδηγός για το βασικό σύνολο λειτουργιών της R",
    "section": "\n27.5 Βρόγχοι for\n",
    "text": "27.5 Βρόγχοι for\n\nΟι βρόγχοι for είναι το θεμελιώδες δομικό στοιχείο της επανάληψης που χρησιμοποιούν και οι οικογένειες apply και map στο παρασκήνιο Οι βρόγχοι for είναι ισχυρά και γενικά εργαλεία που είναι σημαντικό να μάθετε καθώς γίνεστε πιο έμπειρος προγραμματιστής στην R. Η βασική δομή ενός βρόγχου for μοιάζει με το εξής:\n\nfor (element in vector) {\n  # εφαρμόστε οτιδήποτε με την element\n}\n\nΗ πιο απλή χρήση των βρόγχων for είναι είναι για την επίτευξη του ίδιου αποτελέσματος με την walk(): η κλήση κάποιας συνάρτησης με κάποιο αποτέλεσμα σε κάθε στοιχείο μιας λίστας. Για παράδειγμα, στην Ενότητα 26.4.1 αντί να χρησιμοποιήσετε τη walk():\n\npaths |&gt; walk(append_file)\n\nΘα μπορούσαμε να χρησιμοποιήσουμε έναν βρόγχο for:\n\nfor (path in paths) {\n  append_file(path)\n}\n\nΤα πράγματα γίνονται λίγο πιο δύσκολα αν θέλετε να αποθηκεύσετε την έξοδο του βρόγχου for, για παράδειγμα η ανάγνωση όλων των αρχείων excel σε έναν κατάλογο όπως κάναμε στο Κεφάλαιο 26:\n\npaths &lt;- dir(\"data/gapminder\", pattern = \"\\\\.xlsx$\", full.names = TRUE)\nfiles &lt;- map(paths, readxl::read_excel)\n\nΥπάρχουν μερικές διαφορετικές τεχνικές που μπορείτε να χρησιμοποιήσετε, αλλά σας συνιστούμε να είστε ξεκάθαροι σχετικά με το πώς θα είναι το αποτέλεσμα εκ των προτέρων. Σε αυτήν την περίπτωση, θα θέλουμε μία λίστα με το ίδιο μήκος με το paths, την οποία μπορούμε να δημιουργήσουμε με την vector():\n\nfiles &lt;- vector(\"list\", length(paths))\n\nΣτη συνέχεια, αντί να επαναλαμβάνουμε τις διαδικασίες μας στα στοιχεία του paths, θα τις επαναλαμβάνουμε στους δείκτες τους, χρησιμοποιώντας τη seq_along() για να δημιουργήσουμε ένα ευρετήριο για κάθε στοιχείο του paths:\n\nseq_along(paths)\n#&gt;  [1]  1  2  3  4  5  6  7  8  9 10 11 12\n\nΗ χρήση των δεικτών είναι σημαντική γιατί μας επιτρέπει να συνδέσουμε κάθε θέση στην είσοδο με την αντίστοιχη θέση στην έξοδο:\n\nfor (i in seq_along(paths)) {\n  files[[i]] &lt;- readxl::read_excel(paths[[i]])\n}\n\nΓια να συνδυάσετε τη λίστα των tibbles σε ένα μόνο tibble, μπορείτε να χρησιμοποιήσετε τις do.call() + rbind():\n\ndo.call(rbind, files)\n#&gt; # A tibble: 1,704 × 5\n#&gt;   country     continent lifeExp      pop gdpPercap\n#&gt;   &lt;chr&gt;       &lt;chr&gt;       &lt;dbl&gt;    &lt;dbl&gt;     &lt;dbl&gt;\n#&gt; 1 Afghanistan Asia         28.8  8425333      779.\n#&gt; 2 Albania     Europe       55.2  1282697     1601.\n#&gt; 3 Algeria     Africa       43.1  9279525     2449.\n#&gt; 4 Angola      Africa       30.0  4232095     3521.\n#&gt; 5 Argentina   Americas     62.5 17876956     5911.\n#&gt; 6 Australia   Oceania      69.1  8691212    10040.\n#&gt; # ℹ 1,698 more rows\n\nΑντί να δημιουργήσουμε μία λίστα και να αποθηκεύουμε εκεί τα αποτελέσματα καθώς προχωράμε, μία απλούστερη προσέγγιση είναι να δημιουργήσουμε το πλαίσιο δεδομένων κομμάτι-κομμάτι:\n\nout &lt;- NULL\nfor (path in paths) {\n  out &lt;- rbind(out, readxl::read_excel(path))\n}\n\nΣυνιστούμε να αποφύγετε αυτό το μοτίβο γιατί μπορεί να γίνει αρκετά αργό όταν το διάνυσμα είναι πολύ μεγάλο. Αυτή είναι και η πηγή του μύθου ότι οι βρόγχοι for είναι αργοί: δεν είναι, αλλά το να αυξάνεται προοδευτικά ένα διάνυσμα, είναι.",
    "crumbs": [
      "Προγραμματισμός",
      "<span class='chapter-number'>27</span>  <span class='chapter-title'>Ένας οδηγός για το βασικό σύνολο λειτουργιών της R</span>"
    ]
  },
  {
    "objectID": "base-R.html#διαγράμματα",
    "href": "base-R.html#διαγράμματα",
    "title": "27  Ένας οδηγός για το βασικό σύνολο λειτουργιών της R",
    "section": "\n27.6 Διαγράμματα",
    "text": "27.6 Διαγράμματα\nΠολλοί χρήστες της R, που δεν χρησιμοποιούν υπό άλλες συνθήκες το tidyverse, προτιμούν το πακέτο ggplot2 για σχεδίαση, λόγω των χρήσιμων χαρακτηριστικών της, όπως οι λογικές προεπιλογές, τα αυτοματοποιημένα υπομνήματα και η μοντέρνα εμφάνιση. Ωστόσο, οι βασικές συναρτήσεις σχεδίασης της R μπορούν να είναι ακόμα χρήσιμες μόνο και μόνο επειδή επειδή είναι τόσο συνοπτικές — χρειάζεται πολύ λίγη πληκτρολόγηση για να κάνετε ένα απλό εξερευνητικό διάγραμμα.\nΥπάρχουν δύο κύριοι τύποι απλών διαγραμμάτων που θα δείτε εκεί έξω: διαγράμματα διασποράς και ιστογράμματα, που παράγονται με τις plot() και hist() αντίστοιχα. Ακολουθεί ένα γρήγορο παράδειγμα από το σύνολο δεδομένων diamonds:\n# Αριστερά\nhist(diamonds$carat)\n\n# Δεξιά\nplot(diamonds$carat, diamonds$price)\n\n\n\n\n\n\n\n\n\n\nΣημειώστε ότι οι βασικές συναρτήσεις διαγραμμάτων λειτουργούν με διανύσματα, επομένως πρέπει να επιλέξετε στήλες από το πλαίσιο δεδομένων χρησιμοποιώντας το $ ή κάποια άλλη τεχνική.",
    "crumbs": [
      "Προγραμματισμός",
      "<span class='chapter-number'>27</span>  <span class='chapter-title'>Ένας οδηγός για το βασικό σύνολο λειτουργιών της R</span>"
    ]
  },
  {
    "objectID": "base-R.html#σύνοψη",
    "href": "base-R.html#σύνοψη",
    "title": "27  Ένας οδηγός για το βασικό σύνολο λειτουργιών της R",
    "section": "\n27.7 Σύνοψη",
    "text": "27.7 Σύνοψη\nΣε αυτό το κεφάλαιο, σας δείξαμε μία επιλογή από βασικές συναρτήσεις της R που είναι χρήσιμες για την δημιουργία υποσυνόλων και για την επανάληψη. Σε σύγκριση με προσεγγίσεις που συζητούνται αλλού στο βιβλίο, αυτές οι συναρτήσεις τείνουν να έχουν περισσότερο άρωμα “διανύσματος” παρά “πλαισίου δεδομένων”, επειδή οι βασικές συναρτήσεις της R τείνουν να λαμβάνουν μεμονωμένα διανύσματα ως είσοδο, παρά ένα πλαίσιο δεδομένων μαζί με προδιαγραφές στηλών. Αυτό συχνά, στον προγραμματισμό, κάνει τη ζωή πιο εύκολη και γι’ αυτό γίνεται πιο σημαντικό καθώς γράφετε περισσότερες συναρτήσεις και αρχίζετε να γράφετε τα δικά σας πακέτα.\nΑυτό το κεφάλαιο ολοκληρώνει την ενότητα προγραμματισμού του βιβλίου. Έχετε κάνει μία καλή αρχή στο ταξίδι σας για να γίνετε όχι απλώς ένας επιστήμονας δεδομένων που χρησιμοποιεί την R, αλλά ένας επιστήμονας δεδομένων που μπορεί να προγραμματίσει σε R. Ελπίζουμε ότι αυτά τα κεφάλαια έχουν κεντρίσει το ενδιαφέρον σας για τον προγραμματισμό και ότι ανυπομονείτε να μάθετε περισσότερα εκτός αυτού του βιβλίου.",
    "crumbs": [
      "Προγραμματισμός",
      "<span class='chapter-number'>27</span>  <span class='chapter-title'>Ένας οδηγός για το βασικό σύνολο λειτουργιών της R</span>"
    ]
  },
  {
    "objectID": "base-R.html#footnotes",
    "href": "base-R.html#footnotes",
    "title": "27  Ένας οδηγός για το βασικό σύνολο λειτουργιών της R",
    "section": "",
    "text": "Διαβάστε το https://adv-r.hadley.nz/subsetting.html#subset-multiple για να δείτε πώς μπορείτε επίσης να ορίσετε ένα υποσύνολο σε ένα πλαίσιο δεδομένων σαν να είναι αντικείμενο μίας διάστασης και πώς μπορείτε να δημιουργήσετε ένα υποσύνολο με ένα μητρώο.↩︎\nΩστόσο, δεν χειρίζεται ομαδοποιημένα πλαίσια δεδομένων με διαφορετικό τρόπο και δεν υποστηρίζει βοηθητικές συναρτήσεις επιλογής όπως η starts_with().↩︎\nΑπλώς δεν διαθέτει βολικές λειτουργίες, όπως καταστάσεις προόδου και αναφορές για το ποιο στοιχείο προκάλεσε το πρόβλημα εάν υπάρχει σφάλμα.↩︎",
    "crumbs": [
      "Προγραμματισμός",
      "<span class='chapter-number'>27</span>  <span class='chapter-title'>Ένας οδηγός για το βασικό σύνολο λειτουργιών της R</span>"
    ]
  },
  {
    "objectID": "communicate.html",
    "href": "communicate.html",
    "title": "Επικοινωνία της πληροφορίας",
    "section": "",
    "text": "Μέχρι στιγμής, έχετε μάθει τα εργαλεία που χρειάζεστε για να μεταφέρετε τα δεδομένα σας στην R, να τα τακτοποιήσετε σε μία μορφή κατάλληλη για ανάλυση και, στη συνέχεια, να κατανοήσετε τα δεδομένα σας μέσω μετασχηματισμού και οπτικοποίησης. Ωστόσο, δεν έχει σημασία πόσο αξιόλογη είναι η ανάλυσή σας, εκτός αν μπορείτε να την εξηγήσετε σε άλλους: πρέπει να επικοινωνήσετε τα αποτελέσματά σας.\n\n\n\n\n\n\n\nΣχήμα 1: Η επικοινωνία είναι το τελευταίο μέρος της διαδικασίας της επιστήμης των δεδομένων. Εάν δεν μπορείτε να επικοινωνήσετε τα αποτελέσματά σας σε άλλους, δεν έχει σημασία πόσο καλή είναι η ανάλυσή σας.\n\n\n\n\nΗ επικοινωνία είναι το θέμα των επόμενων δύο κεφαλαίων:\n\nΣτο 28  Quarto, θα μάθετε για το Quarto, ένα εργαλείο για την ενοποίηση πεζού λόγου, κώδικα και αποτελεσμάτων. Μπορείτε να χρησιμοποιήσετε το Quarto για επικοινωνία τόσο με άλλους αναλυτές όσο και με τους υπευθύνους για τη λήψη αποφάσεων. Χάρη στη δύναμη των μορφών που προσφέρει το Quarto, μπορείτε ακόμη και να χρησιμοποιήσετε το ίδιο έγγραφο και για τους δύο σκοπούς.\nΣτο 29  Επιλογές μορφοποίησης στο Quarto, θα μάθετε λίγα πράγματα για τις πολλές άλλες επιλογές αρχείων εξόδου που μπορείτε να παράγετε χρησιμοποιώντας το Quarto, συμπεριλαμβανομένων των dashboards, των ιστοτόπων και των βιβλίων.\n\nΑυτά τα κεφάλαια επικεντρώνονται κυρίως στους τεχνικούς μηχανισμούς της επικοινωνίας, όχι στα πραγματικά δύσκολα προβλήματα της επικοινωνίας των σκέψεών σας σε άλλους ανθρώπους. Ωστόσο, υπάρχουν πολλά άλλα σπουδαία βιβλία για την επικοινωνία, τα οποία θα σας αναφέρουμε στο τέλος κάθε κεφαλαίου.",
    "crumbs": [
      "Επικοινωνία της πληροφορίας"
    ]
  },
  {
    "objectID": "quarto.html",
    "href": "quarto.html",
    "title": "28  Quarto",
    "section": "",
    "text": "28.1 Εισαγωγή\nΤο Quarto παρέχει ένα ενοποιημένο πλαίσιο συγγραφής για την επιστήμη δεδομένων, συνδυάζοντας τον κώδικά σας, τα αποτελέσματά του και το κείμενο σας. Τα έγγραφα Quarto είναι πλήρως αναπαράξιμα και υποστηρίζουν εύρος αρχείων εξόδου, όπως PDF, αρχεία Word, παρουσιάσεις και άλλα.\nΤα αρχεία Quarto έχουν σχεδιαστεί για να χρησιμοποιούνται με τρεις τρόπους:\nΤο Quarto είναι ένα εργαλείο διεπαφής που βασίζεται σε γραμμή εντολών, κι όχι ένα πακέτο R. Αυτό σημαίνει ότι η εύρεση βοηθητικού υλικού, κατά πλειοψηφία, μη διαθέσιμη με τον τελεστή ?. Αντί γι αυτό, καθώς δουλεύετε στη διάρκεια αυτό του κεφαλαίου, αλλά και όταν θα χρησιμοποιείτε το Quarto στο μέλλον, είναι καλύτερο να αναφέρεστε στο εγχειρίδιο του Quarto.\nΕάν είστε χρήστης του R Markdown, μπορεί να σκέφτεστε “Το Quarto ακούγεται πολύ σαν το R Markdown”. Και δεν κάνετε λάθος! Το Quarto ενοποιεί τη λειτουργικότητα πολλών πακέτων από το οικοσύστημα του R Markdown (rmarkdown, bookdown, distill, xaringan, κ.λπ.) σε ένα ενιαίο, συνεπές σύστημα και το επεκτείνει με εγγενή υποστήριξη για πολλές γλώσσες προγραμματισμού όπως η Python και η Julia εκτός από την R. Κατά κάποιο τρόπο, το Quarto αντικατοπτρίζει όλα όσα μάθαμε από την επέκταση και την υποστήριξη του οικοσυστήματος του R Markdown για μία δεκαετία.",
    "crumbs": [
      "Επικοινωνία της πληροφορίας",
      "<span class='chapter-number'>28</span>  <span class='chapter-title'>Quarto</span>"
    ]
  },
  {
    "objectID": "quarto.html#εισαγωγή",
    "href": "quarto.html#εισαγωγή",
    "title": "28  Quarto",
    "section": "",
    "text": "Για επικοινωνία με τους υπεύθυνους για τη λήψη αποφάσεων, οι οποίοι θέλουν να εστιάσουν στα συμπεράσματα της ανάλυσης, κι όχι στον κώδικα πίσω από αυτήν.\nΓια συνεργασία με άλλους επιστήμονες δεδομένων (συμπεριλαμβανομένου και του μελλοντικού σας εαυτού), οι οποίοι ενδιαφέρονται τόσο στα συμπεράσματα σας, όσο και στο πως καταλήξατε σε αυτά (δηλαδή στον κώδικα σας).\nΩς ένα περιβάλλον στο οποίο μπορείτε να ασκείτε την επιστήμη των δεδομένων, ένα σύγχρονο τετράδιο εργαστηρίου, στο οποίο καταγράφετε όχι μόνο ότι κάνατε, αλλά και τι σκεφτόσασταν.\n\n\n\n\n28.1.1 Προαπαιτούμενα\nΧρειάζεστε τη διεπαφή γραμμής εντολών του Quarto (Quarto CLI), αλλά δεν χρειάζεται να την εγκαταστήσετε ή να την φορτώσετε, καθώς το RStudio κάνει αυτόματα και τα δύο όταν χρειάζεται.",
    "crumbs": [
      "Επικοινωνία της πληροφορίας",
      "<span class='chapter-number'>28</span>  <span class='chapter-title'>Quarto</span>"
    ]
  },
  {
    "objectID": "quarto.html#βασικά-στοιχεία-του-quarto",
    "href": "quarto.html#βασικά-στοιχεία-του-quarto",
    "title": "28  Quarto",
    "section": "\n28.2 Βασικά στοιχεία του Quarto",
    "text": "28.2 Βασικά στοιχεία του Quarto\nΑυτό είναι ένα αρχείο Quarto – ένα απλό αρχείο κειμένου με την κατάληξη .qmd στο όνομα του:\n\n---\ntitle: \"Diamond sizes\"\ndate: 2022-09-12\nformat: html\n---\n\n```{r}\n#| label: setup\n#| include: false\n\nlibrary(tidyverse)\n\nsmaller &lt;- diamonds |&gt; \n  filter(carat &lt;= 2.5)\n```\n\nWe have data about `r nrow(diamonds)` diamonds.\nOnly `r nrow(diamonds) - nrow(smaller)` are larger than 2.5 carats.\nThe distribution of the remainder is shown below:\n\n```{r}\n#| label: plot-smaller-diamonds\n#| echo: false\n\nsmaller |&gt; \n  ggplot(aes(x = carat)) + \n  geom_freqpoly(binwidth = 0.01)\n```\n\nΠεριέχει τρεις σημαντικούς τύπους περιεχομένου:\n\nΜία (προαιρετική) YAML κεφαλίδα που περιβάλλεται από ---.\n\nΤμήματα κώδικα R που περιβάλλονται από ```.\nΚείμενο μαζί με απλό κείμενο που περιέχει μορφοποιήσεις, όπως για παράδειγμα # heading και _italics_.\n\nΤο Σχήμα 28.1 παρουσιάζει ένα .qmd έγγραφο στο RStudio με διεπαφή σημειωματαρίου, όπου ο κώδικας και το αποτέλεσμα του παρεμβάλλονται. Μπορείτε να εκτελέσετε κάθε κομμάτι κώδικα κάνοντας κλικ στο εικονίδιο Run (Εκτέλεση, μοιάζει με κουμπί αναπαραγωγής στο επάνω μέρος του τμήματος - chunk) ή πατώντας Cmd/Ctrl + Shift + Enter. Το RStudio εκτελεί τον κώδικα και εμφανίζει τα αποτελέσματα\n\n\n\n\n\n\n\nΣχήμα 28.1: Ένα έγγραφο Quarto στο RStudio. Ο κώδικάς και η έξοδος παρεμβάλλονται στο έγγραφο, με το διάγραμμα να εμφανίζεται στα δεξιά κάτω απο τον κώδικα.\n\n\n\n\nΕάν δεν σας αρέσει να βλέπετε τα διαγράμματα και το αποτέλεσμα του κώδικα σας ως μέρος του εγγράφου σας και προτιμάτε να χρησιμοποιήσετε την Κονσόλα και τα παράθυρα Plot του RStudio, μπορείτε να κάνετε κλικ στο εικονίδιο με το γρανάζι δίπλα στο “Render” και να μεταβείτε στο “Chunk Output in Console”, όπως φαίνεται στο Σχήμα 28.2.\n\n\n\n\n\n\n\nΣχήμα 28.2: Ένα έγγραφο Quarto στο RSudio με το διάγραμμα στο παράθυρο Plots.\n\n\n\n\nΓια να δημιουργήσετε μία πλήρη αναφορά που περιέχει όλο το κείμενο, τον κώδικα και τα αποτελέσματα, πατήστε την επιλογή “Render” ή πατήστε Cmd/Ctrl + Shift + K. Μπορείτε επίσης να το κάνετε και προγραμματιστικά, με την εντολή quarto::quarto_render(\"diamond-sizes.qmd\"). Αυτή θα εμφανίσει την αναφορά στο παράθυρο προβολής όπως φαίνεται στο Σχήμα 28.3 και θα δημιουργήσει ένα αρχείο HTML.\n\n\n\n\n\n\n\nΣχήμα 28.3: Ένα έγγραφο Quarto στο RStudio με το έγγραφο να εμφανίζεται στο παράθυρο Viewer.\n\n\n\n\nΌταν δημιουργείτε το έγγραφο εξόδου, το Quarto στέλνει το αρχείο .qmd στη knitr, https://yihui.org/knitr/, η οποία εκτελεί όλα τα κομμάτια κώδικα και δημιουργεί ένα νέο αρχείο markdown (.md) που περιλαμβάνει τον κώδικα σας και το αποτέλεσμα του. Στη συνέχεια, το αρχείο markdown που δημιουργείται από τη knitr επεξεργάζεται από την pandoc, https://pandoc.org, η οποία είναι υπεύθυνη για τη δημιουργία του ολοκληρωμένου αρχείου. Αυτή η διαδικασία παρουσιάζεται στο Σχήμα 28.4. Το πλεονέκτημα αυτής της ροής εργασίας δύο βημάτων είναι ότι μπορείτε να δημιουργήσετε ένα πολύ ευρύ φάσμα μορφών εξόδου, όπως θα μάθετε στο Κεφάλαιο 29.\n\n\n\n\n\n\n\nΣχήμα 28.4: Διάγραμμα μίας ροής εργασίας Quarto αρχίζοντας από qmd, σε knitr, σε md, σε pandoc, σε έξοδο ως PDF, MS Word ή HTML.\n\n\n\n\nΓια να αρχίσετε με το δικό σας .qmd αρχείο, επιλέξτε File &gt; New File &gt; Quarto Document… στη γραμμή επιλογών. Το RStudio θα εκκινήσει έναν οδηγό που μπορείτε να χρησιμοποιήσετε για να συμπληρώσετε εκ των προτέρων το αρχείο σας με χρήσιμο περιεχόμενο που σας υπενθυμίζει πώς λειτουργούν τα βασικά στοιχεία του Quarto.\nΟι ακόλουθες ενότητες εξετάζουν τα τρία στοιχεία ενός εγγράφου Quarto με περισσότερες λεπτομέρειες: το κείμενο markdown, τα τμήματα κώδικα και την κεφαλίδα YAML.\n\n28.2.1 Ασκήσεις\n\nΔημιουργήστε ένα νέο έγγραφο Quarto ακολουθώντας τα βήματα File &gt; New File &gt; Quarto Document. Διαβάστε τις οδηγίες. Εξασκηθείτε στο να τρέχετε τα τμήματα κώδικα μεμονωμένα. Στη συνέχεια, δημιουργήστε το τελικό έγγραφο εξόδου κάνοντας κλικ στο κατάλληλο κουμπί και, στη επαναλάβετε το, χρησιμοποιώντας αυτή την φορά την κατάλληλη συντόμευση πληκτρολογίου. Βεβαιωθείτε ότι μπορείτε να τροποποιήσετε τον κώδικα, να τον εκτελέσετε ξανά και να δείτε την τροποποιημένη έξοδο.\nΔημιουργήστε ένα νέο έγγραφο Quarto για καθεμία από τις τρεις ενσωματωμένες μορφές: HTML, PDF και Word. Δημιουργήστε τα αρχεία εξόδου για κάθε μία από τις τρεις μορφές. Πώς διαφέρουν οι έξοδοι; Πώς διαφέρουν οι είσοδοι; (Μπορεί να χρειαστεί να εγκαταστήσετε το LaTeX για να δημιουργήσετε την έξοδο PDF — Το RStudio θα σας το ζητήσει εάν είναι απαραίτητο.)",
    "crumbs": [
      "Επικοινωνία της πληροφορίας",
      "<span class='chapter-number'>28</span>  <span class='chapter-title'>Quarto</span>"
    ]
  },
  {
    "objectID": "quarto.html#οπτικό-πρόγραμμα-επεξεργασίας-visual-editor",
    "href": "quarto.html#οπτικό-πρόγραμμα-επεξεργασίας-visual-editor",
    "title": "28  Quarto",
    "section": "\n28.3 Οπτικό πρόγραμμα επεξεργασίας (Visual editor)",
    "text": "28.3 Οπτικό πρόγραμμα επεξεργασίας (Visual editor)\nΤο οπτικό πρόγραμμα επεξεργασίας του RStudio παρέχει μία διεπαφή WYSIWYM για τη σύνταξη εγγράφων Quarto. Στο παρασκήνιο, το κείμενα αρχείων Quarto (αρχεία .qmd) είναι γραμμένα σε Markdown, ένα ελαφρύ σύνολο συμβάσεων για τη μορφοποίηση αρχείων απλού κειμένου. Στην πραγματικότητα, το Quarto χρησιμοποιεί Pandoc markdown (μια ελαφρώς εκτεταμένη έκδοση του Markdown που το Quarto κατανοεί), και περιλαμβάνει πίνακες, βιβλιογραφικές αναφορές, παραπομπές, υποσημειώσεων, divs/spans στοιχεία HTML, λίστες ορισμών, ορίσματα, ακατέργαστο HTML/TeX και πολλά άλλα καθώς και υποστήριξη για την εκτέλεση κελιών κώδικα και την προβολή της εξόδου τους ενσωματωμένη στο ίδιο αρχείο. Ενώ το Markdown έχει σχεδιαστεί για να είναι εύκολο στην ανάγνωση και τη γραφή, όπως θα δείτε στην Ενότητα 28.4, εξακολουθεί να απαιτεί την εκμάθηση ενός νέου τρόπου σύνταξης. Επομένως, εάν είστε νέος στα υπολογιστικά έγγραφα όπως τα αρχεία .qmd, αλλά έχετε εμπειρία στη χρήση εργαλείων όπως τα Έγγραφα Google ή το MS Word, ο ευκολότερος τρόπος για να ξεκινήσετε με το Quarto στο RStudio είναι το οπτικό πρόγραμμα επεξεργασίας.\nΣτο οπτικό πρόγραμμα επεξεργασίας μπορείτε είτε να χρησιμοποιήσετε τα κουμπιά στη γραμμή επιλογών για να εισάγετε εικόνες, πίνακες, παραπομπές κ.λπ., είτε μπορείτε να χρησιμοποιήσετε τις συντομεύσεις ⌘ + / ή Ctrl + /, για να εισάγετε σχεδόν οτιδήποτε. Εάν βρίσκεστε στην αρχή μιας γραμμής (όπως φαίνεται στο Σχήμα 28.5), μπορείτε επίσης να εισάγετε απλά / για να καλέσετε τη συντόμευση.\n\n\n\n\n\n\n\nΣχήμα 28.5: Οπτικός επεξεργαστής του Quarto.\n\n\n\n\nΗ εισαγωγή εικόνων και η προσαρμογή του τρόπου εμφάνισης τους διευκολύνεται επίσης με το οπτικό πρόγραμμα επεξεργασίας. Μπορείτε είτε να επικολλήσετε μία εικόνα από το πρόχειρο σας απευθείας στο οπτικό πρόγραμμα επεξεργασίας (και το RStudio θα τοποθετήσει ένα αντίγραφο αυτής της εικόνας στο μονοπάτι του project και θα το συνδέσει σε αυτό) είτε μπορείτε να χρησιμοποιήσετε το μενού Insert (Εισαγωγή) &gt; Figure / Image (Εικόνα / Εικόνα) του προγράμματος οπτικής επεξεργασίας για να περιηγηθείτε στην εικόνα που θέλετε να εισάγετε ή να επικολλήσετε το URL που αντιστοιχεί στη διεύθυνση της. Επιπλέον, χρησιμοποιώντας το ίδιο μενού, μπορείτε να αλλάξετε το μέγεθος της εικόνας καθώς και να προσθέσετε μία λεζάντα, εναλλακτικό κείμενο και έναν σύνδεσμο.\nΤο οπτικό πρόγραμμα επεξεργασίας έχει πολλές περισσότερες δυνατότητες που δεν έχουμε αναφέρει εδώ και που μπορεί να σας φανούν χρήσιμες καθώς αποκτάτε εμπειρία συγγραφής με αυτό.\nΚαι κυρίως, ενώ το οπτικό πρόγραμμα επεξεργασίας εμφανίζει το περιεχόμενό σας με μορφοποίηση, κάτω από την κουκούλα, αποθηκεύει το περιεχόμενό σας σαν απλό Markdown και μπορείτε να κάνετε εναλλαγή μεταξύ του οπτικού προγράμματος επεξεργασίας και του προγράμματος επεξεργασίας πηγαίου κώδικα για να προβάλετε και να επεξεργαστείτε το περιεχόμενό σας χρησιμοποιώντας οποιοδήποτε εργαλείο.\n\n28.3.1 Ασκήσεις\n\nΔημιουργήστε ξανά το έγγραφο που απεικονίζεται στο Σχήμα 28.5 χρησιμοποιώντας το οπτικό πρόγραμμα επεξεργασίας.\nΧρησιμοποιώντας το οπτικό πρόγραμμα επεξεργασίας, εισάγετε ένα τμήμα κώδικα χρησιμοποιώντας το μενού Εισαγωγής (Insert) και, στη συνέχεια, το εργαλείο εισαγωγής οποιουδήποτε στοιχείου.\nΧρησιμοποιώντας το οπτικό πρόγραμμα επεξεργασίας, μάθετε πώς να:\n\nΠροσθέτετε μία υποσημείωση.\nΠροσθέτετε έναν οριζόντιο οδηγό.\nΠροσθέτετε ένα μπλοκ εισαγωγικών (block quote).\n\n\nΣτο οπτικό πρόγραμμα επεξεργασίας, μεταβείτε στο Insert &gt; Citation και εισάγετε μία αναφορά στο άρθρο με τίτλο Welcome to the Tidyverse χρησιμοποιώντας το DOI του ( ψηφιακό αναγνωριστικό αντικειμένου), το οποίο είναι 10.21105/joss.01686. Αποδώστε το τελικό έγγραφο εξόδου και παρατηρήστε πώς εμφανίζεται η αναφορά σε αυτό. Ποια αλλαγή παρατηρείτε στο YAML του εγγράφου σας;",
    "crumbs": [
      "Επικοινωνία της πληροφορίας",
      "<span class='chapter-number'>28</span>  <span class='chapter-title'>Quarto</span>"
    ]
  },
  {
    "objectID": "quarto.html#sec-source-editor",
    "href": "quarto.html#sec-source-editor",
    "title": "28  Quarto",
    "section": "\n28.4 Πρόγραμμα επεξεργασία πηγαίου κώδικα",
    "text": "28.4 Πρόγραμμα επεξεργασία πηγαίου κώδικα\nΑκόμη, μπορείτε να επεξεργαστείτε έγγραφα Quarto χρησιμοποιώντας το πρόγραμμα επεξεργασίας πηγαίου κώδικα στο RStudio, χωρίς τη βοήθεια του προγράμματος οπτικής επεξεργασίας. Ενώ το προγράμματος οπτικής επεξεργασίας θα φαίνεται οικείο σε όσους έχουν εμπειρία στη σύνταξη σε εργαλεία όπως τα έγγραφα Google, το πρόγραμμα επεξεργασίας πηγαίου κώδικα θα φαίνεται πιο οικείο σε όσους έχουν εμπειρία στη σύνταξη αρχείων κώδικα R ή εγγράφων R Markdown. Το πρόγραμμα επεξεργασίας πηγαίου κώδικα μπορεί επίσης να είναι χρήσιμο για τον εντοπισμό οποιωνδήποτε συντακτικών σφαλμάτων Quarto, καθώς συχνά είναι πιο εύκολο να τα εντοπίσετε μέσα σε απλό κείμενο.\nΟ παρακάτω οδηγός δείχνει πώς να χρησιμοποιήσετε το Markdown του Pandoc για τη σύνταξη εγγράφων Quarto στο πρόγραμμα επεξεργασίας πηγαίου κώδικα.\n\n## Text formatting\n\n*italic* **bold** ~~strikeout~~ `code`\n\nsuperscript^2^ subscript~2~\n\n[underline]{.underline} [small caps]{.smallcaps}\n\n## Headings\n\n# 1st Level Header\n\n## 2nd Level Header\n\n### 3rd Level Header\n\n## Lists\n\n-   Bulleted list item 1\n\n-   Item 2\n\n    -   Item 2a\n\n    -   Item 2b\n\n1.  Numbered list item 1\n\n2.  Item 2.\n    The numbers are incremented automatically in the output.\n\n## Links and images\n\n&lt;http://example.com&gt;\n\n[linked phrase](http://example.com)\n\n![optional caption text](quarto.png){fig-alt=\"Quarto logo and the word quarto spelled in small case letters\"}\n\n## Tables\n\n| First Header | Second Header |\n|--------------|---------------|\n| Content Cell | Content Cell  |\n| Content Cell | Content Cell  |\n\nΟ καλύτερος τρόπος για να μάθετε αυτά τα εργαλεία είναι απλά να τα δοκιμάσετε. Θα πάρει μερικές ημέρες, αλλά σύντομα θα σας γίνει δεύτερη φύση, και δεν θα χρειάζεται ούτε καν να τα σκεφτείτε. Και εάν ξεχνάτε, μπορείτε να έχετε έναν εύχρηστο οδηγό αναφοράς με το Help &gt; Markdown Quick Reference.\n\n28.4.1 Ασκήσεις\n\nΕξασκήστε ό,τι έχετε μάθει δημιουργώντας ένα σύντομο βιογραφικό σημείωμα (CV). Ο τίτλος θα πρέπει να είναι το όνομα σας και θα πρέπει να συμπεριλάβετε ως κεφαλίδες (τουλάχιστον) την εκπαίδευση ή το εργασιακά σας ιστορικό. Κάθε μία από τις ενότητες θα πρέπε να περιλαμβάνει μία λίστα με τις δουλειές ή τα πτυχία σας. Δώστε έμφαση στην χρονολογία, χρησιμοποιώντας έντονη γραμματοσειρά (bold).\n\nΧρησιμοποιώντας το πρόγραμμα επεξεργασίας πηγαίου κώδικα και τον οδηγό αναφοράς του Markdown, βρείτε πως να:\n\nΠροσθέσετε μία υποσημείωση.\nΠροσθέσετε ένα οριζόντιο χάρακα.\nΠροσθέτετε ένα μπλοκ εισαγωγικών (block quote).\n\n\nΑντιγράψτε κι επικολλήστε τα περιεχόμενα του diamond-sizes.qmd από το διεύθυνση https://github.com/hadley/r4ds/tree/main/quarto σε ένα τοπικό έγγραφο R Quarto. Ελέγξτε ότι μπορείτε να το εκτελέσετε, και στη συνέχει προσθέστε κείμενο μετά το πολύγωνο συχνοτήτων, που περιγράφει τα πιο εμφανή του χαρακτηριστικά.\nΔημιουργήστε ένα έγγραφο σε μορφή Google doc ή MS Word (ή εντοπίστε ένα έγγραφο που έχετε δημιουργήσει στο παρελθόν) που περιέχει κάποια περιεχόμενο μέσα του, όπως κεφαλίδες, υπερσυνδέσμους, μορφοποιημένο κείμενο, κλπ. Αντιγράψτε τα περιεχόμενα αυτού του εγγράφου και επικολλήστε τα σε ένα έγγραφο Quarto στο πρόγραμμα οπτικής επεξεργασίας. Στη συνέχεια, μεταβείτε στο πρόγραμμα επεξεργασία πηγαίου κώδικα και παρατηρήστε τον πηγαίο αυτό κώδικα.",
    "crumbs": [
      "Επικοινωνία της πληροφορίας",
      "<span class='chapter-number'>28</span>  <span class='chapter-title'>Quarto</span>"
    ]
  },
  {
    "objectID": "quarto.html#τμήματα-κώδικα",
    "href": "quarto.html#τμήματα-κώδικα",
    "title": "28  Quarto",
    "section": "\n28.5 Τμήματα κώδικα",
    "text": "28.5 Τμήματα κώδικα\nΓια να εκτελέσετε κώδικα μέσα σε ένα έγγραφο Quarto, πρέπει να εισάγετε ένα τμήμα κώδικα Υπάρχουν τρεις τρόποι για να γίνει αυτό:\n\nΗ συντόμευση πληκτρολογίου Cmd + Option + I / Ctrl + Alt + I.\nΤο κουμπί “Insert” στη γραμμή εργαλείων του προγράμματος επεξεργασίας.\nΠληκτρολογώντας με μη αυτόματο τρόπο τους οριοθέτες τμημάτων ```{r} και ```.\n\nΣας συνιστούμε να μάθετε τη συντόμευση πληκτρολογίου. Θα σας εξοικονομήσει πολύ χρόνο μακροπρόθεσμα!\nΜπορείτε να συνεχίσετε να εκτελείτε τον κώδικα χρησιμοποιώντας τη συντόμευση πληκτρολογίου που μέχρι τώρα (ελπίζουμε!) γνωρίζετε και αγαπάτε: Cmd/Ctrl + Enter. Ωστόσο, τα τμήματα κώδικα έχουν μία νέα συντόμευση πληκτρολογίου: Cmd/Ctrl + Shift + Enter, η οποία εκτελεί όλο τον κώδικα στο τμήμα αυτό. Σκεφτείτε ένα τμήμα σαν συνάρτηση. Ένα τμήμα θα πρέπει να είναι σχετικά αυτοτελές και να εστιάζει σε μία μεμονωμένη εργασία.\nΟι ακόλουθες ενότητες περιγράφουν την κεφαλίδα τμήματος που αποτελείται από ```{r}, ακολουθούμενη από μία προαιρετική ετικέτα τμημάτων και διάφορες άλλες επιλογές, η καθεμία στη δική της γραμμή, επισημειωμένη με #|.\n\n28.5.1 Σήμανση τμημάτων κώδικα\nΠροαιρετικά, τα τμήματα κώδικα μπορούν να λάβουν μία επισήμανση/ετικέτα, για παράδειγμα:\n\n```{r}\n#| label: simple-addition\n\n1 + 1\n```\n#&gt; [1] 2\n\nΑυτό προσφέρει τρία πλεονεκτήματα:\n\n\nΜπορείτε να πλοηγηθείτε πιο εύκολα σε συγκεκριμένα τμήματα κώδικα χρησιμοποιώντας το αναπτυσσόμενο παράθυρο πλοήγησης κώδικα στο κάτω αριστερό μέρος του παραθύρου επεξεργασίας αρχείων κώδικα:\n\n\n\n\n\n\n\n\n\nΤα γραφικά που παράγονται από τα τμήματα κώδικα θα έχουν χρήσιμα ονόματα που διευκολύνουν την αναφορά και χρήση τους σε άλλα σημεία. Θα δείτε περισσότερα γι’ αυτό στην Ενότητα 28.6.\nΜπορείτε να δημιουργήσετε δίκτυα τμημάτων κώδικα που αποθηκεύονται στην κρυφή μνήμη για να αποφύγετε την εκ νέου εκτέλεση ακριβών υπολογισμών σε κάθε εκτέλεση. Περισσότερα για αυτό στην Ενότητα 28.8.\n\nΟι ετικέτες σας θα πρέπει να είναι σύντομες αλλά εύκολο να τις θυμηθείτε και να μην περιέχουν κενά. Συνιστούμε να χρησιμοποιείτε παύλες (-) για να διαχωρίσετε λέξεις (αντί για κάτω παύλες, _) και να αποφύγετε άλλους ειδικούς χαρακτήρες σε ετικέτες.\nΓενικά, είστε ελεύθεροι να επισημάνετε το τμήμα κώδικα σας όπως θέλετε, ωστόσο υπάρχει ένα όνομα τμήματος που συνεπάγεται ειδική συμπεριφορά: το setup. Όταν βρίσκεστε σε λειτουργία σημειωματαρίου, το τμήμα με το όνομα setup θα εκτελείται αυτόματα μία φορά, πριν εκτελεστεί οποιοσδήποτε άλλος κώδικας.\nΕπιπλέον, οι ετικέτες τμημάτων δεν μπορούν να επαναχρησιμοποιούνται/είναι διπλότυπες. Κάθε ετικέτα κομματιού πρέπει να είναι μοναδική.\n\n28.5.2 Επιλογές τμημάτων κώδικα\nΗ έξοδος τμημάτων κώδικα μπορεί να προσαρμοστεί με επιλογές, πεδία που παρέχονται στην κεφαλίδα των τμημάτων. Η knitr παρέχει σχεδόν 60 επιλογές που μπορείτε να χρησιμοποιήσετε για να προσαρμόσετε τα τμήματα του κώδικα σας. Εδώ θα καλύψουμε τις πιο σημαντικές επιλογές τμημάτων που θα χρησιμοποιείτε συχνά. Μπορείτε να δείτε την πλήρη λίστα στη διεύθυνση https://yihui.org/knitr/options.\nΤο πιο σημαντικό σύνολο επιλογών ελέγχει εάν το μπλοκ κώδικα εκτελείται και ποια αποτελέσματα θα συμπεριληφθούν στην τελική αναφορά:\n\nΤο eval: false αποτρέπει την αξιολόγηση του κώδικα. (Και προφανώς αν δεν εκτελεστεί ο κώδικας, δεν θα δημιουργηθούν αποτελέσματα). Αυτό είναι χρήσιμο για την εμφάνιση παραδειγμάτων κώδικα ή για την απενεργοποίηση ενός μεγάλου μπλοκ κώδικα χωρίς να πρέπει να μετατρέψετε κάθε γραμμή σε σχόλιο.\nΤο include: false εκτελεί τον κώδικα, αλλά δεν εμφανίζει ούτε τον κώδικα, ούτε τα αποτελέσματα στο τελικό έγγραφο. Χρησιμοποιήστε αυτή την επιλογή για κώδικα με υποστηρικτικό ρόλο (setup) που δεν θέλετε να εμφανίζεται στην αναφορά σας.\nΤο echo: false αποτρέπει την εμφάνιση κώδικα, αλλά όχι των αποτελεσμάτων του στο τελικό αρχείο. Χρησιμοποιήστε το όταν γράφετε αναφορές που απευθύνονται σε άτομα που δεν θέλουν να δουν τον υποκείμενο κώδικα R.\nΤο message: false ή warning: false αποτρέπει την εμφάνιση μηνυμάτων ή προειδοποιήσεων στο τελικό αρχείο.\nΤο results: hide αποκρύπτει το αποτέλεσμα, κι αντίστοιχα το fig-show: hide κρύβει τα γραφήματα.\nΤο error: true έχει σαν αποτέλεσμα ο κώδικας που παράγει το τελικό αρχείο να συνεχίσει να τρέχει, ακόμη κι αν το αντίστοιχο τμήμα κώδικα εμφανίσει σφάλμα. Αυτό είναι σπάνια κάτι που θέλετε να συμπεριλάβετε στην τελική έκδοση της αναφοράς σας, αλλά μπορεί να είναι πολύ χρήσιμο εάν χρειάζεται να εντοπίσετε ακριβώς τι συμβαίνει μέσα στο .qmd αρχείο σας. Είναι επίσης χρήσιμο εάν διδάσκετε R και θέλετε να συμπεριλάβετε σκόπιμα ένα σφάλμα. Η προεπιλογή error: false προκαλεί την αποτυχία της μετατροπής του τελικού αρχείου εάν υπάρχει έστω κι ένα σφάλμα στο έγγραφο.\n\nΚαθεμία από αυτές τις επιλογές προστίθεται στην κεφαλίδα του τμήματος κώδικα, ακολουθώντας το #|. Για παράδειγμα, στο επόμενο τμήμα το αποτέλεσμα δεν εκτυπώνεται επειδή το eval έχει οριστεί σε false.\n\n```{r}\n#| label: simple-multiplication\n#| eval: false\n\n2 * 2\n```\n\nΟ παρακάτω πίνακας συνοψίζει ποιους τύπους ενεργειών καταστέλλει κάθε επιλογή:\n\n\n\n\n\n\n\n\n\n\n\nΕπιλογή\nΕκτέλεση\nΕμφάνιση\nΈξοδος\nΔιαγράμματα\nΜηνύματα\nΠροειδοποιήσεις\n\n\n\neval: false\nX\n\nX\nX\nX\nX\n\n\ninclude: false\n\nX\nX\nX\nX\nX\n\n\necho: false\n\nX\n\n\n\n\n\n\nresults: hide\n\n\nX\n\n\n\n\n\nfig-show: hide\n\n\n\nX\n\n\n\n\nmessage: false\n\n\n\n\nX\n\n\n\nwarning: false\n\n\n\n\n\nX\n\n\n\n28.5.3 Καθολικές επιλογές\nΚαθώς εργάζεστε περισσότερο με την knitr, θα ανακαλύψετε ότι ορισμένες από τις προεπιλεγμένα χαρακτηριστικά των τμημάτων κώδικα δεν ταιριάζουν στις ανάγκες σας και θέλετε να τις αλλάξετε.\nΑυτό μπορείτε να το κάνετε προσθέτοντας τις προτιμώμενες επιλογές σας στο YAML του εγγράφου, κάτω από την ενότητα execute. Για παράδειγμα, εάν ετοιμάζετε μία αναφορά για ένα κοινό που δεν χρειάζεται να δει τον κώδικά σας, αλλά μόνο τα αποτελέσματα και την ερμηνεία σας, μπορείτε να ορίσετε το echo: false σε επίπεδο εγγράφου. Αυτό θα αποκρύψει τον κώδικα, επομένως θα εμφανίζονται μόνο τα κομμάτια που επιλέγετε σκόπιμα να εμφανίσετε (θέτοντας echo: true στο αντίστοιχο τμήμα κώδικα). Ακόμη, μπορεί να σκεφτείτε να θέσετε τα message: false και warning: false, αλλά αυτό θα καθιστούσε δυσκολότερο τον εντοπισμό σφαλμάτων μιας και δεν θα βλέπατε κανένα μήνυμα στο τελικό έγγραφο.\ntitle: \"My report\"\nexecute:\n  echo: false\nΜιας και το Quarto έχει σχεδιαστεί για να είναι πολύγλωσσο (λειτουργεί με την R καθώς και με άλλες γλώσσες όπως η Python, η Julia κ.α.), δεν είναι όλες οι επιλογές της knitr διαθέσιμες σε επίπεδο εκτέλεσης εγγράφου, καθώς ορισμένες από αυτές λειτουργούν μόνο με την knitr και όχι άλλες μηχανές που χρησιμοποιεί το Quarto για την εκτέλεση κώδικα σε άλλες γλώσσες (π.χ. Jupyter). Μπορείτε, ωστόσο, να τις ορίσετε ως καθολικές επιλογές για το έγγραφό σας στο πεδίο knitr, στην κάτω από το opts_chunk. Για παράδειγμα, όταν γράφουμε βιβλία και σεμινάρια, θέτουμε:\ntitle: \"Tutorial\"\nknitr:\n  opts_chunk:\n    comment: \"#&gt;\"\n    collapse: true\nΑυτές οι επιλογές ακολουθούν τη μορφοποίηση σχολίων που προτιμάμε και διασφαλίζει ότι ο κώδικας και η έξοδος παραμένουν στενά συνδεδεμένα.\n\n28.5.4 Ένθετος κώδικας\nΥπάρχει ένας ακόμη τρόπος για να ενσωματώσετε τον κώδικα R σας σε ένα έγγραφο Quarto: απευθείας στο κείμενο, με την επιλογή: `r `. Αυτό μπορεί να είναι πολύ χρήσιμο εάν αναφέρετε ιδιότητες των δεδομένων σας στο κείμενο. Για παράδειγμα, το παράδειγμα εγγράφου που χρησιμοποιήθηκε στην αρχή του κεφαλαίου ανέφερε:\n\nΈχουμε δεδομένα σχετικά με `r nrow(diamonds)` διαμάντια . Μόνο `r nrow(diamonds) - nrow(smaller)` είναι μεγαλύτερα από 2.5 καράτια. Η κατανομή των υπολοίπων φαίνεται παρακάτω:\n\nΌταν αποδίδεται η αναφορά, τα αποτελέσματα αυτών των υπολογισμών ενσωματώνονται στο κείμενο ως εξής:\n\nΈχουμε στοιχεία σχετικά με 53940 διαμάντια. Μόνο τα 126 είναι μεγαλύτερα από 2.5 καράτια. Η κατανομή των υπολοίπων φαίνεται παρακάτω:\n\nΌταν εισάγετε αριθμούς στο κείμενο, το format() είναι ο φίλος σας. Σας επιτρέπει να ορίσετε τον αριθμό των ψηφίων (digits) ώστε να μην εκτυπώνετε με παράλογο βαθμό ακρίβειας, ενώ το big.mark διευκολύνει την ανάγνωση των αριθμών. Μπορείτε να συνδυάσετε αυτές τις επιλογές σε μία βοηθητική συνάρτηση:\n\ncomma &lt;- function(x) format(x, digits = 2, big.mark = \",\")\ncomma(3452345)\n#&gt; [1] \"3,452,345\"\ncomma(.12358124331)\n#&gt; [1] \"0.12\"\n\n\n28.5.5 Ασκήσεις\n\nΠροσθέστε μία ενότητα που διερευνά πώς τα μεγέθη διαμαντιών ποικίλλουν ανάλογα με την κοπή, το χρώμα και τη διαύγεια τους. Ας υποθέσουμε ότι γράφετε μία αναφορά για κάποιον που δεν γνωρίζει R και αντί να ρυθμίσετε το echo: false σε κάθε τμήμα κώδικα, ορίστε μία καθολική επιλογή.\nΚάντε λήψη του diamond-sizes.qmd από το https://github.com/hadley/r4ds/tree/main/quarto. Προσθέστε μία ενότητα που περιγράφει τα 20 μεγαλύτερα διαμάντια, συμπεριλαμβανομένου ενός πίνακα που εμφανίζει τα πιο σημαντικά χαρακτηριστικά τους.\nΤροποποιήστε το diamonds-sizes.qmd για να χρησιμοποιεί το label_comma() για να παράγετε αποτελέσματα με ωραία μορφοποίηση. Συμπεριλάβετε επίσης το ποσοστό των διαμαντιών που είναι μεγαλύτερα από 2.5 καράτια.",
    "crumbs": [
      "Επικοινωνία της πληροφορίας",
      "<span class='chapter-number'>28</span>  <span class='chapter-title'>Quarto</span>"
    ]
  },
  {
    "objectID": "quarto.html#sec-figures",
    "href": "quarto.html#sec-figures",
    "title": "28  Quarto",
    "section": "\n28.6 Εικόνες",
    "text": "28.6 Εικόνες\nΟι εικόνες σε ένα έγγραφο Quarto μπορούν να είναι ενσωματωμένες (π.χ. ένα αρχείο PNG ή JPEG) ή να δημιουργούνται ως αποτέλεσμα ενός τμήματος κώδικα.\nΓια να ενσωματώσετε μία εικόνα από ένα εξωτερικό αρχείο, μπορείτε να χρησιμοποιήσετε το μενού Insert στο Οπτικό πρόγραμμα επεξεργασίας του RStudio και να επιλέξετε Figure / Image. Αυτό θα ανοίξει ένα μενού όπου μπορείτε να περιηγηθείτε στην εικόνα που θέλετε να εισάγετε καθώς και να προσθέσετε εναλλακτικό κείμενο ή λεζάντα σε αυτήν και να προσαρμόσετε το μέγεθός της. Στο οπτικό πρόγραμμα επεξεργασίας μπορείτε επίσης απλώς να επικολλήσετε μία εικόνα από το πρόχειρο σας στο έγγραφό σας και το RStudio θα τοποθετήσει ένα αντίγραφο αυτής της εικόνας στο φάκελο του αντίστοιχου project σας.\nΕάν συμπεριλάβετε ένα κομμάτι κώδικα που δημιουργεί μία εικόνα (π.χ., περιλαμβάνει μία κλήση της ggplot()), η εικόνα που προκύπτει θα συμπεριληφθεί αυτόματα στο έγγραφο Quarto.\n\n28.6.1 Μέγεθος εικόνων\nΗ μεγαλύτερη πρόκληση των γραφικών στο Quarto είναι να φέρετε τις εικόνες σας στο σωστό μέγεθος και σχήμα. Υπάρχουν πέντε κύριες επιλογές που ελέγχουν το μέγεθος των εικόνων: fig-width, fig-height, fig-asp, out-width και out-height. Η επιλογή του κατάλληλου μεγέθους της εικόνας είναι δύσκολη, επειδή υπάρχουν δύο μεγέθη (το μέγεθος της εικόνας που δημιουργείται από την R και το μέγεθος στο οποίο εισάγεται στο έγγραφο εξόδου) αλλά και πολλοί τρόποι καθορισμού του μεγέθους (δηλ. ύψος, πλάτος και αναλογία διαστάσεων: να επιλέγετε δύο από τα τρία).\nΠροτείνουμε τρεις από τις πέντε επιλογές:\n\nΤα διαγράμματα τείνουν να είναι πιο ευχάριστα αισθητικά εάν έχουν σταθερό πλάτος. Για να το επιβάλετε, ορίστε τα fig-width: 6 (6”) και fig-asp: 0.618 (η χρυσή τομή) στις προεπιλογές. Στη συνέχεια, σε μεμονωμένα τμήματα κώδικα, προσαρμόστε μόνο το fig-asp.\n\nΕλέγξτε το μέγεθος εξόδου με το out-width και ορίστε το σε ένα ποσοστό του πλάτους του σώματος του εγγράφου εξόδου. Προτείνουμε τη χρήση των out-width: \"70%\" και fig-align: center.\nΑυτό δίνει στα διαγράμματα χώρο να επεκταθούν, χωρίς όμως να καταλαμβάνει πολύ χώρο.\n\nΓια να τοποθετήσετε πολλαπλά διαγράμματα σε μία μόνο γραμμή, ορίστε το layout-ncol σε 2 για δύο διαγράμματα, 3 για τρία διαγράμματα κ.λπ. Αυτό ουσιαστικά ορίζει το out-width στο 50% για κάθε ένα από τα διαγράμματα σας εάν το layout-ncol είναι 2, στο 33% εάν το layout-ncol είναι 3 κ.ο.κ. Ανάλογα με το τι προσπαθείτε να παρουσιάσετε (π.χ. εμφάνιση δεδομένων ή εμφάνιση παραλλαγών μιας γραφικής παράστασης), μπορείτε επίσης να τροποποιήσετε το fig-width, όπως συζητείται παρακάτω.\n\nΕάν διαπιστώσετε ότι χρειάζεται προσπάθεια για να διαβάσετε το κείμενο στο διάγραμμα σας, θα πρέπει να τροποποιήσετε το fig-width. Εάν το fig-width είναι μεγαλύτερο από το μέγεθος στο οποίο η εικόνα αποδίδεται στο τελικό έγγραφο, το κείμενο θα είναι πολύ μικρό, ενώ εάν το fig-width είναι μικρότερο, το κείμενο θα είναι πολύ μεγάλο. Συχνά θα χρειαστεί να κάνετε λίγα πειράματα για να καταλάβετε τη σωστή αναλογία μεταξύ του fig-width και του τελικού πλάτους στο έγγραφό σας. Για να το δούμε και πρακτικά αυτό, τα ακόλουθα τρία διαγράμματα έχουν τιμές fig-width 4, 6 και 8 αντίστοιχα:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nΕάν θέλετε να βεβαιωθείτε ότι το μέγεθος της γραμματοσειράς είναι συνεπείς σε όλες τις εικόνες σας, όποτε ορίζετε το out-width, θα πρέπει επίσης να προσαρμόσετε το fig-width για να διατηρήσετε την ίδια αναλογία με το προεπιλεγμένο out-width . Για παράδειγμα, εάν η προεπιλεγμένη τιμή του fig-width είναι 6 και το out-width είναι 70%, όταν ορίσετε out-width: \"50%\" θα πρέπει να ορίσετε το fig-width σε 4.3 (6 * 0.5 / 0.7).\nΤο μέγεθος και η επιλογή κατάλληλης κλίμακας των εικόνων είναι τέχνη και επιστήμη, και το βρείτε το σωστό συνδυασμό μπορεί να απαιτεί μία επαναληπτική προσέγγιση δοκιμής και λάθους.\nΜπορείτε να μάθετε περισσότερα σχετικά με την προσαρμογή του μεγέθους των εικόνων στο taking control of plot scaling.\n\n28.6.2 Άλλες σημαντικές επιλογές\nΌταν αναμιγνύετε κώδικα και κείμενο, όπως σε αυτό το βιβλίο, μπορείτε να ρυθμίσετε το fig-show: hold έτσι ώστε τα διαγράμματα να εμφανίζονται μετά τον κώδικα. Αυτό έχει τη θετική παρενέργεια ότι σας αναγκάζει να χωρίζετε μεγάλα μπλοκ κώδικα, προσθέτοντας τις εξηγήσεις τους.\nΓια να προσθέσετε μία λεζάντα στο διάγραμμα, χρησιμοποιήστε το fig-cap. Στο Quarto αυτό θα αλλάξει το διάγραμμα από ένθετες (inline) σε “floating”.\nΕάν παράγετε αρχεία εξόδου PDF, ο προεπιλεγμένος τύπος γραφικών είναι το PDF. Αυτή είναι μία καλή προεπιλογή μιας και τα PDF είναι διανυσματικά γραφικά υψηλής ποιότητας. Ωστόσο, μπορούν να παράγουν πολύ μεγάλα και αργά διαγράμματα εάν παρουσιάζετε χιλιάδες σημεία. Σε αυτήν την περίπτωση, ορίστε το fig-format: \"png\" για να επιβάλετε τη χρήση PNG. Είναι ελαφρώς χαμηλότερης ποιότητας, αλλά θα είναι πολύ πιο συμπαγή.\nΕίναι καλή ιδέα να δώσετε ονόματα σε τμήματα κώδικα που παράγουν διαγράμματα, ακόμα κι αν δεν προσθέτετε συνήθως ετικέτες σε άλλα τμήματα. Η ετικέτα του τμήματος χρησιμοποιείται για τη δημιουργία του ονόματος αρχείου του γραφικού στο δίσκο, επομένως η ονομασία των τμημάτων κώδικα σας διευκολύνει πολύ τον εντοπισμό των γραφικών και την επαναχρησιμοποίηση τους σε άλλες περιπτώσεις (π.χ., εάν θέλετε να εισάγετε γρήγορα ένα διάγραμμα σε ένα μήνυμα ηλεκτρονικού ταχυδρομείου).\n\n28.6.3 Ασκήσεις\n\nΑνοίξτε το αρχείο diamond-sizes.qmd στο οπτικό πρόγραμμα επεξεργασίας, βρείτε μία εικόνα ενός διαμαντιού, αντιγράψτε την και επικολλήστε την στο έγγραφο. Κάντε διπλό κλικ στην εικόνα και προσθέστε μία λεζάντα. Αλλάξτε το μέγεθος της εικόνας και δημιουργήστε το τελικό έγγραφό σας. Παρατηρήστε πώς αποθηκεύεται η εικόνα στο τρέχον μονοπάτι εργασίας σας.\nΕπεξεργαστείτε την ετικέτα του τμήματος κώδικα στο diamond-sizes.qmd που δημιουργεί ένα διάγραμμα που ξεκινά με το πρόθεμα fig- και προσθέτει μία λεζάντα στο σχήμα με την επιλογή τμήματος fig-cap. Στη συνέχεια, επεξεργαστείτε το κείμενο πάνω από το τμήμα κώδικα για να προσθέσετε μία αναφορά στην εικόνα σας με το Insert &gt; Cross Reference.\n\nΑλλάξτε το μέγεθος της εικόνας με τις ακόλουθες επιλογές τμημάτων, μία κάθε φορά, αποδώστε το έγγραφό σας και περιγράψτε πώς αλλάζει η εικόνα.\n\nfig-width: 10\nfig-height: 3\nout-width: \"100%\"\nout-width: \"20%\"",
    "crumbs": [
      "Επικοινωνία της πληροφορίας",
      "<span class='chapter-number'>28</span>  <span class='chapter-title'>Quarto</span>"
    ]
  },
  {
    "objectID": "quarto.html#πίνακες",
    "href": "quarto.html#πίνακες",
    "title": "28  Quarto",
    "section": "\n28.7 Πίνακες",
    "text": "28.7 Πίνακες\nΠαρόμοια με τις εικόνες, μπορείτε να συμπεριλάβετε δύο τύπους πινάκων σε ένα έγγραφο Quarto. Μπορεί να είναι είτε πίνακες markdown που δημιουργούνται απευθείας στο Quarto έγγραφό σας (χρησιμοποιώντας το μενού Insert Table) είτε πίνακες που δημιουργούνται ως αποτέλεσμα ενός τμήματος κώδικα. Σε αυτή την ενότητα θα επικεντρωθούμε στους τελευταίους, πίνακες που δημιουργούνται μέσω υπολογισμών.\nΑπό προεπιλογή, το Quarto εκτυπώνει πλαίσια δεδομένων και πίνακες όπως θα τα βλέπατε στην κονσόλα:\n\nmtcars[1:5, ]\n#&gt;                    mpg cyl disp  hp drat    wt  qsec vs am gear carb\n#&gt; Mazda RX4         21.0   6  160 110 3.90 2.620 16.46  0  1    4    4\n#&gt; Mazda RX4 Wag     21.0   6  160 110 3.90 2.875 17.02  0  1    4    4\n#&gt; Datsun 710        22.8   4  108  93 3.85 2.320 18.61  1  1    4    1\n#&gt; Hornet 4 Drive    21.4   6  258 110 3.08 3.215 19.44  1  0    3    1\n#&gt; Hornet Sportabout 18.7   8  360 175 3.15 3.440 17.02  0  0    3    2\n\nΕάν προτιμάτε τα δεδομένα να εμφανίζονται με επιπλέον μορφοποίηση, μπορείτε να χρησιμοποιήσετε τη συνάρτηση knitr::kable(). Ο Πίνακας 28.1 εμφανίζει την έξοδο του παρακάτω κώδικα.\n\nknitr::kable(mtcars[1:5, ], )\n\n\nΠίνακας 28.1: A knitr kable.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nmpg\ncyl\ndisp\nhp\ndrat\nwt\nqsec\nvs\nam\ngear\ncarb\n\n\n\nMazda RX4\n21.0\n6\n160\n110\n3.90\n2.620\n16.46\n0\n1\n4\n4\n\n\nMazda RX4 Wag\n21.0\n6\n160\n110\n3.90\n2.875\n17.02\n0\n1\n4\n4\n\n\nDatsun 710\n22.8\n4\n108\n93\n3.85\n2.320\n18.61\n1\n1\n4\n1\n\n\nHornet 4 Drive\n21.4\n6\n258\n110\n3.08\n3.215\n19.44\n1\n0\n3\n1\n\n\nHornet Sportabout\n18.7\n8\n360\n175\n3.15\n3.440\n17.02\n0\n0\n3\n2\n\n\n\n\n\n\n\n\nΔιαβάστε τις οδηγίες για τη ?knitr::kable για να μάθετε τους άλλους τρόπους με τους οποίους μπορείτε να προσαρμόσετε τον πίνακα σας. Για ακόμη βαθύτερη παραμετροποίηση, εξετάστε τα πακέτα gt, huxtable, reactable, kableExtra, xtable, stargazer, pander, tables και ascii. Κάθε ένα παρέχει ένα σύνολο εργαλείων για την επιστροφή μορφοποιημένων πινάκων από τον κώδικα R.\n\n28.7.1 Ασκήσεις\n\nΑνοίξτε το diamond-sizes.qmd στο οπτικό πρόγραμμα επεξεργασίας, εισάγετε ένα κομμάτι κώδικα και προσθέστε έναν πίνακα με την knitr::kable() που εμφανίζει τις πρώτες 5 σειρές του πλαισίου δεδομένων diamonds.\nΕμφανίστε τον ίδιο πίνακα χρησιμοποιώντας την gt::gt().\nΠροσθέστε μία ετικέτα τμήματος που ξεκινά με το πρόθεμα tbl- και προσθέστε μία λεζάντα στον πίνακα με την επιλογή τμημάτων tbl-cap. Στη συνέχεια, επεξεργαστείτε το κείμενο πάνω από το τμήμα κώδικα για να προσθέσετε μία παραπομπή στον πίνακα με το Insert &gt; Cross Reference.",
    "crumbs": [
      "Επικοινωνία της πληροφορίας",
      "<span class='chapter-number'>28</span>  <span class='chapter-title'>Quarto</span>"
    ]
  },
  {
    "objectID": "quarto.html#sec-caching",
    "href": "quarto.html#sec-caching",
    "title": "28  Quarto",
    "section": "\n28.8 Προσωρινή αποθήκευση στη μνήμη",
    "text": "28.8 Προσωρινή αποθήκευση στη μνήμη\nΚανονικά, κάθε απόδοση ενός εγγράφου (δημιουργία του τελικού εγγράφου από το .qmd αρχείο κώδικα, render) ξεκινά από μία εντελώς καθαρή κατάσταση. Αυτό είναι εξαιρετικό για την αναπαραξιμότητα, επειδή διασφαλίζει ότι έχετε καταγράψει κάθε σημαντικό υπολογισμό μέσα σε κώδικα. Ωστόσο, μπορεί να είναι επώδυνο εάν έχετε κάποιους υπολογισμούς που χρειάζονται πολύ χρόνο. Η λύση γι αυτό είναι η επιλογή cache: true.\nΜπορείτε να ενεργοποιήσετε την προσωρινή αποθήκευση στη μνήμη από την Knitr σε επίπεδο εγγράφου για την προσωρινή αποθήκευση των αποτελεσμάτων όλων των υπολογισμών σε ένα έγγραφο χρησιμοποιώντας τυπικές επιλογές YAML:\n---\ntitle: \"My Document\"\nexecute: \n  cache: true\n---\nΜπορείτε επίσης να ενεργοποιήσετε την προσωρινή αποθήκευση σε επίπεδο τμήματος κώδικα, για την αποθήκευση των αποτελεσμάτων υπολογισμών που γίνονται σε ένα συγκεκριμένο τμήμα κώδικα:\n\n```{r}\n#| cache: true\n\n# code for lengthy computation...\n```\n\nΌταν οριστεί, αυτή η επιλογή θα αποθηκεύσει την έξοδο του τμήματος κώδικα σε ένα ειδικά ονομασμένο αρχείο στο δίσκο. Στις επόμενες εκτελέσεις, η knitr θα ελέγξει αν ο κώδικας έχει αλλάξει και αν δεν έχει αλλάξει, θα χρησιμοποιήσει ξανά τα αποθηκευμένα αποτελέσματα.\nΤο σύστημα προσωρινής αποθήκευσης πρέπει να χρησιμοποιείται με προσοχή, γιατί από προεπιλογή βασίζεται μόνο στον κώδικα σας και όχι σε άλλο κώδικα ή πακέτα στα οποία αυτός εξαρτάται. Για παράδειγμα, εδώ το τμήμα processed_data εξαρτάται από το τμήμα raw-data:\n```{r}\n#| label: raw-data\n#| cache: true\n\nrawdata &lt;- readr::read_csv(\"a_very_large_file.csv\")\n```\n```{r}\n#| label: processed_data\n#| cache: true\n\nprocessed_data &lt;- rawdata |&gt; \n  filter(!is.na(import_var)) |&gt; \n  mutate(new_variable = complicated_transformation(x, y, z))\n```\nΗ προσωρινή αποθήκευση των αποτελεσμάτων του τμήματος processed_data σημαίνει ότι θα εκτελεστεί ξανά εάν αλλάξει η σειρά εργασιών της dplyr, αλλά δεν θα εκτελεστεί ξανά εάν αλλάξει η κλήση read_csv(). Μπορείτε να αποφύγετε αυτό το πρόβλημα με την επιλογή dependson στο αντίστοιχο τμήμα κώδικα:\n```{r}\n#| label: processed-data\n#| cache: true\n#| dependson: \"raw-data\"\n\nprocessed_data &lt;- rawdata |&gt; \n  filter(!is.na(import_var)) |&gt; \n  mutate(new_variable = complicated_transformation(x, y, z))\n```\nΤο dependson θα πρέπει να περιέχει ένα διάνυσμα χαρακτήρων με κάθε τμήμα από το οποίο εξαρτάται το τμήμα κώδικα του οποίου τα αποτελέσματα θέλουμε να αποθηκεύσουμε στην κρυφή μνήμη. Η Knitr θα ενημερώσει τα αποτελέσματα για το αποθηκευμένο τμήμα κώδικα κάθε φορά που εντοπίζει ότι έχει αλλάξει μία από τις εξαρτήσεις του.\nΈχετε υπόψη ότι τα κομμάτια δεν θα ενημερωθούν εάν αλλάξει το a_very_large_file.csv, επειδή η προσωρινή αποθήκευση της knitr παρακολουθεί μόνο αλλαγές στο αρχείο .qmd. Εάν θέλετε επίσης να παρακολουθείτε τις αλλαγές σε αυτό το αρχείο, μπορείτε να χρησιμοποιήσετε την επιλογή cache.extra. Αυτή είναι μία αυθαίρετη έκφραση στην R που θα “ακυρώσει” την προσωρινή αποθήκευση στην μνήμη κάθε φορά που το αρχείο αυτό αλλάζει. Μία χρήση συνάρτηση είναι η file.mtime(): αυτή επιστρέφει το ποια είναι η τελευταία φορά που τροποποιήθηκε το αρχείο. Επομένως, μπορείτε να γράψετε:\n```{r}\n#| label: raw-data\n#| cache: true\n#| cache.extra: !expr file.mtime(\"a_very_large_file.csv\")\n\nrawdata &lt;- readr::read_csv(\"a_very_large_file.csv\")\n```\nΑκολουθήσαμε τη συμβουλή του David Robinson για να δώσουμε ονόματα σε αυτά τα τμήματα κώδικα: κάθε τμήμα ονομάζεται από το κύριο αντικείμενο που δημιουργεί. Αυτό διευκολύνει την κατανόηση των προδιαγραφών του dependson.\nΚαθώς οι στρατηγικές σας για αποθήκευση στην κρυφή μνήμη γίνονται σταδιακά πιο περίπλοκες, είναι καλή ιδέα να φροντίζεται καθαρίζετε τακτικά όλες τις κρυφές μνήμες σας με το knitr::clean_cache().\n\n28.8.1 Ασκήσεις\n\nΔημιουργήστε ένα δίκτυο τμημάτων κώδικα όπου το d εξαρτάται στο c και στο b, ενώ τα b και c εξαρτώνται από το a. Ζητήστε από κάθε τμήμα να εκτυπώσειlubridate::now(), ορίστε cache: true, και στη συνέχει επιβεβαιώστε ότι κατανοείτε την προσωρινή αποθήκευση στη μνήμη.",
    "crumbs": [
      "Επικοινωνία της πληροφορίας",
      "<span class='chapter-number'>28</span>  <span class='chapter-title'>Quarto</span>"
    ]
  },
  {
    "objectID": "quarto.html#επίλυση-προβλημάτων",
    "href": "quarto.html#επίλυση-προβλημάτων",
    "title": "28  Quarto",
    "section": "\n28.9 Επίλυση προβλημάτων",
    "text": "28.9 Επίλυση προβλημάτων\nΟ εντοπισμός κι η αντιμετώπιση προβλημάτων σε έγγραφα Quarto μπορεί να είναι δύσκολη, επειδή δεν βρίσκεστε πλέον σε ένα διαδραστικό περιβάλλον R και θα χρειαστεί να μάθετε μερικά νέα κόλπα. Επιπλέον, το σφάλμα μπορεί να οφείλεται σε προβλήματα με το ίδιο το έγγραφο Quarto ή στον ίδιο τον κώδικα R που υπάρχει στο έγγραφο Quarto.\nΈνα συνηθισμένο σφάλμα σε έγγραφα με κομμάτια κώδικα είναι οι διπλότυπες ετικέτες τμημάτων, οι οποίες είναι ιδιαίτερα διάχυτες εάν η ροή εργασίας σας περιλαμβάνει αντιγραφή και επικόλληση τμημάτων κώδικα. Για να αντιμετωπίσετε αυτό το ζήτημα, το μόνο που χρειάζεται να κάνετε είναι να αλλάξετε μία από τις διπλότυπες ετικέτες σας.\nΕάν τα σφάλματα οφείλονται στον κώδικα R στο έγγραφο, το πρώτο πράγμα που πρέπει πάντα να προσπαθείτε είναι να αναδημιουργήσετε το πρόβλημα σε μία διαδραστική περίοδο λειτουργίας της R. Επανεκκινήστε την R και μετά επιλέξτε “Run all chunks” (“Εκτέλεση όλων των τμημάτων”), είτε από το μενού του Code, κάτω από το Run είτε με τη συντόμευση πληκτρολογίου Ctrl + Alt + R. Εάν είστε τυχεροί, αυτό θα δημιουργήσει ξανά το πρόβλημα και μπορείτε να καταλάβετε τι συμβαίνει διαδραστικά.\nΕάν αυτό δεν βοηθήσει, πρέπει να υπάρχει κάποια διαφορά μεταξύ του διαδραστικού σας περιβάλλοντος και του περιβάλλοντος του Quarto. Θα χρειαστεί να εξερευνήσετε συστηματικά τις διαφορετικές επιλογές που μπορεί να διαφέρουν. Η πιο κοινή διαφορά είναι το μονοπάτι εργασίας: το μονοπάτι εργασίας του αρχείου Quarto είναι το μονοπάτι στο οποίο ζει. Ελέγξτε ότι το μονοπάτι εργασίας είναι αυτό που περιμένετε, συμπεριλαμβάνοντας το getwd() μέσα σε ένα τμήμα κώδικα.\nΣτη συνέχεια, σκεφτείτε όλα τα πράγματα που μπορεί να προκαλέσουν το σφάλμα. Θα χρειαστεί να ελέγχετε συστηματικά ότι είναι τα ίδια στη συνεδρία R και στη συνεδρία Quarto. Ο ευκολότερος τρόπος για να το κάνετε αυτό είναι να ορίσετε το error: true στο τμήμα που προκαλεί το πρόβλημα και, στη συνέχεια, χρησιμοποιήστε τα print() και str() για να ελέγξετε ότι οι ρυθμίσεις είναι όπως περιμένετε.",
    "crumbs": [
      "Επικοινωνία της πληροφορίας",
      "<span class='chapter-number'>28</span>  <span class='chapter-title'>Quarto</span>"
    ]
  },
  {
    "objectID": "quarto.html#κεφαλίδα-yaml",
    "href": "quarto.html#κεφαλίδα-yaml",
    "title": "28  Quarto",
    "section": "\n28.10 Κεφαλίδα YAML",
    "text": "28.10 Κεφαλίδα YAML\nΜπορείτε να ελέγξετε πολλές άλλες ρυθμίσεις που επηρεάζουν ολόκληρο το έγγραφο τροποποιώντας τις παραμέτρους της κεφαλίδας YAML. Ίσως αναρωτιέστε τι σημαίνει το YAML: σημαίνει “YAML Ain’t Markup Language”, η οποία έχει σχεδιαστεί για την αναπαράσταση ιεραρχικών δεδομένων με τρόπο που είναι εύκολο για τους ανθρώπους να διαβάσουν και γράψουν. Το Quarto το χρησιμοποιεί για να ελέγχει πολλές από τις λεπτομέρειες της εξόδου. Εδώ θα συζητήσουμε τρεις περιπτώσεις : αυτοτελή έγγραφα, παραμέτρους εγγράφων και βιβλιογραφίες.\n\n28.10.1 Αυτοτελή έγγραφα\nΤα έγγραφα HTML έχουν συνήθως έναν αριθμό εξωτερικών εξαρτήσεων (π.χ. εικόνες, φύλλα CSS, JavaScript, κ.λπ.) και, από προεπιλογή, το Quarto τοποθετεί αυτές τις εξαρτήσεις σε έναν φάκελο _files στον ίδιο κατάλογο με το αρχείο .qmd σας. Εάν δημοσιεύσετε το αρχείο HTML σε μία πλατφόρμα φιλοξενίας (π.χ. QuartoPub, https://quartopub.com/), οι εξαρτήσεις σε αυτόν τον κατάλογο δημοσιεύονται με το έγγραφό σας και, ως εκ τούτου, είναι διαθέσιμες στη δημοσιευμένη αναφορά. Ωστόσο, εάν θέλετε να στείλετε την αναφορά σε έναν συνάδελφο μέσω email, μπορεί να προτιμήσετε να έχετε ένα ενιαίο, αυτόνομο έγγραφο HTML που να ενσωματώνει όλες τις εξαρτήσεις του. Αυτό μπορείτε να το κάνετε καθορίζοντας την επιλογή embed-resources:\nformat:\n  html:\n    embed-resources: true\nΤο αρχείο που θα προκύψει θα είναι αυτόνομο, έτσι ώστε να μην χρειάζεται εξωτερικά αρχεία και πρόσβαση στο διαδίκτυο για να εμφανίζεται σωστά από ένα πρόγραμμα περιήγησης.\n\n28.10.2 Παράμετροι\nΤα έγγραφα Quarto μπορούν να περιλαμβάνουν μία ή περισσότερες παραμέτρους των οποίων οι τιμές μπορούν να οριστούν κατά την απόδοση της αναφοράς. Οι παράμετροι είναι χρήσιμες όταν θέλετε να αποδώσετε ξανά την ίδια αναφορά με διαφορετικές τιμές για σημαντικές μεταβλητές εισόδου. Για παράδειγμα, μπορεί να παράγετε αναφορές πωλήσεων ανά κλάδο, αποτελέσματα εξετάσεων ανά μαθητή ή δημογραφικές περιλήψεις ανά χώρα. Για να δηλώσετε μία ή περισσότερες παραμέτρους, χρησιμοποιήστε το πεδίο params.\nΑυτό το παράδειγμα χρησιμοποιεί μία παράμετρο my_class για να καθορίσει ποια κατηγορία αυτοκινήτων θα εμφανιστεί:\n\n---\nformat: html\nparams:\n  my_class: \"suv\"\n---\n\n```{r}\n#| label: setup\n#| include: false\n\nlibrary(tidyverse)\n\nclass &lt;- mpg |&gt; filter(class == params$my_class)\n```\n\n# Fuel economy for `r params$my_class`s\n\n```{r}\n#| message: false\n\nggplot(class, aes(x = displ, y = hwy)) + \n  geom_point() + \n  geom_smooth(se = FALSE)\n```\n\nΌπως μπορείτε να δείτε, οι παράμετροι είναι διαθέσιμες στα τμήματα κώδικα ως λίστα μόνο για ανάγνωση με το όνομα params.\nΜπορείτε να γράψετε ατομικά διανύσματα απευθείας στην κεφαλίδα YAML. Μπορείτε επίσης να εκτελέσετε αυθαίρετες εκφράσεις R προτάσσοντας την τιμή της παραμέτρου με !expr. Αυτός είναι ένας καλός τρόπος για να καθορίσετε τις παραμέτρους ημερομηνίας/ώρας.\nparams:\n  start: !expr lubridate::ymd(\"2015-01-01\")\n  snapshot: !expr lubridate::ymd_hms(\"2015-01-01 12:30:00\")\n\n28.10.3 Βιβλιογραφίες κι αναφορές\nΤο Quarto μπορεί να δημιουργήσει αυτόματα παραπομπές και βιβλιογραφία σε διάφορα στυλ. Ο πιο απλός τρόπος για να προσθέσετε αναφορές και βιβλιογραφίες σε ένα έγγραφο Quarto είναι η χρήση του προγράμματος οπτικής επεξεργασίας στο RStudio.\nΓια να προσθέσετε μία αναφορά χρησιμοποιώντας το οπτικό πρόγραμμα επεξεργασίας, μεταβείτε στην επιλογή Insert &gt; Citation Οι παραπομπές μπορούν να εισαχθούν από διάφορες πηγές:\n\nDOI Αναφορές που χρησιμοποιούν το (Document Object Identifier)\nZotero προσωπικές ή ομαδικές βιβλιοθήκες αναφορών.\nΑναζητήσεις στα Crossref, DataCite, ή PubMed.\nΗ βιβλιογραφία του εγγράφου σας (ένα αρχείο .bib στο μονοπάτι του εγγράφου σας)\n\nΣτο παρασκήνιο, η οπτική λειτουργία χρησιμοποιεί την τυπική αναπαράσταση markdown Pandoc για αναφορές (π.χ. [@citation]).\nΕάν προσθέσετε μία αναφορά χρησιμοποιώντας μία από τις τρεις πρώτες μεθόδους, το οπτικό πρόγραμμα επεξεργασίας θα δημιουργήσει αυτόματα ένα αρχείο bibliography.bib για εσάς και θα προσθέσει την αναφορά σε αυτό. Θα προσθέσει επίσης ένα πεδίο bibliography στο έγγραφο YAML. Καθώς προσθέτετε περισσότερες αναφορές, αυτό το αρχείο θα συμπληρώνεται με τις αναφορές τους. Μπορείτε επίσης να επεξεργαστείτε απευθείας αυτό το αρχείο χρησιμοποιώντας πολλές κοινές μορφές βιβλιογραφίας, όπως BibLaTeX, BibTeX, EndNote, Medline.\nΓια να δημιουργήσετε μία αναφορά στο αρχείο .qmd στο πρόγραμμα επεξεργασίας πηγαίου κώδικα, χρησιμοποιήστε ένα κλειδί που αποτελείται από το ‘@’ + το αναγνωριστικό παραπομπής από το αρχείο βιβλιογραφίας. Στη συνέχεια, τοποθετήστε την αναφορά σε αγκύλες. Ακολουθούν μερικά παραδείγματα:\nSeparate multiple citations with a `;`: Blah blah [@smith04; @doe99].\n\nYou can add arbitrary comments inside the square brackets: \nBlah blah [see @doe99, pp. 33-35; also @smith04, ch. 1].\n\nRemove the square brackets to create an in-text citation: @smith04 \nsays blah, or @smith04 [p. 33] says blah.\n\nAdd a `-` before the citation to suppress the author's name: \nSmith says blah [-@smith04].\nΌταν το Quarto αποδίδει το αρχείο σας, θα δημιουργήσει και θα προσαρτήσει μία βιβλιογραφία στο τέλος του εγγράφου σας. Η βιβλιογραφία θα περιέχει καθεμία από τις αναφερόμενες παραπομπές από το αρχείο βιβλιογραφίας σας, αλλά δεν θα περιέχει μία επικεφαλίδα ενότητας. Ως αποτέλεσμα, είναι κοινή πρακτική να τερματίζετε το αρχείο σας με μία κεφαλίδα ενότητας για τη βιβλιογραφία, όπως # References ή # Bibliography.\nΜπορείτε να αλλάξετε το στυλ των παραπομπών και της βιβλιογραφίας σας κάνοντας αναφορά σε ένα αρχείο CSL (γλώσσα στυλ παραπομπής) στο πεδίο csl:\nbibliography: rmarkdown.bib\ncsl: apa.csl\nΌπως και με το πεδίο της βιβλιογραφίας, το αρχείο csl πρέπει να περιέχει ένα μονοπάτι προς το αρχείο. Εδώ θεωρούμε ότι το αρχείο csl βρίσκεται στο ίδιο μονοπάτι με το αρχείο .qmd. Ένα καλό μέρος για να βρείτε αρχεία στυλ CSL για κοινά στυλ βιβλιογραφίας είναι το https://github.com/citation-style-language/styles.",
    "crumbs": [
      "Επικοινωνία της πληροφορίας",
      "<span class='chapter-number'>28</span>  <span class='chapter-title'>Quarto</span>"
    ]
  },
  {
    "objectID": "quarto.html#ροή-εργασίας",
    "href": "quarto.html#ροή-εργασίας",
    "title": "28  Quarto",
    "section": "\n28.11 Ροή εργασίας",
    "text": "28.11 Ροή εργασίας\nΝωρίτερα, συζητήσαμε μία βασική ροή εργασιών για την καταγραφή του κώδικα R, όπου εργάζεστε ,ε αλληλεπίδραση στην κονσόλα και, στη συνέχεια, καταγράφετε ό,τι λειτουργεί στο script editor. Το Quarto συνδυάζει την κονσόλα και τον επεξεργαστή αρχείων κώδικα, θολώνοντας τις γραμμές μεταξύ της διαδραστικής εξερεύνησης και της μακροπρόθεσμης καταγραφής του κώδικα. Μπορείτε να επαναλάβετε εργασίες μέσα σε ένα τμήμα κώδικα, να το επεξεργαστείτε και να το εκτελέσετε ξανά με Cmd/Ctrl + Shift + Enter. Και όταν είστε ευχαριστημένοι, μπορείτε να προχωρήσετε και ξεκινήσετε ένα νέο τμήμα κώδικα.\nΤο Quarto είναι επίσης σημαντικό επειδή ενσωματώνει τόσο στενά κείμενο και κώδικα. Αυτό το καθιστά εξαιρετικό σημειωματάριο ανάλυσης γιατί σας επιτρέπει να αναπτύξετε κώδικα και να καταγράψετε τις σκέψεις σας. Ένα σημειωματάριο ανάλυσης μοιράζεται πολλούς από τους ίδιους στόχους με ένα κλασικό τετράδιο εργαστηρίου στις φυσικές επιστήμες.\nΣυγκεκριμένα:\n\nΚαταγράφει τι κάνατε και γιατί το κάνατε. Ανεξάρτητα από το πόσο καλή είναι η μνήμη σας, αν δεν καταγράψετε αυτό που κάνετε, θα έρθει μία στιγμή που θα έχετε ξεχάσει σημαντικές λεπτομέρειες. Οπότε γράψτε τα για να μην ξεχάσετε!\nΥποστηρίζει τη σχολαστική σκέψη. Είναι πιο πιθανό να καταλήξετε σε μία ισχυρή ανάλυση εάν καταγράφετε τις σκέψεις σας καθώς προχωράτε και συνεχίζετε να τις σκέφτεστε. Αυτό σας εξοικονομεί επίσης χρόνο όταν τελικά γράφετε την ανάλυσή σας για να τη μοιραστείτε με άλλους.\nΒοηθά τους άλλους να κατανοήσουν τη δουλειά σας. Είναι σπάνιο να κάνετε ανάλυση δεδομένων μόνοι σας και συχνά θα εργάζεστε ως μέλος μιας ομάδας. Ένα τετράδιο εργαστηρίου σας βοηθά να μοιραστείτε όχι μόνο αυτό που κάνατε, αλλά και γιατί το κάνατε με τους συναδέλφους ή τους συνεργάτες σας στο εργαστήριο.\n\nΠολλές από τις καλές συμβουλές σχετικά με την αποτελεσματική χρήση των εργαστηριακών τετραδίων μπορούν επίσης να εφαρμοστούν και στα σημειωματάρια ανάλυσης. Χρησιμοποιήσαμε τις δικές μας εμπειρίες και τις συμβουλές του Colin Purrington σχετικά με τα σημειωματάρια εργαστηρίου (https://colinpurrington.com/tips/lab-notebooks) για να καταλήξουμε στις ακόλουθες συμβουλές:\n\nΒεβαιωθείτε ότι κάθε σημειωματάριο έχει έναν περιγραφικό τίτλο, ένα όνομα αρχείου που θα σας βοηθήσει να θυμηθείτε εύκολα τι αφορά και μία πρώτη παράγραφο που περιγράφει εν συντομία τους στόχους της ανάλυσης.\n\nΧρησιμοποιήστε το πεδίο ημερομηνίας της κεφαλίδας YAML για να καταγράψετε την ημερομηνία που ξεκινήσατε να εργάζεστε στο σημειωματάριο:\ndate: 2016-08-23\nΧρησιμοποιήστε τη μορφοποίηση ISO8601 YYYY-MM-DD για να μην υπάρχει ασάφεια. Χρησιμοποιήστε το ακόμη κι αν φυσιολογικά δεν γράφετε τις ημερομηνίες με αυτό τον τρόπο!\n\nΕάν ξοδεύσατε πολύ χρόνο σε μία ιδέα ανάλυσης αλλά αποδειχθεί αδιέξοδο, μην τη διαγράψετε! Γράψτε μία σύντομη σημείωση σχετικά με το γιατί απέτυχε και αφήστε τη στο σημειωματάριο. Αυτό θα σας βοηθήσει να αποφύγετε να καταλήξετε στο ίδιο αδιέξοδο όταν επιστρέψετε στην ανάλυση στο μέλλον.\nΓενικά, είναι καλύτερα να κάνετε την εισαγωγή δεδομένων εκτός της R. Αλλά αν χρειάζεται να καταγράψετε ένα μικρό απόσπασμα δεδομένων, τοποθετήστε το ξεκάθαρα χρησιμοποιώντας το tibble::tribble().\nΕάν ανακαλύψετε ένα σφάλμα σε ένα αρχείο δεδομένων, μην το τροποποιήσετε ποτέ απευθείας, αλλά αντίθετα γράψτε κώδικα για να διορθώσετε την τιμή. Εξηγήστε γιατί κάνατε τη διόρθωση.\nΠριν τελειώσετε τις εργασίες σας και κλείσετε την R, βεβαιωθείτε ότι μπορείτε να μετατρέψετε το σημειωματάριο στο τελικό αρχείο εξόδου. Εάν χρησιμοποιείτε προσωρινή αποθήκευση στη μνήμη, φροντίστε να διαγράψετε τις κρυφές μνήμες. Αυτό θα σας επιτρέψει να διορθώσετε τυχόν προβλήματα όσο ο κώδικας είναι ακόμα φρέσκος στο μυαλό σας.\nΕάν θέλετε ο κώδικάς σας να μπορεί να μπορεί να αναπαραχθεί μακροπρόθεσμα (δηλαδή, να μπορείτε να επιστρέψετε για να τον εκτελέσετε τον επόμενο μήνα ή τον επόμενο χρόνο), θα πρέπει να παρακολουθείτε τις εκδόσεις των πακέτων που χρησιμοποιεί ο κώδικάς σας. Μία ενδελεχής προσέγγιση είναι να χρησιμοποιήσετε το renv, https://rstudio.github.io/renv/index.html, το οποίο αποθηκεύει πακέτα στο μονοπάτι του project σας. Ένα γρήγορο και εύκολο κόλπο είναι να συμπεριλάβετε ένα τμήμα κώδικα που εκτελεί το sessionInfo() — δεν θα σας επιτρέψει να αναδημιουργήσετε εύκολα τα πακέτα σας όπως είναι σήμερα, αλλά τουλάχιστον θα ξέρετε τι ήταν.\nΘα δημιουργήσετε πολλά, πολλά, πολλά σημειωματάρια ανάλυσης κατά την πορεία της καριέρας σας. Πώς θα τα οργανώσετε για να τα βρείτε ξανά στο μέλλον; Σας συνιστούμε να τα αποθηκεύσετε σε μεμονωμένα project και να δημιουργήσετε ένα καλό σχέδιο απόδοσης ονομάτων.",
    "crumbs": [
      "Επικοινωνία της πληροφορίας",
      "<span class='chapter-number'>28</span>  <span class='chapter-title'>Quarto</span>"
    ]
  },
  {
    "objectID": "quarto.html#σύνοψη",
    "href": "quarto.html#σύνοψη",
    "title": "28  Quarto",
    "section": "\n28.12 Σύνοψη",
    "text": "28.12 Σύνοψη\nΣε αυτό το κεφάλαιο σας παρουσιάσαμε το Quarto για τη σύνταξη και τη δημοσίευση αναπαράξιμων υπολογιστικών εγγράφων που περιλαμβάνουν τον κώδικα και το κείμενο σας σε ένα μέρος. Μάθατε πώς να δημιουργείτε έγγραφα Quarto στο RStudio με το οπτικό πρόγραμμα επεξεργασίας ή το πρόγραμμα επεξεργασίας πηγαίου κώδικα, πώς λειτουργούν τα τμήματα κώδικα και πώς να προσαρμόζετε τις επιλογές για αυτά, πώς να συμπεριλαμβάνετε σχήματα και πίνακες στα Quarto έγγραφά σας, καθώς και επιλογές για αποθήκευση στην κρυφή μνήμη για υπολογισμούς. Επιπλέον, μάθατε σχετικά με την προσαρμογή των επιλογών κεφαλίδας YAML για τη δημιουργία αυτοτελών ή παραμετροποιημένων εγγράφων, καθώς και τη συμπερίληψη παραπομπών και βιβλιογραφίας. Σας έχουμε δώσει επίσης ορισμένες συμβουλές αντιμετώπισης προβλημάτων και ροής εργασιών.\nΑν και αυτή η εισαγωγή θα πρέπει να είναι αρκετή για να ξεκινήσετε με το Quarto, υπάρχουν ακόμα πολλά να μάθετε. Το Quarto είναι ακόμα σχετικά νέο και εξακολουθεί να αναπτύσσεται γρήγορα. Το καλύτερο μέρος για να μείνετε στην κορυφή των καινοτομιών είναι ο επίσημος ιστότοπος του Quarto: https://quarto.org.\nΥπάρχουν δύο σημαντικά θέματα που δεν έχουμε καλύψει εδώ: η συνεργασία και οι λεπτομέρειες της επικοινωνίας των ιδεών σας με ακρίβεια σε άλλους ανθρώπους. Η συνεργασία είναι ένα ζωτικό μέρος της σύγχρονης επιστήμης δεδομένων και μπορείτε να κάνετε τη ζωή σας πολύ πιο εύκολη χρησιμοποιώντας εργαλεία ελέγχου εκδόσεων, όπως το Git και το GitHub. Προτείνουμε το “Happy Git with R”, μία φιλική προς τον χρήστη εισαγωγή στο Git και στο GitHub από χρήστες R, από την Jenny Bryan. Το βιβλίο διατίθεται δωρεάν στο διαδίκτυο: https://happygitwithr.com.\nΕπίσης, δεν έχουμε θίξει τι πρέπει πραγματικά να γράψετε για να γνωστοποιήσετε με σαφήνεια τα αποτελέσματα της ανάλυσής σας. Για να βελτιώσετε τη γραφή σας, συνιστούμε ανεπιφύλακτα να διαβάσετε είτε το Style: Lessons in Clarity and Grace του Joseph M. Williams & Joseph Bizup, είτε το The Sense of Structure: Writing from the Reader’s Perspective του George Gopen. Και τα δύο βιβλία θα σας βοηθήσουν να κατανοήσετε τη δομή των προτάσεων και των παραγράφων και θα σας δώσουν τα εργαλεία για να κάνετε τη γραφή σας πιο σαφή. (Αυτά τα βιβλία είναι μάλλον ακριβά αν αγοραστούν καινούργια, αλλά χρησιμοποιούνται από πολλά μαθήματα αγγλικών, επομένως υπάρχουν πολλά φθηνά μεταχειρισμένα αντίγραφα). Ο George Gopen έχει επίσης μία σειρά από σύντομα άρθρα σχετικά με τη συγγραφή στη διεύθυνση https://www.georgegopen.com/litigation-articles.html. Απευθύνονται σε δικηγόρους, αλλά σχεδόν όλα ισχύουν και για τους επιστήμονες δεδομένων.",
    "crumbs": [
      "Επικοινωνία της πληροφορίας",
      "<span class='chapter-number'>28</span>  <span class='chapter-title'>Quarto</span>"
    ]
  },
  {
    "objectID": "quarto-formats.html",
    "href": "quarto-formats.html",
    "title": "29  Επιλογές μορφοποίησης στο Quarto",
    "section": "",
    "text": "29.1 Εισαγωγή\nΜέχρι τώρα, έχετε δει το Quarto να χρησιμοποιείται για την παραγωγή HTML αρχείων. Αυτό το κεφάλαιο παρέχει μία σύντομη περίληψη ορισμένων από τους πολλούς τύπους εγγράφων εξόδου που μπορείτε να παράγετε με το Quarto.\nΥπάρχουν δύο τρόποι για να καθορίσετε τον τύπο του αρχείου εξόδου:",
    "crumbs": [
      "Επικοινωνία της πληροφορίας",
      "<span class='chapter-number'>29</span>  <span class='chapter-title'>Επιλογές μορφοποίησης στο Quarto</span>"
    ]
  },
  {
    "objectID": "quarto-formats.html#εισαγωγή",
    "href": "quarto-formats.html#εισαγωγή",
    "title": "29  Επιλογές μορφοποίησης στο Quarto",
    "section": "",
    "text": "Μόνιμα, τροποποιώντας την YAML επικεφαλίδα:\ntitle: \"Diamond sizes\"\nformat: html\n\n\nΠαροδικά, καλώντας την εντολή quarto::quarto_render():\n\nquarto::quarto_render(\"diamond-sizes.qmd\", output_format = \"docx\")\n\nΑυτή η επιλογή είναι χρήσιμη εάν θέλετε να παράγετε προγραμματιστικά το ίδιο αποτέλεσμα σε πολλαπλούς τύπους εγγράφων, μιας και το όρισμα output_format μπορεί να πάρει μία λίστα από τιμές.\n\nquarto::quarto_render(\"diamond-sizes.qmd\", output_format = c(\"docx\", \"pdf\"))",
    "crumbs": [
      "Επικοινωνία της πληροφορίας",
      "<span class='chapter-number'>29</span>  <span class='chapter-title'>Επιλογές μορφοποίησης στο Quarto</span>"
    ]
  },
  {
    "objectID": "quarto-formats.html#επιλογές-αρχείων-εξόδου",
    "href": "quarto-formats.html#επιλογές-αρχείων-εξόδου",
    "title": "29  Επιλογές μορφοποίησης στο Quarto",
    "section": "\n29.2 Επιλογές αρχείων εξόδου",
    "text": "29.2 Επιλογές αρχείων εξόδου\nΤο Quarto προσφέρει ένα ευρύ φάσμα μορφών εξόδου. Μπορείτε να βρείτε την πλήρη λίστα στη διεύθυνση https://quarto.org/docs/output-formats/all-formats.html. Πολλές μορφές μοιράζονται ορισμένες επιλογές εξόδου (για παράδειγμα, toc: true για τη συμπερίληψη πίνακα περιεχομένων), ενώ άλλες έχουν επιλογές που είναι συγκεκριμένες για τη μορφή αυτή (για παράδειγμα το code-fold: true συμπτύσσει κομμάτια κώδικα σε μία &lt;details&gt; ετικέτα για HTML αρχεία εξόδου, ώστε ο χρήστης να μπορεί να την εμφανίσει κατ’ επιλογή, που δεν είναι διαθέσιμο για έγγραφα PDF ή Word).\nΓια να παρακάμψετε τις προεπιλεγμένες ρυθμίσεις, πρέπει να χρησιμοποιήσετε ένα επεκτεινόμενο πεδίο format. Για παράδειγμα, εάν θέλατε να δημιουργήσετε ένα html αρχείο με έναν αιωρούμενο (floating) πίνακα περιεχομένων, θα χρησιμοποιούσατε:\nformat:\n  html:\n    toc: true\n    toc_float: true\nΜπορείτε ακόμη να δημιουργήσετε πολλαπλά αρχεία εξόδου, παρέχοντας μία λίστα επιλογών μορφοποίησης:\nformat:\n  html:\n    toc: true\n    toc_float: true\n  pdf: default\n  docx: default\nΠαρατηρήστε το ιδιαίτερο συντακτικό (pdf: default) που θα πρέπει να χρησιμοποιήσετε εάν δεν θέλετε να παρακάμψετε τις προκαθορισμένες επιλογές.\nΓια να αποδώσετε (render) όλες τις επιλογές μορφοποίησης που καθορίζονται στην κεφαλίδα YAML ενός εγγράφου, μπορείτε να χρησιμοποιήσετε την επιλογή output_format = \"all\".\n\nquarto::quarto_render(\"diamond-sizes.qmd\", output_format = \"all\")",
    "crumbs": [
      "Επικοινωνία της πληροφορίας",
      "<span class='chapter-number'>29</span>  <span class='chapter-title'>Επιλογές μορφοποίησης στο Quarto</span>"
    ]
  },
  {
    "objectID": "quarto-formats.html#έγγραφα",
    "href": "quarto-formats.html#έγγραφα",
    "title": "29  Επιλογές μορφοποίησης στο Quarto",
    "section": "\n29.3 Έγγραφα",
    "text": "29.3 Έγγραφα\nΤο προηγούμενο κεφάλαιο εστίασε στην προκαθορισμένη επιλογή των html αρχείων εξόδου. Υπάρχουν διάφορες βασικές παραλλαγές αυτού του θέματος, οι οποίες παράγουν διαφορετικούς τύπους εγγράφων. Για παράδειγμα:\n\nΤο pdf δημιουργεί ένα PDF χρησιμοποιώντας LaTeX (ένα σύστημα ανοιχτού κώδικα για τη διάταξη εγγράφων), το οποίο θα πρέπει να εγκαταστήσετε. Το RStudio θα σας ζητήσει αν δεν το έχετε ήδη.\nΤο docx για έγγραφα του Microsoft Word (.docx).\nΤο odt για έγγραφα OpenDocument Text (.odt).\nΤο rtf για έγγραφα με μορφή εμπλουτισμένου κειμένου (.rtf).\nΤο gfm για ένα έγγραφο GitHub Flavored Markdown (.md).\nΤο ipynb για Jupyter Notebooks (.ipynb).\n\nΘυμηθείτε, όταν δημιουργείτε ένα έγγραφο που σκοπεύετε να μοιραστείτε με τους υπεύθυνους λήψης αποφάσεων, μπορείτε να απενεργοποιήσετε την προεπιλεγμένη εμφάνιση του κώδικα ορίζοντας τις αντίστοιχες καθολικές επιλογές στην κεφαλίδα YAML του εγγράφου:\nexecute:\n  echo: false\nΜία εναλλακτική επιλογή για html έγγραφα είναι η τα κομμάτια του κώδικα να παραμένουν κρυμμένα από προεπιλογή, αλλά να γίνονται ορατά με ένα κλικ:\nformat:\n  html:\n    code: true",
    "crumbs": [
      "Επικοινωνία της πληροφορίας",
      "<span class='chapter-number'>29</span>  <span class='chapter-title'>Επιλογές μορφοποίησης στο Quarto</span>"
    ]
  },
  {
    "objectID": "quarto-formats.html#παρουσιάσεις",
    "href": "quarto-formats.html#παρουσιάσεις",
    "title": "29  Επιλογές μορφοποίησης στο Quarto",
    "section": "\n29.4 Παρουσιάσεις",
    "text": "29.4 Παρουσιάσεις\nΜπορείτε επίσης να χρησιμοποιήσετε το Quarto για τη δημιουργία παρουσιάσεων. Έχετε λιγότερο οπτικό έλεγχο από ό,τι με ένα εργαλείο όπως το Keynote ή το PowerPoint, αλλά η αυτόματη εισαγωγή των αποτελεσμάτων του κώδικα σας σε R σε μία παρουσίαση μπορεί να εξοικονομήσει σημαντικό χρόνο. Οι παρουσιάσεις λειτουργούν διαιρώντας το περιεχόμενό σας σε διαφάνειες, με μία νέα διαφάνεια να ξεκινά σε κάθε κεφαλίδα δεύτερου επιπέδου (##). Επιπλέον, οι κεφαλίδες πρώτου επιπέδου (#) υποδεικνύουν την αρχή μιας νέας ενότητας με μία διαφάνεια τίτλου ενότητας που είναι, από προεπιλογή, κεντραρισμένη στη μέση.\nΤο Quarto υποστηρίζει μία ποικιλία μορφών παρουσίασης, που περιλαμβάνουν:\n\nrevealjs - HTML παρουσιάσεις με τη χρήση revealjs\npptx - PowerPoint παρουσιάσεις\nbeamer - PDF παρουσιάσεις με τη χρήση LaTeX Beamer.\n\nΜπορείτε να διαβάσετε περισσότερα για τη δημιουργία παρουσιάσεων με το Quarto στο https://quarto.org/docs/presentations.",
    "crumbs": [
      "Επικοινωνία της πληροφορίας",
      "<span class='chapter-number'>29</span>  <span class='chapter-title'>Επιλογές μορφοποίησης στο Quarto</span>"
    ]
  },
  {
    "objectID": "quarto-formats.html#διαδραστικότητα",
    "href": "quarto-formats.html#διαδραστικότητα",
    "title": "29  Επιλογές μορφοποίησης στο Quarto",
    "section": "\n29.5 Διαδραστικότητα",
    "text": "29.5 Διαδραστικότητα\nΌπως και με κάθε άλλο HTML έγγραφο, τα HTML έγγραφα που δημιουργούνται με το Quarto μπορούν να περιέχουν και διαδραστικά στοιχεία. Εδώ εισάγουμε δύο επιλογές για να συμπεριλάβουμε διαδραστικότητα στα Quarto έγγραφα μας: τα htmlwidgets και το Shiny.\n\n29.5.1 htmlwidgets\nΤο HTML είναι μία διαδραστική μορφή και μπορείτε να επωφεληθείτε από αυτή τη διαδραστικότητα με τη χρήση htmlwidgets, συναρτήσεων της R που παράγουν διαδραστικές HTML απεικονίσεις. Για παράδειγμα, πάρτε τον leaflet χάρτη στην παρακάτω εικόνα. Εάν προβάλλετε αυτήν τη σελίδα στο διαδίκτυο, μπορείτε να σύρετε τον χάρτη, να τον μεγεθύνετε και μικρύνετε κλπ. Προφανώς δεν μπορείτε να το κάνετε αυτό σε ένα βιβλίο, οπότε το Quarto εισάγει αυτόματα ένα στατικό στιγμιότυπο για εσάς.\n\nlibrary(leaflet)\nleaflet() |&gt;\n  setView(174.764, -36.877, zoom = 16) |&gt; \n  addTiles() |&gt;\n  addMarkers(174.764, -36.877, popup = \"Maungawhau\") \n\n\n\n\n\nΤο υπέροχο με τα htmlwidget είναι ότι δεν χρειάζεται να γνωρίζετε τίποτα για HTML ή JavaScript για να τη χρησιμοποιήσετε. Όλες οι λεπτομέρειες περιέχονται στο πακέτο, οπότε δεν χρειάζεται να ανησυχείτε για αυτό.\nΥπάρχουν πολλά πακέτα που παρέχουν htmlwidgets, συμπεριλαμβανομένων των:\n\ndygraphs για διαδραστικές απεικονίσεις χρονοσειρών.\nDT για διαδραστικούς πίνακες.\nthreejs για διαδραστικά τρισδιάστατα διαγράμματα.\nDiagrammeR για διαγράμματα (όπως διαγράμματα ροής και απλά διαγράμματα κόμβων-συνδέσμων).\n\nΓια να μάθετε περισσότερα σχετικά με τα htmlwidgets και για μία πλήρη λίστα των πακέτων που τα παρέχουν, επισκεφθείτε τη διεύθυνση https://www.htmlwidgets.org.\n\n29.5.2 Shiny\nΤα htmlwidgets παρέχουν διαδραστικότητα από την πλευρά του χρήστη (client-side) — όλη η αλληλεπίδραση συμβαίνει στο πρόγραμμα περιήγησης, ανεξάρτητα από την R. Από τη μία, αυτό είναι υπέροχο γιατί μπορείτε να διανείμετε το HTML αρχείο σας χωρίς καμία σύνδεση με την R. Ωστόσο, αυτό περιορίζει θεμελιωδώς το τι μπορείτε να κάνετε σε στοιχεία που έχουν δημιουργηθεί με HTML και JavaScript. Μία εναλλακτική προσέγγιση είναι να χρησιμοποιήσετε το shiny, ένα πακέτο που σας επιτρέπει να δημιουργήσετε διαδραστικότητα χρησιμοποιώντας τον κώδικα R, κι όχι τη JavaScript.\nΓια να εκτελέσετε τον κώδικα σας σε Shiny από ένα έγγραφο Quarto, προσθέστε την επιλογή server: shiny στην κεφαλίδα YAML:\ntitle: \"Shiny Web App\"\nformat: html\nserver: shiny\nΤώρα μπορείτε να χρησιμοποιήσετε τις συναρτήσεις εισαγωγής (“input”) για να προσθέσετε διαδραστικά στοιχεία σε ένα έγγραφο:\n\nlibrary(shiny)\n\ntextInput(\"name\", \"What is your name?\")\nnumericInput(\"age\", \"How old are you?\", NA, min = 0, max = 150)\n\n\n\n\n\n\n\n\n\nΧρειάζεστε επίσης ένα κομμάτι κώδικα με την επιλογή context: server που περιέχει τον κώδικα που πρέπει να εκτελεστεί σε έναν Shiny διακομιστή.\nΣτη συνέχεια, μπορείτε να ανατρέξετε στις τιμές με χρησιμοποιώντας τα input$name και input$age και ο κώδικας που τις χρησιμοποιεί θα εκτελείται ξανά αυτόματα κάθε φορά που αυτά αλλάζουν.\nΔεν μπορούμε να σας δείξουμε μία ζωντανή shiny εφαρμογή εδώ επειδή οι shiny αλληλεπιδράσεις πραγματοποιούνται από την πλευρά του διακομιστή (server-side). Αυτό σημαίνει ότι μπορείτε να γράψετε διαδραστικές εφαρμογές χωρίς να γνωρίζετε JavaScript, αλλά χρειάζεστε έναν διακομιστή για να τις εκτελέσετε. Αυτό εισάγει ένα τεχνικό ζήτημα: Οι εφαρμογές Shiny χρειάζονται έναν διακομιστή Shiny για να εκτελούνται στο διαδίκτυο. Όταν εκτελείτε τις εφαρμογές Shiny στον δικό σας υπολογιστή, το Shiny ρυθμίζει αυτόματα έναν διακομιστή Shiny για εσάς, αλλά χρειάζεστε έναν δημοσίως ορατό διακομιστή Shiny, εάν θέλετε να δημοσιεύσετε αυτού του είδους τη διαδραστικότητα στο διαδίκτυο. Αυτός είναι ο θεμελιώδης συμβιβασμός του shiny: σε ένα shiny έγγραφο μπορείτε να κάνετε ότι θα κάνατε και στην R, αλλά απαιτείται κάποιος να τρέχει την R.\nΓια να μάθετε περισσότερα σχετικά με το Shiny, συνιστούμε να διαβάσετε το Mastering Shiny από τον Hadley Wickham, https://mastering-shiny.org.",
    "crumbs": [
      "Επικοινωνία της πληροφορίας",
      "<span class='chapter-number'>29</span>  <span class='chapter-title'>Επιλογές μορφοποίησης στο Quarto</span>"
    ]
  },
  {
    "objectID": "quarto-formats.html#ιστοσελίδες-και-βιβλία",
    "href": "quarto-formats.html#ιστοσελίδες-και-βιβλία",
    "title": "29  Επιλογές μορφοποίησης στο Quarto",
    "section": "\n29.6 Ιστοσελίδες και βιβλία",
    "text": "29.6 Ιστοσελίδες και βιβλία\nΜε λίγες επιπλέον υποδομές, μπορείτε να χρησιμοποιήσετε το Quarto για να δημιουργήσετε μία πλήρη ιστοσελίδα ή ένα βιβλίο:\n\nΕισάγετε τα αρχεία σας με κατάληξη .qmd σε ένα κοινό μονοπάτι εργασίας. Το index.qmd θα γίνει η αρχική σελίδα σας.\n\nΠροσθέστε ένα YAML αρχείο που ονομάζετε ως _quarto.yml και το οποίο παρέχει την πλοήγηση στον ιστότοπο. Σε αυτό το αρχείο, ορίστε το project είτε ως book είτε ως website, για παράδειγμα:\nproject:\n  type: book\n\n\nΓια παράδειγμα, το ακόλουθο _quarto.yml αρχείο δημιουργεί μία ιστοσελίδα από τρία αρχεία πηγαίου κώδικα: το index.qmd (αρχική σελίδα), το viridis-colors.qmd, και το terrain-colors.qmd.\n\nproject:\n  type: website\n\nwebsite:\n  title: \"A website on color scales\"\n  navbar:\n    left:\n      - href: index.qmd\n        text: Home\n      - href: viridis-colors.qmd\n        text: Viridis colors\n      - href: terrain-colors.qmd\n        text: Terrain colors\n\nΤο αρχείο _quarto.yml που χρειάζεστε για ένα βιβλίο ακολουθεί παρόμοια δομή. Το παρακάτω παράδειγμα δείχνει πως μπορείτε να δημιουργήσετε ένα βιβλίο με τέσσερα κεφάλαια, το οποίο παράγει τρία διαφορετικού τύπου αρχεία εξόδου (html, pdf, και epub). Και πάλι, τα αρχεία του πηγαίου κώδικα είναι αρχεία με κατάληξη .qmd.\n\nproject:\n  type: book\n\nbook:\n  title: \"A book on color scales\"\n  author: \"Jane Coloriste\"\n  chapters:\n    - index.qmd\n    - intro.qmd\n    - viridis-colors.qmd\n    - terrain-colors.qmd\n\nformat:\n  html:\n    theme: cosmo\n  pdf: default\n  epub: default\n\nΣας συνιστούμε να χρησιμοποιήσετε ένα RStudio project για τους ιστοτόπους και τα βιβλία σας. Με βάση το αρχείο _quarto.yml, το RStudio θα αναγνωρίσει τον τύπο του project στο οποίο εργάζεστε και θα προσθέσει μία καρτέλα Build στο IDE, την οποία μπορείτε να χρησιμοποιήσετε για την απόδοση και προεπισκόπηση των ιστοτόπων και των βιβλίων σας. Τόσο οι ιστότοποι όσο και τα βιβλία μπορούν επίσης να αποδοθούν χρησιμοποιώντας την εντολή quarto::quarto_render().\nΔιαβάστε περισσότερα σχετικά με ιστοσελίδες Quarto στο https://quarto.org/docs/websites και στο https://quarto.org/docs/books για βιβλία.",
    "crumbs": [
      "Επικοινωνία της πληροφορίας",
      "<span class='chapter-number'>29</span>  <span class='chapter-title'>Επιλογές μορφοποίησης στο Quarto</span>"
    ]
  },
  {
    "objectID": "quarto-formats.html#άλλες-επιλογές-μορφοποίησης",
    "href": "quarto-formats.html#άλλες-επιλογές-μορφοποίησης",
    "title": "29  Επιλογές μορφοποίησης στο Quarto",
    "section": "\n29.7 Άλλες επιλογές μορφοποίησης",
    "text": "29.7 Άλλες επιλογές μορφοποίησης\nΤο Quarto προσφέρει ακόμη περισσότερες επιλογές αρχείων εξόδου:\n\nΜπορείτε να γράψετε άρθρα σε περιοδικά χρησιμοποιώντας τα Quarto Journal Templates: https://quarto.org/docs/journals/templates.html.\nΜπορείτε να εξάγετε έγγραφα Quarto σε Jupyter Notebooks με την επιλογή format: ipynb: https://quarto.org/docs/reference/formats/ipynb.html.\n\nΔείτε στο https://quarto.org/docs/output-formats/all-formats.html για μία λίστα με ακόμη περισσότερες επιλογές μορφοποίησης.",
    "crumbs": [
      "Επικοινωνία της πληροφορίας",
      "<span class='chapter-number'>29</span>  <span class='chapter-title'>Επιλογές μορφοποίησης στο Quarto</span>"
    ]
  },
  {
    "objectID": "quarto-formats.html#σύνοψη",
    "href": "quarto-formats.html#σύνοψη",
    "title": "29  Επιλογές μορφοποίησης στο Quarto",
    "section": "\n29.8 Σύνοψη",
    "text": "29.8 Σύνοψη\nΣε αυτό το κεφάλαιο σας παρουσιάσαμε μία ποικιλία επιλογών για την επικοινωνία των αποτελεσμάτων σας με το Quarto, από στατικά και διαδραστικά έγγραφα έως παρουσιάσεις, ιστοτόπους και βιβλία.\nΓια να μάθετε περισσότερα σχετικά με την αποτελεσματική επικοινωνία σε αυτές τις διαφορετικές μορφές, συνιστούμε τις ακόλουθες πηγές:\n\nΓια να βελτιώσετε τις δεξιότητες παρουσίασης σας, δοκιμάστε το Presentation Patterns των Neal Ford, Matthew McCollough, και Nathaniel Schutta. Παρέχει ένα σύνολο αποτελεσματικών μοτίβων (χαμηλού και υψηλού επιπέδου) που μπορείτε να εφαρμόσετε για να βελτιώσετε τις παρουσιάσεις σας.\nΕάν δίνετε ακαδημαϊκές ομιλίες μπορεί να σας αρέσει το Leek group guide to giving talks.\nΑν και δεν το έχουμε οι ίδιο, έχουμε ακούσει καλά λόγια για το διαδικτυακό μάθημα του Matt McGarrity για τη δημόσια ομιλία σε κοινό: https://www.coursera.org/learn/public-speaking.\nΕάν δημιουργείτε πολλά dashboards, φροντίστε να διαβάσετε το Information Dashboard Design: The Effective Visual Communication of Data του Stephen Few. Θα σας βοηθήσει να δημιουργείτε dashboards που είναι πραγματικά χρήσιμα, κι όχι απλά όμορφα στην όψη.\nΗ αποτελεσματική επικοινωνία των ιδεών σας συχνά επωφελείται από κάποιες γνώσεις γραφιστικής. Το The Non-Designer’s Design Book της Robin Williams είναι ένα καλό σημείο για να ξεκινήσετε.",
    "crumbs": [
      "Επικοινωνία της πληροφορίας",
      "<span class='chapter-number'>29</span>  <span class='chapter-title'>Επιλογές μορφοποίησης στο Quarto</span>"
    ]
  }
]